/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 253);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyFunction = __webpack_require__(8);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var DOMProperty = __webpack_require__(14);
var ReactDOMComponentFlags = __webpack_require__(70);

var invariant = __webpack_require__(1);

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Check if a given node should be cached.
 */
function shouldPrecacheNode(node, nodeID) {
  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
}

/**
 * Drill down (through composites and empty components) until we get a host or
 * host text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_hostNode` on the rendered host/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}

function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}

/**
 * Populate `_hostNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (shouldPrecacheNode(childNode, childID)) {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}

var ReactDOMComponentTree = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

module.exports = ReactDOMComponentTree;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(17);

var ReactCurrentOwner = __webpack_require__(11);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty)
  // Strip regex characters so we can use it for regex
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  // Remove hasOwnProperty from the template to make it generic
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },


  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs
};

module.exports = ReactComponentTreeHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// Trust the developer to only use ReactInstrumentation with a __DEV__ check

var debugTool = null;

if (process.env.NODE_ENV !== 'production') {
  var ReactDebugTool = __webpack_require__(172);
  debugTool = ReactDebugTool;
}

module.exports = { debugTool: debugTool };
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var CallbackQueue = __webpack_require__(68);
var PooledClass = __webpack_require__(15);
var ReactFeatureFlags = __webpack_require__(73);
var ReactReconciler = __webpack_require__(19);
var Transaction = __webpack_require__(30);

var invariant = __webpack_require__(1);

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return sym; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return TASK; });
/* unused harmony export HELPER */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return MATCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return CANCEL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return SAGA_ACTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return SELF_CANCELLATION; });
/* unused harmony export konst */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return kTrue; });
/* unused harmony export kFalse */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return ident; });
/* harmony export (immutable) */ __webpack_exports__["b"] = check;
/* unused harmony export hasOwn */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return is; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return object; });
/* harmony export (immutable) */ __webpack_exports__["m"] = remove;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return array; });
/* harmony export (immutable) */ __webpack_exports__["w"] = deferred;
/* unused harmony export arrayOfDeffered */
/* harmony export (immutable) */ __webpack_exports__["j"] = delay;
/* unused harmony export createMockTask */
/* unused harmony export autoInc */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return uid; });
/* harmony export (immutable) */ __webpack_exports__["i"] = makeIterator;
/* harmony export (immutable) */ __webpack_exports__["q"] = log;
/* harmony export (immutable) */ __webpack_exports__["d"] = deprecate;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return updateIncentive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return internalErr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return createSetContextWarning; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return wrapSagaDispatch; });
/* unused harmony export cloneableGenerator */
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var sym = function sym(id) {
  return '@@redux-saga/' + id;
};

var TASK = sym('TASK');
var HELPER = sym('HELPER');
var MATCH = sym('MATCH');
var CANCEL = sym('CANCEL_PROMISE');
var SAGA_ACTION = sym('SAGA_ACTION');
var SELF_CANCELLATION = sym('SELF_CANCELLATION');
var konst = function konst(v) {
  return function () {
    return v;
  };
};
var kTrue = konst(true);
var kFalse = konst(false);
var noop = function noop() {};
var ident = function ident(v) {
  return v;
};

function check(value, predicate, error) {
  if (!predicate(value)) {
    log('error', 'uncaught at check', error);
    throw new Error(error);
  }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(object, property) {
  return is.notUndef(object) && hasOwnProperty.call(object, property);
}

var is = {
  undef: function undef(v) {
    return v === null || v === undefined;
  },
  notUndef: function notUndef(v) {
    return v !== null && v !== undefined;
  },
  func: function func(f) {
    return typeof f === 'function';
  },
  number: function number(n) {
    return typeof n === 'number';
  },
  string: function string(s) {
    return typeof s === 'string';
  },
  array: Array.isArray,
  object: function object(obj) {
    return obj && !is.array(obj) && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
  },
  promise: function promise(p) {
    return p && is.func(p.then);
  },
  iterator: function iterator(it) {
    return it && is.func(it.next) && is.func(it.throw);
  },
  iterable: function iterable(it) {
    return it && is.func(Symbol) ? is.func(it[Symbol.iterator]) : is.array(it);
  },
  task: function task(t) {
    return t && t[TASK];
  },
  observable: function observable(ob) {
    return ob && is.func(ob.subscribe);
  },
  buffer: function buffer(buf) {
    return buf && is.func(buf.isEmpty) && is.func(buf.take) && is.func(buf.put);
  },
  pattern: function pattern(pat) {
    return pat && (is.string(pat) || (typeof pat === 'undefined' ? 'undefined' : _typeof(pat)) === 'symbol' || is.func(pat) || is.array(pat));
  },
  channel: function channel(ch) {
    return ch && is.func(ch.take) && is.func(ch.close);
  },
  helper: function helper(it) {
    return it && it[HELPER];
  },
  stringableFunc: function stringableFunc(f) {
    return is.func(f) && hasOwn(f, 'toString');
  }
};

var object = {
  assign: function assign(target, source) {
    for (var i in source) {
      if (hasOwn(source, i)) {
        target[i] = source[i];
      }
    }
  }
};

function remove(array, item) {
  var index = array.indexOf(item);
  if (index >= 0) {
    array.splice(index, 1);
  }
}

var array = {
  'from': function from(obj) {
    var arr = Array(obj.length);
    for (var i in obj) {
      if (hasOwn(obj, i)) {
        arr[i] = obj[i];
      }
    }
    return arr;
  }
};

function deferred() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var def = _extends({}, props);
  var promise = new Promise(function (resolve, reject) {
    def.resolve = resolve;
    def.reject = reject;
  });
  def.promise = promise;
  return def;
}

function arrayOfDeffered(length) {
  var arr = [];
  for (var i = 0; i < length; i++) {
    arr.push(deferred());
  }
  return arr;
}

function delay(ms) {
  var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var timeoutId = void 0;
  var promise = new Promise(function (resolve) {
    timeoutId = setTimeout(function () {
      return resolve(val);
    }, ms);
  });

  promise[CANCEL] = function () {
    return clearTimeout(timeoutId);
  };

  return promise;
}

function createMockTask() {
  var _ref;

  var running = true;
  var _result = void 0,
      _error = void 0;

  return _ref = {}, _ref[TASK] = true, _ref.isRunning = function isRunning() {
    return running;
  }, _ref.result = function result() {
    return _result;
  }, _ref.error = function error() {
    return _error;
  }, _ref.setRunning = function setRunning(b) {
    return running = b;
  }, _ref.setResult = function setResult(r) {
    return _result = r;
  }, _ref.setError = function setError(e) {
    return _error = e;
  }, _ref;
}

function autoInc() {
  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  return function () {
    return ++seed;
  };
}

var uid = autoInc();

var kThrow = function kThrow(err) {
  throw err;
};
var kReturn = function kReturn(value) {
  return { value: value, done: true };
};
function makeIterator(next) {
  var thro = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : kThrow;
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var isHelper = arguments[3];

  var iterator = { name: name, next: next, throw: thro, return: kReturn };

  if (isHelper) {
    iterator[HELPER] = true;
  }
  if (typeof Symbol !== 'undefined') {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }
  return iterator;
}

/**
  Print error in a useful way whether in a browser environment
  (with expandable error stack traces), or in a node.js environment
  (text-only log output)
 **/
function log(level, message) {
  var error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  /*eslint-disable no-console*/
  if (typeof window === 'undefined') {
    console.log('redux-saga ' + level + ': ' + message + '\n' + (error && error.stack || error));
  } else {
    console[level](message, error);
  }
}

function deprecate(fn, deprecationWarning) {
  return function () {
    if (process.env.NODE_ENV === 'development') log('warn', deprecationWarning);
    return fn.apply(undefined, arguments);
  };
}

var updateIncentive = function updateIncentive(deprecated, preferred) {
  return deprecated + ' has been deprecated in favor of ' + preferred + ', please update your code';
};

var internalErr = function internalErr(err) {
  return new Error('\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project\'s github repo.\n  Error: ' + err + '\n');
};

var createSetContextWarning = function createSetContextWarning(ctx, props) {
  return (ctx ? ctx + '.' : '') + 'setContext(props): argument ' + props + ' is not a plain object';
};

var wrapSagaDispatch = function wrapSagaDispatch(dispatch) {
  return function (action) {
    return dispatch(Object.defineProperty(action, SAGA_ACTION, { value: true }));
  };
};

var cloneableGenerator = function cloneableGenerator(generatorFunc) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var history = [];
    var gen = generatorFunc.apply(undefined, args);
    return {
      next: function next(arg) {
        history.push(arg);
        return gen.next(arg);
      },
      clone: function clone() {
        var clonedGen = cloneableGenerator(generatorFunc).apply(undefined, args);
        history.forEach(function (arg) {
          return clonedGen.next(arg);
        });
        return clonedGen;
      },
      return: function _return(value) {
        return gen.return(value);
      },
      throw: function _throw(exception) {
        return gen.throw(exception);
      }
    };
  };
};
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var PooledClass = __webpack_require__(15);

var emptyFunction = __webpack_require__(8);
var warning = __webpack_require__(2);

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  if (process.env.NODE_ENV !== 'production') {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    if (process.env.NODE_ENV !== 'production') {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      // eslint-disable-line valid-typeof
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // eslint-disable-line valid-typeof
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (process.env.NODE_ENV !== 'production') {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      } else {
        this[propName] = null;
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    if (process.env.NODE_ENV !== 'production') {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }

});

SyntheticEvent.Interface = EventInterface;

if (process.env.NODE_ENV !== 'production') {
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}
/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

      if (process.env.NODE_ENV !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if (process.env.NODE_ENV !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   *
   * autofocus is predefined, because adding it to the property whitelist
   * causes unintended side effects.
   *
   * @type {Object}
   */
  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var ReactCurrentOwner = __webpack_require__(11);

var warning = __webpack_require__(2);
var canDefineProperty = __webpack_require__(33);
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = __webpack_require__(93);

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (process.env.NODE_ENV !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMNamespaces = __webpack_require__(41);
var setInnerHTML = __webpack_require__(32);

var createMicrosoftUnsafeLocalFunction = __webpack_require__(48);
var setTextContent = __webpack_require__(86);

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    setInnerHTML(node, tree.html);
  } else if (tree.text != null) {
    setTextContent(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree.insertTreeBefore = insertTreeBefore;
DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree.queueChild = queueChild;
DOMLazyTree.queueHTML = queueHTML;
DOMLazyTree.queueText = queueText;

module.exports = DOMLazyTree;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactRef = __webpack_require__(186);
var ReactInstrumentation = __webpack_require__(9);

var warning = __webpack_require__(2);

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing host component instance
   * @param {?object} info about the host container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
  ) {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
      }
    }
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getHostNode: function (internalInstance) {
    return internalInstance.getHostNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance, safely) {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
      }
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }

};

module.exports = ReactReconciler;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var ReactChildren = __webpack_require__(225);
var ReactComponent = __webpack_require__(56);
var ReactPureComponent = __webpack_require__(230);
var ReactClass = __webpack_require__(226);
var ReactDOMFactories = __webpack_require__(227);
var ReactElement = __webpack_require__(16);
var ReactPropTypes = __webpack_require__(228);
var ReactVersion = __webpack_require__(231);

var onlyChild = __webpack_require__(234);
var warning = __webpack_require__(2);

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  var canDefineProperty = __webpack_require__(33);
  var ReactElementValidator = __webpack_require__(94);
  var didWarnPropTypesDeprecated = false;
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;

if (process.env.NODE_ENV !== 'production') {
  var warned = false;
  __spread = function () {
    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
    warned = true;
    return _assign.apply(null, arguments);
  };
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,
  PureComponent: ReactPureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

// TODO: Fix tests so that this deprecation warning doesn't cause failures.
if (process.env.NODE_ENV !== 'production') {
  if (canDefineProperty) {
    Object.defineProperty(React, 'PropTypes', {
      get: function () {
        process.env.NODE_ENV !== 'production' ? warning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated. Use ' + 'the prop-types package from npm instead.') : void 0;
        didWarnPropTypesDeprecated = true;
        return ReactPropTypes;
      }
    });
  }
}

module.exports = React;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(20);


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var EventPluginRegistry = __webpack_require__(27);
var EventPluginUtils = __webpack_require__(42);
var ReactErrorUtils = __webpack_require__(46);

var accumulateInto = __webpack_require__(80);
var forEachAccumulated = __webpack_require__(81);
var invariant = __webpack_require__(1);

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var getDictionaryKey = function (inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  /**
   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function (inst, registrationName, listener) {
    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (inst, registrationName) {
    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var bankForRegistrationName = listenerBank[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      return null;
    }
    var key = getDictionaryKey(inst);
    return bankForRegistrationName && bankForRegistrationName[key];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      var key = getDictionaryKey(inst);
      delete bankForRegistrationName[key];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function (inst) {
    var key = getDictionaryKey(inst);
    for (var registrationName in listenerBank) {
      if (!listenerBank.hasOwnProperty(registrationName)) {
        continue;
      }

      if (!listenerBank[registrationName][key]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][key];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(23);
var EventPluginUtils = __webpack_require__(42);

var accumulateInto = __webpack_require__(80);
var forEachAccumulated = __webpack_require__(81);
var warning = __webpack_require__(2);

var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

var getEventTarget = __webpack_require__(51);

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  if (process.env.NODE_ENV !== 'production') {
    var lowerCasedName = registrationName.toLowerCase();
    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
  // Trust the developer to only use possibleRegistrationNames in __DEV__

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (injectedEventPluginOrder) {
    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    if (dispatchConfig.phasedRegistrationNames !== undefined) {
      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
      // that it is not undefined.
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      for (var phase in phasedRegistrationNames) {
        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
        if (pluginModule) {
          return pluginModule;
        }
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    eventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
      for (var lowerCasedName in possibleRegistrationNames) {
        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
          delete possibleRegistrationNames[lowerCasedName];
        }
      }
    }
  }

};

module.exports = EventPluginRegistry;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var EventPluginRegistry = __webpack_require__(27);
var ReactEventEmitterMixin = __webpack_require__(176);
var ViewportMetrics = __webpack_require__(79);

var getVendorPrefixedEventName = __webpack_require__(211);
var isEventSupported = __webpack_require__(52);

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topWheel') {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === 'topScroll') {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Protect against document.createEvent() returning null
   * Some popup blocker extensions appear to do this:
   * https://github.com/facebook/react/issues/6887
   */
  supportsEventPageXY: function () {
    if (!document.createEvent) {
      return false;
    }
    var ev = document.createEvent('MouseEvent');
    return ev != null && 'pageX' in ev;
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }

});

module.exports = ReactBrowserEventEmitter;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(26);
var ViewportMetrics = __webpack_require__(79);

var getEventModifierState = __webpack_require__(50);

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

var OBSERVED_ERROR = {};

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var TransactionImpl = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

module.exports = TransactionImpl;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * Based on the escape-html library, which is used under the MIT License below:
 *
 * Copyright (c) 2012-2013 TJ Holowaychuk
 * Copyright (c) 2015 Andreas Lubbe
 * Copyright (c) 2015 Tiancheng "Timothy" Gu
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */



// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html


/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

module.exports = escapeTextContentForBrowser;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);
var DOMNamespaces = __webpack_require__(41);

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction = __webpack_require__(48);

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

module.exports = setInnerHTML;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export BUFFER_OVERFLOW */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return buffers; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(12);


var BUFFER_OVERFLOW = 'Channel\'s Buffer overflow!';

var ON_OVERFLOW_THROW = 1;
var ON_OVERFLOW_DROP = 2;
var ON_OVERFLOW_SLIDE = 3;
var ON_OVERFLOW_EXPAND = 4;

var zeroBuffer = { isEmpty: __WEBPACK_IMPORTED_MODULE_0__utils__["k" /* kTrue */], put: __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */], take: __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */] };

function ringBuffer() {
  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
  var overflowAction = arguments[1];

  var arr = new Array(limit);
  var length = 0;
  var pushIndex = 0;
  var popIndex = 0;

  var push = function push(it) {
    arr[pushIndex] = it;
    pushIndex = (pushIndex + 1) % limit;
    length++;
  };

  var take = function take() {
    if (length != 0) {
      var it = arr[popIndex];
      arr[popIndex] = null;
      length--;
      popIndex = (popIndex + 1) % limit;
      return it;
    }
  };

  var flush = function flush() {
    var items = [];
    while (length) {
      items.push(take());
    }
    return items;
  };

  return {
    isEmpty: function isEmpty() {
      return length == 0;
    },
    put: function put(it) {
      if (length < limit) {
        push(it);
      } else {
        var doubledLimit = void 0;
        switch (overflowAction) {
          case ON_OVERFLOW_THROW:
            throw new Error(BUFFER_OVERFLOW);
          case ON_OVERFLOW_SLIDE:
            arr[pushIndex] = it;
            pushIndex = (pushIndex + 1) % limit;
            popIndex = pushIndex;
            break;
          case ON_OVERFLOW_EXPAND:
            doubledLimit = 2 * limit;

            arr = flush();

            length = arr.length;
            pushIndex = arr.length;
            popIndex = 0;

            arr.length = doubledLimit;
            limit = doubledLimit;

            push(it);
            break;
          default:
          // DROP
        }
      }
    },
    take: take, flush: flush
  };
}

var buffers = {
  none: function none() {
    return zeroBuffer;
  },
  fixed: function fixed(limit) {
    return ringBuffer(limit, ON_OVERFLOW_THROW);
  },
  dropping: function dropping(limit) {
    return ringBuffer(limit, ON_OVERFLOW_DROP);
  },
  sliding: function sliding(limit) {
    return ringBuffer(limit, ON_OVERFLOW_SLIDE);
  },
  expanding: function expanding(initialSize) {
    return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);
  }
};

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return END; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isEnd; });
/* harmony export (immutable) */ __webpack_exports__["e"] = emitter;
/* unused harmony export INVALID_BUFFER */
/* unused harmony export UNDEFINED_INPUT_ERROR */
/* unused harmony export channel */
/* harmony export (immutable) */ __webpack_exports__["d"] = eventChannel;
/* harmony export (immutable) */ __webpack_exports__["b"] = stdChannel;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__buffers__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__scheduler__ = __webpack_require__(101);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';
var END = { type: CHANNEL_END_TYPE };
var isEnd = function isEnd(a) {
  return a && a.type === CHANNEL_END_TYPE;
};

function emitter() {
  var subscribers = [];

  function subscribe(sub) {
    subscribers.push(sub);
    return function () {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["m" /* remove */])(subscribers, sub);
    };
  }

  function emit(item) {
    var arr = subscribers.slice();
    for (var i = 0, len = arr.length; i < len; i++) {
      arr[i](item);
    }
  }

  return {
    subscribe: subscribe,
    emit: emit
  };
}

var INVALID_BUFFER = 'invalid buffer passed to channel factory function';
var UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';

if (process.env.NODE_ENV !== 'production') {
  UNDEFINED_INPUT_ERROR += '\nHints:\n    - check that your Action Creator returns a non-undefined value\n    - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\n  ';
}

function channel() {
  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : __WEBPACK_IMPORTED_MODULE_1__buffers__["a" /* buffers */].fixed();

  var closed = false;
  var takers = [];

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(buffer, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].buffer, INVALID_BUFFER);

  function checkForbiddenStates() {
    if (closed && takers.length) {
      throw __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["n" /* internalErr */])('Cannot have a closed channel with pending takers');
    }
    if (takers.length && !buffer.isEmpty()) {
      throw __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["n" /* internalErr */])('Cannot have pending takers with non empty buffer');
    }
  }

  function put(input) {
    checkForbiddenStates();
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(input, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, UNDEFINED_INPUT_ERROR);
    if (closed) {
      return;
    }
    if (!takers.length) {
      return buffer.put(input);
    }
    for (var i = 0; i < takers.length; i++) {
      var cb = takers[i];
      if (!cb[__WEBPACK_IMPORTED_MODULE_0__utils__["o" /* MATCH */]] || cb[__WEBPACK_IMPORTED_MODULE_0__utils__["o" /* MATCH */]](input)) {
        takers.splice(i, 1);
        return cb(input);
      }
    }
  }

  function take(cb) {
    checkForbiddenStates();
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(cb, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func, 'channel.take\'s callback must be a function');

    if (closed && buffer.isEmpty()) {
      cb(END);
    } else if (!buffer.isEmpty()) {
      cb(buffer.take());
    } else {
      takers.push(cb);
      cb.cancel = function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["m" /* remove */])(takers, cb);
      };
    }
  }

  function flush(cb) {
    checkForbiddenStates(); // TODO: check if some new state should be forbidden now
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(cb, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func, 'channel.flush\' callback must be a function');
    if (closed && buffer.isEmpty()) {
      cb(END);
      return;
    }
    cb(buffer.flush());
  }

  function close() {
    checkForbiddenStates();
    if (!closed) {
      closed = true;
      if (takers.length) {
        var arr = takers;
        takers = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          arr[i](END);
        }
      }
    }
  }

  return { take: take, put: put, flush: flush, close: close,
    get __takers__() {
      return takers;
    },
    get __closed__() {
      return closed;
    }
  };
}

function eventChannel(subscribe) {
  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : __WEBPACK_IMPORTED_MODULE_1__buffers__["a" /* buffers */].none();
  var matcher = arguments[2];

  /**
    should be if(typeof matcher !== undefined) instead?
    see PR #273 for a background discussion
  **/
  if (arguments.length > 2) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(matcher, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func, 'Invalid match function passed to eventChannel');
  }

  var chan = channel(buffer);
  var close = function close() {
    if (!chan.__closed__) {
      if (unsubscribe) {
        unsubscribe();
      }
      chan.close();
    }
  };
  var unsubscribe = subscribe(function (input) {
    if (isEnd(input)) {
      close();
      return;
    }
    if (matcher && !matcher(input)) {
      return;
    }
    chan.put(input);
  });
  if (chan.__closed__) {
    unsubscribe();
  }

  if (!__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func(unsubscribe)) {
    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');
  }

  return {
    take: chan.take,
    flush: chan.flush,
    close: close
  };
}

function stdChannel(subscribe) {
  var chan = eventChannel(function (cb) {
    return subscribe(function (input) {
      if (input[__WEBPACK_IMPORTED_MODULE_0__utils__["p" /* SAGA_ACTION */]]) {
        cb(input);
        return;
      }
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__scheduler__["a" /* asap */])(function () {
        return cb(input);
      });
    });
  });

  return _extends({}, chan, {
    take: function take(cb, matcher) {
      if (arguments.length > 1) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(matcher, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func, 'channel.take\'s matcher argument must be a function');
        cb[__WEBPACK_IMPORTED_MODULE_0__utils__["o" /* MATCH */]] = matcher;
      }
      chan.take(cb);
    }
  });
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = take;
/* unused harmony export takem */
/* harmony export (immutable) */ __webpack_exports__["a"] = put;
/* unused harmony export all */
/* unused harmony export race */
/* harmony export (immutable) */ __webpack_exports__["b"] = call;
/* unused harmony export apply */
/* unused harmony export cps */
/* harmony export (immutable) */ __webpack_exports__["e"] = fork;
/* unused harmony export spawn */
/* unused harmony export join */
/* harmony export (immutable) */ __webpack_exports__["f"] = cancel;
/* unused harmony export select */
/* harmony export (immutable) */ __webpack_exports__["g"] = actionChannel;
/* unused harmony export cancelled */
/* unused harmony export flush */
/* unused harmony export getContext */
/* unused harmony export setContext */
/* harmony export (immutable) */ __webpack_exports__["c"] = takeEvery;
/* unused harmony export takeLatest */
/* unused harmony export throttle */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return asEffect; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sagaHelpers__ = __webpack_require__(100);



var IO = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["a" /* sym */])('IO');
var TAKE = 'TAKE';
var PUT = 'PUT';
var ALL = 'ALL';
var RACE = 'RACE';
var CALL = 'CALL';
var CPS = 'CPS';
var FORK = 'FORK';
var JOIN = 'JOIN';
var CANCEL = 'CANCEL';
var SELECT = 'SELECT';
var ACTION_CHANNEL = 'ACTION_CHANNEL';
var CANCELLED = 'CANCELLED';
var FLUSH = 'FLUSH';
var GET_CONTEXT = 'GET_CONTEXT';
var SET_CONTEXT = 'SET_CONTEXT';

var TEST_HINT = '\n(HINT: if you are getting this errors in tests, consider using createMockTask from redux-saga/utils)';

var effect = function effect(type, payload) {
  var _ref;

  return _ref = {}, _ref[IO] = true, _ref[type] = payload, _ref;
};

function take() {
  var patternOrChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '*';

  if (arguments.length) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(arguments[0], __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, 'take(patternOrChannel): patternOrChannel is undefined');
  }
  if (__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].pattern(patternOrChannel)) {
    return effect(TAKE, { pattern: patternOrChannel });
  }
  if (__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].channel(patternOrChannel)) {
    return effect(TAKE, { channel: patternOrChannel });
  }
  throw new Error('take(patternOrChannel): argument ' + String(patternOrChannel) + ' is not valid channel or a valid pattern');
}

take.maybe = function () {
  var eff = take.apply(undefined, arguments);
  eff[TAKE].maybe = true;
  return eff;
};

var takem = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["d" /* deprecate */])(take.maybe, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["e" /* updateIncentive */])('takem', 'take.maybe'));

function put(channel, action) {
  if (arguments.length > 1) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(channel, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, 'put(channel, action): argument channel is undefined');
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(channel, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].channel, 'put(channel, action): argument ' + channel + ' is not a valid channel');
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(action, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, 'put(channel, action): argument action is undefined');
  } else {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(channel, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, 'put(action): argument action is undefined');
    action = channel;
    channel = null;
  }
  return effect(PUT, { channel: channel, action: action });
}

put.resolve = function () {
  var eff = put.apply(undefined, arguments);
  eff[PUT].resolve = true;
  return eff;
};

put.sync = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["d" /* deprecate */])(put.resolve, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["e" /* updateIncentive */])('put.sync', 'put.resolve'));

function all(effects) {
  return effect(ALL, effects);
}

function race(effects) {
  return effect(RACE, effects);
}

function getFnCallDesc(meth, fn, args) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(fn, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, meth + ': argument fn is undefined');

  var context = null;
  if (__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].array(fn)) {
    var _fn = fn;
    context = _fn[0];
    fn = _fn[1];
  } else if (fn.fn) {
    var _fn2 = fn;
    context = _fn2.context;
    fn = _fn2.fn;
  }
  if (context && __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].string(fn) && __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func(context[fn])) {
    fn = context[fn];
  }
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(fn, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func, meth + ': argument ' + fn + ' is not a function');

  return { context: context, fn: fn, args: args };
}

function call(fn) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return effect(CALL, getFnCallDesc('call', fn, args));
}

function apply(context, fn) {
  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  return effect(CALL, getFnCallDesc('apply', { context: context, fn: fn }, args));
}

function cps(fn) {
  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return effect(CPS, getFnCallDesc('cps', fn, args));
}

function fork(fn) {
  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return effect(FORK, getFnCallDesc('fork', fn, args));
}

function spawn(fn) {
  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  var eff = fork.apply(undefined, [fn].concat(args));
  eff[FORK].detached = true;
  return eff;
}

function join() {
  for (var _len5 = arguments.length, tasks = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    tasks[_key5] = arguments[_key5];
  }

  if (tasks.length > 1) {
    return all(tasks.map(function (t) {
      return join(t);
    }));
  }
  var task = tasks[0];
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(task, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, 'join(task): argument task is undefined');
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(task, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].task, 'join(task): argument ' + task + ' is not a valid Task object ' + TEST_HINT);
  return effect(JOIN, task);
}

function cancel() {
  for (var _len6 = arguments.length, tasks = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    tasks[_key6] = arguments[_key6];
  }

  if (tasks.length > 1) {
    return all(tasks.map(function (t) {
      return cancel(t);
    }));
  }
  var task = tasks[0];
  if (tasks.length === 1) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(task, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, 'cancel(task): argument task is undefined');
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(task, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].task, 'cancel(task): argument ' + task + ' is not a valid Task object ' + TEST_HINT);
  }
  return effect(CANCEL, task || __WEBPACK_IMPORTED_MODULE_0__utils__["f" /* SELF_CANCELLATION */]);
}

function select(selector) {
  for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
    args[_key7 - 1] = arguments[_key7];
  }

  if (arguments.length === 0) {
    selector = __WEBPACK_IMPORTED_MODULE_0__utils__["g" /* ident */];
  } else {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(selector, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, 'select(selector,[...]): argument selector is undefined');
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(selector, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func, 'select(selector,[...]): argument ' + selector + ' is not a function');
  }
  return effect(SELECT, { selector: selector, args: args });
}

/**
  channel(pattern, [buffer])    => creates an event channel for store actions
**/
function actionChannel(pattern, buffer) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(pattern, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, 'actionChannel(pattern,...): argument pattern is undefined');
  if (arguments.length > 1) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(buffer, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].notUndef, 'actionChannel(pattern, buffer): argument buffer is undefined');
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(buffer, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].buffer, 'actionChannel(pattern, buffer): argument ' + buffer + ' is not a valid buffer');
  }
  return effect(ACTION_CHANNEL, { pattern: pattern, buffer: buffer });
}

function cancelled() {
  return effect(CANCELLED, {});
}

function flush(channel) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(channel, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].channel, 'flush(channel): argument ' + channel + ' is not valid channel');
  return effect(FLUSH, channel);
}

function getContext(prop) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(prop, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].string, 'getContext(prop): argument ' + prop + ' is not a string');
  return effect(GET_CONTEXT, prop);
}

function setContext(props) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(props, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].object, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["h" /* createSetContextWarning */])(null, props));
  return effect(SET_CONTEXT, props);
}

function takeEvery(patternOrChannel, worker) {
  for (var _len8 = arguments.length, args = Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {
    args[_key8 - 2] = arguments[_key8];
  }

  return fork.apply(undefined, [__WEBPACK_IMPORTED_MODULE_1__sagaHelpers__["a" /* takeEveryHelper */], patternOrChannel, worker].concat(args));
}

function takeLatest(patternOrChannel, worker) {
  for (var _len9 = arguments.length, args = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {
    args[_key9 - 2] = arguments[_key9];
  }

  return fork.apply(undefined, [__WEBPACK_IMPORTED_MODULE_1__sagaHelpers__["b" /* takeLatestHelper */], patternOrChannel, worker].concat(args));
}

function throttle(ms, pattern, worker) {
  for (var _len10 = arguments.length, args = Array(_len10 > 3 ? _len10 - 3 : 0), _key10 = 3; _key10 < _len10; _key10++) {
    args[_key10 - 3] = arguments[_key10];
  }

  return fork.apply(undefined, [__WEBPACK_IMPORTED_MODULE_1__sagaHelpers__["c" /* throttleHelper */], ms, pattern, worker].concat(args));
}

var createAsEffectType = function createAsEffectType(type) {
  return function (effect) {
    return effect && effect[IO] && effect[type];
  };
};

var asEffect = {
  take: createAsEffectType(TAKE),
  put: createAsEffectType(PUT),
  all: createAsEffectType(ALL),
  race: createAsEffectType(RACE),
  call: createAsEffectType(CALL),
  cps: createAsEffectType(CPS),
  fork: createAsEffectType(FORK),
  join: createAsEffectType(JOIN),
  cancel: createAsEffectType(CANCEL),
  select: createAsEffectType(SELECT),
  actionChannel: createAsEffectType(ACTION_CHANNEL),
  cancelled: createAsEffectType(CANCELLED),
  flush: createAsEffectType(FLUSH),
  getContext: createAsEffectType(GET_CONTEXT),
  setContext: createAsEffectType(SET_CONTEXT)
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(140);




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a" /* default */])(value) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) != objectTag) {
    return false;
  }
  var proto = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a" /* default */])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ __webpack_exports__["a"] = (isPlainObject);


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMLazyTree = __webpack_require__(18);
var Danger = __webpack_require__(149);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactInstrumentation = __webpack_require__(9);

var createMicrosoftUnsafeLocalFunction = __webpack_require__(48);
var setInnerHTML = __webpack_require__(32);
var setTextContent = __webpack_require__(86);

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getHostNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if (process.env.NODE_ENV !== 'production') {
  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
    if (prevInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: prevInstance._debugID,
        type: 'replace with',
        payload: markup.toString()
      });
    } else {
      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
      if (nextInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: nextInstance._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function (parentNode, updates) {
    if (process.env.NODE_ENV !== 'production') {
      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
    }

    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case 'INSERT_MARKUP':
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'insert child',
              payload: { toIndex: update.toIndex, content: update.content.toString() }
            });
          }
          break;
        case 'MOVE_EXISTING':
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'move child',
              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
            });
          }
          break;
        case 'SET_MARKUP':
          setInnerHTML(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace children',
              payload: update.content.toString()
            });
          }
          break;
        case 'TEXT_CONTENT':
          setTextContent(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace text',
              payload: update.content.toString()
            });
          }
          break;
        case 'REMOVE_NODE':
          removeChild(parentNode, update.fromNode);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'remove child',
              payload: { fromIndex: update.fromIndex }
            });
          }
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMNamespaces = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

module.exports = DOMNamespaces;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactErrorUtils = __webpack_require__(46);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function (Injected) {
    ComponentTree = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
    }
  },
  injectTreeTraversal: function (Injected) {
    TreeTraversal = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
    }
  }
};

function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}

function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}
function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}

var validateEventDispatches;
if (process.env.NODE_ENV !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function (node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function (node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function (a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactPropTypesSecret = __webpack_require__(78);
var propTypesFactory = __webpack_require__(64);

var React = __webpack_require__(20);
var PropTypes = propTypesFactory(React.isValidElement);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: PropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if (process.env.NODE_ENV !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactCurrentOwner = __webpack_require__(11);
var ReactInstanceMap = __webpack_require__(25);
var ReactInstrumentation = __webpack_require__(9);
var ReactUpdates = __webpack_require__(10);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var ctor = publicInstance.constructor;
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
    }
    return null;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    // Future-proof 15.5
    if (callback !== undefined && callback !== null) {
      ReactUpdateQueue.validateCallback(callback, 'replaceState');
      if (internalInstance._pendingCallbacks) {
        internalInstance._pendingCallbacks.push(callback);
      } else {
        internalInstance._pendingCallbacks = [callback];
      }
    }

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onSetState();
      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
    }

    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    // TODO: introduce _pendingContext instead of setting it directly.
    internalInstance._context = nextContext;
    enqueueUpdate(internalInstance);
  },

  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
  }

};

module.exports = ReactUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals MSApp */



/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

module.exports = createMicrosoftUnsafeLocalFunction;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

module.exports = shouldUpdateReactComponent;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var emptyFunction = __webpack_require__(8);
var warning = __webpack_require__(2);

var validateDOMNesting = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    do {
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      var whitespaceInfo = '';
      if (childTag === '#text') {
        if (/\S/.test(childText)) {
          tagDisplayName = 'Text nodes';
        } else {
          tagDisplayName = 'Whitespace text nodes';
          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
        }
      } else {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
      }
    }
  };

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(17);

var ReactNoopUpdateQueue = __webpack_require__(57);

var canDefineProperty = __webpack_require__(33);
var emptyObject = __webpack_require__(22);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var warning = __webpack_require__(2);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(114);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(244)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../node_modules/css-loader/index.js?modules!./style.css", function() {
			var newContent = require("!!../node_modules/css-loader/index.js?modules!./style.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 59 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(8);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(139);


/** Built-in value references. */
var Symbol = __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */].Symbol;

/* harmony default export */ __webpack_exports__["a"] = (Symbol);


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



// React 15.5 references this module, and assumes PropTypes are still callable in production.
// Therefore we re-export development-only version with all the PropTypes checks here.
// However if one is migrating to the `prop-types` npm library, they will go through the
// `index.js` entry point, and it will branch depending on the environment.
var factory = __webpack_require__(65);
module.exports = function(isValidElement) {
  // It is still allowed in 15.5.
  var throwOnDirectAccess = false;
  return factory(isValidElement, throwOnDirectAccess);
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(8);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var ReactPropTypesSecret = __webpack_require__(39);
var checkPropTypes = __webpack_require__(141);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(65)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(142)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PooledClass = __webpack_require__(15);

var invariant = __webpack_require__(1);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
  function CallbackQueue(arg) {
    _classCallCheck(this, CallbackQueue);

    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */


  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */


  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };

  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };

  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };

  /**
   * Resets the internal queue.
   *
   * @internal
   */


  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };

  /**
   * `PooledClass` looks for this.
   */


  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(14);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactInstrumentation = __webpack_require__(9);

var quoteAttributeValueForBrowser = __webpack_require__(212);
var warning = __webpack_require__(2);

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function () {
    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function (node) {
    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    if (process.env.NODE_ENV !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForAttribute: function (node, name) {
    node.removeAttribute(name);
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }

    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  }

};

module.exports = DOMPropertyOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentFlags = {
  hasCachedChildNodes: 1 << 0
};

module.exports = ReactDOMComponentFlags;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var LinkedValueUtils = __webpack_require__(44);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(10);

var warning = __webpack_require__(2);

var didWarnValueLink = false;
var didWarnValueDefaultValue = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
    didWarnValueLink = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    } else if (!props.multiple && isArray) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  getHostProps: function (inst, props) {
    return _assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
      didWarnValueDefaultValue = true;
    }
  },

  getSelectValueContext: function (inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactFeatureFlags = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

module.exports = ReactFeatureFlags;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

var genericComponentClass = null;
var textComponentClass = null;

var ReactHostComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  }
};

/**
 * Get a host internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactHostComponent = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};

module.exports = ReactHostComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMSelection = __webpack_require__(167);

var containsNode = __webpack_require__(118);
var focusNode = __webpack_require__(61);
var getActiveElement = __webpack_require__(62);

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var DOMLazyTree = __webpack_require__(18);
var DOMProperty = __webpack_require__(14);
var React = __webpack_require__(20);
var ReactBrowserEventEmitter = __webpack_require__(28);
var ReactCurrentOwner = __webpack_require__(11);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactDOMContainerInfo = __webpack_require__(159);
var ReactDOMFeatureFlags = __webpack_require__(161);
var ReactFeatureFlags = __webpack_require__(73);
var ReactInstanceMap = __webpack_require__(25);
var ReactInstrumentation = __webpack_require__(9);
var ReactMarkupChecksum = __webpack_require__(181);
var ReactReconciler = __webpack_require__(19);
var ReactUpdateQueue = __webpack_require__(47);
var ReactUpdates = __webpack_require__(10);

var emptyObject = __webpack_require__(22);
var instantiateReactComponent = __webpack_require__(84);
var invariant = __webpack_require__(1);
var setInnerHTML = __webpack_require__(32);
var shouldUpdateReactComponent = __webpack_require__(53);
var warning = __webpack_require__(2);

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props.child;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
  );

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onBeginFlush();
  }
  ReactReconciler.unmountComponent(instance, safely);
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onEndFlush();
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return !!(inst && inst._hostParent);
  }
}

/**
 * True if the supplied DOM node is a React DOM element and
 * it has been rendered by another copy of React.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM has been rendered by another copy of React
 * @internal
 */
function nodeIsRenderedByOtherInstance(container) {
  var rootEl = getReactRootElementInContainer(container);
  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
}

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
}

/**
 * True if the supplied DOM node is a valid React node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid React DOM node.
 * @internal
 */
function isReactNode(node) {
  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
}

function getHostRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getHostRootInstanceInContainer(container);
  return root ? root._hostContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if (process.env.NODE_ENV !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by hooks!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent(nextElement, false);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

    var nextContext;
    if (parentComponent) {
      var parentInst = ReactInstanceMap.get(parentComponent);
      nextContext = parentInst._processChildContext(parentInst._context);
    } else {
      nextContext = emptyObject;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props.child;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
      }

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if (process.env.NODE_ENV !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML(container, markup);
      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
    }

    if (process.env.NODE_ENV !== 'production') {
      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
      if (hostNode._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: hostNode._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  }
};

module.exports = ReactMount;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var React = __webpack_require__(20);

var invariant = __webpack_require__(1);

var ReactNodeTypes = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes.EMPTY;
    } else if (React.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes.COMPOSITE;
      } else {
        return ReactNodeTypes.HOST;
      }
    }
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
  }
};

module.exports = ReactNodeTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

module.exports = forEachAccumulated;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactNodeTypes = __webpack_require__(77);

function getHostComponentFromComposite(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes.EMPTY) {
    return null;
  }
}

module.exports = getHostComponentFromComposite;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var ReactCompositeComponent = __webpack_require__(156);
var ReactEmptyComponent = __webpack_require__(72);
var ReactHostComponent = __webpack_require__(74);

var getNextDebugID = __webpack_require__(233);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {boolean} shouldHaveDebugID
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, shouldHaveDebugID) {
  var instance;

  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    var type = element.type;
    if (typeof type !== 'function' && typeof type !== 'string') {
      var info = '';
      if (process.env.NODE_ENV !== 'production') {
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }
      }
      info += getDeclarationErrorAddendum(element._owner);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
    }

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactHostComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);

      // We renamed this. Allow the old name for compat. :(
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent.createInstanceForText(node);
  } else {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if (process.env.NODE_ENV !== 'production') {
    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if (process.env.NODE_ENV !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent
});

module.exports = instantiateReactComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

module.exports = isTextInputElement;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);
var escapeTextContentForBrowser = __webpack_require__(31);
var setInnerHTML = __webpack_require__(32);

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      if (node.nodeType === 3) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactCurrentOwner = __webpack_require__(11);
var REACT_ELEMENT_TYPE = __webpack_require__(175);

var getIteratorFn = __webpack_require__(209);
var invariant = __webpack_require__(1);
var KeyEscapeUtils = __webpack_require__(43);
var warning = __webpack_require__(2);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["a"] = connectAdvanced;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_Subscription__ = __webpack_require__(221);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__ = __webpack_require__(91);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }








var hotReloadingVersion = 0;
var dummyState = {};
function noop() {}
function makeSelectorStateful(sourceSelector, store) {
  // wrap the selector in an object that tracks its results between runs.
  var selector = {
    run: function runComponentSelector(props) {
      try {
        var nextProps = sourceSelector(store.getState(), props);
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true;
          selector.props = nextProps;
          selector.error = null;
        }
      } catch (error) {
        selector.shouldComponentUpdate = true;
        selector.error = error;
      }
    }
  };

  return selector;
}

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory) {
  var _contextTypes, _childContextTypes;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$getDisplayName = _ref.getDisplayName,
      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
    return 'ConnectAdvanced(' + name + ')';
  } : _ref$getDisplayName,
      _ref$methodName = _ref.methodName,
      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
      _ref$renderCountProp = _ref.renderCountProp,
      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
      _ref$storeKey = _ref.storeKey,
      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
      _ref$withRef = _ref.withRef,
      withRef = _ref$withRef === undefined ? false : _ref$withRef,
      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

  var subscriptionKey = storeKey + 'Subscription';
  var version = hotReloadingVersion++;

  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["a" /* storeShape */], _contextTypes[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["b" /* subscriptionShape */], _contextTypes);
  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_4__utils_PropTypes__["b" /* subscriptionShape */], _childContextTypes);

  return function wrapWithConnect(WrappedComponent) {
    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + ('connect. Instead received ' + JSON.stringify(WrappedComponent)));

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      withRef: withRef,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.state = {};
        _this.renderCount = 0;
        _this.store = props[storeKey] || context[storeKey];
        _this.propsMode = Boolean(props[storeKey]);
        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

        __WEBPACK_IMPORTED_MODULE_1_invariant___default()(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

        _this.initSelector();
        _this.initSubscription();
        return _this;
      }

      Connect.prototype.getChildContext = function getChildContext() {
        var _ref2;

        // If this component received store from props, its subscription should be transparent
        // to any descendants receiving store+subscription from context; it passes along
        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
        // Connect to control ordering of notifications to flow top-down.
        var subscription = this.propsMode ? null : this.subscription;
        return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        if (!shouldHandleStateChanges) return;

        // componentWillMount fires during server side rendering, but componentDidMount and
        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
        // To handle the case where a child component may have triggered a state change by
        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
        // re-render.
        this.subscription.trySubscribe();
        this.selector.run(this.props);
        if (this.selector.shouldComponentUpdate) this.forceUpdate();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps);
      };

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate;
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe();
        this.subscription = null;
        this.notifyNestedSubs = noop;
        this.store = null;
        this.selector.run = noop;
        this.selector.shouldComponentUpdate = false;
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        __WEBPACK_IMPORTED_MODULE_1_invariant___default()(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
        return this.wrappedInstance;
      };

      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
        this.wrappedInstance = ref;
      };

      Connect.prototype.initSelector = function initSelector() {
        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
        this.selector = makeSelectorStateful(sourceSelector, this.store);
        this.selector.run(this.props);
      };

      Connect.prototype.initSubscription = function initSubscription() {
        if (!shouldHandleStateChanges) return;

        // parentSub's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
        this.subscription = new __WEBPACK_IMPORTED_MODULE_3__utils_Subscription__["a" /* default */](this.store, parentSub, this.onStateChange.bind(this));

        // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
        // the middle of the notification loop, where `this.subscription` will then be null. An
        // extra null check every change can be avoided by copying the method onto `this` and then
        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
        // listeners logic is changed to not call listeners that have been unsubscribed in the
        // middle of the notification loop.
        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
      };

      Connect.prototype.onStateChange = function onStateChange() {
        this.selector.run(this.props);

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs();
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
          this.setState(dummyState);
        }
      };

      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
        // needs to notify nested subs. Once called, it unimplements itself until further state
        // changes occur. Doing it this way vs having a permanent `componentDidMount` that does
        // a boolean check every time avoids an extra method call most of the time, resulting
        // in some perf boost.
        this.componentDidUpdate = undefined;
        this.notifyNestedSubs();
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed();
      };

      Connect.prototype.addExtraProps = function addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
        // make a shallow copy so that fields added don't leak to the original selector.
        // this is especially important for 'ref' since that's a reference back to the component
        // instance. a singleton memoized selector would then be holding a reference to the
        // instance, preventing the instance from being garbage collected, and that would be bad
        var withExtras = _extends({}, props);
        if (withRef) withExtras.ref = this.setWrappedInstance;
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
        return withExtras;
      };

      Connect.prototype.render = function render() {
        var selector = this.selector;
        selector.shouldComponentUpdate = false;

        if (selector.error) {
          throw selector.error;
        } else {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_react__["createElement"])(WrappedComponent, this.addExtraProps(selector.props));
        }
      };

      return Connect;
    }(__WEBPACK_IMPORTED_MODULE_2_react__["Component"]);

    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;
    Connect.childContextTypes = childContextTypes;
    Connect.contextTypes = contextTypes;
    Connect.propTypes = contextTypes;

    if (process.env.NODE_ENV !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        // We are hot reloading!
        if (this.version !== version) {
          this.version = version;
          this.initSelector();

          if (this.subscription) this.subscription.tryUnsubscribe();
          this.initSubscription();
          if (shouldHandleStateChanges) this.subscription.trySubscribe();
        }
      };
    }

    return __WEBPACK_IMPORTED_MODULE_0_hoist_non_react_statics___default()(Connect, WrappedComponent);
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["b"] = wrapMapToPropsConstant;
/* unused harmony export getDependsOnOwnProps */
/* harmony export (immutable) */ __webpack_exports__["a"] = wrapMapToPropsFunc;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__ = __webpack_require__(92);


function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}

// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
// 
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}

// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
// 
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//    
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//    
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//    
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (process.env.NODE_ENV !== 'production') __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__["a" /* default */])(props, displayName, methodName);

      return props;
    };

    return proxy;
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_Provider__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_connectAdvanced__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__connect_connect__ = __webpack_require__(215);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__components_Provider__["a"]; });
/* unused harmony reexport createProvider */
/* unused harmony reexport connectAdvanced */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_2__connect_connect__["a"]; });






/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return subscriptionShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return storeShape; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_prop_types__);


var subscriptionShape = __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.shape({
  trySubscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  tryUnsubscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  notifyNestedSubs: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  isSubscribed: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired
});

var storeShape = __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.shape({
  subscribe: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  dispatch: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired,
  getState: __WEBPACK_IMPORTED_MODULE_0_prop_types___default.a.func.isRequired
});

/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = verifyPlainObject;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__warning__ = __webpack_require__(55);



function verifyPlainObject(value, displayName, methodName) {
  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__["a" /* default */])(value)) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__warning__["a" /* default */])(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
  }
}

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */



var ReactCurrentOwner = __webpack_require__(11);
var ReactComponentTreeHook = __webpack_require__(7);
var ReactElement = __webpack_require__(16);

var checkReactTypeSpec = __webpack_require__(232);

var canDefineProperty = __webpack_require__(33);
var getIteratorFn = __webpack_require__(96);
var warning = __webpack_require__(2);

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return ' Check your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += ReactComponentTreeHook.getCurrentStackAddendum();

        process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__internal_io__ = __webpack_require__(36);
/* unused harmony reexport take */
/* unused harmony reexport takem */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__internal_io__["a"]; });
/* unused harmony reexport all */
/* unused harmony reexport race */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__internal_io__["b"]; });
/* unused harmony reexport apply */
/* unused harmony reexport cps */
/* unused harmony reexport fork */
/* unused harmony reexport spawn */
/* unused harmony reexport join */
/* unused harmony reexport cancel */
/* unused harmony reexport select */
/* unused harmony reexport actionChannel */
/* unused harmony reexport cancelled */
/* unused harmony reexport flush */
/* unused harmony reexport getContext */
/* unused harmony reexport setContext */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_0__internal_io__["c"]; });
/* unused harmony reexport takeLatest */
/* unused harmony reexport throttle */


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export NOT_ITERATOR_ERROR */
/* unused harmony export CHANNEL_END */
/* unused harmony export TASK_CANCEL */
/* harmony export (immutable) */ __webpack_exports__["a"] = proc;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__scheduler__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__io__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__channel__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__buffers__ = __webpack_require__(34);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if ("value" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } return obj; }







var NOT_ITERATOR_ERROR = 'proc first argument (Saga function result) must be an iterator';

var CHANNEL_END = {
  toString: function toString() {
    return '@@redux-saga/CHANNEL_END';
  }
};
var TASK_CANCEL = {
  toString: function toString() {
    return '@@redux-saga/TASK_CANCEL';
  }
};

var matchers = {
  wildcard: function wildcard() {
    return __WEBPACK_IMPORTED_MODULE_0__utils__["k" /* kTrue */];
  },
  default: function _default(pattern) {
    return (typeof pattern === 'undefined' ? 'undefined' : _typeof(pattern)) === 'symbol' ? function (input) {
      return input.type === pattern;
    } : function (input) {
      return input.type === String(pattern);
    };
  },
  array: function array(patterns) {
    return function (input) {
      return patterns.some(function (p) {
        return matcher(p)(input);
      });
    };
  },
  predicate: function predicate(_predicate) {
    return function (input) {
      return _predicate(input);
    };
  }
};

function matcher(pattern) {
  return (pattern === '*' ? matchers.wildcard : __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].array(pattern) ? matchers.array : __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].stringableFunc(pattern) ? matchers.default : __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func(pattern) ? matchers.predicate : matchers.default)(pattern);
}

/**
  Used to track a parent task and its forks
  In the new fork model, forked tasks are attached by default to their parent
  We model this using the concept of Parent task && main Task
  main task is the main flow of the current Generator, the parent tasks is the
  aggregation of the main tasks + all its forked tasks.
  Thus the whole model represents an execution tree with multiple branches (vs the
  linear execution tree in sequential (non parallel) programming)

  A parent tasks has the following semantics
  - It completes if all its forks either complete or all cancelled
  - If it's cancelled, all forks are cancelled as well
  - It aborts if any uncaught error bubbles up from forks
  - If it completes, the return value is the one returned by the main task
**/
function forkQueue(name, mainTask, cb) {
  var tasks = [],
      result = void 0,
      completed = false;
  addTask(mainTask);

  function abort(err) {
    cancelAll();
    cb(err, true);
  }

  function addTask(task) {
    tasks.push(task);
    task.cont = function (res, isErr) {
      if (completed) {
        return;
      }

      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["m" /* remove */])(tasks, task);
      task.cont = __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
      if (isErr) {
        abort(res);
      } else {
        if (task === mainTask) {
          result = res;
        }
        if (!tasks.length) {
          completed = true;
          cb(result);
        }
      }
    };
    // task.cont.cancel = task.cancel
  }

  function cancelAll() {
    if (completed) {
      return;
    }
    completed = true;
    tasks.forEach(function (t) {
      t.cont = __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
      t.cancel();
    });
    tasks = [];
  }

  return {
    addTask: addTask,
    cancelAll: cancelAll,
    abort: abort,
    getTasks: function getTasks() {
      return tasks;
    },
    taskNames: function taskNames() {
      return tasks.map(function (t) {
        return t.name;
      });
    }
  };
}

function createTaskIterator(_ref) {
  var context = _ref.context,
      fn = _ref.fn,
      args = _ref.args;

  if (__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].iterator(fn)) {
    return fn;
  }

  // catch synchronous failures; see #152 and #441
  var result = void 0,
      error = void 0;
  try {
    result = fn.apply(context, args);
  } catch (err) {
    error = err;
  }

  // i.e. a generator function returns an iterator
  if (__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].iterator(result)) {
    return result;
  }

  // do not bubble up synchronous failures for detached forks
  // instead create a failed task. See #152 and #441
  return error ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["i" /* makeIterator */])(function () {
    throw error;
  }) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["i" /* makeIterator */])(function () {
    var pc = void 0;
    var eff = { done: false, value: result };
    var ret = function ret(value) {
      return { done: true, value: value };
    };
    return function (arg) {
      if (!pc) {
        pc = true;
        return eff;
      } else {
        return ret(arg);
      }
    };
  }());
}

var wrapHelper = function wrapHelper(helper) {
  return { fn: helper };
};

function proc(iterator) {
  var subscribe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
    return __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
  };
  var dispatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
  var getState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
  var parentContext = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
  var parentEffectId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var name = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'anonymous';
  var cont = arguments[8];

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(iterator, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].iterator, NOT_ITERATOR_ERROR);

  var effectsString = '[...effects]';
  var runParallelEffect = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["d" /* deprecate */])(runAllEffect, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["e" /* updateIncentive */])(effectsString, 'all(' + effectsString + ')'));

  var sagaMonitor = options.sagaMonitor,
      logger = options.logger,
      onError = options.onError;

  var log = logger || __WEBPACK_IMPORTED_MODULE_0__utils__["q" /* log */];
  var stdChannel = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__channel__["b" /* stdChannel */])(subscribe);
  var taskContext = Object.create(parentContext);
  /**
    Tracks the current effect cancellation
    Each time the generator progresses. calling runEffect will set a new value
    on it. It allows propagating cancellation to child effects
  **/
  next.cancel = __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];

  /**
    Creates a new task descriptor for this generator, We'll also create a main task
    to track the main flow (besides other forked tasks)
  **/
  var task = newTask(parentEffectId, name, iterator, cont);
  var mainTask = { name: name, cancel: cancelMain, isRunning: true };
  var taskQueue = forkQueue(name, mainTask, end);

  /**
    cancellation of the main task. We'll simply resume the Generator with a Cancel
  **/
  function cancelMain() {
    if (mainTask.isRunning && !mainTask.isCancelled) {
      mainTask.isCancelled = true;
      next(TASK_CANCEL);
    }
  }

  /**
    This may be called by a parent generator to trigger/propagate cancellation
    cancel all pending tasks (including the main task), then end the current task.
     Cancellation propagates down to the whole execution tree holded by this Parent task
    It's also propagated to all joiners of this task and their execution tree/joiners
     Cancellation is noop for terminated/Cancelled tasks tasks
  **/
  function cancel() {
    /**
      We need to check both Running and Cancelled status
      Tasks can be Cancelled but still Running
    **/
    if (iterator._isRunning && !iterator._isCancelled) {
      iterator._isCancelled = true;
      taskQueue.cancelAll();
      /**
        Ending with a Never result will propagate the Cancellation to all joiners
      **/
      end(TASK_CANCEL);
    }
  }
  /**
    attaches cancellation logic to this task's continuation
    this will permit cancellation to propagate down the call chain
  **/
  cont && (cont.cancel = cancel);

  // tracks the running status
  iterator._isRunning = true;

  // kicks up the generator
  next();

  // then return the task descriptor to the caller
  return task;

  /**
    This is the generator driver
    It's a recursive async/continuation function which calls itself
    until the generator terminates or throws
  **/
  function next(arg, isErr) {
    // Preventive measure. If we end up here, then there is really something wrong
    if (!mainTask.isRunning) {
      throw new Error('Trying to resume an already finished generator');
    }

    try {
      var result = void 0;
      if (isErr) {
        result = iterator.throw(arg);
      } else if (arg === TASK_CANCEL) {
        /**
          getting TASK_CANCEL automatically cancels the main task
          We can get this value here
           - By cancelling the parent task manually
          - By joining a Cancelled task
        **/
        mainTask.isCancelled = true;
        /**
          Cancels the current effect; this will propagate the cancellation down to any called tasks
        **/
        next.cancel();
        /**
          If this Generator has a `return` method then invokes it
          This will jump to the finally block
        **/
        result = __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func(iterator.return) ? iterator.return(TASK_CANCEL) : { done: true, value: TASK_CANCEL };
      } else if (arg === CHANNEL_END) {
        // We get CHANNEL_END by taking from a channel that ended using `take` (and not `takem` used to trap End of channels)
        result = __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func(iterator.return) ? iterator.return() : { done: true };
      } else {
        result = iterator.next(arg);
      }

      if (!result.done) {
        runEffect(result.value, parentEffectId, '', next);
      } else {
        /**
          This Generator has ended, terminate the main task and notify the fork queue
        **/
        mainTask.isMainRunning = false;
        mainTask.cont && mainTask.cont(result.value);
      }
    } catch (error) {
      if (mainTask.isCancelled) {
        log('error', 'uncaught at ' + name, error.message);
      }
      mainTask.isMainRunning = false;
      mainTask.cont(error, true);
    }
  }

  function end(result, isErr) {
    iterator._isRunning = false;
    stdChannel.close();
    if (!isErr) {
      if (process.env.NODE_ENV === 'development' && result === TASK_CANCEL) {
        log('info', name + ' has been cancelled', '');
      }
      iterator._result = result;
      iterator._deferredEnd && iterator._deferredEnd.resolve(result);
    } else {
      if (result instanceof Error) {
        result.sagaStack = 'at ' + name + ' \n ' + (result.sagaStack || result.stack);
      }
      if (!task.cont) {
        log('error', 'uncaught', result.sagaStack || result.stack);
        if (result instanceof Error && onError) {
          onError(result);
        }
      }
      iterator._error = result;
      iterator._isAborted = true;
      iterator._deferredEnd && iterator._deferredEnd.reject(result);
    }
    task.cont && task.cont(result, isErr);
    task.joiners.forEach(function (j) {
      return j.cb(result, isErr);
    });
    task.joiners = null;
  }

  function runEffect(effect, parentEffectId) {
    var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var cb = arguments[3];

    var effectId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["r" /* uid */])();
    sagaMonitor && sagaMonitor.effectTriggered({ effectId: effectId, parentEffectId: parentEffectId, label: label, effect: effect });

    /**
      completion callback and cancel callback are mutually exclusive
      We can't cancel an already completed effect
      And We can't complete an already cancelled effectId
    **/
    var effectSettled = void 0;

    // Completion callback passed to the appropriate effect runner
    function currCb(res, isErr) {
      if (effectSettled) {
        return;
      }

      effectSettled = true;
      cb.cancel = __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */]; // defensive measure
      if (sagaMonitor) {
        isErr ? sagaMonitor.effectRejected(effectId, res) : sagaMonitor.effectResolved(effectId, res);
      }
      cb(res, isErr);
    }
    // tracks down the current cancel
    currCb.cancel = __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];

    // setup cancellation logic on the parent cb
    cb.cancel = function () {
      // prevents cancelling an already completed effect
      if (effectSettled) {
        return;
      }

      effectSettled = true;
      /**
        propagates cancel downward
        catch uncaught cancellations errors; since we can no longer call the completion
        callback, log errors raised during cancellations into the console
      **/
      try {
        currCb.cancel();
      } catch (err) {
        log('error', 'uncaught at ' + name, err.message);
      }
      currCb.cancel = __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */]; // defensive measure

      sagaMonitor && sagaMonitor.effectCancelled(effectId);
    };

    /**
      each effect runner must attach its own logic of cancellation to the provided callback
      it allows this generator to propagate cancellation downward.
       ATTENTION! effect runners must setup the cancel logic by setting cb.cancel = [cancelMethod]
      And the setup must occur before calling the callback
       This is a sort of inversion of control: called async functions are responsible
      for completing the flow by calling the provided continuation; while caller functions
      are responsible for aborting the current flow by calling the attached cancel function
       Library users can attach their own cancellation logic to promises by defining a
      promise[CANCEL] method in their returned promises
      ATTENTION! calling cancel must have no effect on an already completed or cancelled effect
    **/
    var data = void 0;
    return (
      // Non declarative effect
      __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].promise(effect) ? resolvePromise(effect, currCb) : __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].helper(effect) ? runForkEffect(wrapHelper(effect), effectId, currCb) : __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].iterator(effect) ? resolveIterator(effect, effectId, name, currCb)

      // declarative effects
      : __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].array(effect) ? runParallelEffect(effect, effectId, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].take(effect)) ? runTakeEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].put(effect)) ? runPutEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].all(effect)) ? runAllEffect(data, effectId, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].race(effect)) ? runRaceEffect(data, effectId, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].call(effect)) ? runCallEffect(data, effectId, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].cps(effect)) ? runCPSEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].fork(effect)) ? runForkEffect(data, effectId, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].join(effect)) ? runJoinEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].cancel(effect)) ? runCancelEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].select(effect)) ? runSelectEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].actionChannel(effect)) ? runChannelEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].flush(effect)) ? runFlushEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].cancelled(effect)) ? runCancelledEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].getContext(effect)) ? runGetContextEffect(data, currCb) : (data = __WEBPACK_IMPORTED_MODULE_2__io__["h" /* asEffect */].setContext(effect)) ? runSetContextEffect(data, currCb) : /* anything else returned as is        */currCb(effect)
    );
  }

  function resolvePromise(promise, cb) {
    var cancelPromise = promise[__WEBPACK_IMPORTED_MODULE_0__utils__["s" /* CANCEL */]];
    if (typeof cancelPromise === 'function') {
      cb.cancel = cancelPromise;
    }
    promise.then(cb, function (error) {
      return cb(error, true);
    });
  }

  function resolveIterator(iterator, effectId, name, cb) {
    proc(iterator, subscribe, dispatch, getState, taskContext, options, effectId, name, cb);
  }

  function runTakeEffect(_ref2, cb) {
    var channel = _ref2.channel,
        pattern = _ref2.pattern,
        maybe = _ref2.maybe;

    channel = channel || stdChannel;
    var takeCb = function takeCb(inp) {
      return inp instanceof Error ? cb(inp, true) : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__channel__["c" /* isEnd */])(inp) && !maybe ? cb(CHANNEL_END) : cb(inp);
    };
    try {
      channel.take(takeCb, matcher(pattern));
    } catch (err) {
      return cb(err, true);
    }
    cb.cancel = takeCb.cancel;
  }

  function runPutEffect(_ref3, cb) {
    var channel = _ref3.channel,
        action = _ref3.action,
        resolve = _ref3.resolve;

    /**
      Schedule the put in case another saga is holding a lock.
      The put will be executed atomically. ie nested puts will execute after
      this put has terminated.
    **/
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__scheduler__["a" /* asap */])(function () {
      var result = void 0;
      try {
        result = (channel ? channel.put : dispatch)(action);
      } catch (error) {
        // If we have a channel or `put.resolve` was used then bubble up the error.
        if (channel || resolve) return cb(error, true);
        log('error', 'uncaught at ' + name, error.stack || error.message || error);
      }

      if (resolve && __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].promise(result)) {
        resolvePromise(result, cb);
      } else {
        return cb(result);
      }
    });
    // Put effects are non cancellables
  }

  function runCallEffect(_ref4, effectId, cb) {
    var context = _ref4.context,
        fn = _ref4.fn,
        args = _ref4.args;

    var result = void 0;
    // catch synchronous failures; see #152
    try {
      result = fn.apply(context, args);
    } catch (error) {
      return cb(error, true);
    }
    return __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].promise(result) ? resolvePromise(result, cb) : __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].iterator(result) ? resolveIterator(result, effectId, fn.name, cb) : cb(result);
  }

  function runCPSEffect(_ref5, cb) {
    var context = _ref5.context,
        fn = _ref5.fn,
        args = _ref5.args;

    // CPS (ie node style functions) can define their own cancellation logic
    // by setting cancel field on the cb

    // catch synchronous failures; see #152
    try {
      var cpsCb = function cpsCb(err, res) {
        return __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].undef(err) ? cb(res) : cb(err, true);
      };
      fn.apply(context, args.concat(cpsCb));
      if (cpsCb.cancel) {
        cb.cancel = function () {
          return cpsCb.cancel();
        };
      }
    } catch (error) {
      return cb(error, true);
    }
  }

  function runForkEffect(_ref6, effectId, cb) {
    var context = _ref6.context,
        fn = _ref6.fn,
        args = _ref6.args,
        detached = _ref6.detached;

    var taskIterator = createTaskIterator({ context: context, fn: fn, args: args });

    try {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__scheduler__["b" /* suspend */])();
      var _task = proc(taskIterator, subscribe, dispatch, getState, taskContext, options, effectId, fn.name, detached ? null : __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */]);

      if (detached) {
        cb(_task);
      } else {
        if (taskIterator._isRunning) {
          taskQueue.addTask(_task);
          cb(_task);
        } else if (taskIterator._error) {
          taskQueue.abort(taskIterator._error);
        } else {
          cb(_task);
        }
      }
    } finally {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__scheduler__["c" /* flush */])();
    }
    // Fork effects are non cancellables
  }

  function runJoinEffect(t, cb) {
    if (t.isRunning()) {
      var joiner = { task: task, cb: cb };
      cb.cancel = function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["m" /* remove */])(t.joiners, joiner);
      };
      t.joiners.push(joiner);
    } else {
      t.isAborted() ? cb(t.error(), true) : cb(t.result());
    }
  }

  function runCancelEffect(taskToCancel, cb) {
    if (taskToCancel === __WEBPACK_IMPORTED_MODULE_0__utils__["f" /* SELF_CANCELLATION */]) {
      taskToCancel = task;
    }
    if (taskToCancel.isRunning()) {
      taskToCancel.cancel();
    }
    cb();
    // cancel effects are non cancellables
  }

  function runAllEffect(effects, effectId, cb) {
    var keys = Object.keys(effects);

    if (!keys.length) {
      return cb(__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].array(effects) ? [] : {});
    }

    var completedCount = 0;
    var completed = void 0;
    var results = {};
    var childCbs = {};

    function checkEffectEnd() {
      if (completedCount === keys.length) {
        completed = true;
        cb(__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].array(effects) ? __WEBPACK_IMPORTED_MODULE_0__utils__["t" /* array */].from(_extends({}, results, { length: keys.length })) : results);
      }
    }

    keys.forEach(function (key) {
      var chCbAtKey = function chCbAtKey(res, isErr) {
        if (completed) {
          return;
        }
        if (isErr || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__channel__["c" /* isEnd */])(res) || res === CHANNEL_END || res === TASK_CANCEL) {
          cb.cancel();
          cb(res, isErr);
        } else {
          results[key] = res;
          completedCount++;
          checkEffectEnd();
        }
      };
      chCbAtKey.cancel = __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
      childCbs[key] = chCbAtKey;
    });

    cb.cancel = function () {
      if (!completed) {
        completed = true;
        keys.forEach(function (key) {
          return childCbs[key].cancel();
        });
      }
    };

    keys.forEach(function (key) {
      return runEffect(effects[key], effectId, key, childCbs[key]);
    });
  }

  function runRaceEffect(effects, effectId, cb) {
    var completed = void 0;
    var keys = Object.keys(effects);
    var childCbs = {};

    keys.forEach(function (key) {
      var chCbAtKey = function chCbAtKey(res, isErr) {
        if (completed) {
          return;
        }

        if (isErr) {
          // Race Auto cancellation
          cb.cancel();
          cb(res, true);
        } else if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__channel__["c" /* isEnd */])(res) && res !== CHANNEL_END && res !== TASK_CANCEL) {
          var _cb;

          cb.cancel();
          completed = true;
          cb((_cb = {}, _cb[key] = res, _cb));
        }
      };
      chCbAtKey.cancel = __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
      childCbs[key] = chCbAtKey;
    });

    cb.cancel = function () {
      // prevents unnecessary cancellation
      if (!completed) {
        completed = true;
        keys.forEach(function (key) {
          return childCbs[key].cancel();
        });
      }
    };
    keys.forEach(function (key) {
      if (completed) {
        return;
      }
      runEffect(effects[key], effectId, key, childCbs[key]);
    });
  }

  function runSelectEffect(_ref7, cb) {
    var selector = _ref7.selector,
        args = _ref7.args;

    try {
      var state = selector.apply(undefined, [getState()].concat(args));
      cb(state);
    } catch (error) {
      cb(error, true);
    }
  }

  function runChannelEffect(_ref8, cb) {
    var pattern = _ref8.pattern,
        buffer = _ref8.buffer;

    var match = matcher(pattern);
    match.pattern = pattern;
    cb(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__channel__["d" /* eventChannel */])(subscribe, buffer || __WEBPACK_IMPORTED_MODULE_4__buffers__["a" /* buffers */].fixed(), match));
  }

  function runCancelledEffect(data, cb) {
    cb(!!mainTask.isCancelled);
  }

  function runFlushEffect(channel, cb) {
    channel.flush(cb);
  }

  function runGetContextEffect(prop, cb) {
    cb(taskContext[prop]);
  }

  function runSetContextEffect(props, cb) {
    __WEBPACK_IMPORTED_MODULE_0__utils__["u" /* object */].assign(taskContext, props);
    cb();
  }

  function newTask(id, name, iterator, cont) {
    var _done, _ref9, _mutatorMap;

    iterator._deferredEnd = null;
    return _ref9 = {}, _ref9[__WEBPACK_IMPORTED_MODULE_0__utils__["v" /* TASK */]] = true, _ref9.id = id, _ref9.name = name, _done = 'done', _mutatorMap = {}, _mutatorMap[_done] = _mutatorMap[_done] || {}, _mutatorMap[_done].get = function () {
      if (iterator._deferredEnd) {
        return iterator._deferredEnd.promise;
      } else {
        var def = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["w" /* deferred */])();
        iterator._deferredEnd = def;
        if (!iterator._isRunning) {
          iterator._error ? def.reject(iterator._error) : def.resolve(iterator._result);
        }
        return def.promise;
      }
    }, _ref9.cont = cont, _ref9.joiners = [], _ref9.cancel = cancel, _ref9.isRunning = function isRunning() {
      return iterator._isRunning;
    }, _ref9.isCancelled = function isCancelled() {
      return iterator._isCancelled;
    }, _ref9.isAborted = function isAborted() {
      return iterator._isAborted;
    }, _ref9.result = function result() {
      return iterator._result;
    }, _ref9.error = function error() {
      return iterator._error;
    }, _ref9.setContext = function setContext(props) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(props, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].object, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["h" /* createSetContextWarning */])('task', props));
      __WEBPACK_IMPORTED_MODULE_0__utils__["u" /* object */].assign(taskContext, props);
    }, _defineEnumerableProperties(_ref9, _mutatorMap), _ref9;
  }
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["a"] = runSaga;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__proc__ = __webpack_require__(98);



var RUN_SAGA_SIGNATURE = 'runSaga(storeInterface, saga, ...args)';
var NON_GENERATOR_ERR = RUN_SAGA_SIGNATURE + ': saga argument must be a Generator function!';

function runSaga(storeInterface, saga) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var iterator = void 0;

  if (__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].iterator(storeInterface)) {
    if (process.env.NODE_ENV === 'development') {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["q" /* log */])('warn', 'runSaga(iterator, storeInterface) has been deprecated in favor of ' + RUN_SAGA_SIGNATURE);
    }
    iterator = storeInterface;
    storeInterface = saga;
  } else {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(saga, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func, NON_GENERATOR_ERR);
    iterator = saga.apply(undefined, args);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(iterator, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].iterator, NON_GENERATOR_ERR);
  }

  var _storeInterface = storeInterface,
      subscribe = _storeInterface.subscribe,
      dispatch = _storeInterface.dispatch,
      getState = _storeInterface.getState,
      context = _storeInterface.context,
      sagaMonitor = _storeInterface.sagaMonitor,
      logger = _storeInterface.logger,
      onError = _storeInterface.onError;


  var effectId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["r" /* uid */])();

  if (sagaMonitor) {
    // monitors are expected to have a certain interface, let's fill-in any missing ones
    sagaMonitor.effectTriggered = sagaMonitor.effectTriggered || __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
    sagaMonitor.effectResolved = sagaMonitor.effectResolved || __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
    sagaMonitor.effectRejected = sagaMonitor.effectRejected || __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
    sagaMonitor.effectCancelled = sagaMonitor.effectCancelled || __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];
    sagaMonitor.actionDispatched = sagaMonitor.actionDispatched || __WEBPACK_IMPORTED_MODULE_0__utils__["l" /* noop */];

    sagaMonitor.effectTriggered({ effectId: effectId, root: true, parentEffectId: 0, effect: { root: true, saga: saga, args: args } });
  }

  var task = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__proc__["a" /* default */])(iterator, subscribe, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["x" /* wrapSagaDispatch */])(dispatch), getState, context, { sagaMonitor: sagaMonitor, logger: logger, onError: onError }, effectId, saga.name);

  if (sagaMonitor) {
    sagaMonitor.effectResolved(effectId, task);
  }

  return task;
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = takeEveryHelper;
/* harmony export (immutable) */ __webpack_exports__["b"] = takeLatestHelper;
/* harmony export (immutable) */ __webpack_exports__["c"] = throttleHelper;
/* unused harmony export takeEvery */
/* unused harmony export takeLatest */
/* unused harmony export throttle */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__channel__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__io__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__buffers__ = __webpack_require__(34);





var done = { done: true, value: undefined };
var qEnd = {};

function fsmIterator(fsm, q0) {
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'iterator';

  var updateState = void 0,
      qNext = q0;

  function next(arg, error) {
    if (qNext === qEnd) {
      return done;
    }

    if (error) {
      qNext = qEnd;
      throw error;
    } else {
      updateState && updateState(arg);

      var _fsm$qNext = fsm[qNext](),
          q = _fsm$qNext[0],
          output = _fsm$qNext[1],
          _updateState = _fsm$qNext[2];

      qNext = q;
      updateState = _updateState;
      return qNext === qEnd ? done : output;
    }
  }

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["i" /* makeIterator */])(next, function (error) {
    return next(null, error);
  }, name, true);
}

function safeName(patternOrChannel) {
  if (__WEBPACK_IMPORTED_MODULE_1__utils__["c" /* is */].channel(patternOrChannel)) {
    return 'channel';
  } else if (Array.isArray(patternOrChannel)) {
    return String(patternOrChannel.map(function (entry) {
      return String(entry);
    }));
  } else {
    return String(patternOrChannel);
  }
}

function takeEveryHelper(patternOrChannel, worker) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var yTake = { done: false, value: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__io__["d" /* take */])(patternOrChannel) };
  var yFork = function yFork(ac) {
    return { done: false, value: __WEBPACK_IMPORTED_MODULE_2__io__["e" /* fork */].apply(undefined, [worker].concat(args, [ac])) };
  };

  var action = void 0,
      setAction = function setAction(ac) {
    return action = ac;
  };

  return fsmIterator({
    q1: function q1() {
      return ['q2', yTake, setAction];
    },
    q2: function q2() {
      return action === __WEBPACK_IMPORTED_MODULE_0__channel__["a" /* END */] ? [qEnd] : ['q1', yFork(action)];
    }
  }, 'q1', 'takeEvery(' + safeName(patternOrChannel) + ', ' + worker.name + ')');
}

function takeLatestHelper(patternOrChannel, worker) {
  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  var yTake = { done: false, value: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__io__["d" /* take */])(patternOrChannel) };
  var yFork = function yFork(ac) {
    return { done: false, value: __WEBPACK_IMPORTED_MODULE_2__io__["e" /* fork */].apply(undefined, [worker].concat(args, [ac])) };
  };
  var yCancel = function yCancel(task) {
    return { done: false, value: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__io__["f" /* cancel */])(task) };
  };

  var task = void 0,
      action = void 0;
  var setTask = function setTask(t) {
    return task = t;
  };
  var setAction = function setAction(ac) {
    return action = ac;
  };

  return fsmIterator({
    q1: function q1() {
      return ['q2', yTake, setAction];
    },
    q2: function q2() {
      return action === __WEBPACK_IMPORTED_MODULE_0__channel__["a" /* END */] ? [qEnd] : task ? ['q3', yCancel(task)] : ['q1', yFork(action), setTask];
    },
    q3: function q3() {
      return ['q1', yFork(action), setTask];
    }
  }, 'q1', 'takeLatest(' + safeName(patternOrChannel) + ', ' + worker.name + ')');
}

function throttleHelper(delayLength, pattern, worker) {
  for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
    args[_key3 - 3] = arguments[_key3];
  }

  var action = void 0,
      channel = void 0;

  var yActionChannel = { done: false, value: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__io__["g" /* actionChannel */])(pattern, __WEBPACK_IMPORTED_MODULE_3__buffers__["a" /* buffers */].sliding(1)) };
  var yTake = function yTake() {
    return { done: false, value: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__io__["d" /* take */])(channel) };
  };
  var yFork = function yFork(ac) {
    return { done: false, value: __WEBPACK_IMPORTED_MODULE_2__io__["e" /* fork */].apply(undefined, [worker].concat(args, [ac])) };
  };
  var yDelay = { done: false, value: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__io__["b" /* call */])(__WEBPACK_IMPORTED_MODULE_1__utils__["j" /* delay */], delayLength) };

  var setAction = function setAction(ac) {
    return action = ac;
  };
  var setChannel = function setChannel(ch) {
    return channel = ch;
  };

  return fsmIterator({
    q1: function q1() {
      return ['q2', yActionChannel, setChannel];
    },
    q2: function q2() {
      return ['q3', yTake(), setAction];
    },
    q3: function q3() {
      return action === __WEBPACK_IMPORTED_MODULE_0__channel__["a" /* END */] ? [qEnd] : ['q4', yFork(action)];
    },
    q4: function q4() {
      return ['q2', yDelay];
    }
  }, 'q1', 'throttle(' + safeName(pattern) + ', ' + worker.name + ')');
}

var deprecationWarning = function deprecationWarning(helperName) {
  return 'import { ' + helperName + ' } from \'redux-saga\' has been deprecated in favor of import { ' + helperName + ' } from \'redux-saga/effects\'.\nThe latter will not work with yield*, as helper effects are wrapped automatically for you in fork effect.\nTherefore yield ' + helperName + ' will return task descriptor to your saga and execute next lines of code.';
};
var takeEvery = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["d" /* deprecate */])(takeEveryHelper, deprecationWarning('takeEvery'));
var takeLatest = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["d" /* deprecate */])(takeLatestHelper, deprecationWarning('takeLatest'));
var throttle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["d" /* deprecate */])(throttleHelper, deprecationWarning('throttle'));

/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = asap;
/* harmony export (immutable) */ __webpack_exports__["b"] = suspend;
/* harmony export (immutable) */ __webpack_exports__["c"] = flush;

var queue = [];
/**
  Variable to hold a counting semaphore
  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not
    already suspended)
  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This
    triggers flushing the queued tasks.
**/
var semaphore = 0;

/**
  Executes a task 'atomically'. Tasks scheduled during this execution will be queued
  and flushed after this task has finished (assuming the scheduler endup in a released
  state).
**/
function exec(task) {
  try {
    suspend();
    task();
  } finally {
    release();
  }
}

/**
  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)
**/
function asap(task) {
  queue.push(task);

  if (!semaphore) {
    suspend();
    flush();
  }
}

/**
  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the
  scheduler is released.
**/
function suspend() {
  semaphore++;
}

/**
  Puts the scheduler in a `released` state.
**/
function release() {
  semaphore--;
}

/**
  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.
**/
function flush() {
  release();

  var task = void 0;
  while (!semaphore && (task = queue.shift()) !== undefined) {
    exec(task);
  }
}

/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  var last = funcs[funcs.length - 1];
  var rest = funcs.slice(0, -1);
  return function () {
    return rest.reduceRight(function (composed, f) {
      return f(composed);
    }, last.apply(undefined, arguments));
  };
}

/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ActionTypes; });
/* harmony export (immutable) */ __webpack_exports__["a"] = createStore;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_symbol_observable__ = __webpack_require__(246);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_symbol_observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_symbol_observable__);



/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT'
};

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} enhancer The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_lodash_es_isPlainObject__["a" /* default */])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/zenparsing/es-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[__WEBPACK_IMPORTED_MODULE_1_symbol_observable___default.a] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[__WEBPACK_IMPORTED_MODULE_1_symbol_observable___default.a] = observable, _ref2;
}

/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createStore__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__combineReducers__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__bindActionCreators__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__applyMiddleware__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__compose__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_warning__ = __webpack_require__(105);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__createStore__["a"]; });
/* unused harmony reexport combineReducers */
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_2__bindActionCreators__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__applyMiddleware__["a"]; });
/* unused harmony reexport compose */







/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__utils_warning__["a" /* default */])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAACo1BMVEUAAAD///9/f3+qqqq/v7+ZmZmqqqq2trafn5+pqamysrKioqKqqqqwsLCjo6Oqqqqfn5+lpaWpqamhoaGlpaWpqamioqKmpqaqqqqjo6Ompqapqamjo6Onp6eqqqqkpKSnp6epqamlpaWlpaWnp6epqamlpaWnp6empqaoqKikpKSmpqaoqKikpKSmpqalpaWmpqaoqKimpqaoqKilpaWnp6eoqKilpaWnp6eoqKinp6eoqKimpqaoqKimpqanp6enp6elpaWmpqanp6elpaWmpqanp6elpaWmpqalpaWoqKimpqanp6eoqKimpqanp6empqaoqKimpqanp6elpaWmpqanp6elpaWmpqanp6elpaWmpqanp6empqampqanp6empqanp6empqanp6enp6empqanp6enp6empqanp6enp6empqanp6enp6empqampqampqampqanp6empqampqanp6empqalpaWnp6empqanp6enp6empqanp6enp6empqanp6enp6empqanp6empqanp6enp6empqanp6empqanp6empqanp6empqalpaWnp6empqalpaWnp6empqanp6empqanp6enp6empqanp6enp6empqanp6elpaWnp6enp6enp6empqalpaWnp6empqalpaWnp6empqalpaWnp6empqalpaWnp6empqanp6enp6enp6enp6elpaWnp6enp6elpaWnp6elpaWnp6empqalpaWmpqalpaWnp6empqanp6empqanp6elpaWlpaWnp6elpaWnp6enp6elpaWnp6enp6elpaWnp6enp6elpaWnp6enp6elpaWnp6empqalpaWnp6elpaWlpaWnp6elpaWlpaWnp6elpaWlpaWnp6elpaWnp6d8QL8lAAAA4HRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiUmJygpKywtLi8wMTM0NTc4OTo7PD0+QEFCREVGSUpLTE1OT1BRU1VWWltcXV9hYmNkZWZnaGlqa2xtbm9wcnN0dXZ3eHl6e3x9gIGChIWGh4iJiouMjY6PkJGSk5SVlpeZmpucnZ6goaOkpaanqKmqq62ur7CxsrO0tre4uru8vb6/wMHCw8TFxsfIycvMzc7P0NLT1NXW2Nna293e4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/tcMmtwAAAS8SURBVBgZ7cFpW1RlAAbgZwYchAQCxLC0FBUDs9xwASxcMlRccik10VJULFMxLTeITCvDFlNxSdRcELfEisIMGbdSSUFBbCCY56ekCMHAmZnzvmf54DX3DR8fHx8fn8eRNXrk1LcXL5yV0j8QpvMfsepEDZvV/7Qm3gIT9d5QzrbK0kOhLBo6i82josqMQLQX9/0m6Crk4wa6Yx+JNl74zsn+aC2gOzQZbKcn621o4TfmEMljcJFZ1Q8aTK+jZ4Wd0aT3ist8KAmtBd/hla6QtpRelUYDsMS9+zMfOQgXs0meC4akJVShMjNt6zU2c/SCiyI+cKQjpEyiuHfgIpqN9tkgob+DwvZb4WI+H9kTAGFBpRRWEgpXu9nkYBBEraMweze0cYPNToZDTGw9RZU+i0ZBqXmd0CiSLS70hJB8ijoZiQeCJ3xTzfF4ZBBbKR8OAYMpKtsGS585+bUkc9DkNbZW96YFqu2moIMLsw7dYqPTNjSZTFe5QVCpWwOlXYlCs2ls43wc1FlEaXf74X+T2JZjnhVq/EhZjkS0GMv2jkbDuzAnJdWNQSsDqOB+egd4k0xJjtFoLYyKSpLgxRLKuZsIV9eobG9fePQ5pVyOQxu76EbDFz3hwQHKKOiCtubSrX+39oFbZyhhgz/a6UEPnHsSLFBWRHFfQskZelSSFg4lpyhuI5TMoBe1O1MC0U4+xeVASWA5vareMTkCrj6juE1QlE41nEWrk0PRYhHF5UBR4CWq5DyfOz8h0oKHxlHcBigbSyFV54/u2PR+PsVlwo1cmiMDbgRfoClmwZ3eFTTDeLg19B5NMAztTckIw0PxlTReNNpbw5otQ60A+pbRaE4b2lvGB67nzhzQKeIwDXYVCt5gs4oyGqwACkbSPJ9CwVM0TxqU2GmaEVCyhWZxBkNJMs1SAkX+12mSzVC2giZJhbLIGpojCm6spCmK4U7IXzTDKrg1gWYYBPe203h/WuFe6EUaLguexFTSaIPhUfw9GqvUAs+GVNBQS+FNzB80UP3T8CpkG42zC2qMLqNREqGKbe4VGuIXC1TqMP5APfU3GQI6TzlBndn94V2X1dPGJg5PHDczc/cN6mwmVHimjkax26DGVholFar0ddIYRVaok0tjDINK3WtohK+gWjoNcLcrVPM7Tf3NhoDnblNvBVaISKijvqqjIWZiA3U1HaIm1lFHOy0QlnCLuikLhYRnC6mT+y9Cit9bd6iLVMiK+OgetVsJDcIW/E6NvrVCE8vzS4/dp7wjAdDOr2fSjEJKKQqBLvyW1VNGcTh0EXOKUoojoIeADAelnA2HHpJLKeeHYOhg4GFK2hYA7Ybtp6xlFmgVMOk0ZVWnQCPLwOy/Ke23PtDkiVeyLlGDzUGQ1jE2df2pOmpx81UI6bB27XsL0+bMW7B849fH7Q3UalsEBEXl1FM3F1+GhJg91Ef14gDIiS+gdrVZkZBmSTpObRyfdIc28XlOSru9Mgra9fjgJqWcfT0I+rCl5NVS0NUPY6GnJ6fu/YeqXVw3xArdBY3a+Cu9u5U3txcMEz5q+b7LdOd2YfbUGAsMF/zSxEXZO44Vl12vqKq6U371wrnD27OWpMZHwsfHx8fnMfIfjP/uIvjVNqwAAAAASUVORK5CYII="

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_file_loader_name_index_html_index_html__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_file_loader_name_index_html_index_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_file_loader_name_index_html_index_html__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_regenerator_runtime_runtime__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_regenerator_runtime_runtime___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_regenerator_runtime_runtime__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_redux_thunk__ = __webpack_require__(239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_redux_thunk___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_redux_thunk__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_redux_saga__ = __webpack_require__(236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_react_redux__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_redux__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_react_dom__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_react_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_react_dom__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__view__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__reducers__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__sagas__ = __webpack_require__(112);













var sagaMiddleware = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_redux_saga__["a" /* default */])();
var store = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_redux__["a" /* createStore */])(__WEBPACK_IMPORTED_MODULE_9__reducers__["a" /* default */], __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_redux__["b" /* applyMiddleware */])(sagaMiddleware));
sagaMiddleware.run(__WEBPACK_IMPORTED_MODULE_10__sagas__["a" /* default */]);

__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_react_dom__["render"])(__WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(
    __WEBPACK_IMPORTED_MODULE_5_react_redux__["a" /* Provider */],
    { store: store },
    __WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__view__["a" /* default */], null)
), document.getElementById('root'));

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = toggleUser;
/* harmony export (immutable) */ __webpack_exports__["a"] = getTweets;
function toggleUser() {
    return {
        type: 'TOGGLE_USER'
    };
}

function getTweets(candidate) {
    return {
        type: 'GET_TWEETS',
        payload: candidate
    };
}

/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__style_css__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__style_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__style_css__);



var Tweet = function Tweet(props) {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        'li',
        { className: __WEBPACK_IMPORTED_MODULE_1__style_css___default.a.tweetItem },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            'div',
            { className: __WEBPACK_IMPORTED_MODULE_1__style_css___default.a.tweetHeader },
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                'span',
                { className: __WEBPACK_IMPORTED_MODULE_1__style_css___default.a.tweetUser },
                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('img', { src: __webpack_require__(106), className: __WEBPACK_IMPORTED_MODULE_1__style_css___default.a.twitterLogo }),
                '@',
                props.user
            ),
            __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                'span',
                { className: __WEBPACK_IMPORTED_MODULE_1__style_css___default.a.tweetDate },
                props.date.substring(0, 10)
            )
        ),
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            'div',
            { className: __WEBPACK_IMPORTED_MODULE_1__style_css___default.a.tweetText },
            props.text
        )
    );
};

/* harmony default export */ __webpack_exports__["a"] = (Tweet);

/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Tweet__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__style_css__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__style_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__style_css__);




var TweetsContainer = function TweetsContainer(props) {
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
        'div',
        { className: __WEBPACK_IMPORTED_MODULE_2__style_css___default.a.tweetContainer },
        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
            'ul',
            { className: __WEBPACK_IMPORTED_MODULE_2__style_css___default.a.tweetContainerUL },
            props.tweets.map(function (tweet, index) {
                return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__Tweet__["a" /* default */], {
                    user: tweet.user,
                    date: tweet.date,
                    text: tweet.text,
                    key: index
                });
            })
        )
    );
};

/* harmony default export */ __webpack_exports__["a"] = (TweetsContainer);

/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = reducer;
var initialState = {
    candidate: 'Trump',
    opponent: 'Hilary',
    tweets: []
};

function reducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
    var action = arguments[1];

    switch (action.type) {
        case 'TOGGLE_USER':
            if (state.candidate == 'Trump') {
                return Object.assign({}, state, {
                    candidate: 'Hilary',
                    opponent: 'Trump',
                    tweets: []
                });
            }

            return Object.assign({}, state, {
                candidate: 'Trump',
                opponent: 'Hilary',
                tweets: []
            });

        case 'RECEIVED_TWEETS':
            return Object.assign({}, state, {
                tweets: action.tweets
            });

        default:
            return state;
    }
}

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getTweetsAsync */
/* harmony export (immutable) */ __webpack_exports__["a"] = watchGetTweet;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_redux_saga_effects__ = __webpack_require__(97);
var _marked = [getTweetsAsync, watchGetTweet].map(regeneratorRuntime.mark);



function fetchTweets(politician) {
    return fetch('/tweets/' + politician, {
        method: 'GET',
        headers: {
            "Accept": "application/json"
        }
    });
}

function getTweetsJson(blob) {
    return blob.json();
}

function getTweetsAsync(action) {
    var filter, tweets, tweetsJson;
    return regeneratorRuntime.wrap(function getTweetsAsync$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    filter = function filter(tweet) {
                        return {
                            user: tweet.user.name,
                            text: tweet.text,
                            date: tweet.created_at
                        };
                    };

                    _context.next = 3;
                    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_redux_saga_effects__["a" /* call */])(fetchTweets, action.payload);

                case 3:
                    tweets = _context.sent;
                    _context.next = 6;
                    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_redux_saga_effects__["a" /* call */])(getTweetsJson, tweets);

                case 6:
                    tweetsJson = _context.sent;
                    _context.next = 9;
                    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_redux_saga_effects__["b" /* put */])({
                        type: 'RECEIVED_TWEETS',
                        tweets: tweetsJson.statuses.map(filter)
                    });

                case 9:
                case 'end':
                    return _context.stop();
            }
        }
    }, _marked[0], this);
};

function watchGetTweet() {
    return regeneratorRuntime.wrap(function watchGetTweet$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    _context2.next = 2;
                    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_redux_saga_effects__["c" /* takeEvery */])('GET_TWEETS', getTweetsAsync);

                case 2:
                case 'end':
                    return _context2.stop();
            }
        }
    }, _marked[1], this);
}

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_redux__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_TweetsContainer__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__actions__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__style_css__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__style_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__style_css__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var MainView = function (_Component) {
    _inherits(MainView, _Component);

    function MainView(props) {
        _classCallCheck(this, MainView);

        var _this = _possibleConstructorReturn(this, (MainView.__proto__ || Object.getPrototypeOf(MainView)).call(this, props));

        _this.clicking = _this.clicking.bind(_this);
        return _this;
    }

    _createClass(MainView, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            var _props = this.props,
                candidate = _props.candidate,
                dispatch = _props.dispatch;

            dispatch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__actions__["a" /* getTweets */])(candidate));
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.candidate !== this.props.candidate) {
                var candidate = nextProps.candidate,
                    dispatch = nextProps.dispatch;

                dispatch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__actions__["a" /* getTweets */])(candidate));
            }
        }
    }, {
        key: 'clicking',
        value: function clicking() {
            var dispatch = this.props.dispatch;

            dispatch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__actions__["b" /* toggleUser */])());
        }
    }, {
        key: 'render',
        value: function render() {
            var _props2 = this.props,
                candidate = _props2.candidate,
                tweets = _props2.tweets,
                opponent = _props2.opponent;


            return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                'div',
                null,
                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                    'div',
                    { className: __WEBPACK_IMPORTED_MODULE_4__style_css___default.a.candidateContainer },
                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('img', {
                        src: __webpack_require__(252)("./" + candidate.toLowerCase() + '.png'),
                        className: __WEBPACK_IMPORTED_MODULE_4__style_css___default.a['position' + candidate]
                    }),
                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__components_TweetsContainer__["a" /* default */], { tweets: tweets }),
                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                        'div',
                        {
                            onClick: this.clicking,
                            className: __WEBPACK_IMPORTED_MODULE_4__style_css___default.a.candidateButton
                        },
                        'See ',
                        opponent
                    )
                )
            );
        }
    }]);

    return MainView;
}(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

var mapStateToProps = function mapStateToProps(state) {
    return {
        candidate: state.candidate,
        opponent: state.opponent,
        tweets: state.tweets
    };
};

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_react_redux__["b" /* connect */])(mapStateToProps)(MainView));

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(115)(undefined);
// imports


// module
exports.push([module.i, "body {\n    width: 100vh;\n    height: 100vw;\n    overflow: hidden;\n    font-family: helvetica, arial, sans-serif;\n}\n\n._3kfByiuBZViilD3Ix4y8Rq {\n    color: #f9f9f9;\n    margin-left: 25px;\n    margin-top: 20px;\n    font-size: 30px;\n    position: absolute;\n}\n\n._1d1VQz-AgDud4Uj5JctfTx {\n    height: 500px;\n    float: right;\n}\n\n._2BB_tjvrzsiuv8cHtX1Jkr {\n    height: 500px;\n    float: left;\n}\n\n._1g8xeVXihaxs56CmzHfzCr {\n    height: 15px;\n    width: 15px;\n}\n\n._3MBCeHxhmiDt8067cDn7in {\n    display: inline-block;\n    margin-top: 40px;\n    margin-left: 20px;\n    height: 350px;\n}\n\n._3byYMI7kcRWFKlLL9poAlU {\n    height: 25px;\n    color: gray;\n}\n\n.DBZtyd_UVx-dVEg6rju45 {\n    float: right;\n}\n\n.pSPeHUOwtqw-ak09Uvd_V {\n    float: left;\n    font-weight: bold;\n}\n\n._3eV2bgXgH32mZoTU5XZ-m0 {\n    text-align: left;\n    padding-left: 20px;\n}\n\n._30pOizh9DeErkBYEg7gTGj {\n    -webkit-margin-before: 0;\n    -webkit-margin-after: 0;\n    -webkit-margin-start: 0;\n    -webkit-margin-end: 0px;\n    -webkit-padding-start: 0;\n}\n\n._3gxMAvPypncLObq32YhF6a {\n    list-style-type: none;\n    font-size: 13px;\n    line-height: 23px;\n    background-color: white;\n    margin: 5px 5px 5px 5px;\n    padding: 10px 10px 10px 10px;\n    border-radius: 5px;\n    max-width: 550px;\n}\n\n._1szl7P00CDnR7J11J_eF6j {\n    width: 950px;\n    height: 500px;\n    background-color: black;\n    position: absolute;\n    margin-top: calc(50vh - 250px);\n    margin-left: calc(50vw - 475px);\n}\n", ""]);

// exports
exports.locals = {
	"candidateButton": "_3kfByiuBZViilD3Ix4y8Rq",
	"positionHilary": "_1d1VQz-AgDud4Uj5JctfTx",
	"positionTrump": "_2BB_tjvrzsiuv8cHtX1Jkr",
	"twitterLogo": "_1g8xeVXihaxs56CmzHfzCr",
	"tweetContainer": "_3MBCeHxhmiDt8067cDn7in",
	"tweetHeader": "_3byYMI7kcRWFKlLL9poAlU",
	"tweetDate": "DBZtyd_UVx-dVEg6rju45",
	"tweetUser": "pSPeHUOwtqw-ak09Uvd_V",
	"tweetText": "_3eV2bgXgH32mZoTU5XZ-m0",
	"tweetContainerUL": "_30pOizh9DeErkBYEg7gTGj",
	"tweetItem": "_3gxMAvPypncLObq32YhF6a",
	"candidateContainer": "_1szl7P00CDnR7J11J_eF6j"
};

/***/ }),
/* 115 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var camelize = __webpack_require__(116);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var isTextNode = __webpack_require__(126);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var invariant = __webpack_require__(1);

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment = __webpack_require__(6);

var createArrayFromMixed = __webpack_require__(119);
var getMarkupWrap = __webpack_require__(121);
var invariant = __webpack_require__(1);

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment = __webpack_require__(6);

var invariant = __webpack_require__(1);

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable.Window && scrollable instanceof scrollable.Window) {
    return {
      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(123);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var isNode = __webpack_require__(125);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @typechecks static-only
 */



/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var ExecutionEnvironment = __webpack_require__(6);

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var performance = __webpack_require__(128);

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function performanceNow() {
    return performance.now();
  };
} else {
  performanceNow = function performanceNow() {
    return Date.now();
  };
}

module.exports = performanceNow;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "index.html";

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
};

var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
        var keys = Object.getOwnPropertyNames(sourceComponent);

        /* istanbul ignore else */
        if (isGetOwnPropertySymbolsAvailable) {
            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
                try {
                    targetComponent[keys[i]] = sourceComponent[keys[i]];
                } catch (error) {

                }
            }
        }
    }

    return targetComponent;
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getRawTag_js__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objectToString_js__ = __webpack_require__(137);




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__["a" /* default */])(value)
    : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__objectToString_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (baseGetTag);


/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(59)))

/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(138);


/** Built-in value references. */
var getPrototype = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a" /* default */])(Object.getPrototypeOf, Object);

/* harmony default export */ __webpack_exports__["a"] = (getPrototype);


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(63);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (getRawTag);


/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ __webpack_exports__["a"] = (objectToString);


/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (overArg);


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(134);


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a" /* default */] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["a"] = (root);


/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ __webpack_exports__["a"] = (isObjectLike);


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(1);
  var warning = __webpack_require__(2);
  var ReactPropTypesSecret = __webpack_require__(39);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(8);
var invariant = __webpack_require__(1);
var ReactPropTypesSecret = __webpack_require__(39);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(157);


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ARIADOMPropertyConfig = {
  Properties: {
    // Global States and Properties
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  },
  DOMAttributeNames: {},
  DOMPropertyNames: {}
};

module.exports = ARIADOMPropertyConfig;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentTree = __webpack_require__(5);

var focusNode = __webpack_require__(61);

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
  }
};

module.exports = AutoFocusUtils;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(24);
var ExecutionEnvironment = __webpack_require__(6);
var FallbackCompositionState = __webpack_require__(152);
var SyntheticCompositionEvent = __webpack_require__(195);
var SyntheticInputEvent = __webpack_require__(198);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (currentComposition) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var CSSProperty = __webpack_require__(67);
var ExecutionEnvironment = __webpack_require__(6);
var ReactInstrumentation = __webpack_require__(9);

var camelizeStyleName = __webpack_require__(117);
var dangerousStyleValue = __webpack_require__(205);
var hyphenateStyleName = __webpack_require__(124);
var memoizeStringOnly = __webpack_require__(127);
var warning = __webpack_require__(2);

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if (process.env.NODE_ENV !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;

  var warnHyphenatedStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
  };

  var warnBadVendoredStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
  };

  var warnStyleValueWithSemicolon = function (name, value, owner) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
  };

  var warnStyleValueIsNaN = function (name, value, owner) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
  };

  var checkRenderMessage = function (owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  };

  /**
   * @param {string} name
   * @param {*} value
   * @param {ReactDOMComponent} component
   */
  var warnValidStyle = function (name, value, component) {
    var owner;
    if (component) {
      owner = component._currentElement._owner;
    }
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, owner);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, owner);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, owner);
    }

    if (typeof value === 'number' && isNaN(value)) {
      warnStyleValueIsNaN(name, value, owner);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function (styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styleValue, component);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: component._debugID,
        type: 'update styles',
        payload: styles
      });
    }

    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styles[styleName], component);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(23);
var EventPropagators = __webpack_require__(24);
var ExecutionEnvironment = __webpack_require__(6);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(10);
var SyntheticEvent = __webpack_require__(13);

var getEventTarget = __webpack_require__(51);
var isEventSupported = __webpack_require__(52);
var isTextInputElement = __webpack_require__(85);

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}
function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  // IE10+ fire input events to often, such when a placeholder
  // changes or when an input with a placeholder is focused.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
}

/**
 * (For IE <=11) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For IE <=11) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  if (activeElement.attachEvent) {
    activeElement.attachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.addEventListener('propertychange', handlePropertyChange, false);
  }
}

/**
 * (For IE <=11) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;

  if (activeElement.detachEvent) {
    activeElement.detachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
  }

  activeElement = null;
  activeElementInst = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For IE <=11) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetInstForInputEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput') {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return targetInst;
  }
}

function handleEventsForInputEventIE(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9-11, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventIE(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementInst;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return targetInst;
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }

};

module.exports = ChangeEventPlugin;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var DOMLazyTree = __webpack_require__(18);
var ExecutionEnvironment = __webpack_require__(6);

var createNodesFromMarkup = __webpack_require__(120);
var emptyFunction = __webpack_require__(8);
var invariant = __webpack_require__(1);

var Danger = {

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.replaceChildWithTree(oldChild, markup);
    }
  }

};

module.exports = Danger;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */

var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

module.exports = DefaultEventPluginOrder;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(24);
var ReactDOMComponentTree = __webpack_require__(5);
var SyntheticMouseEvent = __webpack_require__(29);

var eventTypes = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }

};

module.exports = EnterLeaveEventPlugin;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var PooledClass = __webpack_require__(15);

var getTextContentAccessor = __webpack_require__(83);

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(14);

var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    // specifies target context for links with `preload` type
    as: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: HAS_BOOLEAN_VALUE,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    referrerPolicy: 0,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {},
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

module.exports = HTMLDOMPropertyConfig;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactReconciler = __webpack_require__(19);

var instantiateReactComponent = __webpack_require__(84);
var KeyEscapeUtils = __webpack_require__(43);
var shouldUpdateReactComponent = __webpack_require__(53);
var traverseAllChildren = __webpack_require__(87);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(7);
}

function instantiateChild(childInstances, child, name, selfDebugID) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    if (!ReactComponentTreeHook) {
      ReactComponentTreeHook = __webpack_require__(7);
    }
    if (!keyUnique) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
    }
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
  ) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};

    if (process.env.NODE_ENV !== 'production') {
      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
        return instantiateChild(childInsts, child, name, selfDebugID);
      }, childInstances);
    } else {
      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    }
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
  ) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        // Creating mount image now ensures refs are resolved in right order
        // (see https://github.com/facebook/react/pull/7101 for explanation).
        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild, safely);
      }
    }
  }

};

module.exports = ReactChildReconciler;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMChildrenOperations = __webpack_require__(40);
var ReactDOMIDOperations = __webpack_require__(162);

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup

};

module.exports = ReactComponentBrowserEnvironment;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var React = __webpack_require__(20);
var ReactComponentEnvironment = __webpack_require__(45);
var ReactCurrentOwner = __webpack_require__(11);
var ReactErrorUtils = __webpack_require__(46);
var ReactInstanceMap = __webpack_require__(25);
var ReactInstrumentation = __webpack_require__(9);
var ReactNodeTypes = __webpack_require__(77);
var ReactReconciler = __webpack_require__(19);

if (process.env.NODE_ENV !== 'production') {
  var checkReactTypeSpec = __webpack_require__(204);
}

var emptyObject = __webpack_require__(22);
var invariant = __webpack_require__(1);
var shallowEqual = __webpack_require__(37);
var shouldUpdateReactComponent = __webpack_require__(53);
var warning = __webpack_require__(2);

var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
  }
}

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;

    if (process.env.NODE_ENV !== 'production') {
      this._warnedAboutRefsInRender = false;
    }
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var _this = this;

    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    var updateQueue = transaction.getUpdateQueue();

    // Initialize the public class
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;

    // Support functional components
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
      }

      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';

      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = updateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if (process.env.NODE_ENV !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(function () {
            return inst.componentDidMount();
          }, _this._debugID, 'componentDidMount');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  },

  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
    if (process.env.NODE_ENV !== 'production') {
      ReactCurrentOwner.current = this;
      try {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    }
  },

  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;

    if (doConstruct) {
      if (process.env.NODE_ENV !== 'production') {
        return measureLifeCyclePerf(function () {
          return new Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'ctor');
      } else {
        return new Component(publicProps, publicContext, updateQueue);
      }
    }

    // This can still be an instance in case of factory components
    // but we'll count this as time spent rendering as the more common case.
    if (process.env.NODE_ENV !== 'production') {
      return measureLifeCyclePerf(function () {
        return Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'render');
    } else {
      return Component(publicProps, publicContext, updateQueue);
    }
  },

  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;

    var debugID = 0;
    if (process.env.NODE_ENV !== 'production') {
      debugID = this._debugID;
    }

    if (inst.componentWillMount) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillMount();
        }, debugID, 'componentWillMount');
      } else {
        inst.componentWillMount();
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
    );
    this._renderedComponent = child;

    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

    if (process.env.NODE_ENV !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    return markup;
  },

  getHostNode: function () {
    return ReactReconciler.getHostNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }

    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;

      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        if (process.env.NODE_ENV !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillUnmount();
          }, this._debugID, 'componentWillUnmount');
        } else {
          inst.componentWillUnmount();
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;

    if (inst.getChildContext) {
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
        try {
          childContext = inst.getChildContext();
        } finally {
          ReactInstrumentation.debugTool.onEndProcessingChildContext();
        }
      } else {
        childContext = inst.getChildContext();
      }
    }

    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
      if (process.env.NODE_ENV !== 'production') {
        this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkContextTypes: function (typeSpecs, values, location) {
    if (process.env.NODE_ENV !== 'production') {
      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

    var willReceive = false;
    var nextContext;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;

    // Not a simple state update but a props update
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillReceiveProps(nextProps, nextContext);
        }, this._debugID, 'componentWillReceiveProps');
      } else {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        if (process.env.NODE_ENV !== 'production') {
          shouldUpdate = measureLifeCyclePerf(function () {
            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'shouldComponentUpdate');
        } else {
          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
        }
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;

    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'componentWillUpdate');
      } else {
        inst.componentWillUpdate(nextProps, nextState, nextContext);
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();

    var debugID = 0;
    if (process.env.NODE_ENV !== 'production') {
      debugID = this._debugID;
    }

    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
      ReactReconciler.unmountComponent(prevComponentInstance, false);

      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

      if (process.env.NODE_ENV !== 'production') {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }

      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedElement;

    if (process.env.NODE_ENV !== 'production') {
      renderedElement = measureLifeCyclePerf(function () {
        return inst.render();
      }, this._debugID, 'render');
    } else {
      renderedElement = inst.render();
    }

    if (process.env.NODE_ENV !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (renderedElement === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedElement = null;
      }
    }

    return renderedElement;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedElement;
    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

    return renderedElement;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    if (process.env.NODE_ENV !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

module.exports = ReactCompositeComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/



var ReactDOMComponentTree = __webpack_require__(5);
var ReactDefaultInjection = __webpack_require__(174);
var ReactMount = __webpack_require__(76);
var ReactReconciler = __webpack_require__(19);
var ReactUpdates = __webpack_require__(10);
var ReactVersion = __webpack_require__(189);

var findDOMNode = __webpack_require__(206);
var getHostComponentFromComposite = __webpack_require__(82);
var renderSubtreeIntoContainer = __webpack_require__(213);
var warning = __webpack_require__(2);

ReactDefaultInjection.inject();

var ReactDOM = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function (inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getHostComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

if (process.env.NODE_ENV !== 'production') {
  var ExecutionEnvironment = __webpack_require__(6);
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        // Firefox does not have the issue with devtools loaded over file://
        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    var testFunc = function testFn() {};
    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
        break;
      }
    }
  }
}

if (process.env.NODE_ENV !== 'production') {
  var ReactInstrumentation = __webpack_require__(9);
  var ReactDOMUnknownPropertyHook = __webpack_require__(171);
  var ReactDOMNullInputValuePropHook = __webpack_require__(165);
  var ReactDOMInvalidARIAHook = __webpack_require__(164);

  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
}

module.exports = ReactDOM;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* global hasOwnProperty:true */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var AutoFocusUtils = __webpack_require__(145);
var CSSPropertyOperations = __webpack_require__(147);
var DOMLazyTree = __webpack_require__(18);
var DOMNamespaces = __webpack_require__(41);
var DOMProperty = __webpack_require__(14);
var DOMPropertyOperations = __webpack_require__(69);
var EventPluginHub = __webpack_require__(23);
var EventPluginRegistry = __webpack_require__(27);
var ReactBrowserEventEmitter = __webpack_require__(28);
var ReactDOMComponentFlags = __webpack_require__(70);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactDOMInput = __webpack_require__(163);
var ReactDOMOption = __webpack_require__(166);
var ReactDOMSelect = __webpack_require__(71);
var ReactDOMTextarea = __webpack_require__(169);
var ReactInstrumentation = __webpack_require__(9);
var ReactMultiChild = __webpack_require__(182);
var ReactServerRenderingTransaction = __webpack_require__(187);

var emptyFunction = __webpack_require__(8);
var escapeTextContentForBrowser = __webpack_require__(31);
var invariant = __webpack_require__(1);
var isEventSupported = __webpack_require__(52);
var shallowEqual = __webpack_require__(37);
var validateDOMNesting = __webpack_require__(54);
var warning = __webpack_require__(2);

var Flags = ReactDOMComponentFlags;
var deleteListener = EventPluginHub.deleteListener;
var getNode = ReactDOMComponentTree.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var STYLE = 'style';
var HTML = '__html';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
  }
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
  }
  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.postMountWrapper(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setAndValidateContentChildDev = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  setAndValidateContentChildDev = function (content) {
    var hasExistingContent = this._contentDebugID != null;
    var debugID = this._debugID;
    // This ID represents the inlined child that has no backing instance:
    var contentDebugID = -debugID;

    if (content == null) {
      if (hasExistingContent) {
        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
      }
      this._contentDebugID = null;
      return;
    }

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
  var node = getNode(inst);
  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
        }
      }
      break;
    case 'source':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if (process.env.NODE_ENV !== 'production') {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the parent component instance
   * @param {?object} info about the host container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = hostContainerInfo._idCounter++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, hostParent);
        props = ReactDOMInput.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, hostParent);
        props = ReactDOMOption.getHostProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, hostParent);
        props = ReactDOMSelect.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, hostParent);
        props = ReactDOMTextarea.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (hostParent != null) {
      namespaceURI = hostParent._namespaceURI;
      parentTag = hostParent._tag;
    } else if (hostContainerInfo._tag) {
      namespaceURI = hostContainerInfo._namespaceURI;
      parentTag = hostContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces.html;
    }
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    if (process.env.NODE_ENV !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo._tag) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(this._tag, null, this, parentInfo);
      }
      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else if (props.is) {
          el = ownerDocument.createElement(this._currentElement.type, props.is);
        } else {
          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
          // See discussion in https://github.com/facebook/react/pull/6896
          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
          el = ownerDocument.createElement(this._currentElement.type);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree.precacheNode(this, el);
      this._flags |= Flags.hasCachedChildNodes;
      if (!this._hostParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(inputPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'textarea':
        transaction.getReactMountReady().enqueue(textareaPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'select':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'button':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if (process.env.NODE_ENV !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = _assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._hostParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
        if (process.env.NODE_ENV !== 'production') {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      // TODO: Validate that text is allowed as a child of this node
      if (contentToUse != null) {
        // Avoid setting textContent when the text is empty. In IE11 setting
        // textContent on a text area will cause the placeholder to not
        // show within the textarea until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        if (contentToUse !== '') {
          if (process.env.NODE_ENV !== 'production') {
            setAndValidateContentChildDev.call(this, contentToUse);
          }
          DOMLazyTree.queueText(lazyTree, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'input':
        lastProps = ReactDOMInput.getHostProps(this, lastProps);
        nextProps = ReactDOMInput.getHostProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getHostProps(this, lastProps);
        nextProps = ReactDOMOption.getHostProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
        break;
      case 'textarea':
        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    switch (this._tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        ReactDOMInput.updateWrapper(this);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        break;
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (process.env.NODE_ENV !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = _assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
        if (process.env.NODE_ENV !== 'production') {
          setAndValidateContentChildDev.call(this, nextContent);
        }
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    } else if (nextChildren != null) {
      if (process.env.NODE_ENV !== 'production') {
        setAndValidateContentChildDev.call(this, null);
      }

      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getHostNode: function () {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function (safely) {
    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree.uncacheNode(this);
    EventPluginHub.deleteAllListeners(this);
    this._rootNodeID = 0;
    this._domID = 0;
    this._wrapperState = null;

    if (process.env.NODE_ENV !== 'production') {
      setAndValidateContentChildDev.call(this, null);
    }
  },

  getPublicInstance: function () {
    return getNode(this);
  }

};

_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var validateDOMNesting = __webpack_require__(54);

var DOC_NODE_TYPE = 9;

function ReactDOMContainerInfo(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  if (process.env.NODE_ENV !== 'production') {
    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
  }
  return info;
}

module.exports = ReactDOMContainerInfo;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var DOMLazyTree = __webpack_require__(18);
var ReactDOMComponentTree = __webpack_require__(5);

var ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
};
_assign(ReactDOMEmptyComponent.prototype, {
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    this._domID = domID;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree.precacheNode(this, node);
      return DOMLazyTree(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function () {},
  getHostNode: function () {
    return ReactDOMComponentTree.getNodeFromInstance(this);
  },
  unmountComponent: function () {
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMEmptyComponent;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMFeatureFlags = {
  useCreateElement: true,
  useFiber: false
};

module.exports = ReactDOMFeatureFlags;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMChildrenOperations = __webpack_require__(40);
var ReactDOMComponentTree = __webpack_require__(5);

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.processUpdates(node, updates);
  }
};

module.exports = ReactDOMIDOperations;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var DOMPropertyOperations = __webpack_require__(69);
var LinkedValueUtils = __webpack_require__(44);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(10);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var hostProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

      var owner = inst._currentElement._owner;

      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnCheckedLink = true;
      }
      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnValueDefaultValue = true;
      }
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      controlled: isControlled(props)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    if (process.env.NODE_ENV !== 'production') {
      var controlled = isControlled(props);
      var owner = inst._currentElement._owner;

      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnUncontrolledToControlled = true;
      }
      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnControlledToUncontrolled = true;
      }
    }

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      if (value === 0 && node.value === '') {
        node.value = '0';
        // Note: IE9 reports a number inputs as 'text', so check props instead.
      } else if (props.type === 'number') {
        // Simulate `input.valueAsNumber`. IE9 does not support it
        var valueAsNumber = parseFloat(node.value, 10) || 0;

        // eslint-disable-next-line
        if (value != valueAsNumber) {
          // Cast `value` to a string to ensure the value is set correctly. While
          // browsers typically do this as necessary, jsdom doesn't.
          node.value = '' + value;
        }
        // eslint-disable-next-line
      } else if (value != node.value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        // In Chrome, assigning defaultValue to certain input types triggers input validation.
        // For number inputs, the display value loses trailing decimal points. For email inputs,
        // Chrome raises "The specified value <x> is not a valid email address".
        //
        // Here we check to see if the defaultValue has actually changed, avoiding these problems
        // when the user is inputting text
        //
        // https://github.com/facebook/react/issues/7253
        if (node.defaultValue !== '' + props.defaultValue) {
          node.defaultValue = '' + props.defaultValue;
        }
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  },

  postMountWrapper: function (inst) {
    var props = inst._currentElement.props;

    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(14);
var ReactComponentTreeHook = __webpack_require__(7);

var warning = __webpack_require__(2);

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

function validateProperty(tagName, name, debugID) {
  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
    return true;
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(debugID, element) {
  var invalidProps = [];

  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (invalidProps.length > 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
}

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }

  warnInvalidARIAProps(debugID, element);
}

var ReactDOMInvalidARIAHook = {
  onBeforeMountComponent: function (debugID, element) {
    if (process.env.NODE_ENV !== 'production') {
      handleElement(debugID, element);
    }
  },
  onBeforeUpdateComponent: function (debugID, element) {
    if (process.env.NODE_ENV !== 'production') {
      handleElement(debugID, element);
    }
  }
};

module.exports = ReactDOMInvalidARIAHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactComponentTreeHook = __webpack_require__(7);

var warning = __webpack_require__(2);

var didWarnValueNull = false;

function handleElement(debugID, element) {
  if (element == null) {
    return;
  }
  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
    return;
  }
  if (element.props != null && element.props.value === null && !didWarnValueNull) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

    didWarnValueNull = true;
  }
}

var ReactDOMNullInputValuePropHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMNullInputValuePropHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var React = __webpack_require__(20);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactDOMSelect = __webpack_require__(71);

var warning = __webpack_require__(2);
var didWarnInvalidOptionChildren = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    } else if (!didWarnInvalidOptionChildren) {
      didWarnInvalidOptionChildren = true;
      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, hostParent) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
    }

    // Look up whether this option is 'selected'
    var selectValue = null;
    if (hostParent != null) {
      var selectParent = hostParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._hostParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      var value;
      if (props.value != null) {
        value = props.value + '';
      } else {
        value = flattenChildren(props.children);
      }
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function (inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getHostProps: function (inst, props) {
    var hostProps = _assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      hostProps.selected = inst._wrapperState.selected;
    }

    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }

};

module.exports = ReactDOMOption;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);

var getNodeForCharacterOffset = __webpack_require__(210);
var getTextContentAccessor = __webpack_require__(83);

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var DOMChildrenOperations = __webpack_require__(40);
var DOMLazyTree = __webpack_require__(18);
var ReactDOMComponentTree = __webpack_require__(5);

var escapeTextContentForBrowser = __webpack_require__(31);
var invariant = __webpack_require__(1);
var validateDOMNesting = __webpack_require__(54);

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign(ReactDOMTextComponent.prototype, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    if (process.env.NODE_ENV !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo != null) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(null, this._stringText, this, parentInfo);
      }
    }

    var domID = hostContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._hostParent = hostParent;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getHostNode();
        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
      }
    }
  },

  getHostNode: function () {
    var hostNode = this._commentNodes;
    if (hostNode) {
      return hostNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    hostNode = [this._hostNode, this._closingComment];
    this._commentNodes = hostNode;
    return hostNode;
  },

  unmountComponent: function () {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree.uncacheNode(this);
  }

});

module.exports = ReactDOMTextComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var LinkedValueUtils = __webpack_require__(44);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(10);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var didWarnValueLink = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getHostProps: function (inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
    // The value can be a boolean or object so that's why it's forced to be a string.
    var hostProps = _assign({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValDefaultVal = true;
      }
    }

    var value = LinkedValueUtils.getValue(props);
    var initialValue = value;

    // Only bother fetching default value if we're going to use it
    if (value == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
        }
        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    inst._wrapperState = {
      initialValue: '' + initialValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  },

  postMountWrapper: function (inst) {
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var textContent = node.textContent;

    // Only set node.value if textContent is equal to the expected
    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
    // will populate textContent as well.
    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
    if (textContent === inst._wrapperState.initialValue) {
      node.value = textContent;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

  return inst._hostParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}

module.exports = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(14);
var EventPluginRegistry = __webpack_require__(27);
var ReactComponentTreeHook = __webpack_require__(7);

var warning = __webpack_require__(2);

if (process.env.NODE_ENV !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true,

    autoFocus: true,
    defaultValue: true,
    valueLink: true,
    defaultChecked: true,
    checkedLink: true,
    innerHTML: true,
    suppressContentEditableWarning: true,
    onFocusIn: true,
    onFocusOut: true
  };
  var warnedProperties = {};

  var validateProperty = function (tagName, name, debugID) {
    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
      return true;
    }
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return true;
    }
    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
      return true;
    }
    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

    if (standardName != null) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else if (registrationName != null) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else {
      // We were unable to guess which prop the user intended.
      // It is likely that the user was just blindly spreading/forwarding props
      // Components should be careful to only render valid props/attributes.
      // Warning will be invoked in warnUnknownProperties to allow grouping.
      return false;
    }
  };
}

var warnUnknownProperties = function (debugID, element) {
  var unknownProps = [];
  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (unknownProps.length > 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
};

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }
  warnUnknownProperties(debugID, element);
}

var ReactDOMUnknownPropertyHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMUnknownPropertyHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactInvalidSetStateWarningHook = __webpack_require__(180);
var ReactHostOperationHistoryHook = __webpack_require__(178);
var ReactComponentTreeHook = __webpack_require__(7);
var ExecutionEnvironment = __webpack_require__(6);

var performanceNow = __webpack_require__(129);
var warning = __webpack_require__(2);

var hooks = [];
var didHookThrowForEvent = {};

function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
  try {
    fn.call(context, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
    didHookThrowForEvent[event] = true;
  }
}

function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    var fn = hook[event];
    if (fn) {
      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
    }
  }
}

var isProfiling = false;
var flushHistory = [];
var lifeCycleTimerStack = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = [];
var currentFlushStartTime = 0;
var currentTimerDebugID = null;
var currentTimerStartTime = 0;
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
  ReactComponentTreeHook.purgeUnmountedComponents();
  ReactHostOperationHistoryHook.clearHistory();
}

function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeHook.getOwnerID(id);
    var parentID = ReactComponentTreeHook.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeHook.getDisplayName(id),
      text: ReactComponentTreeHook.getText(id),
      updateCount: ReactComponentTreeHook.getUpdateCount(id),
      childIDs: ReactComponentTreeHook.getChildIDs(id),
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
      parentID: parentID
    };
    return tree;
  }, {});
}

function resetMeasurements() {
  var previousStartTime = currentFlushStartTime;
  var previousMeasurements = currentFlushMeasurements;
  var previousOperations = ReactHostOperationHistoryHook.getHistory();

  if (currentFlushNesting === 0) {
    currentFlushStartTime = 0;
    currentFlushMeasurements = [];
    clearHistory();
    return;
  }

  if (previousMeasurements.length || previousOperations.length) {
    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
    flushHistory.push({
      duration: performanceNow() - previousStartTime,
      measurements: previousMeasurements || [],
      operations: previousOperations || [],
      treeSnapshot: getTreeSnapshot(registeredIDs)
    });
  }

  clearHistory();
  currentFlushStartTime = performanceNow();
  currentFlushMeasurements = [];
}

function checkDebugID(debugID) {
  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (allowRoot && debugID === 0) {
    return;
  }
  if (!debugID) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
  }
}

function beginLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType && !lifeCycleTimerHasWarned) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  currentTimerStartTime = performanceNow();
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

function endLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  if (isProfiling) {
    currentFlushMeasurements.push({
      timerType: timerType,
      instanceID: debugID,
      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
    });
  }
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function pauseCurrentLifeCycleTimer() {
  var currentTimer = {
    startTime: currentTimerStartTime,
    nestedFlushStartTime: performanceNow(),
    debugID: currentTimerDebugID,
    timerType: currentTimerType
  };
  lifeCycleTimerStack.push(currentTimer);
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function resumeCurrentLifeCycleTimer() {
  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
      startTime = _lifeCycleTimerStack$.startTime,
      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
      debugID = _lifeCycleTimerStack$.debugID,
      timerType = _lifeCycleTimerStack$.timerType;

  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
  currentTimerStartTime = startTime;
  currentTimerNestedFlushDuration += nestedFlushDuration;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

var lastMarkTimeStamp = 0;
var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

function shouldMark(debugID) {
  if (!isProfiling || !canUsePerformanceMeasure) {
    return false;
  }
  var element = ReactComponentTreeHook.getElement(debugID);
  if (element == null || typeof element !== 'object') {
    return false;
  }
  var isHostElement = typeof element.type === 'string';
  if (isHostElement) {
    return false;
  }
  return true;
}

function markBegin(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  lastMarkTimeStamp = performanceNow();
  performance.mark(markName);
}

function markEnd(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

  // Chrome has an issue of dropping markers recorded too fast:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
  // To work around this, we will not report very small measurements.
  // I determined the magic number by tweaking it back and forth.
  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
  // When the bug is fixed, we can `measure()` unconditionally if we want to.
  var timeStamp = performanceNow();
  if (timeStamp - lastMarkTimeStamp > 0.1) {
    var measurementName = displayName + ' [' + markType + ']';
    performance.measure(measurementName, markName);
  }

  performance.clearMarks(markName);
  performance.clearMeasures(measurementName);
}

var ReactDebugTool = {
  addHook: function (hook) {
    hooks.push(hook);
  },
  removeHook: function (hook) {
    for (var i = 0; i < hooks.length; i++) {
      if (hooks[i] === hook) {
        hooks.splice(i, 1);
        i--;
      }
    }
  },
  isProfiling: function () {
    return isProfiling;
  },
  beginProfiling: function () {
    if (isProfiling) {
      return;
    }

    isProfiling = true;
    flushHistory.length = 0;
    resetMeasurements();
    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
    if (!isProfiling) {
      return;
    }

    isProfiling = false;
    resetMeasurements();
    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
  },
  getFlushHistory: function () {
    return flushHistory;
  },
  onBeginFlush: function () {
    currentFlushNesting++;
    resetMeasurements();
    pauseCurrentLifeCycleTimer();
    emitEvent('onBeginFlush');
  },
  onEndFlush: function () {
    resetMeasurements();
    currentFlushNesting--;
    resumeCurrentLifeCycleTimer();
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    markBegin(debugID, timerType);
    beginLifeCycleTimer(debugID, timerType);
  },
  onEndLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    endLifeCycleTimer(debugID, timerType);
    markEnd(debugID, timerType);
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function () {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function () {
    emitEvent('onEndProcessingChildContext');
  },
  onHostOperation: function (operation) {
    checkDebugID(operation.instanceID);
    emitEvent('onHostOperation', operation);
  },
  onSetState: function () {
    emitEvent('onSetState');
  },
  onSetChildren: function (debugID, childDebugIDs) {
    checkDebugID(debugID);
    childDebugIDs.forEach(checkDebugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onBeforeMountComponent: function (debugID, element, parentDebugID) {
    checkDebugID(debugID);
    checkDebugID(parentDebugID, true);
    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
    markBegin(debugID, 'mount');
  },
  onMountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'mount');
    emitEvent('onMountComponent', debugID);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    checkDebugID(debugID);
    emitEvent('onBeforeUpdateComponent', debugID, element);
    markBegin(debugID, 'update');
  },
  onUpdateComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'update');
    emitEvent('onUpdateComponent', debugID);
  },
  onBeforeUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onBeforeUnmountComponent', debugID);
    markBegin(debugID, 'unmount');
  },
  onUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'unmount');
    emitEvent('onUnmountComponent', debugID);
  },
  onTestEvent: function () {
    emitEvent('onTestEvent');
  }
};

// TODO remove these when RN/www gets updated
ReactDebugTool.addDevtool = ReactDebugTool.addHook;
ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool.addHook(ReactComponentTreeHook);
var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
if (/[?&]react_perf\b/.test(url)) {
  ReactDebugTool.beginProfiling();
}

module.exports = ReactDebugTool;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var ReactUpdates = __webpack_require__(10);
var Transaction = __webpack_require__(30);

var emptyFunction = __webpack_require__(8);

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ARIADOMPropertyConfig = __webpack_require__(144);
var BeforeInputEventPlugin = __webpack_require__(146);
var ChangeEventPlugin = __webpack_require__(148);
var DefaultEventPluginOrder = __webpack_require__(150);
var EnterLeaveEventPlugin = __webpack_require__(151);
var HTMLDOMPropertyConfig = __webpack_require__(153);
var ReactComponentBrowserEnvironment = __webpack_require__(155);
var ReactDOMComponent = __webpack_require__(158);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactDOMEmptyComponent = __webpack_require__(160);
var ReactDOMTreeTraversal = __webpack_require__(170);
var ReactDOMTextComponent = __webpack_require__(168);
var ReactDefaultBatchingStrategy = __webpack_require__(173);
var ReactEventListener = __webpack_require__(177);
var ReactInjection = __webpack_require__(179);
var ReactReconcileTransaction = __webpack_require__(185);
var SVGDOMPropertyConfig = __webpack_require__(190);
var SelectEventPlugin = __webpack_require__(191);
var SimpleEventPlugin = __webpack_require__(192);

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

module.exports = {
  inject: inject
};

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(23);

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var EventListener = __webpack_require__(60);
var ExecutionEnvironment = __webpack_require__(6);
var PooledClass = __webpack_require__(15);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(10);

var getEventTarget = __webpack_require__(51);
var getUnboundedScrollPosition = __webpack_require__(122);

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._hostParent) {
    inst = inst._hostParent;
  }
  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var history = [];

var ReactHostOperationHistoryHook = {
  onHostOperation: function (operation) {
    history.push(operation);
  },
  clearHistory: function () {
    if (ReactHostOperationHistoryHook._preventClearing) {
      // Should only be used for tests.
      return;
    }

    history = [];
  },
  getHistory: function () {
    return history;
  }
};

module.exports = ReactHostOperationHistoryHook;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(14);
var EventPluginHub = __webpack_require__(23);
var EventPluginUtils = __webpack_require__(42);
var ReactComponentEnvironment = __webpack_require__(45);
var ReactEmptyComponent = __webpack_require__(72);
var ReactBrowserEventEmitter = __webpack_require__(28);
var ReactHostComponent = __webpack_require__(74);
var ReactUpdates = __webpack_require__(10);

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventPluginUtils: EventPluginUtils.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  HostComponent: ReactHostComponent.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var warning = __webpack_require__(2);

if (process.env.NODE_ENV !== 'production') {
  var processingChildContext = false;

  var warnInvalidSetState = function () {
    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
  };
}

var ReactInvalidSetStateWarningHook = {
  onBeginProcessingChildContext: function () {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function () {
    processingChildContext = false;
  },
  onSetState: function () {
    warnInvalidSetState();
  }
};

module.exports = ReactInvalidSetStateWarningHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var adler32 = __webpack_require__(203);

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactComponentEnvironment = __webpack_require__(45);
var ReactInstanceMap = __webpack_require__(25);
var ReactInstrumentation = __webpack_require__(9);

var ReactCurrentOwner = __webpack_require__(11);
var ReactReconciler = __webpack_require__(19);
var ReactChildReconciler = __webpack_require__(154);

var emptyFunction = __webpack_require__(8);
var flattenChildren = __webpack_require__(207);
var invariant = __webpack_require__(1);

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  var getDebugID = function (inst) {
    if (!inst._debugID) {
      // Check for ART-like instances. TODO: This is silly/gross.
      var internal;
      if (internal = ReactInstanceMap.get(inst)) {
        inst = internal;
      }
    }
    return inst._debugID;
  };
  setChildrenForInstrumentation = function (children) {
    var debugID = getDebugID(this);
    // TODO: React Native empty components are also multichild.
    // This means they still get into this method but don't have _debugID.
    if (debugID !== 0) {
      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
        return children[key]._debugID;
      }) : []);
    }
  };
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if (process.env.NODE_ENV !== 'production') {
        var selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      if (process.env.NODE_ENV !== 'production') {
        selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          if (process.env.NODE_ENV !== 'production') {
            selfDebugID = getDebugID(this);
          }
          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, children);
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var nextIndex = 0;
      var lastIndex = 0;
      // `nextMountIndex` will increment for each newly mounted child.
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }

  }

};

module.exports = ReactMultiChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid owner.
 * @final
 */
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {
  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var CallbackQueue = __webpack_require__(68);
var PooledClass = __webpack_require__(15);
var ReactBrowserEventEmitter = __webpack_require__(28);
var ReactInputSelection = __webpack_require__(75);
var ReactInstrumentation = __webpack_require__(9);
var Transaction = __webpack_require__(30);
var ReactUpdateQueue = __webpack_require__(47);

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

if (process.env.NODE_ENV !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return ReactUpdateQueue;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function () {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactOwner = __webpack_require__(183);

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var PooledClass = __webpack_require__(15);
var Transaction = __webpack_require__(30);
var ReactInstrumentation = __webpack_require__(9);
var ReactServerUpdateQueue = __webpack_require__(188);

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [];

if (process.env.NODE_ENV !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

var noopCallbackQueue = {
  enqueue: function () {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return noopCallbackQueue;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return this.updateQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {},

  checkpoint: function () {},

  rollback: function () {}
};

_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReactUpdateQueue = __webpack_require__(47);

var warning = __webpack_require__(2);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the update queue used for server rendering.
 * It delegates to ReactUpdateQueue while server rendering is in progress and
 * switches to ReactNoopUpdateQueue after the transaction has completed.
 * @class ReactServerUpdateQueue
 * @param {Transaction} transaction
 */

var ReactServerUpdateQueue = function () {
  function ReactServerUpdateQueue(transaction) {
    _classCallCheck(this, ReactServerUpdateQueue);

    this.transaction = transaction;
  }

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */


  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
    return false;
  };

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
    } else {
      warnNoop(publicInstance, 'forceUpdate');
    }
  };

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} completeState Next state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
    } else {
      warnNoop(publicInstance, 'replaceState');
    }
  };

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();

module.exports = ReactServerUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.5.4';

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlns: 0,
  xmlnsXlink: 'xmlns:xlink',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
  }
});

module.exports = SVGDOMPropertyConfig;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(24);
var ExecutionEnvironment = __webpack_require__(6);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactInputSelection = __webpack_require__(75);
var SyntheticEvent = __webpack_require__(13);

var getActiveElement = __webpack_require__(62);
var isTextInputElement = __webpack_require__(85);
var shallowEqual = __webpack_require__(37);

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (inst, registrationName, listener) {
    if (registrationName === 'onSelect') {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var EventListener = __webpack_require__(60);
var EventPropagators = __webpack_require__(24);
var ReactDOMComponentTree = __webpack_require__(5);
var SyntheticAnimationEvent = __webpack_require__(193);
var SyntheticClipboardEvent = __webpack_require__(194);
var SyntheticEvent = __webpack_require__(13);
var SyntheticFocusEvent = __webpack_require__(197);
var SyntheticKeyboardEvent = __webpack_require__(199);
var SyntheticMouseEvent = __webpack_require__(29);
var SyntheticDragEvent = __webpack_require__(196);
var SyntheticTouchEvent = __webpack_require__(200);
var SyntheticTransitionEvent = __webpack_require__(201);
var SyntheticUIEvent = __webpack_require__(26);
var SyntheticWheelEvent = __webpack_require__(202);

var emptyFunction = __webpack_require__(8);
var getEventCharCode = __webpack_require__(49);
var invariant = __webpack_require__(1);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

var onClickListeners = {};

function getDictionaryKey(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topAbort':
      case 'topCanPlay':
      case 'topCanPlayThrough':
      case 'topDurationChange':
      case 'topEmptied':
      case 'topEncrypted':
      case 'topEnded':
      case 'topError':
      case 'topInput':
      case 'topInvalid':
      case 'topLoad':
      case 'topLoadedData':
      case 'topLoadedMetadata':
      case 'topLoadStart':
      case 'topPause':
      case 'topPlay':
      case 'topPlaying':
      case 'topProgress':
      case 'topRateChange':
      case 'topReset':
      case 'topSeeked':
      case 'topSeeking':
      case 'topStalled':
      case 'topSubmit':
      case 'topSuspend':
      case 'topTimeUpdate':
      case 'topVolumeChange':
      case 'topWaiting':
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (!onClickListeners[key]) {
        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (inst, registrationName) {
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      onClickListeners[key].remove();
      delete onClickListeners[key];
    }
  }

};

module.exports = SimpleEventPlugin;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

module.exports = SyntheticAnimationEvent;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticMouseEvent = __webpack_require__(29);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(26);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(26);

var getEventCharCode = __webpack_require__(49);
var getEventKey = __webpack_require__(208);
var getEventModifierState = __webpack_require__(50);

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(26);

var getEventModifierState = __webpack_require__(50);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

module.exports = SyntheticTransitionEvent;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticMouseEvent = __webpack_require__(29);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactPropTypeLocationNames = __webpack_require__(184);
var ReactPropTypesSecret = __webpack_require__(78);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(7);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(7);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var CSSProperty = __webpack_require__(67);
var warning = __webpack_require__(2);

var isUnitlessNumber = CSSProperty.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, component) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    if (process.env.NODE_ENV !== 'production') {
      // Allow '0' to pass through without warning. 0 is already special and
      // doesn't require units, so we don't need to warn about it.
      if (component && value !== '0') {
        var owner = component._currentElement._owner;
        var ownerName = owner ? owner.getName() : null;
        if (ownerName && !styleWarnings[ownerName]) {
          styleWarnings[ownerName] = {};
        }
        var warned = false;
        if (ownerName) {
          var warnings = styleWarnings[ownerName];
          warned = warnings[name];
          if (!warned) {
            warnings[name] = true;
          }
        }
        if (!warned) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
        }
      }
    }
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactCurrentOwner = __webpack_require__(11);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactInstanceMap = __webpack_require__(25);

var getHostComponentFromComposite = __webpack_require__(82);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
  } else {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
  }
}

module.exports = findDOMNode;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var KeyEscapeUtils = __webpack_require__(43);
var traverseAllChildren = __webpack_require__(87);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(7);
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if (process.env.NODE_ENV !== 'production') {
      if (!ReactComponentTreeHook) {
        ReactComponentTreeHook = __webpack_require__(7);
      }
      if (!keyUnique) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
      }
    }
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  if (process.env.NODE_ENV !== 'production') {
    traverseAllChildren(children, function (traverseContext, child, name) {
      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
    }, result);
  } else {
    traverseAllChildren(children, flattenSingleChildIntoContext, result);
  }
  return result;
}

module.exports = flattenChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var getEventCharCode = __webpack_require__(49);

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

module.exports = getVendorPrefixedEventName;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var escapeTextContentForBrowser = __webpack_require__(31);

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactMount = __webpack_require__(76);

module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export createProvider */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_warning__ = __webpack_require__(55);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__utils_warning__["a" /* default */])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

function createProvider() {
  var _Provider$childContex;

  var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
  var subKey = arguments[1];

  var subscriptionKey = subKey || storeKey + 'Subscription';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
    };

    function Provider(props, context) {
      _classCallCheck(this, Provider);

      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

      _this[storeKey] = props.store;
      return _this;
    }

    Provider.prototype.render = function render() {
      return __WEBPACK_IMPORTED_MODULE_0_react__["Children"].only(this.props.children);
    };

    return Provider;
  }(__WEBPACK_IMPORTED_MODULE_0_react__["Component"]);

  if (process.env.NODE_ENV !== 'production') {
    Provider.prototype.componentWillReceiveProps = function (nextProps) {
      if (this[storeKey] !== nextProps.store) {
        warnAboutReceivingStore();
      }
    };
  }

  Provider.propTypes = {
    store: __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["a" /* storeShape */].isRequired,
    children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.element.isRequired
  };
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["a" /* storeShape */].isRequired, _Provider$childContex[subscriptionKey] = __WEBPACK_IMPORTED_MODULE_2__utils_PropTypes__["b" /* subscriptionShape */], _Provider$childContex);
  Provider.displayName = 'Provider';

  return Provider;
}

/* harmony default export */ __webpack_exports__["a"] = (createProvider());
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export createConnect */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_connectAdvanced__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__ = __webpack_require__(222);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapDispatchToProps__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mapStateToProps__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mergeProps__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__selectorFactory__ = __webpack_require__(219);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }








/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
  };
}

function strictEqual(a, b) {
  return a === b;
}

// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
function createConnect() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === undefined ? __WEBPACK_IMPORTED_MODULE_0__components_connectAdvanced__["a" /* default */] : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? __WEBPACK_IMPORTED_MODULE_3__mapStateToProps__["a" /* default */] : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? __WEBPACK_IMPORTED_MODULE_2__mapDispatchToProps__["a" /* default */] : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === undefined ? __WEBPACK_IMPORTED_MODULE_4__mergeProps__["a" /* default */] : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === undefined ? __WEBPACK_IMPORTED_MODULE_5__selectorFactory__["a" /* default */] : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref2$pure = _ref2.pure,
        pure = _ref2$pure === undefined ? true : _ref2$pure,
        _ref2$areStatesEqual = _ref2.areStatesEqual,
        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areOwnPropsEqua,
        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areStatePropsEq,
        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? __WEBPACK_IMPORTED_MODULE_1__utils_shallowEqual__["a" /* default */] : _ref2$areMergedPropsE,
        extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return 'Connect(' + name + ')';
      },

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),

      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual

    }, extraOptions));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (createConnect());

/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export whenMapDispatchToPropsIsFunction */
/* unused harmony export whenMapDispatchToPropsIsMissing */
/* unused harmony export whenMapDispatchToPropsIsObject */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_redux__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__ = __webpack_require__(89);



function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["a" /* wrapMapToPropsFunc */])(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}

function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["b" /* wrapMapToPropsConstant */])(function (dispatch) {
    return { dispatch: dispatch };
  }) : undefined;
}

function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__wrapMapToProps__["b" /* wrapMapToPropsConstant */])(function (dispatch) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_redux__["c" /* bindActionCreators */])(mapDispatchToProps, dispatch);
  }) : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);

/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export whenMapStateToPropsIsFunction */
/* unused harmony export whenMapStateToPropsIsMissing */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__ = __webpack_require__(89);


function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__["a" /* wrapMapToPropsFunc */])(mapStateToProps, 'mapStateToProps') : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__wrapMapToProps__["b" /* wrapMapToPropsConstant */])(function () {
    return {};
  }) : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);

/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export defaultMergeProps */
/* unused harmony export wrapMergePropsFunc */
/* unused harmony export whenMergePropsIsFunction */
/* unused harmony export whenMergePropsIsOmitted */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__ = __webpack_require__(92);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}

function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;

    var hasRunOnce = false;
    var mergedProps = void 0;

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;

        if (process.env.NODE_ENV !== 'production') __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_verifyPlainObject__["a" /* default */])(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}

function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}

function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export impureFinalPropsSelectorFactory */
/* unused harmony export pureFinalPropsSelectorFactory */
/* harmony export (immutable) */ __webpack_exports__["a"] = finalPropsSelectorFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__verifySubselectors__ = __webpack_require__(220);
function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }



function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}

function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;

  var hasRunAtLeastOnce = false;
  var state = void 0;
  var ownProps = void 0;
  var stateProps = void 0;
  var dispatchProps = void 0;
  var mergedProps = void 0;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;

    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;

    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}

// TODO: Add more comments

// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (process.env.NODE_ENV !== 'production') {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__verifySubselectors__["a" /* default */])(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = verifySubselectors;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_warning__ = __webpack_require__(55);


function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!selector.hasOwnProperty('dependsOnOwnProps')) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils_warning__["a" /* default */])('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}

/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Subscription; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var CLEARED = null;
var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  var current = [];
  var next = [];

  return {
    clear: function clear() {
      next = CLEARED;
      current = CLEARED;
    },
    notify: function notify() {
      var listeners = current = next;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    },
    subscribe: function subscribe(listener) {
      var isSubscribed = true;
      if (next === current) next = current.slice();
      next.push(listener);

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return;
        isSubscribed = false;

        if (next === current) next = current.slice();
        next.splice(next.indexOf(listener), 1);
      };
    }
  };
}

var Subscription = function () {
  function Subscription(store, parentSub, onStateChange) {
    _classCallCheck(this, Subscription);

    this.store = store;
    this.parentSub = parentSub;
    this.onStateChange = onStateChange;
    this.unsubscribe = null;
    this.listeners = nullListeners;
  }

  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  Subscription.prototype.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  Subscription.prototype.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

      this.listeners = createListenerCollection();
    }
  };

  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();



/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = shallowEqual;
var hasOwn = Object.prototype.hasOwnProperty;

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(17);

var invariant = __webpack_require__(1);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var PooledClass = __webpack_require__(224);
var ReactElement = __webpack_require__(16);

var emptyFunction = __webpack_require__(8);
var traverseAllChildren = __webpack_require__(235);

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(17),
    _assign = __webpack_require__(4);

var ReactComponent = __webpack_require__(56);
var ReactElement = __webpack_require__(16);
var ReactPropTypeLocationNames = __webpack_require__(95);
var ReactNoopUpdateQueue = __webpack_require__(57);

var emptyObject = __webpack_require__(22);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

/**
 * Policies that describe methods in `ReactClassInterface`.
 */


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or host components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: 'DEFINE_MANY',

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: 'DEFINE_MANY',

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: 'DEFINE_MANY',

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: 'DEFINE_MANY',

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: 'DEFINE_MANY',

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: 'DEFINE_MANY_MERGED',

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: 'DEFINE_MANY_MERGED',

  /**
   * @return {object}
   * @optional
   */
  getChildContext: 'DEFINE_MANY_MERGED',

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @required
   */
  render: 'DEFINE_ONCE',

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: 'DEFINE_MANY',

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: 'DEFINE_MANY',

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: 'DEFINE_MANY',

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: 'DEFINE_ONCE',

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: 'DEFINE_MANY',

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: 'OVERRIDE_BASE'

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, childContextTypes, 'childContext');
    }
    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, contextTypes, 'context');
    }
    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, propTypes, 'prop');
    }
    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    if (process.env.NODE_ENV !== 'production') {
      var typeofSpec = typeof spec;
      var isMixinValid = typeofSpec === 'object' && spec !== null;

      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
    }

    return;
  }

  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === 'DEFINE_MANY_MERGED') {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === 'DEFINE_MANY') {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (process.env.NODE_ENV !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (process.env.NODE_ENV !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
      } else if (!args.length) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function () {};
_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

var didWarnDeprecated = false;

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(didWarnDeprecated, '%s: React.createClass is deprecated and will be removed in version 16. ' + 'Use plain JavaScript classes instead. If you\'re not yet ready to ' + 'migrate, create-react-class is available on npm as a ' + 'drop-in replacement.', spec && spec.displayName || 'A Component') : void 0;
      didWarnDeprecated = true;
    }

    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactElement = __webpack_require__(16);

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if (process.env.NODE_ENV !== 'production') {
  var ReactElementValidator = __webpack_require__(94);
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _require = __webpack_require__(16),
    isValidElement = _require.isValidElement;

var factory = __webpack_require__(64);

module.exports = factory(isValidElement);

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var ReactComponent = __webpack_require__(56);
var ReactNoopUpdateQueue = __webpack_require__(57);

var emptyObject = __webpack_require__(22);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = ReactPureComponent;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.5.4';

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(17);

var ReactPropTypeLocationNames = __webpack_require__(95);
var ReactPropTypesSecret = __webpack_require__(229);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(7);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(7);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var nextDebugID = 1;

function getNextDebugID() {
  return nextDebugID++;
}

module.exports = getNextDebugID;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */


var _prodInvariant = __webpack_require__(17);

var ReactElement = __webpack_require__(16);

var invariant = __webpack_require__(1);

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(17);

var ReactCurrentOwner = __webpack_require__(11);
var REACT_ELEMENT_TYPE = __webpack_require__(93);

var getIteratorFn = __webpack_require__(96);
var invariant = __webpack_require__(1);
var KeyEscapeUtils = __webpack_require__(223);
var warning = __webpack_require__(2);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__internal_middleware__ = __webpack_require__(237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__internal_runSaga__ = __webpack_require__(99);
/* unused harmony reexport runSaga */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__internal_channel__ = __webpack_require__(35);
/* unused harmony reexport END */
/* unused harmony reexport eventChannel */
/* unused harmony reexport channel */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__internal_buffers__ = __webpack_require__(34);
/* unused harmony reexport buffers */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__internal_sagaHelpers__ = __webpack_require__(100);
/* unused harmony reexport takeEvery */
/* unused harmony reexport takeLatest */
/* unused harmony reexport throttle */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__internal_utils__ = __webpack_require__(12);
/* unused harmony reexport delay */
/* unused harmony reexport CANCEL */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__effects__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils__ = __webpack_require__(238);
/* unused harmony reexport effects */
/* unused harmony reexport utils */

/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__internal_middleware__["a" /* default */]);












/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__["a"] = sagaMiddlewareFactory;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__channel__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__runSaga__ = __webpack_require__(99);
function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






function sagaMiddlewareFactory() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _ref$context = _ref.context,
      context = _ref$context === undefined ? {} : _ref$context,
      options = _objectWithoutProperties(_ref, ['context']);

  var sagaMonitor = options.sagaMonitor,
      logger = options.logger,
      onError = options.onError;


  if (__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func(options)) {
    if (process.env.NODE_ENV === 'production') {
      throw new Error('Saga middleware no longer accept Generator functions. Use sagaMiddleware.run instead');
    } else {
      throw new Error('You passed a function to the Saga middleware. You are likely trying to start a        Saga by directly passing it to the middleware. This is no longer possible starting from 0.10.0.        To run a Saga, you must do it dynamically AFTER mounting the middleware into the store.\n        Example:\n          import createSagaMiddleware from \'redux-saga\'\n          ... other imports\n\n          const sagaMiddleware = createSagaMiddleware()\n          const store = createStore(reducer, applyMiddleware(sagaMiddleware))\n          sagaMiddleware.run(saga, ...args)\n      ');
    }
  }

  if (logger && !__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func(logger)) {
    throw new Error('`options.logger` passed to the Saga middleware is not a function!');
  }

  if (process.env.NODE_ENV === 'development' && options.onerror) {
    throw new Error('`options.onerror` was removed. Use `options.onError` instead.');
  }

  if (onError && !__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func(onError)) {
    throw new Error('`options.onError` passed to the Saga middleware is not a function!');
  }

  if (options.emitter && !__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].func(options.emitter)) {
    throw new Error('`options.emitter` passed to the Saga middleware is not a function!');
  }

  function sagaMiddleware(_ref2) {
    var getState = _ref2.getState,
        dispatch = _ref2.dispatch;

    var sagaEmitter = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__channel__["e" /* emitter */])();
    sagaEmitter.emit = (options.emitter || __WEBPACK_IMPORTED_MODULE_0__utils__["g" /* ident */])(sagaEmitter.emit);

    sagaMiddleware.run = __WEBPACK_IMPORTED_MODULE_2__runSaga__["a" /* runSaga */].bind(null, {
      context: context,
      subscribe: sagaEmitter.subscribe,
      dispatch: dispatch,
      getState: getState,
      sagaMonitor: sagaMonitor,
      logger: logger,
      onError: onError
    });

    return function (next) {
      return function (action) {
        if (sagaMonitor && sagaMonitor.actionDispatched) {
          sagaMonitor.actionDispatched(action);
        }
        var result = next(action); // hit reducers
        sagaEmitter.emit(action);
        return result;
      };
    };
  }

  sagaMiddleware.run = function () {
    throw new Error('Before running a Saga, you must mount the Saga middleware on the Store using applyMiddleware');
  };

  sagaMiddleware.setContext = function (props) {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["b" /* check */])(props, __WEBPACK_IMPORTED_MODULE_0__utils__["c" /* is */].object, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__utils__["h" /* createSetContextWarning */])('sagaMiddleware', props));
    __WEBPACK_IMPORTED_MODULE_0__utils__["u" /* object */].assign(context, props);
  };

  return sagaMiddleware;
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__internal_utils__ = __webpack_require__(12);
/* unused harmony reexport TASK */
/* unused harmony reexport SAGA_ACTION */
/* unused harmony reexport noop */
/* unused harmony reexport is */
/* unused harmony reexport deferred */
/* unused harmony reexport arrayOfDeffered */
/* unused harmony reexport createMockTask */
/* unused harmony reexport cloneableGenerator */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__internal_io__ = __webpack_require__(36);
/* unused harmony reexport asEffect */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__internal_proc__ = __webpack_require__(98);
/* unused harmony reexport CHANNEL_END */




/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

exports['default'] = thunk;

/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = applyMiddleware;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__compose__ = __webpack_require__(102);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = __WEBPACK_IMPORTED_MODULE_0__compose__["a" /* default */].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* unused harmony export default */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createStore__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash_es_isPlainObject__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_warning__ = __webpack_require__(105);




function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === __WEBPACK_IMPORTED_MODULE_0__createStore__["b" /* ActionTypes */].INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_lodash_es_isPlainObject__["a" /* default */])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerSanity(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: __WEBPACK_IMPORTED_MODULE_0__createStore__["b" /* ActionTypes */].INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + __WEBPACK_IMPORTED_MODULE_0__createStore__["b" /* ActionTypes */].INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (process.env.NODE_ENV !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_warning__["a" /* default */])('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  if (process.env.NODE_ENV !== 'production') {
    var unexpectedKeyCache = {};
  }

  var sanityError;
  try {
    assertReducerSanity(finalReducers);
  } catch (e) {
    sanityError = e;
  }

  return function combination() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var action = arguments[1];

    if (sanityError) {
      throw sanityError;
    }

    if (process.env.NODE_ENV !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__utils_warning__["a" /* default */])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var i = 0; i < finalReducerKeys.length; i++) {
      var key = finalReducerKeys[i];
      var reducer = finalReducers[key];
      var previousStateForKey = state[key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(key, action);
        throw new Error(errorMessage);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(245);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list, options);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list, options) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove, transformResult;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    transformResult = options.transform(obj.css);
	    
	    if (transformResult) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = transformResult;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css. 
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 245 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(247);


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = __webpack_require__(248);

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59), __webpack_require__(251)(module)))

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

/***/ }),
/* 249 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 250 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 251 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./hilary.png": 249,
	"./trump.png": 250,
	"./twitter.png": 106
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 252;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(107);


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOTJiYjg5ZWQwNTllZWZiZDU0MTMiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwid2VicGFjazovLy8uLi9+L29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4uL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5zdHJ1bWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC1zYWdhL2VzL2ludGVybmFsL3V0aWxzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1Bvb2xlZENsYXNzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL0RPTUxhenlUcmVlLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0L2xpYi9SZWFjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC9yZWFjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvRXZlbnRQcm9wYWdhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9UcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL3NldElubmVySFRNTC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVkdXgtc2FnYS9lcy9pbnRlcm5hbC9idWZmZXJzLmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4LXNhZ2EvZXMvaW50ZXJuYWwvY2hhbm5lbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC1zYWdhL2VzL2ludGVybmFsL2lvLmpzIiwid2VicGFjazovLy8uLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gtZXMvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL0RPTU5hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LXJlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9zdHlsZS5jc3M/ZjY5NiIsIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uLi9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwid2VicGFjazovLy8uLi9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoLWVzL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvcC10eXBlcy9mYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9+L3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvQ2FsbGJhY2tRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdE1vdW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3ROb2RlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL3NldFRleHRDb250ZW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LXJlZHV4L2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LXJlZHV4L2VzL3V0aWxzL1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50U3ltYm9sLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4LXNhZ2EvZXMvaW50ZXJuYWwvcHJvYy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC1zYWdhL2VzL2ludGVybmFsL3J1blNhZ2EuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVkdXgtc2FnYS9lcy9pbnRlcm5hbC9zYWdhSGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC1zYWdhL2VzL2ludGVybmFsL3NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC9lcy9jb21wb3NlLmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4L2VzL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4L2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vaW1nL3R3aXR0ZXIucG5nIiwid2VicGFjazovLy8uL2luZGV4LmpzIiwid2VicGFjazovLy8uL2FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9Ud2VldC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL1R3ZWV0c0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9yZWR1Y2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9zYWdhcy5qcyIsIndlYnBhY2s6Ly8vLi92aWV3LmpzIiwid2VicGFjazovLy8uL3N0eWxlLmNzcyIsIndlYnBhY2s6Ly8vLi4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzIiwid2VicGFjazovLy8uLi9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vZmJqcy9saWIvaHlwaGVuYXRlLmpzIiwid2VicGFjazovLy8uLi9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vZmJqcy9saWIvaXNUZXh0Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIndlYnBhY2s6Ly8vLi9pbmRleC5odG1sIiwid2VicGFjazovLy8uLi9+L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoLWVzL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vbG9kYXNoLWVzL19yb290LmpzIiwid2VicGFjazovLy8uLi9+L2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9BUklBRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL0Rhbmdlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29udGFpbmVySW5mby5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01PcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RPd25lci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0UmVmLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0U2VydmVyVXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNBbmltYXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9maW5kRE9NTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50S2V5LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtZG9tL2xpYi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1kb20vbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LWRvbS9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tZXJnZVByb3BzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0LXJlZHV4L2VzL3V0aWxzL1N1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QvbGliL0tleUVzY2FwZVV0aWxzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QvbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC9saWIvZ2V0TmV4dERlYnVnSUQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC1zYWdhL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4LXNhZ2EvZXMvaW50ZXJuYWwvbWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC1zYWdhL2VzL3V0aWxzLmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4LXRodW5rL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC9lcy9hcHBseU1pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVkdXgvZXMvYmluZEFjdGlvbkNyZWF0b3JzLmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4L2VzL2NvbWJpbmVSZWR1Y2Vycy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHlsZS1sb2FkZXIvZml4VXJscy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vc3ltYm9sLW9ic2VydmFibGUvbGliL3BvbnlmaWxsLmpzIiwid2VicGFjazovLy8uL2ltZy9oaWxhcnkucG5nIiwid2VicGFjazovLy8uL2ltZy90cnVtcC5wbmciLCJ3ZWJwYWNrOi8vLy4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9pbWcgXlxcLlxcLy4qXFwucG5nJCJdLCJuYW1lcyI6WyJzYWdhTWlkZGxld2FyZSIsImNyZWF0ZVNhZ2FNaWRkbGV3YXJlIiwic3RvcmUiLCJjcmVhdGVTdG9yZSIsImFwcGx5TWlkZGxld2FyZSIsInJ1biIsInJlbmRlciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJ0b2dnbGVVc2VyIiwidHlwZSIsImdldFR3ZWV0cyIsImNhbmRpZGF0ZSIsInBheWxvYWQiLCJUd2VldCIsInByb3BzIiwic3R5bGVzIiwidHdlZXRJdGVtIiwidHdlZXRIZWFkZXIiLCJ0d2VldFVzZXIiLCJyZXF1aXJlIiwidHdpdHRlckxvZ28iLCJ1c2VyIiwidHdlZXREYXRlIiwiZGF0ZSIsInN1YnN0cmluZyIsInR3ZWV0VGV4dCIsInRleHQiLCJUd2VldHNDb250YWluZXIiLCJ0d2VldENvbnRhaW5lciIsInR3ZWV0Q29udGFpbmVyVUwiLCJ0d2VldHMiLCJtYXAiLCJ0d2VldCIsImluZGV4IiwiaW5pdGlhbFN0YXRlIiwib3Bwb25lbnQiLCJyZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRUd2VldHNBc3luYyIsIndhdGNoR2V0VHdlZXQiLCJmZXRjaFR3ZWV0cyIsInBvbGl0aWNpYW4iLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJnZXRUd2VldHNKc29uIiwiYmxvYiIsImpzb24iLCJmaWx0ZXIiLCJuYW1lIiwiY3JlYXRlZF9hdCIsImNhbGwiLCJ0d2VldHNKc29uIiwicHV0Iiwic3RhdHVzZXMiLCJ0YWtlRXZlcnkiLCJNYWluVmlldyIsImNsaWNraW5nIiwiYmluZCIsImRpc3BhdGNoIiwibmV4dFByb3BzIiwiY2FuZGlkYXRlQ29udGFpbmVyIiwidG9Mb3dlckNhc2UiLCJjYW5kaWRhdGVCdXR0b24iLCJtYXBTdGF0ZVRvUHJvcHMiLCJjb25uZWN0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7QUN2THRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBLDJCOzs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixhQUFhO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSw4RkFBOEYsZUFBZTtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSx5Qjs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBb0Q7O0FBRXBELHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBLG9DOzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUM7Ozs7Ozs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQzs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBLHdDOzs7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b0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBLEdBQUc7QUFD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O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7OztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyw4QkFBOEI7QUFDOUI7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esb0VBQW9FLHlCQUF5Qjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBb0Q7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLDZCOzs7Ozs7OztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkI7Ozs7Ozs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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ZTtBQUM1QixhQUFhLDBEQUEwRDtBQUN2RSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsMEJBQTBCO0FBQ3ZDLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDOzs7Ozs7OztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUI7Ozs7Ozs7O0FDdEdBOztBQUVBOzs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkI7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0dBQXdHO0FBQ3hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0M7Ozs7Ozs7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQzs7Ozs7Ozs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtDOzs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtDOzs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHVFQUF1RTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUM7Ozs7Ozs7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdSQUF3UjtBQUN4Ujs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDL2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87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O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUM7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DOzs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQzs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDOzs7Ozs7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsV0FBVztBQUN0QixXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwyQzs7Ozs7Ozs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0M7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDL1FBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7QUNsRW1DO0FBQ25DO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7Ozs7OztBQ2JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQzs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0RTtBQUM1RSxPQUFPO0FBQ1A7QUFDQSxpSEFBaUU7QUFDakUsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELG1GQUFtRjs7QUFFbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkVBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsdUNBQXVDOztBQUVsRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkM7QUFDM0M7O0FBRUE7QUFD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Q2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzFEQTs7QUFFQTs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUEsdUM7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0M7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1DOzs7Ozs7O0FDeFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0I7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUM7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1Qzs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLDBDOzs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUM7Ozs7Ozs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUtBQXFLO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLDBCQUEwQjtBQUN2QyxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0Q7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMERBQTBEO0FBQ3ZFLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBMEQ7QUFDdkUsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBEQUEwRDtBQUN2RSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMERBQTBEO0FBQ3ZFLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQzs7Ozs7Ozs7QUN2K0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDOzs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx3Qzs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0M7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDOzs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBMEQ7QUFDdkUsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsdUM7Ozs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDOzs7Ozs7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDOzs7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDOzs7Ozs7OztBQ3JXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEM7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFOzs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0M7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwyQzs7Ozs7Ozs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEI7Ozs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1Qiw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUQ7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsVUFBVTtBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsd0M7Ozs7Ozs7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQjs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNDOzs7Ozs7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DOzs7Ozs7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1DOzs7Ozs7OztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUM7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Qzs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkM7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DOzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQzs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQzs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDOzs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDOzs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQzs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUM7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Qjs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSkFBaUo7QUFDako7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNJQUFzSTtBQUN0STtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixXQUFXLGtCQUFrQjtBQUM3QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQzs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw2Qjs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUtBQXVLO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkI7Ozs7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCOzs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQzs7Ozs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDOzs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0M7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVEOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFBQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SixpREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTljO0FBQzlCO0FBQ3dDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTs7QUFFQSwyRTs7Ozs7Ozs7Ozs7Ozs7QUN4RUE7QUFBQSxtREFBbUQsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUU5UCw4Q0FBOEMsaUJBQWlCLHFCQUFxQixvQ0FBb0MsNkRBQTZELG9CQUFvQixFQUFFLGVBQWU7O0FBRTFOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMEU7Ozs7Ozs7Ozs7OztBQ3RHNkI7QUFDd0I7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsOEo7Ozs7Ozs7Ozs7QUNuQnFEOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHdIOzs7Ozs7Ozs7OztBQ1pBO0FBQUEsbURBQW1ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFOVA7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSw4Rzs7Ozs7Ozs7Ozs7QUM1Q0E7QUFBQSw4Q0FBOEMsaUJBQWlCLHFCQUFxQixvQ0FBb0MsNkRBQTZELG9CQUFvQixFQUFFLGVBQWU7O0FBRTFOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7O0FDckdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQ2hCQTtBQUFBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7O0FDdEZEO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQzs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkI7Ozs7Ozs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsRUFBRTtBQUNiLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCOzs7Ozs7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCOzs7Ozs7OztBQ2p0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlDOzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQjs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlKQUFpSjtBQUNqSjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0lBQXNJO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQzs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkI7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMExBQTJMLHlDQUF5QywrR0FBK0cseUNBQXlDO0FBQzVYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5S0E7QUFDQTs7QUFFa0I7QUFDbUI7QUFDbkI7QUFDd0I7QUFDbEI7O0FBRXhCO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQUEsOENBQThDLGlCQUFpQixxQkFBcUIsb0NBQW9DLDZEQUE2RCxvQkFBb0IsRUFBRSxlQUFlOztBQUVySztBQUNuQztBQUNGO0FBQ0U7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZxRztBQUNsRjs7Ozs7Ozs7QUNEbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCOzs7Ozs7OztBQ3RCQTtBQUFBLG1EQUFtRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRTlQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDOzs7Ozs7O0FDL0NBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7QUM5Q3NCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0VBQXlCOztBQUVwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVcsRUFBRTtBQUNyRCx3Q0FBd0MsV0FBVyxFQUFFOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNDQUFzQztBQUN0QyxHQUFHO0FBQ0g7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOzs7Ozs7O0FDeEZBOzs7Ozs7OztzRENBQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0EsNEI7Ozs7Ozs7O0FDNUJBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsRTs7Ozs7O0FDdEJBLGlDQUFpQyxvNStVOzs7Ozs7QUNBakMsaUNBQWlDLHd2NlE7Ozs7OztBQ0FqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QiIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyNTMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDkyYmI4OWVkMDU5ZWVmYmQ1NDEzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9O1xuXG4gICAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICAgIH1cblxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2ZianMvbGliL3dhcm5pbmcuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG5mdW5jdGlvbiByZWFjdFByb2RJbnZhcmlhbnQoY29kZSkge1xuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICB2YXIgbWVzc2FnZSA9ICdNaW5pZmllZCBSZWFjdCBlcnJvciAjJyArIGNvZGUgKyAnOyB2aXNpdCAnICsgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xuICAgIG1lc3NhZ2UgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYXJnSWR4ICsgMV0pO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCcgKyAnIGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLic7XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgdGhyb3cgZXJyb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RQcm9kSW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRGbGFncycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIG5vZGUgc2hvdWxkIGJlIGNhY2hlZC5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkUHJlY2FjaGVOb2RlKG5vZGUsIG5vZGVJRCkge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpID09PSBTdHJpbmcobm9kZUlEKSB8fCBub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LXRleHQ6ICcgKyBub2RlSUQgKyAnICcgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1lbXB0eTogJyArIG5vZGVJRCArICcgJztcbn1cblxuLyoqXG4gKiBEcmlsbCBkb3duICh0aHJvdWdoIGNvbXBvc2l0ZXMgYW5kIGVtcHR5IGNvbXBvbmVudHMpIHVudGlsIHdlIGdldCBhIGhvc3Qgb3JcbiAqIGhvc3QgdGV4dCBjb21wb25lbnQuXG4gKlxuICogVGhpcyBpcyBwcmV0dHkgcG9seW1vcnBoaWMgYnV0IHVuYXZvaWRhYmxlIHdpdGggdGhlIGN1cnJlbnQgc3RydWN0dXJlIHdlIGhhdmVcbiAqIGZvciBgX3JlbmRlcmVkQ2hpbGRyZW5gLlxuICovXG5mdW5jdGlvbiBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICB2YXIgcmVuZGVyZWQ7XG4gIHdoaWxlIChyZW5kZXJlZCA9IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQgPSByZW5kZXJlZDtcbiAgfVxuICByZXR1cm4gY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIHRoZSByZW5kZXJlZCBob3N0L3RleHQgY29tcG9uZW50IHdpdGggdGhlIGdpdmVuXG4gKiBET00gbm9kZS4gVGhlIHBhc3NlZCBgaW5zdGAgY2FuIGJlIGEgY29tcG9zaXRlLlxuICovXG5mdW5jdGlvbiBwcmVjYWNoZU5vZGUoaW5zdCwgbm9kZSkge1xuICB2YXIgaG9zdEluc3QgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGluc3QpO1xuICBob3N0SW5zdC5faG9zdE5vZGUgPSBub2RlO1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5cbmZ1bmN0aW9uIHVuY2FjaGVOb2RlKGluc3QpIHtcbiAgdmFyIG5vZGUgPSBpbnN0Ll9ob3N0Tm9kZTtcbiAgaWYgKG5vZGUpIHtcbiAgICBkZWxldGUgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgICBpbnN0Ll9ob3N0Tm9kZSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSBgX2hvc3ROb2RlYCBvbiBlYWNoIGNoaWxkIG9mIGBpbnN0YCwgYXNzdW1pbmcgdGhhdCB0aGUgY2hpbGRyZW5cbiAqIG1hdGNoIHVwIHdpdGggdGhlIERPTSAoZWxlbWVudCkgY2hpbGRyZW4gb2YgYG5vZGVgLlxuICpcbiAqIFdlIGNhY2hlIGVudGlyZSBsZXZlbHMgYXQgb25jZSB0byBhdm9pZCBhbiBuXjIgcHJvYmxlbSB3aGVyZSB3ZSBhY2Nlc3MgdGhlXG4gKiBjaGlsZHJlbiBvZiBhIG5vZGUgc2VxdWVudGlhbGx5IGFuZCBoYXZlIHRvIHdhbGsgZnJvbSB0aGUgc3RhcnQgdG8gb3VyIHRhcmdldFxuICogbm9kZSBldmVyeSB0aW1lLlxuICpcbiAqIFNpbmNlIHdlIHVwZGF0ZSBgX3JlbmRlcmVkQ2hpbGRyZW5gIGFuZCB0aGUgYWN0dWFsIERPTSBhdCAoc2xpZ2h0bHkpXG4gKiBkaWZmZXJlbnQgdGltZXMsIHdlIGNvdWxkIHJhY2UgaGVyZSBhbmQgc2VlIGEgbmV3ZXIgYF9yZW5kZXJlZENoaWxkcmVuYCB0aGFuXG4gKiB0aGUgRE9NIG5vZGVzIHdlIHNlZS4gVG8gYXZvaWQgdGhpcywgUmVhY3RNdWx0aUNoaWxkIGNhbGxzXG4gKiBgcHJlcGFyZVRvTWFuYWdlQ2hpbGRyZW5gIGJlZm9yZSB3ZSBjaGFuZ2UgYF9yZW5kZXJlZENoaWxkcmVuYCwgYXQgd2hpY2hcbiAqIHRpbWUgdGhlIGNvbnRhaW5lcidzIGNoaWxkIG5vZGVzIGFyZSBhbHdheXMgY2FjaGVkICh1bnRpbCBpdCB1bm1vdW50cykuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBub2RlKSB7XG4gIGlmIChpbnN0Ll9mbGFncyAmIEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNoaWxkcmVuID0gaW5zdC5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgb3V0ZXI6IGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICBpZiAoIWNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdCA9IGNoaWxkcmVuW25hbWVdO1xuICAgIHZhciBjaGlsZElEID0gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChjaGlsZEluc3QpLl9kb21JRDtcbiAgICBpZiAoY2hpbGRJRCA9PT0gMCkge1xuICAgICAgLy8gV2UncmUgY3VycmVudGx5IHVubW91bnRpbmcgdGhpcyBjaGlsZCBpbiBSZWFjdE11bHRpQ2hpbGQ7IHNraXAgaXQuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gV2UgYXNzdW1lIHRoZSBjaGlsZCBub2RlcyBhcmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIGNoaWxkIGluc3RhbmNlcy5cbiAgICBmb3IgKDsgY2hpbGROb2RlICE9PSBudWxsOyBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChzaG91bGRQcmVjYWNoZU5vZGUoY2hpbGROb2RlLCBjaGlsZElEKSkge1xuICAgICAgICBwcmVjYWNoZU5vZGUoY2hpbGRJbnN0LCBjaGlsZE5vZGUpO1xuICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBET00gY2hpbGRyZW4gd2l0aG91dCBmaW5kaW5nIGFuIElEIG1hdGNoLlxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBlbGVtZW50IHdpdGggSUQgJXMuJywgY2hpbGRJRCkgOiBfcHJvZEludmFyaWFudCgnMzInLCBjaGlsZElEKSA6IHZvaWQgMDtcbiAgfVxuICBpbnN0Ll9mbGFncyB8PSBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgaW5zdGFuY2Ugd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3Nlc3Q7XG4gIHZhciBpbnN0O1xuICBmb3IgKDsgbm9kZSAmJiAoaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pOyBub2RlID0gcGFyZW50cy5wb3AoKSkge1xuICAgIGNsb3Nlc3QgPSBpbnN0O1xuICAgIGlmIChwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgaW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAoaW5zdCAhPSBudWxsICYmIGluc3QuX2hvc3ROb2RlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgIShpbnN0Ll9ob3N0Tm9kZSAhPT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG5cbiAgaWYgKGluc3QuX2hvc3ROb2RlKSB7XG4gICAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIERPTSBub2RlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIWluc3QuX2hvc3ROb2RlKSB7XG4gICAgcGFyZW50cy5wdXNoKGluc3QpO1xuICAgICFpbnN0Ll9ob3N0UGFyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0IERPTSB0cmVlIHJvb3Qgc2hvdWxkIGFsd2F5cyBoYXZlIGEgbm9kZSByZWZlcmVuY2UuJykgOiBfcHJvZEludmFyaWFudCgnMzQnKSA6IHZvaWQgMDtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuXG4gIC8vIE5vdyBwYXJlbnRzIGNvbnRhaW5zIGVhY2ggYW5jZXN0b3IgdGhhdCBkb2VzICpub3QqIGhhdmUgYSBjYWNoZWQgbmF0aXZlXG4gIC8vIG5vZGUsIGFuZCBgaW5zdGAgaXMgdGhlIGRlZXBlc3QgYW5jZXN0b3IgdGhhdCBkb2VzLlxuICBmb3IgKDsgcGFyZW50cy5sZW5ndGg7IGluc3QgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIGluc3QuX2hvc3ROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHtcbiAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlLFxuICBwcmVjYWNoZUNoaWxkTm9kZXM6IHByZWNhY2hlQ2hpbGROb2RlcyxcbiAgcHJlY2FjaGVOb2RlOiBwcmVjYWNoZU5vZGUsXG4gIHVuY2FjaGVOb2RlOiB1bmNhY2hlTm9kZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaXNOYXRpdmUoZm4pIHtcbiAgLy8gQmFzZWQgb24gaXNOYXRpdmUoKSBmcm9tIExvZGFzaFxuICB2YXIgZnVuY1RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jVG9TdHJpbmdcbiAgLy8gVGFrZSBhbiBleGFtcGxlIG5hdGl2ZSBmdW5jdGlvbiBzb3VyY2UgZm9yIGNvbXBhcmlzb25cbiAgLmNhbGwoaGFzT3duUHJvcGVydHkpXG4gIC8vIFN0cmlwIHJlZ2V4IGNoYXJhY3RlcnMgc28gd2UgY2FuIHVzZSBpdCBmb3IgcmVnZXhcbiAgLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLy8gUmVtb3ZlIGhhc093blByb3BlcnR5IGZyb20gdGhlIHRlbXBsYXRlIHRvIG1ha2UgaXQgZ2VuZXJpY1xuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCcpO1xuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSBmdW5jVG9TdHJpbmcuY2FsbChmbik7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChzb3VyY2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIGNhblVzZUNvbGxlY3Rpb25zID1cbi8vIEFycmF5LmZyb21cbnR5cGVvZiBBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nICYmXG4vLyBNYXBcbnR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwKSAmJlxuLy8gTWFwLnByb3RvdHlwZS5rZXlzXG5NYXAucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXAucHJvdG90eXBlLmtleXMpICYmXG4vLyBTZXRcbnR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0KSAmJlxuLy8gU2V0LnByb3RvdHlwZS5rZXlzXG5TZXQucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQucHJvdG90eXBlLmtleXMpO1xuXG52YXIgc2V0SXRlbTtcbnZhciBnZXRJdGVtO1xudmFyIHJlbW92ZUl0ZW07XG52YXIgZ2V0SXRlbUlEcztcbnZhciBhZGRSb290O1xudmFyIHJlbW92ZVJvb3Q7XG52YXIgZ2V0Um9vdElEcztcblxuaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gIHZhciBpdGVtTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgcm9vdElEU2V0ID0gbmV3IFNldCgpO1xuXG4gIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcbiAgICBpdGVtTWFwLnNldChpZCwgaXRlbSk7XG4gIH07XG4gIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaXRlbU1hcC5nZXQoaWQpO1xuICB9O1xuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaXRlbU1hcFsnZGVsZXRlJ10oaWQpO1xuICB9O1xuICBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1NYXAua2V5cygpKTtcbiAgfTtcblxuICBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcm9vdElEU2V0LmFkZChpZCk7XG4gIH07XG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByb290SURTZXRbJ2RlbGV0ZSddKGlkKTtcbiAgfTtcbiAgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyb290SURTZXQua2V5cygpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBpdGVtQnlLZXkgPSB7fTtcbiAgdmFyIHJvb3RCeUtleSA9IHt9O1xuXG4gIC8vIFVzZSBub24tbnVtZXJpYyBrZXlzIHRvIHByZXZlbnQgVjggcGVyZm9ybWFuY2UgaXNzdWVzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHZhciBnZXRLZXlGcm9tSUQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gJy4nICsgaWQ7XG4gIH07XG4gIHZhciBnZXRJREZyb21LZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGtleS5zdWJzdHIoMSksIDEwKTtcbiAgfTtcblxuICBzZXRJdGVtID0gZnVuY3Rpb24gKGlkLCBpdGVtKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgaXRlbUJ5S2V5W2tleV0gPSBpdGVtO1xuICB9O1xuICBnZXRJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcmV0dXJuIGl0ZW1CeUtleVtrZXldO1xuICB9O1xuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIGl0ZW1CeUtleVtrZXldO1xuICB9O1xuICBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtQnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9O1xuXG4gIGFkZFJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByb290QnlLZXlba2V5XSA9IHRydWU7XG4gIH07XG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgcm9vdEJ5S2V5W2tleV07XG4gIH07XG4gIGdldFJvb3RJRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3RCeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH07XG59XG5cbnZhciB1bm1vdW50ZWRJRHMgPSBbXTtcblxuZnVuY3Rpb24gcHVyZ2VEZWVwKGlkKSB7XG4gIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gIGlmIChpdGVtKSB7XG4gICAgdmFyIGNoaWxkSURzID0gaXRlbS5jaGlsZElEcztcblxuICAgIHJlbW92ZUl0ZW0oaWQpO1xuICAgIGNoaWxkSURzLmZvckVhY2gocHVyZ2VEZWVwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiAnI2VtcHR5JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcjdGV4dCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlSUQoaWQpIHtcbiAgdmFyIG5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKTtcbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcklEKSB7XG4gICAgb3duZXJOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShvd25lcklEKTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50LCAnUmVhY3RDb21wb25lbnRUcmVlSG9vazogTWlzc2luZyBSZWFjdCBlbGVtZW50IGZvciBkZWJ1Z0lEICVzIHdoZW4gJyArICdidWlsZGluZyBzdGFjaycsIGlkKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgZWxlbWVudCAmJiBlbGVtZW50Ll9zb3VyY2UsIG93bmVyTmFtZSk7XG59XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0ge1xuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoaWQsIG5leHRDaGlsZElEcykge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgIWl0ZW0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSXRlbSBtdXN0IGhhdmUgYmVlbiBzZXQnKSA6IF9wcm9kSW52YXJpYW50KCcxNDQnKSA6IHZvaWQgMDtcbiAgICBpdGVtLmNoaWxkSURzID0gbmV4dENoaWxkSURzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRJRCA9IG5leHRDaGlsZElEc1tpXTtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBnZXRJdGVtKG5leHRDaGlsZElEKTtcbiAgICAgICFuZXh0Q2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9vayBldmVudHMgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDAnKSA6IHZvaWQgMDtcbiAgICAgICEobmV4dENoaWxkLmNoaWxkSURzICE9IG51bGwgfHwgdHlwZW9mIG5leHRDaGlsZC5lbGVtZW50ICE9PSAnb2JqZWN0JyB8fCBuZXh0Q2hpbGQuZWxlbWVudCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvblNldENoaWxkcmVuKCkgdG8gZmlyZSBmb3IgYSBjb250YWluZXIgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MScpIDogdm9pZCAwO1xuICAgICAgIW5leHRDaGlsZC5pc01vdW50ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25Nb3VudENvbXBvbmVudCgpIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnNzEnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChuZXh0Q2hpbGQucGFyZW50SUQgPT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGQucGFyZW50SUQgPSBpZDtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IGJ1dCBtb3VudGluZyBhIG5ldyByb290IGR1cmluZyBpblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgY3VycmVudGx5IGNhdXNlcyBub3QteWV0LW1vdW50ZWQgY29tcG9uZW50cyB0b1xuICAgICAgICAvLyBiZSBwdXJnZWQgZnJvbSBvdXIgdHJlZSBkYXRhIHNvIHRoZWlyIHBhcmVudCBpZCBpcyBtaXNzaW5nLlxuICAgICAgfVxuICAgICAgIShuZXh0Q2hpbGQucGFyZW50SUQgPT09IGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbkJlZm9yZU1vdW50Q29tcG9uZW50KCkgcGFyZW50IGFuZCBvblNldENoaWxkcmVuKCkgdG8gYmUgY29uc2lzdGVudCAoJXMgaGFzIHBhcmVudHMgJXMgYW5kICVzKS4nLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiBfcHJvZEludmFyaWFudCgnMTQyJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBwYXJlbnRJRCkge1xuICAgIHZhciBpdGVtID0ge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICAgIHRleHQ6IG51bGwsXG4gICAgICBjaGlsZElEczogW10sXG4gICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgdXBkYXRlQ291bnQ6IDBcbiAgICB9O1xuICAgIHNldEl0ZW0oaWQsIGl0ZW0pO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50KSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0uZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgIWl0ZW0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSXRlbSBtdXN0IGhhdmUgYmVlbiBzZXQnKSA6IF9wcm9kSW52YXJpYW50KCcxNDQnKSA6IHZvaWQgMDtcbiAgICBpdGVtLmlzTW91bnRlZCA9IHRydWU7XG4gICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgYWRkUm9vdChpZCk7XG4gICAgfVxuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0udXBkYXRlQ291bnQrKztcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIGl0IGV4aXN0cy5cbiAgICAgIC8vIGBpdGVtYCBtaWdodCBub3QgZXhpc3QgaWYgaXQgaXMgaW5zaWRlIGFuIGVycm9yIGJvdW5kYXJ5LCBhbmQgYSBzaWJsaW5nXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSBjaGlsZCB0aHJldyB3aGlsZSBtb3VudGluZy4gVGhlbiB0aGlzIGluc3RhbmNlIG5ldmVyXG4gICAgICAvLyBnb3QgYSBjaGFuY2UgdG8gbW91bnQsIGJ1dCBpdCBzdGlsbCBnZXRzIGFuIHVubW91bnRpbmcgZXZlbnQgZHVyaW5nXG4gICAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgY2xlYW51cC5cbiAgICAgIGl0ZW0uaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgcmVtb3ZlUm9vdChpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgfSxcbiAgcHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0Q29tcG9uZW50VHJlZUhvb2suX3ByZXZlbnRQdXJnaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0aW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5tb3VudGVkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSB1bm1vdW50ZWRJRHNbaV07XG4gICAgICBwdXJnZURlZXAoaWQpO1xuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5pc01vdW50ZWQgOiBmYWxzZTtcbiAgfSxcbiAgZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW06IGZ1bmN0aW9uICh0b3BFbGVtZW50KSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodG9wRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZSh0b3BFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IHRvcEVsZW1lbnQuX293bmVyO1xuICAgICAgaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHRvcEVsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudE93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB2YXIgaWQgPSBjdXJyZW50T3duZXIgJiYgY3VycmVudE93bmVyLl9kZWJ1Z0lEO1xuXG4gICAgaW5mbyArPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGlkKTtcbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0U3RhY2tBZGRlbmR1bUJ5SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgd2hpbGUgKGlkKSB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlSUQoaWQpO1xuICAgICAgaWQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldENoaWxkSURzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaGlsZElEcyA6IFtdO1xuICB9LFxuICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShlbGVtZW50KTtcbiAgfSxcbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gIH0sXG4gIGdldE93bmVySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQuX293bmVyLl9kZWJ1Z0lEO1xuICB9LFxuICBnZXRQYXJlbnRJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucGFyZW50SUQgOiBudWxsO1xuICB9LFxuICBnZXRTb3VyY2U6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgdmFyIGVsZW1lbnQgPSBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LFxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnJyArIGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnVwZGF0ZUNvdW50IDogMDtcbiAgfSxcblxuXG4gIGdldFJvb3RJRHM6IGdldFJvb3RJRHMsXG4gIGdldFJlZ2lzdGVyZWRJRHM6IGdldEl0ZW1JRHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBSZWFjdEluc3RydW1lbnRhdGlvbiB3aXRoIGEgX19ERVZfXyBjaGVja1xuXG52YXIgZGVidWdUb29sID0gbnVsbDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RGVidWdUb29sID0gcmVxdWlyZSgnLi9SZWFjdERlYnVnVG9vbCcpO1xuICBkZWJ1Z1Rvb2wgPSBSZWFjdERlYnVnVG9vbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGRlYnVnVG9vbDogZGVidWdUb29sIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5zdHJ1bWVudGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciB1cGRhdGVCYXRjaE51bWJlciA9IDA7XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTIzJykgOiB2b2lkIDA7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi90cnVlKTtcbn1cblxuX2Fzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgcmV0dXJuIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpO1xufVxuXG4vKipcbiAqIEFycmF5IGNvbXBhcmF0b3IgZm9yIFJlYWN0Q29tcG9uZW50cyBieSBtb3VudCBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnRPcmRlckNvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnRPcmRlciAtIGMyLl9tb3VudE9yZGVyO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAhKGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvIG1hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IF9wcm9kSW52YXJpYW50KCcxMjQnLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogdm9pZCAwO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XG5cbiAgLy8gQW55IHVwZGF0ZXMgZW5xdWV1ZWQgd2hpbGUgcmVjb25jaWxpbmcgbXVzdCBiZSBwZXJmb3JtZWQgYWZ0ZXIgdGhpcyBlbnRpcmVcbiAgLy8gYmF0Y2guIE90aGVyd2lzZSwgaWYgZGlydHlDb21wb25lbnRzIGlzIFtBLCBCXSB3aGVyZSBBIGhhcyBjaGlsZHJlbiBCIGFuZFxuICAvLyBDLCBCIGNvdWxkIHVwZGF0ZSB0d2ljZSBpbiBhIHNpbmdsZSBiYXRjaCBpZiBDJ3MgcmVuZGVyIGVucXVldWVzIGFuIHVwZGF0ZVxuICAvLyB0byBCIChzaW5jZSBCIHdvdWxkIGhhdmUgYWxyZWFkeSB1cGRhdGVkLCB3ZSBzaG91bGQgc2tpcCBpdCwgYW5kIHRoZSBvbmx5XG4gIC8vIHdheSB3ZSBjYW4ga25vdyB0byBkbyBzbyBpcyBieSBjaGVja2luZyB0aGUgYmF0Y2ggY291bnRlcikuXG4gIHVwZGF0ZUJhdGNoTnVtYmVyKys7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpdCB3aWxsIHN0aWxsXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcblxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxuICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XG4gICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIHZhciBtYXJrZXJOYW1lO1xuICAgIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICAgIHZhciBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgIC8vIER1Y2sgdHlwZSBUb3BMZXZlbFdyYXBwZXIuIFRoaXMgaXMgcHJvYmFibHkgYWx3YXlzIHRydWUuXG4gICAgICBpZiAoY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC50eXBlLmlzUmVhY3RUb3BMZXZlbFdyYXBwZXIpIHtcbiAgICAgICAgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgICAgfVxuICAgICAgbWFya2VyTmFtZSA9ICdSZWFjdCB1cGRhdGU6ICcgKyBuYW1lZENvbXBvbmVudC5nZXROYW1lKCk7XG4gICAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcik7XG5cbiAgICBpZiAobWFya2VyTmFtZSkge1xuICAgICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFja3Nbal0sIGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFN0YXRlLCBmb3JjZVVwZGF0ZSwgZXRjLjsgY3JlYXRpb24gYW5kXG4gIC8vIGRlc3RydWN0aW9uIG9mIHRvcC1sZXZlbCBjb21wb25lbnRzIGlzIGd1YXJkZWQgaW4gUmVhY3RNb3VudC4pXG5cbiAgaWYgKCFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhlbnF1ZXVlVXBkYXRlLCBjb21wb25lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpcnR5Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIGlmIChjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID09IG51bGwpIHtcbiAgICBjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxO1xuICB9XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRvIGJlIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJhdGNoaW5nIGN5Y2xlLiBUaHJvd3NcbiAqIGlmIG5vIHVwZGF0ZXMgYXJlIGN1cnJlbnRseSBiZWluZyBwZXJmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzLmFzYXA6IENhblxcJ3QgZW5xdWV1ZSBhbiBhc2FwIGNhbGxiYWNrIGluIGEgY29udGV4dCB3aGVyZXVwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzEyNScpIDogdm9pZCAwO1xuICBhc2FwQ2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgYXNhcEVucXVldWVkID0gdHJ1ZTtcbn1cblxudmFyIFJlYWN0VXBkYXRlc0luamVjdGlvbiA9IHtcbiAgaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChSZWNvbmNpbGVUcmFuc2FjdGlvbikge1xuICAgICFSZWNvbmNpbGVUcmFuc2FjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcycpIDogX3Byb2RJbnZhcmlhbnQoJzEyNicpIDogdm9pZCAwO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XG4gICAgIV9iYXRjaGluZ1N0cmF0ZWd5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IF9wcm9kSW52YXJpYW50KCcxMjcnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBfcHJvZEludmFyaWFudCgnMTI4JykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYW4gaXNCYXRjaGluZ1VwZGF0ZXMgYm9vbGVhbiBhdHRyaWJ1dGUnKSA6IF9wcm9kSW52YXJpYW50KCcxMjknKSA6IHZvaWQgMDtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5ID0gX2JhdGNoaW5nU3RyYXRlZ3k7XG4gIH1cbn07XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSB7XG4gIC8qKlxuICAgKiBSZWFjdCByZWZlcmVuY2VzIGBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uYCB1c2luZyB0aGlzIHByb3BlcnR5IGluIG9yZGVyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXG5cbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxuICBmbHVzaEJhdGNoZWRVcGRhdGVzOiBmbHVzaEJhdGNoZWRVcGRhdGVzLFxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvbixcbiAgYXNhcDogYXNhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydCB2YXIgc3ltID0gZnVuY3Rpb24gc3ltKGlkKSB7XG4gIHJldHVybiAnQEByZWR1eC1zYWdhLycgKyBpZDtcbn07XG5cbmV4cG9ydCB2YXIgVEFTSyA9IHN5bSgnVEFTSycpO1xuZXhwb3J0IHZhciBIRUxQRVIgPSBzeW0oJ0hFTFBFUicpO1xuZXhwb3J0IHZhciBNQVRDSCA9IHN5bSgnTUFUQ0gnKTtcbmV4cG9ydCB2YXIgQ0FOQ0VMID0gc3ltKCdDQU5DRUxfUFJPTUlTRScpO1xuZXhwb3J0IHZhciBTQUdBX0FDVElPTiA9IHN5bSgnU0FHQV9BQ1RJT04nKTtcbmV4cG9ydCB2YXIgU0VMRl9DQU5DRUxMQVRJT04gPSBzeW0oJ1NFTEZfQ0FOQ0VMTEFUSU9OJyk7XG5leHBvcnQgdmFyIGtvbnN0ID0gZnVuY3Rpb24ga29uc3Qodikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2O1xuICB9O1xufTtcbmV4cG9ydCB2YXIga1RydWUgPSBrb25zdCh0cnVlKTtcbmV4cG9ydCB2YXIga0ZhbHNlID0ga29uc3QoZmFsc2UpO1xuZXhwb3J0IHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuZXhwb3J0IHZhciBpZGVudCA9IGZ1bmN0aW9uIGlkZW50KHYpIHtcbiAgcmV0dXJuIHY7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2sodmFsdWUsIHByZWRpY2F0ZSwgZXJyb3IpIHtcbiAgaWYgKCFwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgbG9nKCdlcnJvcicsICd1bmNhdWdodCBhdCBjaGVjaycsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5leHBvcnQgZnVuY3Rpb24gaGFzT3duKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIGlzLm5vdFVuZGVmKG9iamVjdCkgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbn1cblxuZXhwb3J0IHZhciBpcyA9IHtcbiAgdW5kZWY6IGZ1bmN0aW9uIHVuZGVmKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQ7XG4gIH0sXG4gIG5vdFVuZGVmOiBmdW5jdGlvbiBub3RVbmRlZih2KSB7XG4gICAgcmV0dXJuIHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICBmdW5jOiBmdW5jdGlvbiBmdW5jKGYpIHtcbiAgICByZXR1cm4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbic7XG4gIH0sXG4gIG51bWJlcjogZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInO1xuICB9LFxuICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyhzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJztcbiAgfSxcbiAgYXJyYXk6IEFycmF5LmlzQXJyYXksXG4gIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgIWlzLmFycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpID09PSAnb2JqZWN0JztcbiAgfSxcbiAgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZShwKSB7XG4gICAgcmV0dXJuIHAgJiYgaXMuZnVuYyhwLnRoZW4pO1xuICB9LFxuICBpdGVyYXRvcjogZnVuY3Rpb24gaXRlcmF0b3IoaXQpIHtcbiAgICByZXR1cm4gaXQgJiYgaXMuZnVuYyhpdC5uZXh0KSAmJiBpcy5mdW5jKGl0LnRocm93KTtcbiAgfSxcbiAgaXRlcmFibGU6IGZ1bmN0aW9uIGl0ZXJhYmxlKGl0KSB7XG4gICAgcmV0dXJuIGl0ICYmIGlzLmZ1bmMoU3ltYm9sKSA/IGlzLmZ1bmMoaXRbU3ltYm9sLml0ZXJhdG9yXSkgOiBpcy5hcnJheShpdCk7XG4gIH0sXG4gIHRhc2s6IGZ1bmN0aW9uIHRhc2sodCkge1xuICAgIHJldHVybiB0ICYmIHRbVEFTS107XG4gIH0sXG4gIG9ic2VydmFibGU6IGZ1bmN0aW9uIG9ic2VydmFibGUob2IpIHtcbiAgICByZXR1cm4gb2IgJiYgaXMuZnVuYyhvYi5zdWJzY3JpYmUpO1xuICB9LFxuICBidWZmZXI6IGZ1bmN0aW9uIGJ1ZmZlcihidWYpIHtcbiAgICByZXR1cm4gYnVmICYmIGlzLmZ1bmMoYnVmLmlzRW1wdHkpICYmIGlzLmZ1bmMoYnVmLnRha2UpICYmIGlzLmZ1bmMoYnVmLnB1dCk7XG4gIH0sXG4gIHBhdHRlcm46IGZ1bmN0aW9uIHBhdHRlcm4ocGF0KSB7XG4gICAgcmV0dXJuIHBhdCAmJiAoaXMuc3RyaW5nKHBhdCkgfHwgKHR5cGVvZiBwYXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdCkpID09PSAnc3ltYm9sJyB8fCBpcy5mdW5jKHBhdCkgfHwgaXMuYXJyYXkocGF0KSk7XG4gIH0sXG4gIGNoYW5uZWw6IGZ1bmN0aW9uIGNoYW5uZWwoY2gpIHtcbiAgICByZXR1cm4gY2ggJiYgaXMuZnVuYyhjaC50YWtlKSAmJiBpcy5mdW5jKGNoLmNsb3NlKTtcbiAgfSxcbiAgaGVscGVyOiBmdW5jdGlvbiBoZWxwZXIoaXQpIHtcbiAgICByZXR1cm4gaXQgJiYgaXRbSEVMUEVSXTtcbiAgfSxcbiAgc3RyaW5nYWJsZUZ1bmM6IGZ1bmN0aW9uIHN0cmluZ2FibGVGdW5jKGYpIHtcbiAgICByZXR1cm4gaXMuZnVuYyhmKSAmJiBoYXNPd24oZiwgJ3RvU3RyaW5nJyk7XG4gIH1cbn07XG5cbmV4cG9ydCB2YXIgb2JqZWN0ID0ge1xuICBhc3NpZ246IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIGkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaGFzT3duKHNvdXJjZSwgaSkpIHtcbiAgICAgICAgdGFyZ2V0W2ldID0gc291cmNlW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaXRlbSkge1xuICB2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn1cblxuZXhwb3J0IHZhciBhcnJheSA9IHtcbiAgJ2Zyb20nOiBmdW5jdGlvbiBmcm9tKG9iaikge1xuICAgIHZhciBhcnIgPSBBcnJheShvYmoubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgaWYgKGhhc093bihvYmosIGkpKSB7XG4gICAgICAgIGFycltpXSA9IG9ialtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmVycmVkKCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBkZWYgPSBfZXh0ZW5kcyh7fSwgcHJvcHMpO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBkZWYucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgZGVmLnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG4gIGRlZi5wcm9taXNlID0gcHJvbWlzZTtcbiAgcmV0dXJuIGRlZjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5T2ZEZWZmZXJlZChsZW5ndGgpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyLnB1c2goZGVmZXJyZWQoKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5KG1zKSB7XG4gIHZhciB2YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgdmFyIHRpbWVvdXRJZCA9IHZvaWQgMDtcbiAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmUodmFsKTtcbiAgICB9LCBtcyk7XG4gIH0pO1xuXG4gIHByb21pc2VbQ0FOQ0VMXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNb2NrVGFzaygpIHtcbiAgdmFyIF9yZWY7XG5cbiAgdmFyIHJ1bm5pbmcgPSB0cnVlO1xuICB2YXIgX3Jlc3VsdCA9IHZvaWQgMCxcbiAgICAgIF9lcnJvciA9IHZvaWQgMDtcblxuICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW1RBU0tdID0gdHJ1ZSwgX3JlZi5pc1J1bm5pbmcgPSBmdW5jdGlvbiBpc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIHJ1bm5pbmc7XG4gIH0sIF9yZWYucmVzdWx0ID0gZnVuY3Rpb24gcmVzdWx0KCkge1xuICAgIHJldHVybiBfcmVzdWx0O1xuICB9LCBfcmVmLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgcmV0dXJuIF9lcnJvcjtcbiAgfSwgX3JlZi5zZXRSdW5uaW5nID0gZnVuY3Rpb24gc2V0UnVubmluZyhiKSB7XG4gICAgcmV0dXJuIHJ1bm5pbmcgPSBiO1xuICB9LCBfcmVmLnNldFJlc3VsdCA9IGZ1bmN0aW9uIHNldFJlc3VsdChyKSB7XG4gICAgcmV0dXJuIF9yZXN1bHQgPSByO1xuICB9LCBfcmVmLnNldEVycm9yID0gZnVuY3Rpb24gc2V0RXJyb3IoZSkge1xuICAgIHJldHVybiBfZXJyb3IgPSBlO1xuICB9LCBfcmVmO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXV0b0luYygpIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKytzZWVkO1xuICB9O1xufVxuXG5leHBvcnQgdmFyIHVpZCA9IGF1dG9JbmMoKTtcblxudmFyIGtUaHJvdyA9IGZ1bmN0aW9uIGtUaHJvdyhlcnIpIHtcbiAgdGhyb3cgZXJyO1xufTtcbnZhciBrUmV0dXJuID0gZnVuY3Rpb24ga1JldHVybih2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IHRydWUgfTtcbn07XG5leHBvcnQgZnVuY3Rpb24gbWFrZUl0ZXJhdG9yKG5leHQpIHtcbiAgdmFyIHRocm8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGtUaHJvdztcbiAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuICB2YXIgaXNIZWxwZXIgPSBhcmd1bWVudHNbM107XG5cbiAgdmFyIGl0ZXJhdG9yID0geyBuYW1lOiBuYW1lLCBuZXh0OiBuZXh0LCB0aHJvdzogdGhybywgcmV0dXJuOiBrUmV0dXJuIH07XG5cbiAgaWYgKGlzSGVscGVyKSB7XG4gICAgaXRlcmF0b3JbSEVMUEVSXSA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9O1xuICB9XG4gIHJldHVybiBpdGVyYXRvcjtcbn1cblxuLyoqXG4gIFByaW50IGVycm9yIGluIGEgdXNlZnVsIHdheSB3aGV0aGVyIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuICAod2l0aCBleHBhbmRhYmxlIGVycm9yIHN0YWNrIHRyYWNlcyksIG9yIGluIGEgbm9kZS5qcyBlbnZpcm9ubWVudFxuICAodGV4dC1vbmx5IGxvZyBvdXRwdXQpXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gbG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gIHZhciBlcnJvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJyc7XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5sb2coJ3JlZHV4LXNhZ2EgJyArIGxldmVsICsgJzogJyArIG1lc3NhZ2UgKyAnXFxuJyArIChlcnJvciAmJiBlcnJvci5zdGFjayB8fCBlcnJvcikpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGVbbGV2ZWxdKG1lc3NhZ2UsIGVycm9yKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBkZXByZWNhdGlvbldhcm5pbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIGxvZygnd2FybicsIGRlcHJlY2F0aW9uV2FybmluZyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IHZhciB1cGRhdGVJbmNlbnRpdmUgPSBmdW5jdGlvbiB1cGRhdGVJbmNlbnRpdmUoZGVwcmVjYXRlZCwgcHJlZmVycmVkKSB7XG4gIHJldHVybiBkZXByZWNhdGVkICsgJyBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mICcgKyBwcmVmZXJyZWQgKyAnLCBwbGVhc2UgdXBkYXRlIHlvdXIgY29kZSc7XG59O1xuXG5leHBvcnQgdmFyIGludGVybmFsRXJyID0gZnVuY3Rpb24gaW50ZXJuYWxFcnIoZXJyKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ1xcbiAgcmVkdXgtc2FnYTogRXJyb3IgY2hlY2tpbmcgaG9va3MgZGV0ZWN0ZWQgYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBUaGlzIGlzIGxpa2VseSBhIGJ1Z1xcbiAgaW4gcmVkdXgtc2FnYSBjb2RlIGFuZCBub3QgeW91cnMuIFRoYW5rcyBmb3IgcmVwb3J0aW5nIHRoaXMgaW4gdGhlIHByb2plY3RcXCdzIGdpdGh1YiByZXBvLlxcbiAgRXJyb3I6ICcgKyBlcnIgKyAnXFxuJyk7XG59O1xuXG5leHBvcnQgdmFyIGNyZWF0ZVNldENvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gY3JlYXRlU2V0Q29udGV4dFdhcm5pbmcoY3R4LCBwcm9wcykge1xuICByZXR1cm4gKGN0eCA/IGN0eCArICcuJyA6ICcnKSArICdzZXRDb250ZXh0KHByb3BzKTogYXJndW1lbnQgJyArIHByb3BzICsgJyBpcyBub3QgYSBwbGFpbiBvYmplY3QnO1xufTtcblxuZXhwb3J0IHZhciB3cmFwU2FnYURpc3BhdGNoID0gZnVuY3Rpb24gd3JhcFNhZ2FEaXNwYXRjaChkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgIHJldHVybiBkaXNwYXRjaChPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aW9uLCBTQUdBX0FDVElPTiwgeyB2YWx1ZTogdHJ1ZSB9KSk7XG4gIH07XG59O1xuXG5leHBvcnQgdmFyIGNsb25lYWJsZUdlbmVyYXRvciA9IGZ1bmN0aW9uIGNsb25lYWJsZUdlbmVyYXRvcihnZW5lcmF0b3JGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGhpc3RvcnkgPSBbXTtcbiAgICB2YXIgZ2VuID0gZ2VuZXJhdG9yRnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KGFyZykge1xuICAgICAgICBoaXN0b3J5LnB1c2goYXJnKTtcbiAgICAgICAgcmV0dXJuIGdlbi5uZXh0KGFyZyk7XG4gICAgICB9LFxuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICB2YXIgY2xvbmVkR2VuID0gY2xvbmVhYmxlR2VuZXJhdG9yKGdlbmVyYXRvckZ1bmMpLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgIGhpc3RvcnkuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lZEdlbi5uZXh0KGFyZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvbmVkR2VuO1xuICAgICAgfSxcbiAgICAgIHJldHVybjogZnVuY3Rpb24gX3JldHVybih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2VuLnJldHVybih2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdGhyb3c6IGZ1bmN0aW9uIF90aHJvdyhleGNlcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIGdlbi50aHJvdyhleGNlcHRpb24pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVkdXgtc2FnYS9lcy9pbnRlcm5hbC91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHRoZXNlIGhhdmUgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIGRlbGV0ZSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGRlbGV0ZSB0aGlzLnByZXZlbnREZWZhdWx0O1xuICAgIGRlbGV0ZSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gJyArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcblxuICBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2xhc3MsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG59O1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oU3ludGhldGljRXZlbnQsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICAqXG4gICogQHBhcmFtIHtvYmplY3R9IFN5bnRoZXRpY0V2ZW50XG4gICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAgKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgc2VlaW5nIHRoaXMsICcgKyAneW91XFwncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiAnICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpIDogdm9pZCAwO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0V2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSBcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc0OCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzUwJywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuICBST09UX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdHJvb3QnLFxuXG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIsXG4gIEFUVFJJQlVURV9OQU1FX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICpcbiAgICogYXV0b2ZvY3VzIGlzIHByZWRlZmluZWQsIGJlY2F1c2UgYWRkaW5nIGl0IHRvIHRoZSBwcm9wZXJ0eSB3aGl0ZWxpc3RcbiAgICogY2F1c2VzIHVuaW50ZW5kZWQgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7IGF1dG9mb2N1czogJ2F1dG9Gb2N1cycgfSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogX3Byb2RJbnZhcmlhbnQoJzI1JykgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIC8vIENhc3RpbmcgYXMgYW55IHNvIHRoYXQgZmxvdyBpZ25vcmVzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gYW5kIHRydXN0c1xuICAvLyBpdCB0byBtYXRjaCB0aGUgdHlwZSB3ZSBkZWNsYXJlZFxuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1Bvb2xlZENsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZmFjdG9yeVxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgLy8gRXhwb3NlIHRoZSB0eXBlIG9uIHRoZSBmYWN0b3J5IGFuZCB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gIC8vIHRoYXQgY3JlYXRlZCB0aGUgZWxlbWVudCwgYW5kIGl0IG1heSBub3QgZXZlbiBiZSBhIGNvbnN0cnVjdG9yLlxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5ID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jbG9uZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5pc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbmZ1bmN0aW9uIHJlYWN0UHJvZEludmFyaWFudChjb2RlKSB7XG4gIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXG4gIHZhciBtZXNzYWdlID0gJ01pbmlmaWVkIFJlYWN0IGVycm9yICMnICsgY29kZSArICc7IHZpc2l0ICcgKyAnaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9JyArIGNvZGU7XG5cbiAgZm9yICh2YXIgYXJnSWR4ID0gMDsgYXJnSWR4IDwgYXJnQ291bnQ7IGFyZ0lkeCsrKSB7XG4gICAgbWVzc2FnZSArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1thcmdJZHggKyAxXSk7XG4gIH1cblxuICBtZXNzYWdlICs9ICcgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50JyArICcgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJztcblxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCByZWFjdFByb2RJbnZhcmlhbnQncyBvd24gZnJhbWVcblxuICB0aHJvdyBlcnJvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdFByb2RJbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbi8qKlxuICogSW4gSUUgKDgtMTEpIGFuZCBFZGdlLCBhcHBlbmRpbmcgbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBpcyBkcmFtYXRpY2FsbHlcbiAqIGZhc3RlciB0aGFuIGFwcGVuZGluZyBhIGZ1bGwgc3VidHJlZSwgc28gd2UgZXNzZW50aWFsbHkgcXVldWUgdXAgdGhlXG4gKiAuYXBwZW5kQ2hpbGQgY2FsbHMgaGVyZSBhbmQgYXBwbHkgdGhlbSBzbyBlYWNoIG5vZGUgaXMgYWRkZWQgdG8gaXRzIHBhcmVudFxuICogYmVmb3JlIGFueSBjaGlsZHJlbiBhcmUgYWRkZWQuXG4gKlxuICogSW4gb3RoZXIgYnJvd3NlcnMsIGRvaW5nIHNvIGlzIHNsb3dlciBvciBuZXV0cmFsIGNvbXBhcmVkIHRvIHRoZSBvdGhlciBvcmRlclxuICogKGluIEZpcmVmb3gsIHR3aWNlIGFzIHNsb3cpIHNvIHdlIG9ubHkgZG8gdGhpcyBpbnZlcnNpb24gaW4gSUUuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zcGljeWovaW5uZXJodG1sLXZzLWNyZWF0ZWVsZW1lbnQtdnMtY2xvbmVub2RlLlxuICovXG52YXIgZW5hYmxlTGF6eSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnICYmIC9cXGJFZGdlXFwvXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5mdW5jdGlvbiBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSkge1xuICBpZiAoIWVuYWJsZUxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5vZGUgPSB0cmVlLm5vZGU7XG4gIHZhciBjaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnNlcnRUcmVlQmVmb3JlKG5vZGUsIGNoaWxkcmVuW2ldLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHJlZS5odG1sICE9IG51bGwpIHtcbiAgICBzZXRJbm5lckhUTUwobm9kZSwgdHJlZS5odG1sKTtcbiAgfSBlbHNlIGlmICh0cmVlLnRleHQgIT0gbnVsbCkge1xuICAgIHNldFRleHRDb250ZW50KG5vZGUsIHRyZWUudGV4dCk7XG4gIH1cbn1cblxudmFyIGluc2VydFRyZWVCZWZvcmUgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChwYXJlbnROb2RlLCB0cmVlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZW4ndCBhY3R1YWxseSBwYXJ0IG9mIHRoZSBET00gYWZ0ZXIgaW5zZXJ0aW9uIHNvXG4gIC8vIGFwcGVuZGluZyBjaGlsZHJlbiB3b24ndCB1cGRhdGUgdGhlIERPTS4gV2UgbmVlZCB0byBlbnN1cmUgdGhlIGZyYWdtZW50XG4gIC8vIGlzIHByb3Blcmx5IHBvcHVsYXRlZCBmaXJzdCwgYnJlYWtpbmcgb3V0IG9mIG91ciBsYXp5IGFwcHJvYWNoIGZvciBqdXN0XG4gIC8vIHRoaXMgbGV2ZWwuIEFsc28sIHNvbWUgPG9iamVjdD4gcGx1Z2lucyAobGlrZSBGbGFzaCBQbGF5ZXIpIHdpbGwgcmVhZFxuICAvLyA8cGFyYW0+IG5vZGVzIGltbWVkaWF0ZWx5IHVwb24gaW5zZXJ0aW9uIGludG8gdGhlIERPTSwgc28gPG9iamVjdD5cbiAgLy8gbXVzdCBhbHNvIGJlIHBvcHVsYXRlZCBwcmlvciB0byBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICBpZiAodHJlZS5ub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgfHwgdHJlZS5ub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSAmJiB0cmVlLm5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgJiYgKHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCB0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpKSB7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiByZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGROb2RlLCBuZXdUcmVlKSB7XG4gIG9sZE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3VHJlZS5ub2RlLCBvbGROb2RlKTtcbiAgaW5zZXJ0VHJlZUNoaWxkcmVuKG5ld1RyZWUpO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUNoaWxkKHBhcmVudFRyZWUsIGNoaWxkVHJlZSkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHBhcmVudFRyZWUuY2hpbGRyZW4ucHVzaChjaGlsZFRyZWUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudFRyZWUubm9kZS5hcHBlbmRDaGlsZChjaGlsZFRyZWUubm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWVIVE1MKHRyZWUsIGh0bWwpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICB0cmVlLmh0bWwgPSBodG1sO1xuICB9IGVsc2Uge1xuICAgIHNldElubmVySFRNTCh0cmVlLm5vZGUsIGh0bWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlVGV4dCh0cmVlLCB0ZXh0KSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS50ZXh0ID0gdGV4dDtcbiAgfSBlbHNlIHtcbiAgICBzZXRUZXh0Q29udGVudCh0cmVlLm5vZGUsIHRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5ub2RlLm5vZGVOYW1lO1xufVxuXG5mdW5jdGlvbiBET01MYXp5VHJlZShub2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgaHRtbDogbnVsbCxcbiAgICB0ZXh0OiBudWxsLFxuICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICB9O1xufVxuXG5ET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlID0gaW5zZXJ0VHJlZUJlZm9yZTtcbkRPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlID0gcmVwbGFjZUNoaWxkV2l0aFRyZWU7XG5ET01MYXp5VHJlZS5xdWV1ZUNoaWxkID0gcXVldWVDaGlsZDtcbkRPTUxhenlUcmVlLnF1ZXVlSFRNTCA9IHF1ZXVlSFRNTDtcbkRPTUxhenlUcmVlLnF1ZXVlVGV4dCA9IHF1ZXVlVGV4dDtcblxubW9kdWxlLmV4cG9ydHMgPSBET01MYXp5VHJlZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvRE9NTGF6eVRyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoJy4vUmVhY3RSZWYnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNhbGwgUmVhY3RSZWYuYXR0YWNoUmVmcyB3aXRoIHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCwgc3BsaXQgb3V0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFJlZnMoKSB7XG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdGhlIGNvbnRhaW5pbmcgaG9zdCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgcGFyZW50RGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudCh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvXG4gICAqIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwLlxuICAgKi9cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2UuZ2V0SG9zdE5vZGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHNhZmVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoc2FmZWx5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBuZXh0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcikge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciAhPT0gdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQncyBlbnF1ZXVlZCBiYXRjaCBudW1iZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgY3VycmVudFxuICAgICAgLy8gYmF0Y2ggb3IgdGhlIGZvbGxvd2luZyBvbmUuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsIHx8IGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09PSB1cGRhdGVCYXRjaE51bWJlciArIDEsICdwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IFVuZXhwZWN0ZWQgYmF0Y2ggbnVtYmVyIChjdXJyZW50ICVzLCAnICsgJ3BlbmRpbmcgJXMpJywgdXBkYXRlQmF0Y2hOdW1iZXIsIGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGludGVybmFsSW5zdGFuY2UucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFB1cmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0UHVyZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIHZhciBkaWRXYXJuUHJvcFR5cGVzRGVwcmVjYXRlZCA9IGZhbHNlO1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIF9fc3ByZWFkID0gX2Fzc2lnbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh3YXJuZWQsICdSZWFjdC5fX3NwcmVhZCBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuIFVzZSAnICsgJ09iamVjdC5hc3NpZ24gZGlyZWN0bHkgb3IgYW5vdGhlciBoZWxwZXIgZnVuY3Rpb24gd2l0aCBzaW1pbGFyICcgKyAnc2VtYW50aWNzLiBZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIHlvdXIgY29tcGlsZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtc3ByZWFkLWRlcHJlY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG4gICAgd2FybmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gX2Fzc2lnbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgUmVhY3QgPSB7XG5cbiAgLy8gTW9kZXJuXG5cbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuLnRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUmVhY3RQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIERlcHJlY2F0ZWQgaG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nLlxuICBfX3NwcmVhZDogX19zcHJlYWRcbn07XG5cbi8vIFRPRE86IEZpeCB0ZXN0cyBzbyB0aGF0IHRoaXMgZGVwcmVjYXRpb24gd2FybmluZyBkb2Vzbid0IGNhdXNlIGZhaWx1cmVzLlxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0LCAnUHJvcFR5cGVzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5Qcm9wVHlwZXNEZXByZWNhdGVkLCAnQWNjZXNzaW5nIFByb3BUeXBlcyB2aWEgdGhlIG1haW4gUmVhY3QgcGFja2FnZSBpcyBkZXByZWNhdGVkLiBVc2UgJyArICd0aGUgcHJvcC10eXBlcyBwYWNrYWdlIGZyb20gbnBtIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5Qcm9wVHlwZXNEZXByZWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9saWIvUmVhY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9yZWFjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdG9yZSBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxudmFyIGdldERpY3Rpb25hcnlLZXkgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn07XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxuZnVuY3Rpb24gc2hvdWxkUHJldmVudE1vdXNlRXZlbnQobmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnb25DbGljayc6XG4gICAgY2FzZSAnb25DbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2snOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bic6XG4gICAgY2FzZSAnb25Nb3VzZURvd25DYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmVDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlVXAnOlxuICAgIGNhc2UgJ29uTW91c2VVcENhcHR1cmUnOlxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG5cbiAgfSxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldYC4gSXMgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgISh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkICVzIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IHR5cGUgJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogX3Byb2RJbnZhcmlhbnQoJzk0JywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcblxuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSB8fCAobGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdID0ge30pO1xuICAgIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gICAqL1xuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAgIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC5fY3VycmVudEVsZW1lbnQudHlwZSwgaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHMpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgcmV0dXJuIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lICYmIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBsaXN0ZW5lciBmcm9tIHRoZSByZWdpc3RyYXRpb24gYmFuay5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKi9cbiAgZGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIGRlbGV0ZSBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiBsaXN0ZW5lckJhbmspIHtcbiAgICAgIGlmICghbGlzdGVuZXJCYW5rLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgICBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gICAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICAgKiBgcHJvY2Vzc0V2ZW50UXVldWVgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVFdmVudHM6IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NFdmVudFF1ZXVlOiBmdW5jdGlvbiAoc2ltdWxhdGVkKSB7XG4gICAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAgIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICAgIGV2ZW50UXVldWUgPSBudWxsO1xuICAgIGlmIChzaW11bGF0ZWQpIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XG4gICAgfVxuICAgICEhZXZlbnRRdWV1ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5NScpIDogdm9pZCAwO1xuICAgIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICAgIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlc2UgYXJlIG5lZWRlZCBmb3IgdGVzdHMgb25seS4gRG8gbm90IHVzZSFcbiAgICovXG4gIF9fcHVyZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICBsaXN0ZW5lckJhbmsgPSB7fTtcbiAgfSxcblxuICBfX2dldExpc3RlbmVyQmFuazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsaXN0ZW5lckJhbms7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpbkh1YjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5IdWIuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gRXZlbnRQbHVnaW5VdGlscy5nZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0SW5zdGFuY2VNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1VJRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5NicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTcnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gcGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5OCcsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTknLCBldmVudE5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIHJlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwMCcsIHJlZ2lzdHJhdGlvbk5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG5cbiAgLyoqXG4gICAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICAgKi9cbiAgcGx1Z2luczogW10sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICAgKi9cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAgICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICAgKiBvbmx5IGluIF9fREVWX18uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuICAvLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgaW4gX19ERVZfX1xuXG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uIChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAhIWV2ZW50UGx1Z2luT3JkZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDEnKSA6IHZvaWQgMDtcbiAgICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gICAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gICAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gICAqXG4gICAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGZ1bmN0aW9uIChpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBwbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IHR3byBkaWZmZXJlbnQgZXZlbnQgcGx1Z2lucyB1c2luZyB0aGUgc2FtZSBuYW1lLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwMicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvb2tzIHVwIHRoZSBwbHVnaW4gZm9yIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEEgc3ludGhldGljIGV2ZW50LlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBUaGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnO1xuICAgIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICByZXR1cm4gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lXSB8fCBudWxsO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcHVsbGluZyBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyBvdXQgb2YgZGlzcGF0Y2hDb25maWcgaGVscHMgRmxvdyBzZWVcbiAgICAgIC8vIHRoYXQgaXQgaXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBmb3IgKHZhciBwaGFzZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgICBpZiAoIXBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlXV07XG4gICAgICAgIGlmIChwbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm4gcGx1Z2luTW9kdWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRFdmVudFBsdWdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudFBsdWdpbk9yZGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAobmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnMubGVuZ3RoID0gMDtcblxuICAgIHZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcykge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG4gICAgICBmb3IgKHZhciBsb3dlckNhc2VkTmFtZSBpbiBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICAgIGlmIChwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgICAgIGRlbGV0ZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luUmVnaXN0cnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgPSByZXF1aXJlKCcuL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGhhc0V2ZW50UGFnZVhZO1xudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSB8fCAnYW5pbWF0aW9uc3RhcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpIHx8ICd0cmFuc2l0aW9uZW5kJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBfYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEJsdXInLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BCbHVyID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJvdGVjdCBhZ2FpbnN0IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkgcmV0dXJuaW5nIG51bGxcbiAgICogU29tZSBwb3B1cCBibG9ja2VyIGV4dGVuc2lvbnMgYXBwZWFyIHRvIGRvIHRoaXM6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjg4N1xuICAgKi9cbiAgc3VwcG9ydHNFdmVudFBhZ2VYWTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICByZXR1cm4gZXYgIT0gbnVsbCAmJiAncGFnZVgnIGluIGV2O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc3VwcG9ydHNFdmVudFBhZ2VYWSgpO1xuICAgIH1cbiAgICBpZiAoIWhhc0V2ZW50UGFnZVhZICYmICFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWScgaW4gZXZlbnQgPyBldmVudC5wYWdlWSA6IGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljTW91c2VFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBPQlNFUlZFRF9FUlJPUiA9IHt9O1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwZGF0ZXMuXG4gKlxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxuICogLSBBIG1vZHVsZSB0aGF0IGhhcyBhbiBgaW5pdGlhbGl6ZWAgbWV0aG9kIHRoYXQgcmV0dXJucyBhbnkgcHJlY29tcHV0YXRpb24uXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gU2luZ2xlIHRyYW5zYWN0aW9uIGZvciByZXVzZSBpbiB0aHJlYWQuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKi9cbnZhciBUcmFuc2FjdGlvbkltcGwgPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGEgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGQgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAhIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24ucGVyZm9ybSguLi4pOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgaXMgYWxyZWFkeSBhbiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyNycpIDogdm9pZCAwO1xuICAgIHZhciBlcnJvclRocm93bjtcbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgIC8vIG9uZSBvZiB0aGVzZSBjYWxscyB0aHJldy5cbiAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbCgwKTtcbiAgICAgIHJldCA9IG1ldGhvZC5jYWxsKHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIElmIGBtZXRob2RgIHRocm93cywgcHJlZmVyIHRvIHNob3cgdGhhdCBzdGFjayB0cmFjZSBvdmVyIGFueSB0aHJvd25cbiAgICAgICAgICAvLyBieSBpbnZva2luZyBgY2xvc2VBbGxgLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW5jZSBgbWV0aG9kYCBkaWRuJ3QgdGhyb3csIHdlIGRvbid0IHdhbnQgdG8gc2lsZW5jZSB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBpbml0aWFsaXplQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aCB0aGVcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcbiAgICAgICAgLy8gYmxvY2ssIGl0IG1lYW5zIHdyYXBwZXIuaW5pdGlhbGl6ZSB0aHJldy5cbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBPQlNFUlZFRF9FUlJPUjtcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgPyB3cmFwcGVyLmluaXRpYWxpemUuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGFbaV0gPT09IE9CU0VSVkVEX0VSUk9SKSB7XG4gICAgICAgICAgLy8gVGhlIGluaXRpYWxpemVyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGluaXRpYWxpemUgdGhlXG4gICAgICAgICAgLy8gcmVtYWluaW5nIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmVcbiAgICAgICAgICAvLyB0aGF0IHRoZSBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgZWFjaCBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmNsb3NlW2ldYCBmdW5jdGlvbnMsIHBhc3NpbmcgaW50b1xuICAgKiB0aGVtIHRoZSByZXNwZWN0aXZlIHJldHVybiB2YWx1ZXMgb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5pbml0W2ldYFxuICAgKiAoYGNsb3NlYHJzIHRoYXQgY29ycmVzcG9uZCB0byBpbml0aWFsaXplcnMgdGhhdCBmYWlsZWQgd2lsbCBub3QgYmVcbiAgICogaW52b2tlZCkuXG4gICAqL1xuICBjbG9zZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICAhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzI4JykgOiB2b2lkIDA7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLndyYXBwZXJJbml0RGF0YVtpXTtcbiAgICAgIHZhciBlcnJvclRocm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgICAvLyB3cmFwcGVyLmNsb3NlIHRocmV3LlxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gT0JTRVJWRURfRVJST1IgJiYgd3JhcHBlci5jbG9zZSkge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UuY2FsbCh0aGlzLCBpbml0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xuICAgICAgICAgIC8vIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uSW1wbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvVHJhbnNhY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEJhc2VkIG9uIHRoZSBlc2NhcGUtaHRtbCBsaWJyYXJ5LCB3aGljaCBpcyB1c2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBiZWxvdzpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0IChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG5cbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lcjtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAvLyB0aGUgdGFyZ2V0IG5vZGVcbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgLy8gaW4gaG9wZXMgdGhhdCB0aGlzIGlzIHByZXNlcnZlZCBldmVuIGlmIFwiXFx1RkVGRlwiIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxuICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSArIGh0bWw7XG5cbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcbiAgICAgICAgLy8gY2hpbGRyZW4uIERlZmluaXRlbHkgd2FudCB0byBhdm9pZCB0aGlzLlxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL3NldElubmVySFRNTC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBrVHJ1ZSwgbm9vcCB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgdmFyIEJVRkZFUl9PVkVSRkxPVyA9ICdDaGFubmVsXFwncyBCdWZmZXIgb3ZlcmZsb3chJztcblxudmFyIE9OX09WRVJGTE9XX1RIUk9XID0gMTtcbnZhciBPTl9PVkVSRkxPV19EUk9QID0gMjtcbnZhciBPTl9PVkVSRkxPV19TTElERSA9IDM7XG52YXIgT05fT1ZFUkZMT1dfRVhQQU5EID0gNDtcblxudmFyIHplcm9CdWZmZXIgPSB7IGlzRW1wdHk6IGtUcnVlLCBwdXQ6IG5vb3AsIHRha2U6IG5vb3AgfTtcblxuZnVuY3Rpb24gcmluZ0J1ZmZlcigpIHtcbiAgdmFyIGxpbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxMDtcbiAgdmFyIG92ZXJmbG93QWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gIHZhciBhcnIgPSBuZXcgQXJyYXkobGltaXQpO1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHB1c2hJbmRleCA9IDA7XG4gIHZhciBwb3BJbmRleCA9IDA7XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGl0KSB7XG4gICAgYXJyW3B1c2hJbmRleF0gPSBpdDtcbiAgICBwdXNoSW5kZXggPSAocHVzaEluZGV4ICsgMSkgJSBsaW1pdDtcbiAgICBsZW5ndGgrKztcbiAgfTtcblxuICB2YXIgdGFrZSA9IGZ1bmN0aW9uIHRha2UoKSB7XG4gICAgaWYgKGxlbmd0aCAhPSAwKSB7XG4gICAgICB2YXIgaXQgPSBhcnJbcG9wSW5kZXhdO1xuICAgICAgYXJyW3BvcEluZGV4XSA9IG51bGw7XG4gICAgICBsZW5ndGgtLTtcbiAgICAgIHBvcEluZGV4ID0gKHBvcEluZGV4ICsgMSkgJSBsaW1pdDtcbiAgICAgIHJldHVybiBpdDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgd2hpbGUgKGxlbmd0aCkge1xuICAgICAgaXRlbXMucHVzaCh0YWtlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIGxlbmd0aCA9PSAwO1xuICAgIH0sXG4gICAgcHV0OiBmdW5jdGlvbiBwdXQoaXQpIHtcbiAgICAgIGlmIChsZW5ndGggPCBsaW1pdCkge1xuICAgICAgICBwdXNoKGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkb3VibGVkTGltaXQgPSB2b2lkIDA7XG4gICAgICAgIHN3aXRjaCAob3ZlcmZsb3dBY3Rpb24pIHtcbiAgICAgICAgICBjYXNlIE9OX09WRVJGTE9XX1RIUk9XOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEJVRkZFUl9PVkVSRkxPVyk7XG4gICAgICAgICAgY2FzZSBPTl9PVkVSRkxPV19TTElERTpcbiAgICAgICAgICAgIGFycltwdXNoSW5kZXhdID0gaXQ7XG4gICAgICAgICAgICBwdXNoSW5kZXggPSAocHVzaEluZGV4ICsgMSkgJSBsaW1pdDtcbiAgICAgICAgICAgIHBvcEluZGV4ID0gcHVzaEluZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBPTl9PVkVSRkxPV19FWFBBTkQ6XG4gICAgICAgICAgICBkb3VibGVkTGltaXQgPSAyICogbGltaXQ7XG5cbiAgICAgICAgICAgIGFyciA9IGZsdXNoKCk7XG5cbiAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICBwdXNoSW5kZXggPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgcG9wSW5kZXggPSAwO1xuXG4gICAgICAgICAgICBhcnIubGVuZ3RoID0gZG91YmxlZExpbWl0O1xuICAgICAgICAgICAgbGltaXQgPSBkb3VibGVkTGltaXQ7XG5cbiAgICAgICAgICAgIHB1c2goaXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBEUk9QXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHRha2U6IHRha2UsIGZsdXNoOiBmbHVzaFxuICB9O1xufVxuXG5leHBvcnQgdmFyIGJ1ZmZlcnMgPSB7XG4gIG5vbmU6IGZ1bmN0aW9uIG5vbmUoKSB7XG4gICAgcmV0dXJuIHplcm9CdWZmZXI7XG4gIH0sXG4gIGZpeGVkOiBmdW5jdGlvbiBmaXhlZChsaW1pdCkge1xuICAgIHJldHVybiByaW5nQnVmZmVyKGxpbWl0LCBPTl9PVkVSRkxPV19USFJPVyk7XG4gIH0sXG4gIGRyb3BwaW5nOiBmdW5jdGlvbiBkcm9wcGluZyhsaW1pdCkge1xuICAgIHJldHVybiByaW5nQnVmZmVyKGxpbWl0LCBPTl9PVkVSRkxPV19EUk9QKTtcbiAgfSxcbiAgc2xpZGluZzogZnVuY3Rpb24gc2xpZGluZyhsaW1pdCkge1xuICAgIHJldHVybiByaW5nQnVmZmVyKGxpbWl0LCBPTl9PVkVSRkxPV19TTElERSk7XG4gIH0sXG4gIGV4cGFuZGluZzogZnVuY3Rpb24gZXhwYW5kaW5nKGluaXRpYWxTaXplKSB7XG4gICAgcmV0dXJuIHJpbmdCdWZmZXIoaW5pdGlhbFNpemUsIE9OX09WRVJGTE9XX0VYUEFORCk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWR1eC1zYWdhL2VzL2ludGVybmFsL2J1ZmZlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB7IGlzLCBjaGVjaywgcmVtb3ZlLCBNQVRDSCwgaW50ZXJuYWxFcnIsIFNBR0FfQUNUSU9OIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBidWZmZXJzIH0gZnJvbSAnLi9idWZmZXJzJztcbmltcG9ydCB7IGFzYXAgfSBmcm9tICcuL3NjaGVkdWxlcic7XG5cbnZhciBDSEFOTkVMX0VORF9UWVBFID0gJ0BAcmVkdXgtc2FnYS9DSEFOTkVMX0VORCc7XG5leHBvcnQgdmFyIEVORCA9IHsgdHlwZTogQ0hBTk5FTF9FTkRfVFlQRSB9O1xuZXhwb3J0IHZhciBpc0VuZCA9IGZ1bmN0aW9uIGlzRW5kKGEpIHtcbiAgcmV0dXJuIGEgJiYgYS50eXBlID09PSBDSEFOTkVMX0VORF9UWVBFO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShzdWIpIHtcbiAgICBzdWJzY3JpYmVycy5wdXNoKHN1Yik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZW1vdmUoc3Vic2NyaWJlcnMsIHN1Yik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXQoaXRlbSkge1xuICAgIHZhciBhcnIgPSBzdWJzY3JpYmVycy5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFycltpXShpdGVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGVtaXQ6IGVtaXRcbiAgfTtcbn1cblxuZXhwb3J0IHZhciBJTlZBTElEX0JVRkZFUiA9ICdpbnZhbGlkIGJ1ZmZlciBwYXNzZWQgdG8gY2hhbm5lbCBmYWN0b3J5IGZ1bmN0aW9uJztcbmV4cG9ydCB2YXIgVU5ERUZJTkVEX0lOUFVUX0VSUk9SID0gJ1NhZ2Egd2FzIHByb3ZpZGVkIHdpdGggYW4gdW5kZWZpbmVkIGFjdGlvbic7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFVOREVGSU5FRF9JTlBVVF9FUlJPUiArPSAnXFxuSGludHM6XFxuICAgIC0gY2hlY2sgdGhhdCB5b3VyIEFjdGlvbiBDcmVhdG9yIHJldHVybnMgYSBub24tdW5kZWZpbmVkIHZhbHVlXFxuICAgIC0gaWYgdGhlIFNhZ2Egd2FzIHN0YXJ0ZWQgdXNpbmcgcnVuU2FnYSwgY2hlY2sgdGhhdCB5b3VyIHN1YnNjcmliZSBzb3VyY2UgcHJvdmlkZXMgdGhlIGFjdGlvbiB0byBpdHMgbGlzdGVuZXJzXFxuICAnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhbm5lbCgpIHtcbiAgdmFyIGJ1ZmZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYnVmZmVycy5maXhlZCgpO1xuXG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgdmFyIHRha2VycyA9IFtdO1xuXG4gIGNoZWNrKGJ1ZmZlciwgaXMuYnVmZmVyLCBJTlZBTElEX0JVRkZFUik7XG5cbiAgZnVuY3Rpb24gY2hlY2tGb3JiaWRkZW5TdGF0ZXMoKSB7XG4gICAgaWYgKGNsb3NlZCAmJiB0YWtlcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBpbnRlcm5hbEVycignQ2Fubm90IGhhdmUgYSBjbG9zZWQgY2hhbm5lbCB3aXRoIHBlbmRpbmcgdGFrZXJzJyk7XG4gICAgfVxuICAgIGlmICh0YWtlcnMubGVuZ3RoICYmICFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgICB0aHJvdyBpbnRlcm5hbEVycignQ2Fubm90IGhhdmUgcGVuZGluZyB0YWtlcnMgd2l0aCBub24gZW1wdHkgYnVmZmVyJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHV0KGlucHV0KSB7XG4gICAgY2hlY2tGb3JiaWRkZW5TdGF0ZXMoKTtcbiAgICBjaGVjayhpbnB1dCwgaXMubm90VW5kZWYsIFVOREVGSU5FRF9JTlBVVF9FUlJPUik7XG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRha2Vycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBidWZmZXIucHV0KGlucHV0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYiA9IHRha2Vyc1tpXTtcbiAgICAgIGlmICghY2JbTUFUQ0hdIHx8IGNiW01BVENIXShpbnB1dCkpIHtcbiAgICAgICAgdGFrZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGNiKGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0YWtlKGNiKSB7XG4gICAgY2hlY2tGb3JiaWRkZW5TdGF0ZXMoKTtcbiAgICBjaGVjayhjYiwgaXMuZnVuYywgJ2NoYW5uZWwudGFrZVxcJ3MgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICBpZiAoY2xvc2VkICYmIGJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICAgIGNiKEVORCk7XG4gICAgfSBlbHNlIGlmICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgICAgY2IoYnVmZmVyLnRha2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRha2Vycy5wdXNoKGNiKTtcbiAgICAgIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSh0YWtlcnMsIGNiKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goY2IpIHtcbiAgICBjaGVja0ZvcmJpZGRlblN0YXRlcygpOyAvLyBUT0RPOiBjaGVjayBpZiBzb21lIG5ldyBzdGF0ZSBzaG91bGQgYmUgZm9yYmlkZGVuIG5vd1xuICAgIGNoZWNrKGNiLCBpcy5mdW5jLCAnY2hhbm5lbC5mbHVzaFxcJyBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICBpZiAoY2xvc2VkICYmIGJ1ZmZlci5pc0VtcHR5KCkpIHtcbiAgICAgIGNiKEVORCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNiKGJ1ZmZlci5mbHVzaCgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGNoZWNrRm9yYmlkZGVuU3RhdGVzKCk7XG4gICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAodGFrZXJzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyID0gdGFrZXJzO1xuICAgICAgICB0YWtlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGFycltpXShFTkQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgdGFrZTogdGFrZSwgcHV0OiBwdXQsIGZsdXNoOiBmbHVzaCwgY2xvc2U6IGNsb3NlLFxuICAgIGdldCBfX3Rha2Vyc19fKCkge1xuICAgICAgcmV0dXJuIHRha2VycztcbiAgICB9LFxuICAgIGdldCBfX2Nsb3NlZF9fKCkge1xuICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmVudENoYW5uZWwoc3Vic2NyaWJlKSB7XG4gIHZhciBidWZmZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGJ1ZmZlcnMubm9uZSgpO1xuICB2YXIgbWF0Y2hlciA9IGFyZ3VtZW50c1syXTtcblxuICAvKipcbiAgICBzaG91bGQgYmUgaWYodHlwZW9mIG1hdGNoZXIgIT09IHVuZGVmaW5lZCkgaW5zdGVhZD9cbiAgICBzZWUgUFIgIzI3MyBmb3IgYSBiYWNrZ3JvdW5kIGRpc2N1c3Npb25cbiAgKiovXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgIGNoZWNrKG1hdGNoZXIsIGlzLmZ1bmMsICdJbnZhbGlkIG1hdGNoIGZ1bmN0aW9uIHBhc3NlZCB0byBldmVudENoYW5uZWwnKTtcbiAgfVxuXG4gIHZhciBjaGFuID0gY2hhbm5lbChidWZmZXIpO1xuICB2YXIgY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoIWNoYW4uX19jbG9zZWRfXykge1xuICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgICBjaGFuLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuICB2YXIgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlzRW5kKGlucHV0KSkge1xuICAgICAgY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoZXIgJiYgIW1hdGNoZXIoaW5wdXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNoYW4ucHV0KGlucHV0KTtcbiAgfSk7XG4gIGlmIChjaGFuLl9fY2xvc2VkX18pIHtcbiAgICB1bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgaWYgKCFpcy5mdW5jKHVuc3Vic2NyaWJlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW4gZXZlbnRDaGFubmVsOiBzdWJzY3JpYmUgc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRha2U6IGNoYW4udGFrZSxcbiAgICBmbHVzaDogY2hhbi5mbHVzaCxcbiAgICBjbG9zZTogY2xvc2VcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZENoYW5uZWwoc3Vic2NyaWJlKSB7XG4gIHZhciBjaGFuID0gZXZlbnRDaGFubmVsKGZ1bmN0aW9uIChjYikge1xuICAgIHJldHVybiBzdWJzY3JpYmUoZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXRbU0FHQV9BQ1RJT05dKSB7XG4gICAgICAgIGNiKGlucHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjYihpbnB1dCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBjaGFuLCB7XG4gICAgdGFrZTogZnVuY3Rpb24gdGFrZShjYiwgbWF0Y2hlcikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNoZWNrKG1hdGNoZXIsIGlzLmZ1bmMsICdjaGFubmVsLnRha2VcXCdzIG1hdGNoZXIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNiW01BVENIXSA9IG1hdGNoZXI7XG4gICAgICB9XG4gICAgICBjaGFuLnRha2UoY2IpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWR1eC1zYWdhL2VzL2ludGVybmFsL2NoYW5uZWwuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IHN5bSwgaXMsIGlkZW50LCBjaGVjaywgZGVwcmVjYXRlLCB1cGRhdGVJbmNlbnRpdmUsIGNyZWF0ZVNldENvbnRleHRXYXJuaW5nLCBTRUxGX0NBTkNFTExBVElPTiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgdGFrZUV2ZXJ5SGVscGVyLCB0YWtlTGF0ZXN0SGVscGVyLCB0aHJvdHRsZUhlbHBlciB9IGZyb20gJy4vc2FnYUhlbHBlcnMnO1xuXG52YXIgSU8gPSBzeW0oJ0lPJyk7XG52YXIgVEFLRSA9ICdUQUtFJztcbnZhciBQVVQgPSAnUFVUJztcbnZhciBBTEwgPSAnQUxMJztcbnZhciBSQUNFID0gJ1JBQ0UnO1xudmFyIENBTEwgPSAnQ0FMTCc7XG52YXIgQ1BTID0gJ0NQUyc7XG52YXIgRk9SSyA9ICdGT1JLJztcbnZhciBKT0lOID0gJ0pPSU4nO1xudmFyIENBTkNFTCA9ICdDQU5DRUwnO1xudmFyIFNFTEVDVCA9ICdTRUxFQ1QnO1xudmFyIEFDVElPTl9DSEFOTkVMID0gJ0FDVElPTl9DSEFOTkVMJztcbnZhciBDQU5DRUxMRUQgPSAnQ0FOQ0VMTEVEJztcbnZhciBGTFVTSCA9ICdGTFVTSCc7XG52YXIgR0VUX0NPTlRFWFQgPSAnR0VUX0NPTlRFWFQnO1xudmFyIFNFVF9DT05URVhUID0gJ1NFVF9DT05URVhUJztcblxudmFyIFRFU1RfSElOVCA9ICdcXG4oSElOVDogaWYgeW91IGFyZSBnZXR0aW5nIHRoaXMgZXJyb3JzIGluIHRlc3RzLCBjb25zaWRlciB1c2luZyBjcmVhdGVNb2NrVGFzayBmcm9tIHJlZHV4LXNhZ2EvdXRpbHMpJztcblxudmFyIGVmZmVjdCA9IGZ1bmN0aW9uIGVmZmVjdCh0eXBlLCBwYXlsb2FkKSB7XG4gIHZhciBfcmVmO1xuXG4gIHJldHVybiBfcmVmID0ge30sIF9yZWZbSU9dID0gdHJ1ZSwgX3JlZlt0eXBlXSA9IHBheWxvYWQsIF9yZWY7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGFrZSgpIHtcbiAgdmFyIHBhdHRlcm5PckNoYW5uZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcqJztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNoZWNrKGFyZ3VtZW50c1swXSwgaXMubm90VW5kZWYsICd0YWtlKHBhdHRlcm5PckNoYW5uZWwpOiBwYXR0ZXJuT3JDaGFubmVsIGlzIHVuZGVmaW5lZCcpO1xuICB9XG4gIGlmIChpcy5wYXR0ZXJuKHBhdHRlcm5PckNoYW5uZWwpKSB7XG4gICAgcmV0dXJuIGVmZmVjdChUQUtFLCB7IHBhdHRlcm46IHBhdHRlcm5PckNoYW5uZWwgfSk7XG4gIH1cbiAgaWYgKGlzLmNoYW5uZWwocGF0dGVybk9yQ2hhbm5lbCkpIHtcbiAgICByZXR1cm4gZWZmZWN0KFRBS0UsIHsgY2hhbm5lbDogcGF0dGVybk9yQ2hhbm5lbCB9KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3Rha2UocGF0dGVybk9yQ2hhbm5lbCk6IGFyZ3VtZW50ICcgKyBTdHJpbmcocGF0dGVybk9yQ2hhbm5lbCkgKyAnIGlzIG5vdCB2YWxpZCBjaGFubmVsIG9yIGEgdmFsaWQgcGF0dGVybicpO1xufVxuXG50YWtlLm1heWJlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWZmID0gdGFrZS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIGVmZltUQUtFXS5tYXliZSA9IHRydWU7XG4gIHJldHVybiBlZmY7XG59O1xuXG5leHBvcnQgdmFyIHRha2VtID0gZGVwcmVjYXRlKHRha2UubWF5YmUsIHVwZGF0ZUluY2VudGl2ZSgndGFrZW0nLCAndGFrZS5tYXliZScpKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHB1dChjaGFubmVsLCBhY3Rpb24pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgY2hlY2soY2hhbm5lbCwgaXMubm90VW5kZWYsICdwdXQoY2hhbm5lbCwgYWN0aW9uKTogYXJndW1lbnQgY2hhbm5lbCBpcyB1bmRlZmluZWQnKTtcbiAgICBjaGVjayhjaGFubmVsLCBpcy5jaGFubmVsLCAncHV0KGNoYW5uZWwsIGFjdGlvbik6IGFyZ3VtZW50ICcgKyBjaGFubmVsICsgJyBpcyBub3QgYSB2YWxpZCBjaGFubmVsJyk7XG4gICAgY2hlY2soYWN0aW9uLCBpcy5ub3RVbmRlZiwgJ3B1dChjaGFubmVsLCBhY3Rpb24pOiBhcmd1bWVudCBhY3Rpb24gaXMgdW5kZWZpbmVkJyk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2soY2hhbm5lbCwgaXMubm90VW5kZWYsICdwdXQoYWN0aW9uKTogYXJndW1lbnQgYWN0aW9uIGlzIHVuZGVmaW5lZCcpO1xuICAgIGFjdGlvbiA9IGNoYW5uZWw7XG4gICAgY2hhbm5lbCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGVmZmVjdChQVVQsIHsgY2hhbm5lbDogY2hhbm5lbCwgYWN0aW9uOiBhY3Rpb24gfSk7XG59XG5cbnB1dC5yZXNvbHZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWZmID0gcHV0LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgZWZmW1BVVF0ucmVzb2x2ZSA9IHRydWU7XG4gIHJldHVybiBlZmY7XG59O1xuXG5wdXQuc3luYyA9IGRlcHJlY2F0ZShwdXQucmVzb2x2ZSwgdXBkYXRlSW5jZW50aXZlKCdwdXQuc3luYycsICdwdXQucmVzb2x2ZScpKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsbChlZmZlY3RzKSB7XG4gIHJldHVybiBlZmZlY3QoQUxMLCBlZmZlY3RzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhY2UoZWZmZWN0cykge1xuICByZXR1cm4gZWZmZWN0KFJBQ0UsIGVmZmVjdHMpO1xufVxuXG5mdW5jdGlvbiBnZXRGbkNhbGxEZXNjKG1ldGgsIGZuLCBhcmdzKSB7XG4gIGNoZWNrKGZuLCBpcy5ub3RVbmRlZiwgbWV0aCArICc6IGFyZ3VtZW50IGZuIGlzIHVuZGVmaW5lZCcpO1xuXG4gIHZhciBjb250ZXh0ID0gbnVsbDtcbiAgaWYgKGlzLmFycmF5KGZuKSkge1xuICAgIHZhciBfZm4gPSBmbjtcbiAgICBjb250ZXh0ID0gX2ZuWzBdO1xuICAgIGZuID0gX2ZuWzFdO1xuICB9IGVsc2UgaWYgKGZuLmZuKSB7XG4gICAgdmFyIF9mbjIgPSBmbjtcbiAgICBjb250ZXh0ID0gX2ZuMi5jb250ZXh0O1xuICAgIGZuID0gX2ZuMi5mbjtcbiAgfVxuICBpZiAoY29udGV4dCAmJiBpcy5zdHJpbmcoZm4pICYmIGlzLmZ1bmMoY29udGV4dFtmbl0pKSB7XG4gICAgZm4gPSBjb250ZXh0W2ZuXTtcbiAgfVxuICBjaGVjayhmbiwgaXMuZnVuYywgbWV0aCArICc6IGFyZ3VtZW50ICcgKyBmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcblxuICByZXR1cm4geyBjb250ZXh0OiBjb250ZXh0LCBmbjogZm4sIGFyZ3M6IGFyZ3MgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZWZmZWN0KENBTEwsIGdldEZuQ2FsbERlc2MoJ2NhbGwnLCBmbiwgYXJncykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkoY29udGV4dCwgZm4pIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXG4gIHJldHVybiBlZmZlY3QoQ0FMTCwgZ2V0Rm5DYWxsRGVzYygnYXBwbHknLCB7IGNvbnRleHQ6IGNvbnRleHQsIGZuOiBmbiB9LCBhcmdzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcHMoZm4pIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICByZXR1cm4gZWZmZWN0KENQUywgZ2V0Rm5DYWxsRGVzYygnY3BzJywgZm4sIGFyZ3MpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcmsoZm4pIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gZWZmZWN0KEZPUkssIGdldEZuQ2FsbERlc2MoJ2ZvcmsnLCBmbiwgYXJncykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Bhd24oZm4pIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICB2YXIgZWZmID0gZm9yay5hcHBseSh1bmRlZmluZWQsIFtmbl0uY29uY2F0KGFyZ3MpKTtcbiAgZWZmW0ZPUktdLmRldGFjaGVkID0gdHJ1ZTtcbiAgcmV0dXJuIGVmZjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpvaW4oKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgdGFza3MgPSBBcnJheShfbGVuNSksIF9rZXk1ID0gMDsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgIHRhc2tzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gIH1cblxuICBpZiAodGFza3MubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBhbGwodGFza3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gam9pbih0KTtcbiAgICB9KSk7XG4gIH1cbiAgdmFyIHRhc2sgPSB0YXNrc1swXTtcbiAgY2hlY2sodGFzaywgaXMubm90VW5kZWYsICdqb2luKHRhc2spOiBhcmd1bWVudCB0YXNrIGlzIHVuZGVmaW5lZCcpO1xuICBjaGVjayh0YXNrLCBpcy50YXNrLCAnam9pbih0YXNrKTogYXJndW1lbnQgJyArIHRhc2sgKyAnIGlzIG5vdCBhIHZhbGlkIFRhc2sgb2JqZWN0ICcgKyBURVNUX0hJTlQpO1xuICByZXR1cm4gZWZmZWN0KEpPSU4sIHRhc2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsKCkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIHRhc2tzID0gQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICB0YXNrc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgaWYgKHRhc2tzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gYWxsKHRhc2tzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIGNhbmNlbCh0KTtcbiAgICB9KSk7XG4gIH1cbiAgdmFyIHRhc2sgPSB0YXNrc1swXTtcbiAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNoZWNrKHRhc2ssIGlzLm5vdFVuZGVmLCAnY2FuY2VsKHRhc2spOiBhcmd1bWVudCB0YXNrIGlzIHVuZGVmaW5lZCcpO1xuICAgIGNoZWNrKHRhc2ssIGlzLnRhc2ssICdjYW5jZWwodGFzayk6IGFyZ3VtZW50ICcgKyB0YXNrICsgJyBpcyBub3QgYSB2YWxpZCBUYXNrIG9iamVjdCAnICsgVEVTVF9ISU5UKTtcbiAgfVxuICByZXR1cm4gZWZmZWN0KENBTkNFTCwgdGFzayB8fCBTRUxGX0NBTkNFTExBVElPTik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Qoc2VsZWN0b3IpIHtcbiAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjcgPiAxID8gX2xlbjcgLSAxIDogMCksIF9rZXk3ID0gMTsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgIGFyZ3NbX2tleTcgLSAxXSA9IGFyZ3VtZW50c1tfa2V5N107XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHNlbGVjdG9yID0gaWRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2soc2VsZWN0b3IsIGlzLm5vdFVuZGVmLCAnc2VsZWN0KHNlbGVjdG9yLFsuLi5dKTogYXJndW1lbnQgc2VsZWN0b3IgaXMgdW5kZWZpbmVkJyk7XG4gICAgY2hlY2soc2VsZWN0b3IsIGlzLmZ1bmMsICdzZWxlY3Qoc2VsZWN0b3IsWy4uLl0pOiBhcmd1bWVudCAnICsgc2VsZWN0b3IgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIGVmZmVjdChTRUxFQ1QsIHsgc2VsZWN0b3I6IHNlbGVjdG9yLCBhcmdzOiBhcmdzIH0pO1xufVxuXG4vKipcbiAgY2hhbm5lbChwYXR0ZXJuLCBbYnVmZmVyXSkgICAgPT4gY3JlYXRlcyBhbiBldmVudCBjaGFubmVsIGZvciBzdG9yZSBhY3Rpb25zXG4qKi9cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb25DaGFubmVsKHBhdHRlcm4sIGJ1ZmZlcikge1xuICBjaGVjayhwYXR0ZXJuLCBpcy5ub3RVbmRlZiwgJ2FjdGlvbkNoYW5uZWwocGF0dGVybiwuLi4pOiBhcmd1bWVudCBwYXR0ZXJuIGlzIHVuZGVmaW5lZCcpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBjaGVjayhidWZmZXIsIGlzLm5vdFVuZGVmLCAnYWN0aW9uQ2hhbm5lbChwYXR0ZXJuLCBidWZmZXIpOiBhcmd1bWVudCBidWZmZXIgaXMgdW5kZWZpbmVkJyk7XG4gICAgY2hlY2soYnVmZmVyLCBpcy5idWZmZXIsICdhY3Rpb25DaGFubmVsKHBhdHRlcm4sIGJ1ZmZlcik6IGFyZ3VtZW50ICcgKyBidWZmZXIgKyAnIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlcicpO1xuICB9XG4gIHJldHVybiBlZmZlY3QoQUNUSU9OX0NIQU5ORUwsIHsgcGF0dGVybjogcGF0dGVybiwgYnVmZmVyOiBidWZmZXIgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxsZWQoKSB7XG4gIHJldHVybiBlZmZlY3QoQ0FOQ0VMTEVELCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaChjaGFubmVsKSB7XG4gIGNoZWNrKGNoYW5uZWwsIGlzLmNoYW5uZWwsICdmbHVzaChjaGFubmVsKTogYXJndW1lbnQgJyArIGNoYW5uZWwgKyAnIGlzIG5vdCB2YWxpZCBjaGFubmVsJyk7XG4gIHJldHVybiBlZmZlY3QoRkxVU0gsIGNoYW5uZWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dChwcm9wKSB7XG4gIGNoZWNrKHByb3AsIGlzLnN0cmluZywgJ2dldENvbnRleHQocHJvcCk6IGFyZ3VtZW50ICcgKyBwcm9wICsgJyBpcyBub3QgYSBzdHJpbmcnKTtcbiAgcmV0dXJuIGVmZmVjdChHRVRfQ09OVEVYVCwgcHJvcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KHByb3BzKSB7XG4gIGNoZWNrKHByb3BzLCBpcy5vYmplY3QsIGNyZWF0ZVNldENvbnRleHRXYXJuaW5nKG51bGwsIHByb3BzKSk7XG4gIHJldHVybiBlZmZlY3QoU0VUX0NPTlRFWFQsIHByb3BzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRha2VFdmVyeShwYXR0ZXJuT3JDaGFubmVsLCB3b3JrZXIpIHtcbiAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjggPiAyID8gX2xlbjggLSAyIDogMCksIF9rZXk4ID0gMjsgX2tleTggPCBfbGVuODsgX2tleTgrKykge1xuICAgIGFyZ3NbX2tleTggLSAyXSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gIH1cblxuICByZXR1cm4gZm9yay5hcHBseSh1bmRlZmluZWQsIFt0YWtlRXZlcnlIZWxwZXIsIHBhdHRlcm5PckNoYW5uZWwsIHdvcmtlcl0uY29uY2F0KGFyZ3MpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRha2VMYXRlc3QocGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyKSB7XG4gIGZvciAodmFyIF9sZW45ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW45ID4gMiA/IF9sZW45IC0gMiA6IDApLCBfa2V5OSA9IDI7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIHtcbiAgICBhcmdzW19rZXk5IC0gMl0gPSBhcmd1bWVudHNbX2tleTldO1xuICB9XG5cbiAgcmV0dXJuIGZvcmsuYXBwbHkodW5kZWZpbmVkLCBbdGFrZUxhdGVzdEhlbHBlciwgcGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyXS5jb25jYXQoYXJncykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUobXMsIHBhdHRlcm4sIHdvcmtlcikge1xuICBmb3IgKHZhciBfbGVuMTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjEwID4gMyA/IF9sZW4xMCAtIDMgOiAwKSwgX2tleTEwID0gMzsgX2tleTEwIDwgX2xlbjEwOyBfa2V5MTArKykge1xuICAgIGFyZ3NbX2tleTEwIC0gM10gPSBhcmd1bWVudHNbX2tleTEwXTtcbiAgfVxuXG4gIHJldHVybiBmb3JrLmFwcGx5KHVuZGVmaW5lZCwgW3Rocm90dGxlSGVscGVyLCBtcywgcGF0dGVybiwgd29ya2VyXS5jb25jYXQoYXJncykpO1xufVxuXG52YXIgY3JlYXRlQXNFZmZlY3RUeXBlID0gZnVuY3Rpb24gY3JlYXRlQXNFZmZlY3RUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICByZXR1cm4gZWZmZWN0ICYmIGVmZmVjdFtJT10gJiYgZWZmZWN0W3R5cGVdO1xuICB9O1xufTtcblxuZXhwb3J0IHZhciBhc0VmZmVjdCA9IHtcbiAgdGFrZTogY3JlYXRlQXNFZmZlY3RUeXBlKFRBS0UpLFxuICBwdXQ6IGNyZWF0ZUFzRWZmZWN0VHlwZShQVVQpLFxuICBhbGw6IGNyZWF0ZUFzRWZmZWN0VHlwZShBTEwpLFxuICByYWNlOiBjcmVhdGVBc0VmZmVjdFR5cGUoUkFDRSksXG4gIGNhbGw6IGNyZWF0ZUFzRWZmZWN0VHlwZShDQUxMKSxcbiAgY3BzOiBjcmVhdGVBc0VmZmVjdFR5cGUoQ1BTKSxcbiAgZm9yazogY3JlYXRlQXNFZmZlY3RUeXBlKEZPUkspLFxuICBqb2luOiBjcmVhdGVBc0VmZmVjdFR5cGUoSk9JTiksXG4gIGNhbmNlbDogY3JlYXRlQXNFZmZlY3RUeXBlKENBTkNFTCksXG4gIHNlbGVjdDogY3JlYXRlQXNFZmZlY3RUeXBlKFNFTEVDVCksXG4gIGFjdGlvbkNoYW5uZWw6IGNyZWF0ZUFzRWZmZWN0VHlwZShBQ1RJT05fQ0hBTk5FTCksXG4gIGNhbmNlbGxlZDogY3JlYXRlQXNFZmZlY3RUeXBlKENBTkNFTExFRCksXG4gIGZsdXNoOiBjcmVhdGVBc0VmZmVjdFR5cGUoRkxVU0gpLFxuICBnZXRDb250ZXh0OiBjcmVhdGVBc0VmZmVjdFR5cGUoR0VUX0NPTlRFWFQpLFxuICBzZXRDb250ZXh0OiBjcmVhdGVBc0VmZmVjdFR5cGUoU0VUX0NPTlRFWFQpXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVkdXgtc2FnYS9lcy9pbnRlcm5hbC9pby5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgZ2V0UHJvdG90eXBlIGZyb20gJy4vX2dldFByb3RvdHlwZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1BsYWluT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9sb2Rhc2gtZXMvaXNQbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERhbmdlciA9IHJlcXVpcmUoJy4vRGFuZ2VyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG5mdW5jdGlvbiBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgbm9kZSkge1xuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRleHQgY29tcG9uZW50cywgd2hpY2ggcmV0dXJuIFtvcGVuLCBjbG9zZV0gY29tbWVudHNcbiAgLy8gZnJvbSBnZXRIb3N0Tm9kZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZVsxXTtcbiAgfVxuICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dFNpYmxpbmcgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgaW5zZXJ0Q2hpbGRBdCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBXZSByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiAoVXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsIGJyb3dzZXJzIHNvXG4gIC8vIHdlIGFyZSBjYXJlZnVsIHRvIHVzZSBgbnVsbGAuKVxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xufSk7XG5cbmZ1bmN0aW9uIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGVbMF0sIGNoaWxkTm9kZVsxXSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XG4gICAgdmFyIGNsb3NpbmdDb21tZW50ID0gY2hpbGROb2RlWzFdO1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZVswXTtcbiAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvc2luZ0NvbW1lbnQpO1xuICB9XG4gIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbn1cblxuZnVuY3Rpb24gbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCByZWZlcmVuY2VOb2RlKSB7XG4gIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIG5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIHN0YXJ0Tm9kZSwgY2xvc2luZ0NvbW1lbnQpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIC8vIFRoZSBjbG9zaW5nIGNvbW1lbnQgaXMgcmVtb3ZlZCBieSBSZWFjdE11bHRpQ2hpbGQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZURlbGltaXRlZFRleHQob3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCBzdHJpbmdUZXh0KSB7XG4gIHZhciBwYXJlbnROb2RlID0gb3BlbmluZ0NvbW1lbnQucGFyZW50Tm9kZTtcbiAgdmFyIG5vZGVBZnRlckNvbW1lbnQgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5vZGVBZnRlckNvbW1lbnQgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIHRleHQgbm9kZXMgYmV0d2VlbiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBjb21tZW50czsgaW5zZXJ0XG4gICAgLy8gYSBuZXcgb25lIGlmIHN0cmluZ1RleHQgaXNuJ3QgZW1wdHkuXG4gICAgaWYgKHN0cmluZ1RleHQpIHtcbiAgICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nVGV4dCksIG5vZGVBZnRlckNvbW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIG9wZW5pbmcgY29tbWVudCwgYW5kXG4gICAgICAvLyByZW1vdmUgYWxsIGZvbGxvd2luZyBub2RlcyB1cCB1bnRpbCB0aGUgY2xvc2luZyBjb21tZW50LlxuICAgICAgc2V0VGV4dENvbnRlbnQobm9kZUFmdGVyQ29tbWVudCwgc3RyaW5nVGV4dCk7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG5vZGVBZnRlckNvbW1lbnQsIGNsb3NpbmdDb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvcGVuaW5nQ29tbWVudCkuX2RlYnVnSUQsXG4gICAgICB0eXBlOiAncmVwbGFjZSB0ZXh0JyxcbiAgICAgIHBheWxvYWQ6IHN0cmluZ1RleHRcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgaWYgKHByZXZJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IHByZXZJbnN0YW5jZS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlcGxhY2Ugd2l0aCcsXG4gICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgaW5zdGFuY2VJRDogbmV4dEluc3RhbmNlLl9kZWJ1Z0lELFxuICAgICAgICAgIHR5cGU6ICdtb3VudCcsXG4gICAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCxcblxuICByZXBsYWNlRGVsaW1pdGVkVGV4dDogcmVwbGFjZURlbGltaXRlZFRleHQsXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuIFRoZVxuICAgKiB1cGRhdGUgY29uZmlndXJhdGlvbnMgYXJlIGVhY2ggZXhwZWN0ZWQgdG8gaGF2ZSBhIGBwYXJlbnROb2RlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50Tm9kZSwgdXBkYXRlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZURlYnVnSUQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShwYXJlbnROb2RlKS5fZGVidWdJRDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHVwZGF0ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlICdJTlNFUlRfTUFSS1VQJzpcbiAgICAgICAgICBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ2luc2VydCBjaGlsZCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgdG9JbmRleDogdXBkYXRlLnRvSW5kZXgsIGNvbnRlbnQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKCkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNT1ZFX0VYSVNUSU5HJzpcbiAgICAgICAgICBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlLCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdtb3ZlIGNoaWxkJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXgsIHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU0VUX01BUktVUCc6XG4gICAgICAgICAgc2V0SW5uZXJIVE1MKHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVwbGFjZSBjaGlsZHJlbicsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVEVYVF9DT05URU5UJzpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ3JlcGxhY2UgdGV4dCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUkVNT1ZFX05PREUnOlxuICAgICAgICAgIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIHVwZGF0ZS5mcm9tTm9kZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ3JlbW92ZSBjaGlsZCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9ET01OYW1lc3BhY2VzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgQ29tcG9uZW50VHJlZWA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBpbnN0YW5jZXNcbiAqICAgYW5kIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBDb21wb25lbnRUcmVlO1xudmFyIFRyZWVUcmF2ZXJzYWw7XG52YXIgaW5qZWN0aW9uID0ge1xuICBpbmplY3RDb21wb25lbnRUcmVlOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBDb21wb25lbnRUcmVlID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2UgJiYgSW5qZWN0ZWQuZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBpbmplY3RUcmVlVHJhdmVyc2FsOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBUcmVlVHJhdmVyc2FsID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmlzQW5jZXN0b3IgJiYgSW5qZWN0ZWQuZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RUcmVlVHJhdmVyc2FsKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgaXNBbmNlc3RvciBvciBnZXRMb3dlc3RDb21tb25BbmNlc3Rvci4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzRW5kaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hFbmQnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoQ2FuY2VsJztcbn1cblxuZnVuY3Rpb24gaXNNb3ZlaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VNb3ZlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaE1vdmUnO1xufVxuZnVuY3Rpb24gaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlRG93bicgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hTdGFydCc7XG59XG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdGFuY2VzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIGluc3RhbmNlc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIGlmIChzaW11bGF0ZWQpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayh0eXBlLCBsaXN0ZW5lciwgZXZlbnQpO1xuICB9XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICB9XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMsIGJ1dCBzdG9wc1xuICogYXQgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiByZXR1cm5pbmcgdHJ1ZSwgYW5kIHJldHVybnMgdGhhdCBpZC5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBpZCBvZiB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHdobydzIGxpc3RlbmVyIHJldHVybnNcbiAqIHRydWUsIG9yIG51bGwgaWYgbm8gbGlzdGVuZXIgcmV0dXJuZWQgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnNbaV0oZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzW2ldKSkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlcykpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlKGV2ZW50KSB7XG4gIHZhciByZXQgPSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCk7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRXhlY3V0aW9uIG9mIGEgXCJkaXJlY3RcIiBkaXNwYXRjaCAtIHRoZXJlIG11c3QgYmUgYXQgbW9zdCBvbmUgZGlzcGF0Y2hcbiAqIGFjY3VtdWxhdGVkIG9uIHRoZSBldmVudCBvciBpdCBpcyBjb25zaWRlcmVkIGFuIGVycm9yLiBJdCBkb2Vzbid0IHJlYWxseSBtYWtlXG4gKiBzZW5zZSBmb3IgYW4gZXZlbnQgd2l0aCBtdWx0aXBsZSBkaXNwYXRjaGVzIChidWJibGVkKSB0byBrZWVwIHRyYWNrIG9mIHRoZVxuICogcmV0dXJuIHZhbHVlcyBhdCBlYWNoIGRpc3BhdGNoIGV4ZWN1dGlvbiwgYnV0IGl0IGRvZXMgdGVuZCB0byBtYWtlIHNlbnNlIHdoZW5cbiAqIGRlYWxpbmcgd2l0aCBcImRpcmVjdFwiIGRpc3BhdGNoZXMuXG4gKlxuICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpcmVjdERpc3BhdGNoKGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIHZhciBkaXNwYXRjaExpc3RlbmVyID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZSA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgISFBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2V4ZWN1dGVEaXJlY3REaXNwYXRjaCguLi4pOiBJbnZhbGlkIGBldmVudGAuJykgOiBfcHJvZEludmFyaWFudCgnMTAzJykgOiB2b2lkIDA7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBkaXNwYXRjaExpc3RlbmVyID8gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGRpc3BhdGNoSW5zdGFuY2UpIDogbnVsbDtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgPyBkaXNwYXRjaExpc3RlbmVyKGV2ZW50KSA6IG51bGw7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogR2VuZXJhbCB1dGlsaXRpZXMgdGhhdCBhcmUgdXNlZnVsIGluIGNyZWF0aW5nIGN1c3RvbSBFdmVudCBQbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHtcbiAgaXNFbmRpc2g6IGlzRW5kaXNoLFxuICBpc01vdmVpc2g6IGlzTW92ZWlzaCxcbiAgaXNTdGFydGlzaDogaXNTdGFydGlzaCxcblxuICBleGVjdXRlRGlyZWN0RGlzcGF0Y2g6IGV4ZWN1dGVEaXJlY3REaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWU6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUsXG4gIGhhc0Rpc3BhdGNoZXM6IGhhc0Rpc3BhdGNoZXMsXG5cbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xuICB9LFxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2Uobm9kZSk7XG4gIH0sXG4gIGlzQW5jZXN0b3I6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuaXNBbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3I6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoYSwgYik7XG4gIH0sXG4gIGdldFBhcmVudEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmdldFBhcmVudEluc3RhbmNlKGluc3QpO1xuICB9LFxuICB0cmF2ZXJzZVR3b1BoYXNlOiBmdW5jdGlvbiAodGFyZ2V0LCBmbiwgYXJnKSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwudHJhdmVyc2VUd29QaGFzZSh0YXJnZXQsIGZuLCBhcmcpO1xuICB9LFxuICB0cmF2ZXJzZUVudGVyTGVhdmU6IGZ1bmN0aW9uIChmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwudHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pO1xuICB9LFxuXG4gIGluamVjdGlvbjogaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvS2V5RXNjYXBlVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBwcm9wVHlwZXNGYWN0b3J5ID0gcmVxdWlyZSgncHJvcC10eXBlcy9mYWN0b3J5Jyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFByb3BUeXBlcyA9IHByb3BUeXBlc0ZhY3RvcnkoUmVhY3QuaXNWYWxpZEVsZW1lbnQpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnY2hlY2tib3gnOiB0cnVlLFxuICAnaW1hZ2UnOiB0cnVlLFxuICAnaGlkZGVuJzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogX3Byb2RJbnZhcmlhbnQoJzg3JykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogX3Byb2RJbnZhcmlhbnQoJzg4JykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgY2hlY2tlZExpbmsnKSA6IF9wcm9kSW52YXJpYW50KCc4OScpIDogdm9pZCAwO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsICdwcm9wJywgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvTGlua2VkVmFsdWVVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxuICAgKiB0aGUgdHJlZS5cbiAgICovXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDQnKSA6IHZvaWQgMDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBhIEZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0geyp9IGIgU2Vjb25kIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBhKSB7XG4gIHRyeSB7XG4gICAgZnVuYyhhKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgY2F1Z2h0RXJyb3IgPSB4O1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogSW52b2tlZCBieSBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSBzbyB0aGF0IGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSBldmVudFxuICAgKiBoYW5kbGVyIGFyZSBzdXJlIHRvIGJlIHJldGhyb3duIGJ5IHJldGhyb3dDYXVnaHRFcnJvci5cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaDogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqXG4gICAqIFRvIGhlbHAgZGV2ZWxvcG1lbnQgd2UgY2FuIGdldCBiZXR0ZXIgZGV2dG9vbHMgaW50ZWdyYXRpb24gYnkgc2ltdWxhdGluZyBhXG4gICAqIHJlYWwgYnJvd3NlciBldmVudC5cbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgYSkge1xuICAgICAgdmFyIGJvdW5kRnVuYyA9IGZ1bmMuYmluZChudWxsLCBhKTtcbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyBuYW1lO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlscztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFcnJvclV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHZhciBkaXNwbGF5TmFtZSA9IGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY29uc3RydWN0b3IubmFtZSB8fCB0eXBlO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDAgJiYga2V5cy5sZW5ndGggPCAyMCkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZSArICcgKGtleXM6ICcgKyBrZXlzLmpvaW4oJywgJykgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY3RvciAmJiAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICclcyguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzICcgKyAnc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yICcgKyAnc2lkZS1lZmZlY3RzIGFyZSBhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gJyArICdgY29tcG9uZW50V2lsbE1vdW50YC4nLCBjYWxsZXJOYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcbiAgICAgIC8vIHRoYXQgd2lsbCBhbHdheXMgcmVuZGVyIHRvIHNvbWV0aGluZy4gQXQgbGVhc3QgZm9yIG5vdy4gU28gd2UgY2FuIHVzZVxuICAgICAgLy8gdGhpcyBoYWNrLlxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsbGVyTmFtZSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaykge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gdHJ1ZTtcblxuICAgIC8vIEZ1dHVyZS1wcm9vZiAxNS41XG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldFN0YXRlKCk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwYXJ0aWFsU3RhdGUgIT0gbnVsbCwgJ3NldFN0YXRlKC4uLik6IFlvdSBwYXNzZWQgYW4gdW5kZWZpbmVkIG9yIG51bGwgc3RhdGUgb2JqZWN0OyAnICsgJ2luc3RlYWQsIHVzZSBmb3JjZVVwZGF0ZSgpLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlIHx8IChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtdKTtcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVFbGVtZW50SW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQpIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIC8vIFRPRE86IGludHJvZHVjZSBfcGVuZGluZ0NvbnRleHQgaW5zdGVhZCBvZiBzZXR0aW5nIGl0IGRpcmVjdGx5LlxuICAgIGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIHZhbGlkYXRlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICEoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IF9wcm9kSW52YXJpYW50KCcxMjInLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IHZvaWQgMDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlUXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50Q2hhckNvZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IDMgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudFRhcmdldDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRUYXJnZXQuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL2lzRXZlbnRTdXBwb3J0ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZWxlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuICBpZiAocHJldkVtcHR5IHx8IG5leHRFbXB0eSkge1xuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcbiAgfVxuXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xuICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgaW5zdGFuY2UsIHJldHVybiBhIGxpc3Qgb2YgaXRzIHJlY3Vyc2l2ZVxuICAgKiBvd25lcnMsIHN0YXJ0aW5nIGF0IHRoZSByb290IGFuZCBlbmRpbmcgd2l0aCB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgdmFyIGZpbmRPd25lclN0YWNrID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGRvIHtcbiAgICAgIHN0YWNrLnB1c2goaW5zdGFuY2UpO1xuICAgIH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgc3RhY2sucmV2ZXJzZSgpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBjaGlsZEluc3RhbmNlLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY2hpbGRUYWcgPT0gbnVsbCwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpIDogdm9pZCAwO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBwcm9ibGVtYXRpYyA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuXG4gICAgaWYgKHByb2JsZW1hdGljKSB7XG4gICAgICB2YXIgYW5jZXN0b3JUYWcgPSBwcm9ibGVtYXRpYy50YWc7XG4gICAgICB2YXIgYW5jZXN0b3JJbnN0YW5jZSA9IHByb2JsZW1hdGljLmluc3RhbmNlO1xuXG4gICAgICB2YXIgY2hpbGRPd25lciA9IGNoaWxkSW5zdGFuY2UgJiYgY2hpbGRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXIgPSBhbmNlc3Rvckluc3RhbmNlICYmIGFuY2VzdG9ySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgdmFyIGNoaWxkT3duZXJzID0gZmluZE93bmVyU3RhY2soY2hpbGRPd25lcik7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lcnMgPSBmaW5kT3duZXJTdGFjayhhbmNlc3Rvck93bmVyKTtcblxuICAgICAgdmFyIG1pblN0YWNrTGVuID0gTWF0aC5taW4oY2hpbGRPd25lcnMubGVuZ3RoLCBhbmNlc3Rvck93bmVycy5sZW5ndGgpO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIHZhciBkZWVwZXN0Q29tbW9uID0gLTE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWluU3RhY2tMZW47IGkrKykge1xuICAgICAgICBpZiAoY2hpbGRPd25lcnNbaV0gPT09IGFuY2VzdG9yT3duZXJzW2ldKSB7XG4gICAgICAgICAgZGVlcGVzdENvbW1vbiA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFVOS05PV04gPSAnKHVua25vd24pJztcbiAgICAgIHZhciBjaGlsZE93bmVyTmFtZXMgPSBjaGlsZE93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lck5hbWVzID0gYW5jZXN0b3JPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIG93bmVySW5mbyA9IFtdLmNvbmNhdChcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgYW5kIGNoaWxkIGluc3RhbmNlcyBoYXZlIGEgY29tbW9uIG93bmVyIGFuY2VzdG9yLCBzdGFydFxuICAgICAgLy8gd2l0aCB0aGF0IC0tIG90aGVyd2lzZSB3ZSBqdXN0IHN0YXJ0IHdpdGggdGhlIHBhcmVudCdzIG93bmVycy5cbiAgICAgIGRlZXBlc3RDb21tb24gIT09IC0xID8gY2hpbGRPd25lcnNbZGVlcGVzdENvbW1vbl0uZ2V0TmFtZSgpIHx8IFVOS05PV04gOiBbXSwgYW5jZXN0b3JPd25lck5hbWVzLCBhbmNlc3RvclRhZyxcbiAgICAgIC8vIElmIHdlJ3JlIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCAobm9uLXBhcmVudCkgYW5jZXN0cnksIGFkZCAnLi4uJ1xuICAgICAgaW52YWxpZEFuY2VzdG9yID8gWycuLi4nXSA6IFtdLCBjaGlsZE93bmVyTmFtZXMsIGNoaWxkVGFnKS5qb2luKCcgPiAnKTtcblxuICAgICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgb3duZXJJbmZvO1xuICAgICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG4gICAgICBpZiAoY2hpbGRUYWcgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgICAgd2hpdGVzcGFjZUluZm8gPSAnIE1ha2Ugc3VyZSB5b3UgZG9uXFwndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiAnICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyAnICsgJ1NlZSAlcy4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgd2hpdGVzcGFjZUluZm8sIG93bmVySW5mbywgaW5mbykgOiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uIFNlZSAlcy4nLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIG93bmVySW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbztcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlRE9NTmVzdGluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtcmVkdXgvZXMvdXRpbHMvd2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IF9wcm9kSW52YXJpYW50KCc4NScpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2spIHt9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9tb2R1bGVzIS4vc3R5bGUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMhLi9zdHlsZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP21vZHVsZXMhLi9zdHlsZS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoLWVzL19TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gUmVhY3QgMTUuNSByZWZlcmVuY2VzIHRoaXMgbW9kdWxlLCBhbmQgYXNzdW1lcyBQcm9wVHlwZXMgYXJlIHN0aWxsIGNhbGxhYmxlIGluIHByb2R1Y3Rpb24uXG4vLyBUaGVyZWZvcmUgd2UgcmUtZXhwb3J0IGRldmVsb3BtZW50LW9ubHkgdmVyc2lvbiB3aXRoIGFsbCB0aGUgUHJvcFR5cGVzIGNoZWNrcyBoZXJlLlxuLy8gSG93ZXZlciBpZiBvbmUgaXMgbWlncmF0aW5nIHRvIHRoZSBgcHJvcC10eXBlc2AgbnBtIGxpYnJhcnksIHRoZXkgd2lsbCBnbyB0aHJvdWdoIHRoZVxuLy8gYGluZGV4LmpzYCBlbnRyeSBwb2ludCwgYW5kIGl0IHdpbGwgYnJhbmNoIGRlcGVuZGluZyBvbiB0aGUgZW52aXJvbm1lbnQuXG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQpIHtcbiAgLy8gSXQgaXMgc3RpbGwgYWxsb3dlZCBpbiAxNS41LlxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IGZhbHNlO1xuICByZXR1cm4gZmFjdG9yeShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9wcm9wLXR5cGVzL2ZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xuXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWVcbiAgfSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXG4gICAgb3V0bGluZUNvbG9yOiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXG4gKlxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBDYWxsYmFja1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYWxsYmFja1F1ZXVlKGFyZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWxsYmFja1F1ZXVlKTtcblxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgIHRoaXMuX2FyZyA9IGFyZztcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5ub3RpZnlBbGwgPSBmdW5jdGlvbiBub3RpZnlBbGwoKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICB2YXIgYXJnID0gdGhpcy5fYXJnO1xuICAgIGlmIChjYWxsYmFja3MgJiYgY29udGV4dHMpIHtcbiAgICAgICEoY2FsbGJhY2tzLmxlbmd0aCA9PT0gY29udGV4dHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWUnKSA6IF9wcm9kSW52YXJpYW50KCcyNCcpIDogdm9pZCAwO1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKGNvbnRleHRzW2ldLCBhcmcpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfTtcblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5jaGVja3BvaW50ID0gZnVuY3Rpb24gY2hlY2twb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzID8gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA6IDA7XG4gIH07XG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUucm9sbGJhY2sgPSBmdW5jdGlvbiByb2xsYmFjayhsZW4pIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NvbnRleHRzKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID0gbGVuO1xuICAgICAgdGhpcy5fY29udGV4dHMubGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH07XG5cbiAgcmV0dXJuIENhbGxiYWNrUXVldWU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENhbGxiYWNrUXVldWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9DYWxsYmFja1F1ZXVlLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBJRCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuZXNjYXBlZCBJRC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9ySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKGlkKTtcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JJRDogZnVuY3Rpb24gKG5vZGUsIGlkKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUsIGlkKTtcbiAgfSxcblxuICBjcmVhdGVNYXJrdXBGb3JSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUgKyAnPVwiXCInO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvclJvb3Q6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRSwgJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBjdXN0b20gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgcGF5bG9hZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAncmVtb3ZlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHtcbiAgaGFzQ2FjaGVkQ2hpbGROb2RlczogMSA8PCAwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCAmJiB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpIHtcbiAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgb3duZXIpO1xuXG4gIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgc2VsZWN0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGluc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyBwcm9wVmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgcGVuZGluZ1VwZGF0ZTogZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdCksXG4gICAgICB3YXNNdWx0aXBsZTogQm9vbGVhbihwcm9wcy5tdWx0aXBsZSlcbiAgICB9O1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U2VsZWN0VmFsdWVDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFJlYWN0RE9NT3B0aW9uIGxvb2tzIGF0IHRoaXMgaW5pdGlhbCB2YWx1ZSBzbyB0aGUgaW5pdGlhbCBnZW5lcmF0ZWRcbiAgICAvLyBtYXJrdXAgaGFzIGNvcnJlY3QgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgcmV0dXJuIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSkpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3QuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUNvbXBvbmVudEZhY3Rvcnk7XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RFbXB0eUNvbXBvbmVudEZhY3Rvcnk6IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgZW1wdHlDb21wb25lbnRGYWN0b3J5ID0gZmFjdG9yeTtcbiAgfVxufTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIGVtcHR5Q29tcG9uZW50RmFjdG9yeShpbnN0YW50aWF0ZSk7XG4gIH1cbn07XG5cblJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uID0gUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFncztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RGZWF0dXJlRmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IG51bGw7XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBob3N0IGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCkge1xuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IF9wcm9kSW52YXJpYW50KCcxMTEnLCBlbGVtZW50LnR5cGUpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0ge1xuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0Q29tcG9uZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEhvc3RDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3Rpb24nKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xuXG4gIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAndGV4dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICAgIHNlbGVjdGlvblJhbmdlOiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gICAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICAgKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAgICovXG4gIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uIChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gICAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgaWYgKFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICAgIFJlYWN0SW5wdXRTZWxlY3Rpb24uc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgfVxuICAgICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gICAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICAgKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICAgKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAgICovXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHNlbGVjdGlvbjtcblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgIC8vIElFOCBpbnB1dC5cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIHNlbGVjdGlvbiBwZXIgZG9jdW1lbnQgaW4gSUUsIHNvIGl0IG11c3RcbiAgICAgIC8vIGJlIGluIG91ciBlbGVtZW50LlxuICAgICAgaWYgKHJhbmdlLnBhcmVudEVsZW1lbnQoKSA9PT0gaW5wdXQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiAtcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICBlbmQ6IC1yYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IFJlYWN0RE9NU2VsZWN0aW9uLmdldE9mZnNldHMoaW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICAgKiB0aGUgaW5wdXQuXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldHMpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01Db250YWluZXJJbmZvID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbnRhaW5lckluZm8nKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIFJPT1RfQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICogdGhhdCdzIG5vdCBjb21tb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIG1hcmtlck5hbWU7XG4gIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICB2YXIgd3JhcHBlZEVsZW1lbnQgPSB3cmFwcGVySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnByb3BzLmNoaWxkO1xuICAgIHZhciB0eXBlID0gd3JhcHBlZEVsZW1lbnQudHlwZTtcbiAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IG1vdW50OiAnICsgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSk7XG4gICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh3cmFwcGVySW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBudWxsLCBSZWFjdERPTUNvbnRhaW5lckluZm8od3JhcHBlckluc3RhbmNlLCBjb250YWluZXIpLCBjb250ZXh0LCAwIC8qIHBhcmVudERlYnVnSUQgKi9cbiAgKTtcblxuICBpZiAobWFya2VyTmFtZSkge1xuICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHdyYXBwZXJJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IHdyYXBwZXJJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCB3cmFwcGVySW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi9cbiAgIXNob3VsZFJldXNlTWFya3VwICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgc2FmZWx5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCgpO1xuICB9XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlLCBzYWZlbHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoKCk7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIGlmIChyb290RWwpIHtcbiAgICB2YXIgaW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gICAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5faG9zdFBhcmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIFJlYWN0IERPTSBlbGVtZW50IGFuZFxuICogaXQgaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3RcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsICYmIGlzUmVhY3ROb2RlKHJvb3RFbCkgJiYgIVJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIFJlYWN0IG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBSZWFjdCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1JlYWN0Tm9kZShub2RlKSB7XG4gIHJldHVybiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpICYmIChub2RlLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICB2YXIgcHJldkhvc3RJbnN0YW5jZSA9IHJvb3RFbCAmJiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICByZXR1cm4gcHJldkhvc3RJbnN0YW5jZSAmJiAhcHJldkhvc3RJbnN0YW5jZS5faG9zdFBhcmVudCA/IHByZXZIb3N0SW5zdGFuY2UgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3QgPSBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3QgPyByb290Ll9ob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciB0b3BMZXZlbFJvb3RDb3VudGVyID0gMTtcbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdElEID0gdG9wTGV2ZWxSb290Q291bnRlcisrO1xufTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGQ7XG59O1xuVG9wTGV2ZWxXcmFwcGVyLmlzUmVhY3RUb3BMZXZlbFdyYXBwZXIgPSB0cnVlO1xuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZyBpdHNcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyKFxuICogICAgIGNvbXBvbmVudCxcbiAqICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbiAqICAgKTtcbiAqXG4gKiAgIDxkaXYgaWQ9XCJjb250YWluZXJcIj4gICAgICAgICAgICAgICAgICAgPC0tIFN1cHBsaWVkIGBjb250YWluZXJgLlxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKlxuICogSW5zaWRlIG9mIGBjb250YWluZXJgLCB0aGUgZmlyc3QgZWxlbWVudCByZW5kZXJlZCBpcyB0aGUgXCJyZWFjdFJvb3RcIi5cbiAqL1xudmFyIFJlYWN0TW91bnQgPSB7XG5cbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgZGV2dG9vbHMuIFRoZSBrZXlzIGFyZSBub3QgaW1wb3J0YW50LlxuICAgKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uIEhvb2tlZCBieSBob29rcyFcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50KCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gJyArICdyZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzcnKSA6IHZvaWQgMDtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBmYWxzZSk7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIHZhciB3cmFwcGVySUQgPSBjb21wb25lbnRJbnN0YW5jZS5faW5zdGFuY2Uucm9vdElEO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbd3JhcHBlcklEXSA9IGNvbXBvbmVudEluc3RhbmNlO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgUmVhY3RJbnN0YW5jZU1hcC5oYXMocGFyZW50Q29tcG9uZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCczOCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCAnUmVhY3RET00ucmVuZGVyJyk7XG4gICAgIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzM5JywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDogbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCB7IGNoaWxkOiBuZXh0RWxlbWVudCB9KTtcblxuICAgIHZhciBuZXh0Q29udGV4dDtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcGFyZW50SW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gICAgICBuZXh0Q29udGV4dCA9IHBhcmVudEluc3QuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50SW5zdC5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcmV2V3JhcHBlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcy5jaGlsZDtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBwdWJsaWNJbnN0ID0gcHJldkNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgbmV4dENvbnRleHQpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5yZW5kZXJcbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20udW5tb3VudGNvbXBvbmVudGF0bm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQwJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIW5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lciksICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGlmICghcHJldkNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgYmVpbmcgdW5tb3VudGVkIHdhcyByZW5kZXJlZCBieSBSZWFjdCwgYnV0IGlzbid0IGFcbiAgICAgIC8vIHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcHJldkNvbXBvbmVudC5faW5zdGFuY2Uucm9vdElEXTtcbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBwcmV2Q29tcG9uZW50LCBjb250YWluZXIsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIGluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBfcHJvZEludmFyaWFudCgnNDEnKSA6IHZvaWQgMDtcblxuICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xuICAgICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCByb290RWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uIHRoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3Ugc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyBhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogX3Byb2RJbnZhcmlhbnQoJzQyJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0IHlvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzIHdpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzQzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShjb250YWluZXIsIG1hcmt1cCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBob3N0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIGlmIChob3N0Tm9kZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICBpbnN0YW5jZUlEOiBob3N0Tm9kZS5fZGVidWdJRCxcbiAgICAgICAgICB0eXBlOiAnbW91bnQnLFxuICAgICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdE1vdW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHtcbiAgSE9TVDogMCxcbiAgQ09NUE9TSVRFOiAxLFxuICBFTVBUWTogMixcblxuICBnZXRUeXBlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuRU1QVFk7XG4gICAgfSBlbHNlIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgaWYgKHR5cGVvZiBub2RlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkNPTVBPU0lURTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5IT1NUO1xuICAgICAgfVxuICAgIH1cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBub2RlOiAlcycsIG5vZGUpIDogX3Byb2RJbnZhcmlhbnQoJzI2Jywgbm9kZSkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb2RlVHlwZXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0Tm9kZVR5cGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmlld3BvcnRNZXRyaWNzID0ge1xuXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24gKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb24ueDtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcCA9IHNjcm9sbFBvc2l0aW9uLnk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1ldHJpY3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1ZpZXdwb3J0TWV0cmljcy5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiBfcHJvZEludmFyaWFudCgnMzAnKSA6IHZvaWQgMDtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGVJbnRvO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9hY2N1bXVsYXRlSW50by5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG5cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcblxuZnVuY3Rpb24gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCkge1xuICB2YXIgdHlwZTtcblxuICB3aGlsZSAoKHR5cGUgPSBpbnN0Ll9yZW5kZXJlZE5vZGVUeXBlKSA9PT0gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFKSB7XG4gICAgaW5zdCA9IGluc3QuX3JlbmRlcmVkQ29tcG9uZW50O1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJlYWN0Tm9kZVR5cGVzLkhPU1QpIHtcbiAgICByZXR1cm4gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZS5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0Q29tcG9uZW50Jyk7XG5cbnZhciBnZXROZXh0RGVidWdJRCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9nZXROZXh0RGVidWdJRCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8vIFRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3ksIHdlIGNyZWF0ZSB0aGUgZmluYWwgY2xhc3MgaW4gdGhpcyBtb2R1bGVcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB0aGlzLmNvbnN0cnVjdChlbGVtZW50KTtcbn07XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0eXBlIHJlZmVyZW5jZSBpcyBhIGtub3duIGludGVybmFsIHR5cGUuIEkuZS4gbm90IGEgdXNlclxuICogcHJvdmlkZWQgY29tcG9zaXRlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBpbnRlcm5hbCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc0ludGVybmFsQ29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0Tm9kZSwgY3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgd2lsbCBhY3R1YWxseSBiZSBtb3VudGVkLlxuICpcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEhhdmVEZWJ1Z0lEXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSwgc2hvdWxkSGF2ZURlYnVnSUQpIHtcbiAgdmFyIGluc3RhbmNlO1xuXG4gIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdEVtcHR5Q29tcG9uZW50LmNyZWF0ZShpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyAnaXRcXCdzIGRlZmluZWQgaW4uJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oZWxlbWVudC5fb3duZXIpO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pIDogX3Byb2RJbnZhcmlhbnQoJzEzMCcsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoaXNJbnRlcm5hbENvbXBvbmVudFR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgICAgLy8gVGhpcyBpcyB0ZW1wb3JhcmlseSBhdmFpbGFibGUgZm9yIGN1c3RvbSBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9ucy4gSS5lLiBBUlQuIE9uY2UgdGhvc2UgYXJlIHVwZGF0ZWQgdG8gdXNlIHRoZSBzdHJpbmdcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3ZSBjYW4gZHJvcCB0aGlzIGNvZGUgcGF0aC5cbiAgICAgIGluc3RhbmNlID0gbmV3IGVsZW1lbnQudHlwZShlbGVtZW50KTtcblxuICAgICAgLy8gV2UgcmVuYW1lZCB0aGlzLiBBbGxvdyB0aGUgb2xkIG5hbWUgZm9yIGNvbXBhdC4gOihcbiAgICAgIGlmICghaW5zdGFuY2UuZ2V0SG9zdE5vZGUpIHtcbiAgICAgICAgaW5zdGFuY2UuZ2V0SG9zdE5vZGUgPSBpbnN0YW5jZS5nZXROYXRpdmVOb2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIoZWxlbWVudCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICBpbnN0YW5jZSA9IFJlYWN0SG9zdENvbXBvbmVudC5jcmVhdGVJbnN0YW5jZUZvclRleHQobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VuY291bnRlcmVkIGludmFsaWQgUmVhY3Qgbm9kZSBvZiB0eXBlICVzJywgdHlwZW9mIG5vZGUpIDogX3Byb2RJbnZhcmlhbnQoJzEzMScsIHR5cGVvZiBub2RlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3RhbmNlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UudW5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJywgJ09ubHkgUmVhY3QgQ29tcG9uZW50cyBjYW4gYmUgbW91bnRlZC4nKSA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIFRoZXNlIHR3byBmaWVsZHMgYXJlIHVzZWQgYnkgdGhlIERPTSBhbmQgQVJUIGRpZmZpbmcgYWxnb3JpdGhtc1xuICAvLyByZXNwZWN0aXZlbHkuIEluc3RlYWQgb2YgdXNpbmcgZXhwYW5kb3Mgb24gY29tcG9uZW50cywgd2Ugc2hvdWxkIGJlXG4gIC8vIHN0b3JpbmcgdGhlIHN0YXRlIG5lZWRlZCBieSB0aGUgZGlmZmluZyBhbGdvcml0aG1zIGVsc2V3aGVyZS5cbiAgaW5zdGFuY2UuX21vdW50SW5kZXggPSAwO1xuICBpbnN0YW5jZS5fbW91bnRJbWFnZSA9IG51bGw7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpbnN0YW5jZS5fZGVidWdJRCA9IHNob3VsZEhhdmVEZWJ1Z0lEID8gZ2V0TmV4dERlYnVnSUQoKSA6IDA7XG4gIH1cblxuICAvLyBJbnRlcm5hbCBpbnN0YW5jZXMgc2hvdWxkIGZ1bGx5IGNvbnN0cnVjdGVkIGF0IHRoaXMgcG9pbnQsIHNvIHRoZXkgc2hvdWxkXG4gIC8vIG5vdCBnZXQgYW55IG5ldyBmaWVsZHMgYWRkZWQgdG8gdGhlbSBhdCB0aGlzIHBvaW50LlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5fYXNzaWduKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUsIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LCB7XG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cblxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gICdjb2xvcic6IHRydWUsXG4gICdkYXRlJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgJ2VtYWlsJzogdHJ1ZSxcbiAgJ21vbnRoJzogdHJ1ZSxcbiAgJ251bWJlcic6IHRydWUsXG4gICdwYXNzd29yZCc6IHRydWUsXG4gICdyYW5nZSc6IHRydWUsXG4gICdzZWFyY2gnOiB0cnVlLFxuICAndGVsJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlLFxuICAndGltZSc6IHRydWUsXG4gICd1cmwnOiB0cnVlLFxuICAnd2Vlayc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRleHRDb250ZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9zZXRUZXh0Q29udGVudC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUaGlzIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQgc2luY2UgdGhpcyBmaWxlIGlzIHNoYXJlZCBiZXR3ZWVuXG4gKiBpc29tb3JwaGljIGFuZCByZW5kZXJlcnMuIFdlIGNvdWxkIGV4dHJhY3QgdGhpcyB0byBhXG4gKlxuICovXG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50LiBUaGlzIG1lYW5zIHdlIGNhbiBvcHRpbWl6ZVxuICAvLyBzb21lIGNoZWNrcy4gUmVhY3QgRmliZXIgYWxzbyBpbmxpbmVzIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgcHVycG9zZXMuXG4gIHR5cGUgPT09ICdvYmplY3QnICYmIGNoaWxkcmVuLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgU3Vic2NyaXB0aW9uIGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBzdG9yZVNoYXBlLCBzdWJzY3JpcHRpb25TaGFwZSB9IGZyb20gJy4uL3V0aWxzL1Byb3BUeXBlcyc7XG5cbnZhciBob3RSZWxvYWRpbmdWZXJzaW9uID0gMDtcbnZhciBkdW1teVN0YXRlID0ge307XG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIG1ha2VTZWxlY3RvclN0YXRlZnVsKHNvdXJjZVNlbGVjdG9yLCBzdG9yZSkge1xuICAvLyB3cmFwIHRoZSBzZWxlY3RvciBpbiBhbiBvYmplY3QgdGhhdCB0cmFja3MgaXRzIHJlc3VsdHMgYmV0d2VlbiBydW5zLlxuICB2YXIgc2VsZWN0b3IgPSB7XG4gICAgcnVuOiBmdW5jdGlvbiBydW5Db21wb25lbnRTZWxlY3Rvcihwcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5leHRQcm9wcyA9IHNvdXJjZVNlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHByb3BzKTtcbiAgICAgICAgaWYgKG5leHRQcm9wcyAhPT0gc2VsZWN0b3IucHJvcHMgfHwgc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHNlbGVjdG9yLnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgICAgIHNlbGVjdG9yLmVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0b3IuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25uZWN0QWR2YW5jZWQoXG4vKlxuICBzZWxlY3RvckZhY3RvcnkgaXMgYSBmdW5jIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHJldHVybmluZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gdXNlZCB0b1xuICBjb21wdXRlIG5ldyBwcm9wcyBmcm9tIHN0YXRlLCBwcm9wcywgYW5kIGRpc3BhdGNoLiBGb3IgZXhhbXBsZTpcbiAgICAgZXhwb3J0IGRlZmF1bHQgY29ubmVjdEFkdmFuY2VkKChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKHN0YXRlLCBwcm9wcykgPT4gKHtcbiAgICAgIHRoaW5nOiBzdGF0ZS50aGluZ3NbcHJvcHMudGhpbmdJZF0sXG4gICAgICBzYXZlVGhpbmc6IGZpZWxkcyA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9ycy5zYXZlVGhpbmcocHJvcHMudGhpbmdJZCwgZmllbGRzKSksXG4gICAgfSkpKFlvdXJDb21wb25lbnQpXG4gICBBY2Nlc3MgdG8gZGlzcGF0Y2ggaXMgcHJvdmlkZWQgdG8gdGhlIGZhY3Rvcnkgc28gc2VsZWN0b3JGYWN0b3JpZXMgY2FuIGJpbmQgYWN0aW9uQ3JlYXRvcnNcbiAgb3V0c2lkZSBvZiB0aGVpciBzZWxlY3RvciBhcyBhbiBvcHRpbWl6YXRpb24uIE9wdGlvbnMgcGFzc2VkIHRvIGNvbm5lY3RBZHZhbmNlZCBhcmUgcGFzc2VkIHRvXG4gIHRoZSBzZWxlY3RvckZhY3RvcnksIGFsb25nIHdpdGggZGlzcGxheU5hbWUgYW5kIFdyYXBwZWRDb21wb25lbnQsIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICBOb3RlIHRoYXQgc2VsZWN0b3JGYWN0b3J5IGlzIHJlc3BvbnNpYmxlIGZvciBhbGwgY2FjaGluZy9tZW1vaXphdGlvbiBvZiBpbmJvdW5kIGFuZCBvdXRib3VuZFxuICBwcm9wcy4gRG8gbm90IHVzZSBjb25uZWN0QWR2YW5jZWQgZGlyZWN0bHkgd2l0aG91dCBtZW1vaXppbmcgcmVzdWx0cyBiZXR3ZWVuIGNhbGxzIHRvIHlvdXJcbiAgc2VsZWN0b3IsIG90aGVyd2lzZSB0aGUgQ29ubmVjdCBjb21wb25lbnQgd2lsbCByZS1yZW5kZXIgb24gZXZlcnkgc3RhdGUgb3IgcHJvcHMgY2hhbmdlLlxuKi9cbnNlbGVjdG9yRmFjdG9yeSkge1xuICB2YXIgX2NvbnRleHRUeXBlcywgX2NoaWxkQ29udGV4dFR5cGVzO1xuXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkZ2V0RGlzcGxheU5hbWUgPSBfcmVmLmdldERpc3BsYXlOYW1lLFxuICAgICAgZ2V0RGlzcGxheU5hbWUgPSBfcmVmJGdldERpc3BsYXlOYW1lID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAnQ29ubmVjdEFkdmFuY2VkKCcgKyBuYW1lICsgJyknO1xuICB9IDogX3JlZiRnZXREaXNwbGF5TmFtZSxcbiAgICAgIF9yZWYkbWV0aG9kTmFtZSA9IF9yZWYubWV0aG9kTmFtZSxcbiAgICAgIG1ldGhvZE5hbWUgPSBfcmVmJG1ldGhvZE5hbWUgPT09IHVuZGVmaW5lZCA/ICdjb25uZWN0QWR2YW5jZWQnIDogX3JlZiRtZXRob2ROYW1lLFxuICAgICAgX3JlZiRyZW5kZXJDb3VudFByb3AgPSBfcmVmLnJlbmRlckNvdW50UHJvcCxcbiAgICAgIHJlbmRlckNvdW50UHJvcCA9IF9yZWYkcmVuZGVyQ291bnRQcm9wID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfcmVmJHJlbmRlckNvdW50UHJvcCxcbiAgICAgIF9yZWYkc2hvdWxkSGFuZGxlU3RhdCA9IF9yZWYuc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gX3JlZiRzaG91bGRIYW5kbGVTdGF0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRzaG91bGRIYW5kbGVTdGF0LFxuICAgICAgX3JlZiRzdG9yZUtleSA9IF9yZWYuc3RvcmVLZXksXG4gICAgICBzdG9yZUtleSA9IF9yZWYkc3RvcmVLZXkgPT09IHVuZGVmaW5lZCA/ICdzdG9yZScgOiBfcmVmJHN0b3JlS2V5LFxuICAgICAgX3JlZiR3aXRoUmVmID0gX3JlZi53aXRoUmVmLFxuICAgICAgd2l0aFJlZiA9IF9yZWYkd2l0aFJlZiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHdpdGhSZWYsXG4gICAgICBjb25uZWN0T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2dldERpc3BsYXlOYW1lJywgJ21ldGhvZE5hbWUnLCAncmVuZGVyQ291bnRQcm9wJywgJ3Nob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcycsICdzdG9yZUtleScsICd3aXRoUmVmJ10pO1xuXG4gIHZhciBzdWJzY3JpcHRpb25LZXkgPSBzdG9yZUtleSArICdTdWJzY3JpcHRpb24nO1xuICB2YXIgdmVyc2lvbiA9IGhvdFJlbG9hZGluZ1ZlcnNpb24rKztcblxuICB2YXIgY29udGV4dFR5cGVzID0gKF9jb250ZXh0VHlwZXMgPSB7fSwgX2NvbnRleHRUeXBlc1tzdG9yZUtleV0gPSBzdG9yZVNoYXBlLCBfY29udGV4dFR5cGVzW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX2NvbnRleHRUeXBlcyk7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IChfY2hpbGRDb250ZXh0VHlwZXMgPSB7fSwgX2NoaWxkQ29udGV4dFR5cGVzW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb25TaGFwZSwgX2NoaWxkQ29udGV4dFR5cGVzKTtcblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICBpbnZhcmlhbnQodHlwZW9mIFdyYXBwZWRDb21wb25lbnQgPT0gJ2Z1bmN0aW9uJywgJ1lvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5ICcgKyAoJ2Nvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJyArIEpTT04uc3RyaW5naWZ5KFdyYXBwZWRDb21wb25lbnQpKSk7XG5cbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKHdyYXBwZWRDb21wb25lbnROYW1lKTtcblxuICAgIHZhciBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0gX2V4dGVuZHMoe30sIGNvbm5lY3RPcHRpb25zLCB7XG4gICAgICBnZXREaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWUsXG4gICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgcmVuZGVyQ291bnRQcm9wOiByZW5kZXJDb3VudFByb3AsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIHN0b3JlS2V5OiBzdG9yZUtleSxcbiAgICAgIHdpdGhSZWY6IHdpdGhSZWYsXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZTogd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50OiBXcmFwcGVkQ29tcG9uZW50XG4gICAgfSk7XG5cbiAgICB2YXIgQ29ubmVjdCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHMoQ29ubmVjdCwgX0NvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIENvbm5lY3QocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbm5lY3QpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgICAgIF90aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICBfdGhpcy5yZW5kZXJDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLnN0b3JlID0gcHJvcHNbc3RvcmVLZXldIHx8IGNvbnRleHRbc3RvcmVLZXldO1xuICAgICAgICBfdGhpcy5wcm9wc01vZGUgPSBCb29sZWFuKHByb3BzW3N0b3JlS2V5XSk7XG4gICAgICAgIF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZSA9IF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZS5iaW5kKF90aGlzKTtcblxuICAgICAgICBpbnZhcmlhbnQoX3RoaXMuc3RvcmUsICdDb3VsZCBub3QgZmluZCBcIicgKyBzdG9yZUtleSArICdcIiBpbiBlaXRoZXIgdGhlIGNvbnRleHQgb3IgcHJvcHMgb2YgJyArICgnXCInICsgZGlzcGxheU5hbWUgKyAnXCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sICcpICsgKCdvciBleHBsaWNpdGx5IHBhc3MgXCInICsgc3RvcmVLZXkgKyAnXCIgYXMgYSBwcm9wIHRvIFwiJyArIGRpc3BsYXlOYW1lICsgJ1wiLicpKTtcblxuICAgICAgICBfdGhpcy5pbml0U2VsZWN0b3IoKTtcbiAgICAgICAgX3RoaXMuaW5pdFN1YnNjcmlwdGlvbigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IHJlY2VpdmVkIHN0b3JlIGZyb20gcHJvcHMsIGl0cyBzdWJzY3JpcHRpb24gc2hvdWxkIGJlIHRyYW5zcGFyZW50XG4gICAgICAgIC8vIHRvIGFueSBkZXNjZW5kYW50cyByZWNlaXZpbmcgc3RvcmUrc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dDsgaXQgcGFzc2VzIGFsb25nXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbiBwYXNzZWQgdG8gaXQuIE90aGVyd2lzZSwgaXQgc2hhZG93cyB0aGUgcGFyZW50IHN1YnNjcmlwdGlvbiwgd2hpY2ggYWxsb3dzXG4gICAgICAgIC8vIENvbm5lY3QgdG8gY29udHJvbCBvcmRlcmluZyBvZiBub3RpZmljYXRpb25zIHRvIGZsb3cgdG9wLWRvd24uXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnByb3BzTW9kZSA/IG51bGwgOiB0aGlzLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb24gfHwgdGhpcy5jb250ZXh0W3N1YnNjcmlwdGlvbktleV0sIF9yZWYyO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybjtcblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZmlyZXMgZHVyaW5nIHNlcnZlciBzaWRlIHJlbmRlcmluZywgYnV0IGNvbXBvbmVudERpZE1vdW50IGFuZFxuICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBkbyBub3QuIEJlY2F1c2Ugb2YgdGhpcywgdHJ5U3Vic2NyaWJlIGhhcHBlbnMgZHVyaW5nIC4uLmRpZE1vdW50LlxuICAgICAgICAvLyBPdGhlcndpc2UsIHVuc3Vic2NyaXB0aW9uIHdvdWxkIG5ldmVyIHRha2UgcGxhY2UgZHVyaW5nIFNTUiwgY2F1c2luZyBhIG1lbW9yeSBsZWFrLlxuICAgICAgICAvLyBUbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjb21wb25lbnQgbWF5IGhhdmUgdHJpZ2dlcmVkIGEgc3RhdGUgY2hhbmdlIGJ5XG4gICAgICAgIC8vIGRpc3BhdGNoaW5nIGFuIGFjdGlvbiBpbiBpdHMgY29tcG9uZW50V2lsbE1vdW50LCB3ZSBoYXZlIHRvIHJlLXJ1biB0aGUgc2VsZWN0IGFuZCBtYXliZVxuICAgICAgICAvLyByZS1yZW5kZXIuXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5ydW4obmV4dFByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicyA9IG5vb3A7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1biA9IG5vb3A7XG4gICAgICAgIHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5nZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAgIGludmFyaWFudCh3aXRoUmVmLCAnVG8gYWNjZXNzIHRoZSB3cmFwcGVkIGluc3RhbmNlLCB5b3UgbmVlZCB0byBzcGVjaWZ5ICcgKyAoJ3sgd2l0aFJlZjogdHJ1ZSB9IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50IG9mIHRoZSAnICsgbWV0aG9kTmFtZSArICcoKSBjYWxsLicpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZEluc3RhbmNlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2V0V3JhcHBlZEluc3RhbmNlID0gZnVuY3Rpb24gc2V0V3JhcHBlZEluc3RhbmNlKHJlZikge1xuICAgICAgICB0aGlzLndyYXBwZWRJbnN0YW5jZSA9IHJlZjtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmluaXRTZWxlY3RvciA9IGZ1bmN0aW9uIGluaXRTZWxlY3RvcigpIHtcbiAgICAgICAgdmFyIHNvdXJjZVNlbGVjdG9yID0gc2VsZWN0b3JGYWN0b3J5KHRoaXMuc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gbWFrZVNlbGVjdG9yU3RhdGVmdWwoc291cmNlU2VsZWN0b3IsIHRoaXMuc3RvcmUpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmluaXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBpbml0U3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuO1xuXG4gICAgICAgIC8vIHBhcmVudFN1YidzIHNvdXJjZSBzaG91bGQgbWF0Y2ggd2hlcmUgc3RvcmUgY2FtZSBmcm9tOiBwcm9wcyB2cy4gY29udGV4dC4gQSBjb21wb25lbnRcbiAgICAgICAgLy8gY29ubmVjdGVkIHRvIHRoZSBzdG9yZSB2aWEgcHJvcHMgc2hvdWxkbid0IHVzZSBzdWJzY3JpcHRpb24gZnJvbSBjb250ZXh0LCBvciB2aWNlIHZlcnNhLlxuICAgICAgICB2YXIgcGFyZW50U3ViID0gKHRoaXMucHJvcHNNb2RlID8gdGhpcy5wcm9wcyA6IHRoaXMuY29udGV4dClbc3Vic2NyaXB0aW9uS2V5XTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMuc3RvcmUsIHBhcmVudFN1YiwgdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIGBub3RpZnlOZXN0ZWRTdWJzYCBpcyBkdXBsaWNhdGVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY29tcG9uZW50IGlzICB1bm1vdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AsIHdoZXJlIGB0aGlzLnN1YnNjcmlwdGlvbmAgd2lsbCB0aGVuIGJlIG51bGwuIEFuXG4gICAgICAgIC8vIGV4dHJhIG51bGwgY2hlY2sgZXZlcnkgY2hhbmdlIGNhbiBiZSBhdm9pZGVkIGJ5IGNvcHlpbmcgdGhlIG1ldGhvZCBvbnRvIGB0aGlzYCBhbmQgdGhlblxuICAgICAgICAvLyByZXBsYWNpbmcgaXQgd2l0aCBhIG5vLW9wIG9uIHVubW91bnQuIFRoaXMgY2FuIHByb2JhYmx5IGJlIGF2b2lkZWQgaWYgU3Vic2NyaXB0aW9uJ3NcbiAgICAgICAgLy8gbGlzdGVuZXJzIGxvZ2ljIGlzIGNoYW5nZWQgdG8gbm90IGNhbGwgbGlzdGVuZXJzIHRoYXQgaGF2ZSBiZWVuIHVuc3Vic2NyaWJlZCBpbiB0aGVcbiAgICAgICAgLy8gbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcC5cbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzID0gdGhpcy5zdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHRoaXMuc3Vic2NyaXB0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLm9uU3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiBvblN0YXRlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUgPSB0aGlzLm5vdGlmeU5lc3RlZFN1YnNPbkNvbXBvbmVudERpZFVwZGF0ZTtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKGR1bW15U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5ub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIC8vIGBjb21wb25lbnREaWRVcGRhdGVgIGlzIGNvbmRpdGlvbmFsbHkgaW1wbGVtZW50ZWQgd2hlbiBgb25TdGF0ZUNoYW5nZWAgZGV0ZXJtaW5lcyBpdFxuICAgICAgICAvLyBuZWVkcyB0byBub3RpZnkgbmVzdGVkIHN1YnMuIE9uY2UgY2FsbGVkLCBpdCB1bmltcGxlbWVudHMgaXRzZWxmIHVudGlsIGZ1cnRoZXIgc3RhdGVcbiAgICAgICAgLy8gY2hhbmdlcyBvY2N1ci4gRG9pbmcgaXQgdGhpcyB3YXkgdnMgaGF2aW5nIGEgcGVybWFuZW50IGBjb21wb25lbnREaWRNb3VudGAgdGhhdCBkb2VzXG4gICAgICAgIC8vIGEgYm9vbGVhbiBjaGVjayBldmVyeSB0aW1lIGF2b2lkcyBhbiBleHRyYSBtZXRob2QgY2FsbCBtb3N0IG9mIHRoZSB0aW1lLCByZXN1bHRpbmdcbiAgICAgICAgLy8gaW4gc29tZSBwZXJmIGJvb3N0LlxuICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuc3Vic2NyaXB0aW9uKSAmJiB0aGlzLnN1YnNjcmlwdGlvbi5pc1N1YnNjcmliZWQoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmFkZEV4dHJhUHJvcHMgPSBmdW5jdGlvbiBhZGRFeHRyYVByb3BzKHByb3BzKSB7XG4gICAgICAgIGlmICghd2l0aFJlZiAmJiAhcmVuZGVyQ291bnRQcm9wICYmICEodGhpcy5wcm9wc01vZGUgJiYgdGhpcy5zdWJzY3JpcHRpb24pKSByZXR1cm4gcHJvcHM7XG4gICAgICAgIC8vIG1ha2UgYSBzaGFsbG93IGNvcHkgc28gdGhhdCBmaWVsZHMgYWRkZWQgZG9uJ3QgbGVhayB0byB0aGUgb3JpZ2luYWwgc2VsZWN0b3IuXG4gICAgICAgIC8vIHRoaXMgaXMgZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yICdyZWYnIHNpbmNlIHRoYXQncyBhIHJlZmVyZW5jZSBiYWNrIHRvIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaW5zdGFuY2UuIGEgc2luZ2xldG9uIG1lbW9pemVkIHNlbGVjdG9yIHdvdWxkIHRoZW4gYmUgaG9sZGluZyBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgLy8gaW5zdGFuY2UsIHByZXZlbnRpbmcgdGhlIGluc3RhbmNlIGZyb20gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWQsIGFuZCB0aGF0IHdvdWxkIGJlIGJhZFxuICAgICAgICB2YXIgd2l0aEV4dHJhcyA9IF9leHRlbmRzKHt9LCBwcm9wcyk7XG4gICAgICAgIGlmICh3aXRoUmVmKSB3aXRoRXh0cmFzLnJlZiA9IHRoaXMuc2V0V3JhcHBlZEluc3RhbmNlO1xuICAgICAgICBpZiAocmVuZGVyQ291bnRQcm9wKSB3aXRoRXh0cmFzW3JlbmRlckNvdW50UHJvcF0gPSB0aGlzLnJlbmRlckNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLnByb3BzTW9kZSAmJiB0aGlzLnN1YnNjcmlwdGlvbikgd2l0aEV4dHJhc1tzdWJzY3JpcHRpb25LZXldID0gdGhpcy5zdWJzY3JpcHRpb247XG4gICAgICAgIHJldHVybiB3aXRoRXh0cmFzO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzZWxlY3Rvci5lcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCB0aGlzLmFkZEV4dHJhUHJvcHMoc2VsZWN0b3IucHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbm5lY3Q7XG4gICAgfShDb21wb25lbnQpO1xuXG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgQ29ubmVjdC5jaGlsZENvbnRleHRUeXBlcyA9IGNoaWxkQ29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QuY29udGV4dFR5cGVzID0gY29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QucHJvcFR5cGVzID0gY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICAvLyBXZSBhcmUgaG90IHJlbG9hZGluZyFcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiAhPT0gdmVyc2lvbikge1xuICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgdGhpcy5pbml0U2VsZWN0b3IoKTtcblxuICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikgdGhpcy5zdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB0aGlzLmluaXRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB0aGlzLnN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9pc3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB2ZXJpZnlQbGFpbk9iamVjdCBmcm9tICcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCwgb3B0aW9ucykge1xuICAgIHZhciBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn1cblxuLy8gZGVwZW5kc09uT3duUHJvcHMgaXMgdXNlZCBieSBjcmVhdGVNYXBUb1Byb3BzUHJveHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGFzcyBwcm9wcyBhcyBhcmdzXG4vLyB0byB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyB3cmFwcGVkLiBJdCBpcyBhbHNvIHVzZWQgYnkgbWFrZVB1cmVQcm9wc1NlbGVjdG9yIHRvIGRldGVybWluZVxuLy8gd2hldGhlciBtYXBUb1Byb3BzIG5lZWRzIHRvIGJlIGludm9rZWQgd2hlbiBwcm9wcyBoYXZlIGNoYW5nZWQuXG4vLyBcbi8vIEEgbGVuZ3RoIG9mIG9uZSBzaWduYWxzIHRoYXQgbWFwVG9Qcm9wcyBkb2VzIG5vdCBkZXBlbmQgb24gcHJvcHMgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudC5cbi8vIEEgbGVuZ3RoIG9mIHplcm8gaXMgYXNzdW1lZCB0byBtZWFuIG1hcFRvUHJvcHMgaXMgZ2V0dGluZyBhcmdzIHZpYSBhcmd1bWVudHMgb3IgLi4uYXJncyBhbmRcbi8vIHRoZXJlZm9yZSBub3QgcmVwb3J0aW5nIGl0cyBsZW5ndGggYWNjdXJhdGVseS4uXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcykge1xuICByZXR1cm4gbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyAhPT0gbnVsbCAmJiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzICE9PSB1bmRlZmluZWQgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59XG5cbi8vIFVzZWQgYnkgd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24gYW5kIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uLFxuLy8gdGhpcyBmdW5jdGlvbiB3cmFwcyBtYXBUb1Byb3BzIGluIGEgcHJveHkgZnVuY3Rpb24gd2hpY2ggZG9lcyBzZXZlcmFsIHRoaW5nczpcbi8vIFxuLy8gICogRGV0ZWN0cyB3aGV0aGVyIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBkZXBlbmRzIG9uIHByb3BzLCB3aGljaFxuLy8gICAgaXMgdXNlZCBieSBzZWxlY3RvckZhY3RvcnkgdG8gZGVjaWRlIGlmIGl0IHNob3VsZCByZWludm9rZSBvbiBwcm9wcyBjaGFuZ2VzLlxuLy8gICAgXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCBoYW5kbGVzIG1hcFRvUHJvcHMgaWYgcmV0dXJucyBhbm90aGVyIGZ1bmN0aW9uLCBhbmQgdHJlYXRzIHRoYXRcbi8vICAgIG5ldyBmdW5jdGlvbiBhcyB0aGUgdHJ1ZSBtYXBUb1Byb3BzIGZvciBzdWJzZXF1ZW50IGNhbGxzLlxuLy8gICAgXG4vLyAgKiBPbiBmaXJzdCBjYWxsLCB2ZXJpZmllcyB0aGUgZmlyc3QgcmVzdWx0IGlzIGEgcGxhaW4gb2JqZWN0LCBpbiBvcmRlciB0byB3YXJuXG4vLyAgICB0aGUgZGV2ZWxvcGVyIHRoYXQgdGhlaXIgbWFwVG9Qcm9wcyBmdW5jdGlvbiBpcyBub3QgcmV0dXJuaW5nIGEgdmFsaWQgcmVzdWx0LlxuLy8gICAgXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCBfcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZTtcblxuICAgIHZhciBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gpO1xuICAgIH07XG5cbiAgICAvLyBhbGxvdyBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IHRvIGdldCBvd25Qcm9wc1xuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZTtcblxuICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBmdW5jdGlvbiBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBtYXBUb1Byb3BzO1xuICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKTtcbiAgICAgIHZhciBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuXG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBwcm9wcztcbiAgICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhwcm9wcyk7XG4gICAgICAgIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB2ZXJpZnlQbGFpbk9iamVjdChwcm9wcywgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpO1xuXG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvd3JhcE1hcFRvUHJvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBQcm92aWRlciwgeyBjcmVhdGVQcm92aWRlciB9IGZyb20gJy4vY29tcG9uZW50cy9Qcm92aWRlcic7XG5pbXBvcnQgY29ubmVjdEFkdmFuY2VkIGZyb20gJy4vY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQnO1xuaW1wb3J0IGNvbm5lY3QgZnJvbSAnLi9jb25uZWN0L2Nvbm5lY3QnO1xuXG5leHBvcnQgeyBQcm92aWRlciwgY3JlYXRlUHJvdmlkZXIsIGNvbm5lY3RBZHZhbmNlZCwgY29ubmVjdCB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtcmVkdXgvZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmV4cG9ydCB2YXIgc3Vic2NyaXB0aW9uU2hhcGUgPSBQcm9wVHlwZXMuc2hhcGUoe1xuICB0cnlTdWJzY3JpYmU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHRyeVVuc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBub3RpZnlOZXN0ZWRTdWJzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBpc1N1YnNjcmliZWQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG5leHBvcnQgdmFyIHN0b3JlU2hhcGUgPSBQcm9wVHlwZXMuc2hhcGUoe1xuICBzdWJzY3JpYmU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGRpc3BhdGNoOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBnZXRTdGF0ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy9Qcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vd2FybmluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVBsYWluT2JqZWN0KHZhbHVlLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybmluZyhtZXRob2ROYW1lICsgJygpIGluICcgKyBkaXNwbGF5TmFtZSArICcgbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQgJyArIHZhbHVlICsgJy4nKTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtcmVkdXgvZXMvdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJyBDaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgfHwgKG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgPSB7fSk7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAobWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBlbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLic7XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWMoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQsIG51bGwpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XG5cbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyAnaXRcXCdzIGRlZmluZWQgaW4uJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5mbyArPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbiAgfSxcblxuICBjbG9uZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudFZhbGlkYXRvcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfZGVmaW5lRW51bWVyYWJsZVByb3BlcnRpZXMob2JqLCBkZXNjcykgeyBmb3IgKHZhciBrZXkgaW4gZGVzY3MpIHsgdmFyIGRlc2MgPSBkZXNjc1trZXldOyBkZXNjLmNvbmZpZ3VyYWJsZSA9IGRlc2MuZW51bWVyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzYykgZGVzYy53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgZGVzYyk7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyBub29wLCBrVHJ1ZSwgaXMsIGxvZyBhcyBfbG9nLCBjaGVjaywgZGVmZXJyZWQsIHVpZCBhcyBuZXh0RWZmZWN0SWQsIGFycmF5LCByZW1vdmUsIG9iamVjdCwgVEFTSywgQ0FOQ0VMLCBTRUxGX0NBTkNFTExBVElPTiwgbWFrZUl0ZXJhdG9yLCBjcmVhdGVTZXRDb250ZXh0V2FybmluZywgZGVwcmVjYXRlLCB1cGRhdGVJbmNlbnRpdmUgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGFzYXAsIHN1c3BlbmQsIGZsdXNoIH0gZnJvbSAnLi9zY2hlZHVsZXInO1xuaW1wb3J0IHsgYXNFZmZlY3QgfSBmcm9tICcuL2lvJztcbmltcG9ydCB7IHN0ZENoYW5uZWwgYXMgX3N0ZENoYW5uZWwsIGV2ZW50Q2hhbm5lbCwgaXNFbmQgfSBmcm9tICcuL2NoYW5uZWwnO1xuaW1wb3J0IHsgYnVmZmVycyB9IGZyb20gJy4vYnVmZmVycyc7XG5cbmV4cG9ydCB2YXIgTk9UX0lURVJBVE9SX0VSUk9SID0gJ3Byb2MgZmlyc3QgYXJndW1lbnQgKFNhZ2EgZnVuY3Rpb24gcmVzdWx0KSBtdXN0IGJlIGFuIGl0ZXJhdG9yJztcblxuZXhwb3J0IHZhciBDSEFOTkVMX0VORCA9IHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnQEByZWR1eC1zYWdhL0NIQU5ORUxfRU5EJztcbiAgfVxufTtcbmV4cG9ydCB2YXIgVEFTS19DQU5DRUwgPSB7XG4gIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0BAcmVkdXgtc2FnYS9UQVNLX0NBTkNFTCc7XG4gIH1cbn07XG5cbnZhciBtYXRjaGVycyA9IHtcbiAgd2lsZGNhcmQ6IGZ1bmN0aW9uIHdpbGRjYXJkKCkge1xuICAgIHJldHVybiBrVHJ1ZTtcbiAgfSxcbiAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQocGF0dGVybikge1xuICAgIHJldHVybiAodHlwZW9mIHBhdHRlcm4gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdHRlcm4pKSA9PT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC50eXBlID09PSBwYXR0ZXJuO1xuICAgIH0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC50eXBlID09PSBTdHJpbmcocGF0dGVybik7XG4gICAgfTtcbiAgfSxcbiAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KHBhdHRlcm5zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgcmV0dXJuIHBhdHRlcm5zLnNvbWUoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIocCkoaW5wdXQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcbiAgcHJlZGljYXRlOiBmdW5jdGlvbiBwcmVkaWNhdGUoX3ByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBfcHJlZGljYXRlKGlucHV0KTtcbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBtYXRjaGVyKHBhdHRlcm4pIHtcbiAgcmV0dXJuIChwYXR0ZXJuID09PSAnKicgPyBtYXRjaGVycy53aWxkY2FyZCA6IGlzLmFycmF5KHBhdHRlcm4pID8gbWF0Y2hlcnMuYXJyYXkgOiBpcy5zdHJpbmdhYmxlRnVuYyhwYXR0ZXJuKSA/IG1hdGNoZXJzLmRlZmF1bHQgOiBpcy5mdW5jKHBhdHRlcm4pID8gbWF0Y2hlcnMucHJlZGljYXRlIDogbWF0Y2hlcnMuZGVmYXVsdCkocGF0dGVybik7XG59XG5cbi8qKlxuICBVc2VkIHRvIHRyYWNrIGEgcGFyZW50IHRhc2sgYW5kIGl0cyBmb3Jrc1xuICBJbiB0aGUgbmV3IGZvcmsgbW9kZWwsIGZvcmtlZCB0YXNrcyBhcmUgYXR0YWNoZWQgYnkgZGVmYXVsdCB0byB0aGVpciBwYXJlbnRcbiAgV2UgbW9kZWwgdGhpcyB1c2luZyB0aGUgY29uY2VwdCBvZiBQYXJlbnQgdGFzayAmJiBtYWluIFRhc2tcbiAgbWFpbiB0YXNrIGlzIHRoZSBtYWluIGZsb3cgb2YgdGhlIGN1cnJlbnQgR2VuZXJhdG9yLCB0aGUgcGFyZW50IHRhc2tzIGlzIHRoZVxuICBhZ2dyZWdhdGlvbiBvZiB0aGUgbWFpbiB0YXNrcyArIGFsbCBpdHMgZm9ya2VkIHRhc2tzLlxuICBUaHVzIHRoZSB3aG9sZSBtb2RlbCByZXByZXNlbnRzIGFuIGV4ZWN1dGlvbiB0cmVlIHdpdGggbXVsdGlwbGUgYnJhbmNoZXMgKHZzIHRoZVxuICBsaW5lYXIgZXhlY3V0aW9uIHRyZWUgaW4gc2VxdWVudGlhbCAobm9uIHBhcmFsbGVsKSBwcm9ncmFtbWluZylcblxuICBBIHBhcmVudCB0YXNrcyBoYXMgdGhlIGZvbGxvd2luZyBzZW1hbnRpY3NcbiAgLSBJdCBjb21wbGV0ZXMgaWYgYWxsIGl0cyBmb3JrcyBlaXRoZXIgY29tcGxldGUgb3IgYWxsIGNhbmNlbGxlZFxuICAtIElmIGl0J3MgY2FuY2VsbGVkLCBhbGwgZm9ya3MgYXJlIGNhbmNlbGxlZCBhcyB3ZWxsXG4gIC0gSXQgYWJvcnRzIGlmIGFueSB1bmNhdWdodCBlcnJvciBidWJibGVzIHVwIGZyb20gZm9ya3NcbiAgLSBJZiBpdCBjb21wbGV0ZXMsIHRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIG9uZSByZXR1cm5lZCBieSB0aGUgbWFpbiB0YXNrXG4qKi9cbmZ1bmN0aW9uIGZvcmtRdWV1ZShuYW1lLCBtYWluVGFzaywgY2IpIHtcbiAgdmFyIHRhc2tzID0gW10sXG4gICAgICByZXN1bHQgPSB2b2lkIDAsXG4gICAgICBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgYWRkVGFzayhtYWluVGFzayk7XG5cbiAgZnVuY3Rpb24gYWJvcnQoZXJyKSB7XG4gICAgY2FuY2VsQWxsKCk7XG4gICAgY2IoZXJyLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFRhc2sodGFzaykge1xuICAgIHRhc2tzLnB1c2godGFzayk7XG4gICAgdGFzay5jb250ID0gZnVuY3Rpb24gKHJlcywgaXNFcnIpIHtcbiAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZW1vdmUodGFza3MsIHRhc2spO1xuICAgICAgdGFzay5jb250ID0gbm9vcDtcbiAgICAgIGlmIChpc0Vycikge1xuICAgICAgICBhYm9ydChyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhc2sgPT09IG1haW5UYXNrKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICBjYihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAvLyB0YXNrLmNvbnQuY2FuY2VsID0gdGFzay5jYW5jZWxcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFsbCgpIHtcbiAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgdGFza3MuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgdC5jb250ID0gbm9vcDtcbiAgICAgIHQuY2FuY2VsKCk7XG4gICAgfSk7XG4gICAgdGFza3MgPSBbXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRkVGFzazogYWRkVGFzayxcbiAgICBjYW5jZWxBbGw6IGNhbmNlbEFsbCxcbiAgICBhYm9ydDogYWJvcnQsXG4gICAgZ2V0VGFza3M6IGZ1bmN0aW9uIGdldFRhc2tzKCkge1xuICAgICAgcmV0dXJuIHRhc2tzO1xuICAgIH0sXG4gICAgdGFza05hbWVzOiBmdW5jdGlvbiB0YXNrTmFtZXMoKSB7XG4gICAgICByZXR1cm4gdGFza3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lm5hbWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhc2tJdGVyYXRvcihfcmVmKSB7XG4gIHZhciBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgZm4gPSBfcmVmLmZuLFxuICAgICAgYXJncyA9IF9yZWYuYXJncztcblxuICBpZiAoaXMuaXRlcmF0b3IoZm4pKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gY2F0Y2ggc3luY2hyb25vdXMgZmFpbHVyZXM7IHNlZSAjMTUyIGFuZCAjNDQxXG4gIHZhciByZXN1bHQgPSB2b2lkIDAsXG4gICAgICBlcnJvciA9IHZvaWQgMDtcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBlcnI7XG4gIH1cblxuICAvLyBpLmUuIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHJldHVybnMgYW4gaXRlcmF0b3JcbiAgaWYgKGlzLml0ZXJhdG9yKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gZG8gbm90IGJ1YmJsZSB1cCBzeW5jaHJvbm91cyBmYWlsdXJlcyBmb3IgZGV0YWNoZWQgZm9ya3NcbiAgLy8gaW5zdGVhZCBjcmVhdGUgYSBmYWlsZWQgdGFzay4gU2VlICMxNTIgYW5kICM0NDFcbiAgcmV0dXJuIGVycm9yID8gbWFrZUl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSkgOiBtYWtlSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYyA9IHZvaWQgMDtcbiAgICB2YXIgZWZmID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IHJlc3VsdCB9O1xuICAgIHZhciByZXQgPSBmdW5jdGlvbiByZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIGlmICghcGMpIHtcbiAgICAgICAgcGMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldChhcmcpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG59XG5cbnZhciB3cmFwSGVscGVyID0gZnVuY3Rpb24gd3JhcEhlbHBlcihoZWxwZXIpIHtcbiAgcmV0dXJuIHsgZm46IGhlbHBlciB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvYyhpdGVyYXRvcikge1xuICB2YXIgc3Vic2NyaWJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5vb3A7XG4gIH07XG4gIHZhciBkaXNwYXRjaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbm9vcDtcbiAgdmFyIGdldFN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBub29wO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgdmFyIHBhcmVudEVmZmVjdElkID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiAwO1xuICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogJ2Fub255bW91cyc7XG4gIHZhciBjb250ID0gYXJndW1lbnRzWzhdO1xuXG4gIGNoZWNrKGl0ZXJhdG9yLCBpcy5pdGVyYXRvciwgTk9UX0lURVJBVE9SX0VSUk9SKTtcblxuICB2YXIgZWZmZWN0c1N0cmluZyA9ICdbLi4uZWZmZWN0c10nO1xuICB2YXIgcnVuUGFyYWxsZWxFZmZlY3QgPSBkZXByZWNhdGUocnVuQWxsRWZmZWN0LCB1cGRhdGVJbmNlbnRpdmUoZWZmZWN0c1N0cmluZywgJ2FsbCgnICsgZWZmZWN0c1N0cmluZyArICcpJykpO1xuXG4gIHZhciBzYWdhTW9uaXRvciA9IG9wdGlvbnMuc2FnYU1vbml0b3IsXG4gICAgICBsb2dnZXIgPSBvcHRpb25zLmxvZ2dlcixcbiAgICAgIG9uRXJyb3IgPSBvcHRpb25zLm9uRXJyb3I7XG5cbiAgdmFyIGxvZyA9IGxvZ2dlciB8fCBfbG9nO1xuICB2YXIgc3RkQ2hhbm5lbCA9IF9zdGRDaGFubmVsKHN1YnNjcmliZSk7XG4gIHZhciB0YXNrQ29udGV4dCA9IE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCk7XG4gIC8qKlxuICAgIFRyYWNrcyB0aGUgY3VycmVudCBlZmZlY3QgY2FuY2VsbGF0aW9uXG4gICAgRWFjaCB0aW1lIHRoZSBnZW5lcmF0b3IgcHJvZ3Jlc3Nlcy4gY2FsbGluZyBydW5FZmZlY3Qgd2lsbCBzZXQgYSBuZXcgdmFsdWVcbiAgICBvbiBpdC4gSXQgYWxsb3dzIHByb3BhZ2F0aW5nIGNhbmNlbGxhdGlvbiB0byBjaGlsZCBlZmZlY3RzXG4gICoqL1xuICBuZXh0LmNhbmNlbCA9IG5vb3A7XG5cbiAgLyoqXG4gICAgQ3JlYXRlcyBhIG5ldyB0YXNrIGRlc2NyaXB0b3IgZm9yIHRoaXMgZ2VuZXJhdG9yLCBXZSdsbCBhbHNvIGNyZWF0ZSBhIG1haW4gdGFza1xuICAgIHRvIHRyYWNrIHRoZSBtYWluIGZsb3cgKGJlc2lkZXMgb3RoZXIgZm9ya2VkIHRhc2tzKVxuICAqKi9cbiAgdmFyIHRhc2sgPSBuZXdUYXNrKHBhcmVudEVmZmVjdElkLCBuYW1lLCBpdGVyYXRvciwgY29udCk7XG4gIHZhciBtYWluVGFzayA9IHsgbmFtZTogbmFtZSwgY2FuY2VsOiBjYW5jZWxNYWluLCBpc1J1bm5pbmc6IHRydWUgfTtcbiAgdmFyIHRhc2tRdWV1ZSA9IGZvcmtRdWV1ZShuYW1lLCBtYWluVGFzaywgZW5kKTtcblxuICAvKipcbiAgICBjYW5jZWxsYXRpb24gb2YgdGhlIG1haW4gdGFzay4gV2UnbGwgc2ltcGx5IHJlc3VtZSB0aGUgR2VuZXJhdG9yIHdpdGggYSBDYW5jZWxcbiAgKiovXG4gIGZ1bmN0aW9uIGNhbmNlbE1haW4oKSB7XG4gICAgaWYgKG1haW5UYXNrLmlzUnVubmluZyAmJiAhbWFpblRhc2suaXNDYW5jZWxsZWQpIHtcbiAgICAgIG1haW5UYXNrLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIG5leHQoVEFTS19DQU5DRUwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgIFRoaXMgbWF5IGJlIGNhbGxlZCBieSBhIHBhcmVudCBnZW5lcmF0b3IgdG8gdHJpZ2dlci9wcm9wYWdhdGUgY2FuY2VsbGF0aW9uXG4gICAgY2FuY2VsIGFsbCBwZW5kaW5nIHRhc2tzIChpbmNsdWRpbmcgdGhlIG1haW4gdGFzayksIHRoZW4gZW5kIHRoZSBjdXJyZW50IHRhc2suXG4gICAgIENhbmNlbGxhdGlvbiBwcm9wYWdhdGVzIGRvd24gdG8gdGhlIHdob2xlIGV4ZWN1dGlvbiB0cmVlIGhvbGRlZCBieSB0aGlzIFBhcmVudCB0YXNrXG4gICAgSXQncyBhbHNvIHByb3BhZ2F0ZWQgdG8gYWxsIGpvaW5lcnMgb2YgdGhpcyB0YXNrIGFuZCB0aGVpciBleGVjdXRpb24gdHJlZS9qb2luZXJzXG4gICAgIENhbmNlbGxhdGlvbiBpcyBub29wIGZvciB0ZXJtaW5hdGVkL0NhbmNlbGxlZCB0YXNrcyB0YXNrc1xuICAqKi9cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIC8qKlxuICAgICAgV2UgbmVlZCB0byBjaGVjayBib3RoIFJ1bm5pbmcgYW5kIENhbmNlbGxlZCBzdGF0dXNcbiAgICAgIFRhc2tzIGNhbiBiZSBDYW5jZWxsZWQgYnV0IHN0aWxsIFJ1bm5pbmdcbiAgICAqKi9cbiAgICBpZiAoaXRlcmF0b3IuX2lzUnVubmluZyAmJiAhaXRlcmF0b3IuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICBpdGVyYXRvci5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgdGFza1F1ZXVlLmNhbmNlbEFsbCgpO1xuICAgICAgLyoqXG4gICAgICAgIEVuZGluZyB3aXRoIGEgTmV2ZXIgcmVzdWx0IHdpbGwgcHJvcGFnYXRlIHRoZSBDYW5jZWxsYXRpb24gdG8gYWxsIGpvaW5lcnNcbiAgICAgICoqL1xuICAgICAgZW5kKFRBU0tfQ0FOQ0VMKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAgYXR0YWNoZXMgY2FuY2VsbGF0aW9uIGxvZ2ljIHRvIHRoaXMgdGFzaydzIGNvbnRpbnVhdGlvblxuICAgIHRoaXMgd2lsbCBwZXJtaXQgY2FuY2VsbGF0aW9uIHRvIHByb3BhZ2F0ZSBkb3duIHRoZSBjYWxsIGNoYWluXG4gICoqL1xuICBjb250ICYmIChjb250LmNhbmNlbCA9IGNhbmNlbCk7XG5cbiAgLy8gdHJhY2tzIHRoZSBydW5uaW5nIHN0YXR1c1xuICBpdGVyYXRvci5faXNSdW5uaW5nID0gdHJ1ZTtcblxuICAvLyBraWNrcyB1cCB0aGUgZ2VuZXJhdG9yXG4gIG5leHQoKTtcblxuICAvLyB0aGVuIHJldHVybiB0aGUgdGFzayBkZXNjcmlwdG9yIHRvIHRoZSBjYWxsZXJcbiAgcmV0dXJuIHRhc2s7XG5cbiAgLyoqXG4gICAgVGhpcyBpcyB0aGUgZ2VuZXJhdG9yIGRyaXZlclxuICAgIEl0J3MgYSByZWN1cnNpdmUgYXN5bmMvY29udGludWF0aW9uIGZ1bmN0aW9uIHdoaWNoIGNhbGxzIGl0c2VsZlxuICAgIHVudGlsIHRoZSBnZW5lcmF0b3IgdGVybWluYXRlcyBvciB0aHJvd3NcbiAgKiovXG4gIGZ1bmN0aW9uIG5leHQoYXJnLCBpc0Vycikge1xuICAgIC8vIFByZXZlbnRpdmUgbWVhc3VyZS4gSWYgd2UgZW5kIHVwIGhlcmUsIHRoZW4gdGhlcmUgaXMgcmVhbGx5IHNvbWV0aGluZyB3cm9uZ1xuICAgIGlmICghbWFpblRhc2suaXNSdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byByZXN1bWUgYW4gYWxyZWFkeSBmaW5pc2hlZCBnZW5lcmF0b3InKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGlmIChpc0Vycikge1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci50aHJvdyhhcmcpO1xuICAgICAgfSBlbHNlIGlmIChhcmcgPT09IFRBU0tfQ0FOQ0VMKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgIGdldHRpbmcgVEFTS19DQU5DRUwgYXV0b21hdGljYWxseSBjYW5jZWxzIHRoZSBtYWluIHRhc2tcbiAgICAgICAgICBXZSBjYW4gZ2V0IHRoaXMgdmFsdWUgaGVyZVxuICAgICAgICAgICAtIEJ5IGNhbmNlbGxpbmcgdGhlIHBhcmVudCB0YXNrIG1hbnVhbGx5XG4gICAgICAgICAgLSBCeSBqb2luaW5nIGEgQ2FuY2VsbGVkIHRhc2tcbiAgICAgICAgKiovXG4gICAgICAgIG1haW5UYXNrLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAgQ2FuY2VscyB0aGUgY3VycmVudCBlZmZlY3Q7IHRoaXMgd2lsbCBwcm9wYWdhdGUgdGhlIGNhbmNlbGxhdGlvbiBkb3duIHRvIGFueSBjYWxsZWQgdGFza3NcbiAgICAgICAgKiovXG4gICAgICAgIG5leHQuY2FuY2VsKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgIElmIHRoaXMgR2VuZXJhdG9yIGhhcyBhIGByZXR1cm5gIG1ldGhvZCB0aGVuIGludm9rZXMgaXRcbiAgICAgICAgICBUaGlzIHdpbGwganVtcCB0byB0aGUgZmluYWxseSBibG9ja1xuICAgICAgICAqKi9cbiAgICAgICAgcmVzdWx0ID0gaXMuZnVuYyhpdGVyYXRvci5yZXR1cm4pID8gaXRlcmF0b3IucmV0dXJuKFRBU0tfQ0FOQ0VMKSA6IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IFRBU0tfQ0FOQ0VMIH07XG4gICAgICB9IGVsc2UgaWYgKGFyZyA9PT0gQ0hBTk5FTF9FTkQpIHtcbiAgICAgICAgLy8gV2UgZ2V0IENIQU5ORUxfRU5EIGJ5IHRha2luZyBmcm9tIGEgY2hhbm5lbCB0aGF0IGVuZGVkIHVzaW5nIGB0YWtlYCAoYW5kIG5vdCBgdGFrZW1gIHVzZWQgdG8gdHJhcCBFbmQgb2YgY2hhbm5lbHMpXG4gICAgICAgIHJlc3VsdCA9IGlzLmZ1bmMoaXRlcmF0b3IucmV0dXJuKSA/IGl0ZXJhdG9yLnJldHVybigpIDogeyBkb25lOiB0cnVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KGFyZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcnVuRWZmZWN0KHJlc3VsdC52YWx1ZSwgcGFyZW50RWZmZWN0SWQsICcnLCBuZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgIFRoaXMgR2VuZXJhdG9yIGhhcyBlbmRlZCwgdGVybWluYXRlIHRoZSBtYWluIHRhc2sgYW5kIG5vdGlmeSB0aGUgZm9yayBxdWV1ZVxuICAgICAgICAqKi9cbiAgICAgICAgbWFpblRhc2suaXNNYWluUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBtYWluVGFzay5jb250ICYmIG1haW5UYXNrLmNvbnQocmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG1haW5UYXNrLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgIGxvZygnZXJyb3InLCAndW5jYXVnaHQgYXQgJyArIG5hbWUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbWFpblRhc2suaXNNYWluUnVubmluZyA9IGZhbHNlO1xuICAgICAgbWFpblRhc2suY29udChlcnJvciwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kKHJlc3VsdCwgaXNFcnIpIHtcbiAgICBpdGVyYXRvci5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgc3RkQ2hhbm5lbC5jbG9zZSgpO1xuICAgIGlmICghaXNFcnIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiByZXN1bHQgPT09IFRBU0tfQ0FOQ0VMKSB7XG4gICAgICAgIGxvZygnaW5mbycsIG5hbWUgKyAnIGhhcyBiZWVuIGNhbmNlbGxlZCcsICcnKTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdG9yLl9yZXN1bHQgPSByZXN1bHQ7XG4gICAgICBpdGVyYXRvci5fZGVmZXJyZWRFbmQgJiYgaXRlcmF0b3IuX2RlZmVycmVkRW5kLnJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJlc3VsdC5zYWdhU3RhY2sgPSAnYXQgJyArIG5hbWUgKyAnIFxcbiAnICsgKHJlc3VsdC5zYWdhU3RhY2sgfHwgcmVzdWx0LnN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGFzay5jb250KSB7XG4gICAgICAgIGxvZygnZXJyb3InLCAndW5jYXVnaHQnLCByZXN1bHQuc2FnYVN0YWNrIHx8IHJlc3VsdC5zdGFjayk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvciAmJiBvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpdGVyYXRvci5fZXJyb3IgPSByZXN1bHQ7XG4gICAgICBpdGVyYXRvci5faXNBYm9ydGVkID0gdHJ1ZTtcbiAgICAgIGl0ZXJhdG9yLl9kZWZlcnJlZEVuZCAmJiBpdGVyYXRvci5fZGVmZXJyZWRFbmQucmVqZWN0KHJlc3VsdCk7XG4gICAgfVxuICAgIHRhc2suY29udCAmJiB0YXNrLmNvbnQocmVzdWx0LCBpc0Vycik7XG4gICAgdGFzay5qb2luZXJzLmZvckVhY2goZnVuY3Rpb24gKGopIHtcbiAgICAgIHJldHVybiBqLmNiKHJlc3VsdCwgaXNFcnIpO1xuICAgIH0pO1xuICAgIHRhc2suam9pbmVycyA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBydW5FZmZlY3QoZWZmZWN0LCBwYXJlbnRFZmZlY3RJZCkge1xuICAgIHZhciBsYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJyc7XG4gICAgdmFyIGNiID0gYXJndW1lbnRzWzNdO1xuXG4gICAgdmFyIGVmZmVjdElkID0gbmV4dEVmZmVjdElkKCk7XG4gICAgc2FnYU1vbml0b3IgJiYgc2FnYU1vbml0b3IuZWZmZWN0VHJpZ2dlcmVkKHsgZWZmZWN0SWQ6IGVmZmVjdElkLCBwYXJlbnRFZmZlY3RJZDogcGFyZW50RWZmZWN0SWQsIGxhYmVsOiBsYWJlbCwgZWZmZWN0OiBlZmZlY3QgfSk7XG5cbiAgICAvKipcbiAgICAgIGNvbXBsZXRpb24gY2FsbGJhY2sgYW5kIGNhbmNlbCBjYWxsYmFjayBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlXG4gICAgICBXZSBjYW4ndCBjYW5jZWwgYW4gYWxyZWFkeSBjb21wbGV0ZWQgZWZmZWN0XG4gICAgICBBbmQgV2UgY2FuJ3QgY29tcGxldGUgYW4gYWxyZWFkeSBjYW5jZWxsZWQgZWZmZWN0SWRcbiAgICAqKi9cbiAgICB2YXIgZWZmZWN0U2V0dGxlZCA9IHZvaWQgMDtcblxuICAgIC8vIENvbXBsZXRpb24gY2FsbGJhY2sgcGFzc2VkIHRvIHRoZSBhcHByb3ByaWF0ZSBlZmZlY3QgcnVubmVyXG4gICAgZnVuY3Rpb24gY3VyckNiKHJlcywgaXNFcnIpIHtcbiAgICAgIGlmIChlZmZlY3RTZXR0bGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZWZmZWN0U2V0dGxlZCA9IHRydWU7XG4gICAgICBjYi5jYW5jZWwgPSBub29wOyAvLyBkZWZlbnNpdmUgbWVhc3VyZVxuICAgICAgaWYgKHNhZ2FNb25pdG9yKSB7XG4gICAgICAgIGlzRXJyID8gc2FnYU1vbml0b3IuZWZmZWN0UmVqZWN0ZWQoZWZmZWN0SWQsIHJlcykgOiBzYWdhTW9uaXRvci5lZmZlY3RSZXNvbHZlZChlZmZlY3RJZCwgcmVzKTtcbiAgICAgIH1cbiAgICAgIGNiKHJlcywgaXNFcnIpO1xuICAgIH1cbiAgICAvLyB0cmFja3MgZG93biB0aGUgY3VycmVudCBjYW5jZWxcbiAgICBjdXJyQ2IuY2FuY2VsID0gbm9vcDtcblxuICAgIC8vIHNldHVwIGNhbmNlbGxhdGlvbiBsb2dpYyBvbiB0aGUgcGFyZW50IGNiXG4gICAgY2IuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcHJldmVudHMgY2FuY2VsbGluZyBhbiBhbHJlYWR5IGNvbXBsZXRlZCBlZmZlY3RcbiAgICAgIGlmIChlZmZlY3RTZXR0bGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZWZmZWN0U2V0dGxlZCA9IHRydWU7XG4gICAgICAvKipcbiAgICAgICAgcHJvcGFnYXRlcyBjYW5jZWwgZG93bndhcmRcbiAgICAgICAgY2F0Y2ggdW5jYXVnaHQgY2FuY2VsbGF0aW9ucyBlcnJvcnM7IHNpbmNlIHdlIGNhbiBubyBsb25nZXIgY2FsbCB0aGUgY29tcGxldGlvblxuICAgICAgICBjYWxsYmFjaywgbG9nIGVycm9ycyByYWlzZWQgZHVyaW5nIGNhbmNlbGxhdGlvbnMgaW50byB0aGUgY29uc29sZVxuICAgICAgKiovXG4gICAgICB0cnkge1xuICAgICAgICBjdXJyQ2IuY2FuY2VsKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nKCdlcnJvcicsICd1bmNhdWdodCBhdCAnICsgbmFtZSwgZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgY3VyckNiLmNhbmNlbCA9IG5vb3A7IC8vIGRlZmVuc2l2ZSBtZWFzdXJlXG5cbiAgICAgIHNhZ2FNb25pdG9yICYmIHNhZ2FNb25pdG9yLmVmZmVjdENhbmNlbGxlZChlZmZlY3RJZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgZWFjaCBlZmZlY3QgcnVubmVyIG11c3QgYXR0YWNoIGl0cyBvd24gbG9naWMgb2YgY2FuY2VsbGF0aW9uIHRvIHRoZSBwcm92aWRlZCBjYWxsYmFja1xuICAgICAgaXQgYWxsb3dzIHRoaXMgZ2VuZXJhdG9yIHRvIHByb3BhZ2F0ZSBjYW5jZWxsYXRpb24gZG93bndhcmQuXG4gICAgICAgQVRURU5USU9OISBlZmZlY3QgcnVubmVycyBtdXN0IHNldHVwIHRoZSBjYW5jZWwgbG9naWMgYnkgc2V0dGluZyBjYi5jYW5jZWwgPSBbY2FuY2VsTWV0aG9kXVxuICAgICAgQW5kIHRoZSBzZXR1cCBtdXN0IG9jY3VyIGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFja1xuICAgICAgIFRoaXMgaXMgYSBzb3J0IG9mIGludmVyc2lvbiBvZiBjb250cm9sOiBjYWxsZWQgYXN5bmMgZnVuY3Rpb25zIGFyZSByZXNwb25zaWJsZVxuICAgICAgZm9yIGNvbXBsZXRpbmcgdGhlIGZsb3cgYnkgY2FsbGluZyB0aGUgcHJvdmlkZWQgY29udGludWF0aW9uOyB3aGlsZSBjYWxsZXIgZnVuY3Rpb25zXG4gICAgICBhcmUgcmVzcG9uc2libGUgZm9yIGFib3J0aW5nIHRoZSBjdXJyZW50IGZsb3cgYnkgY2FsbGluZyB0aGUgYXR0YWNoZWQgY2FuY2VsIGZ1bmN0aW9uXG4gICAgICAgTGlicmFyeSB1c2VycyBjYW4gYXR0YWNoIHRoZWlyIG93biBjYW5jZWxsYXRpb24gbG9naWMgdG8gcHJvbWlzZXMgYnkgZGVmaW5pbmcgYVxuICAgICAgcHJvbWlzZVtDQU5DRUxdIG1ldGhvZCBpbiB0aGVpciByZXR1cm5lZCBwcm9taXNlc1xuICAgICAgQVRURU5USU9OISBjYWxsaW5nIGNhbmNlbCBtdXN0IGhhdmUgbm8gZWZmZWN0IG9uIGFuIGFscmVhZHkgY29tcGxldGVkIG9yIGNhbmNlbGxlZCBlZmZlY3RcbiAgICAqKi9cbiAgICB2YXIgZGF0YSA9IHZvaWQgMDtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gTm9uIGRlY2xhcmF0aXZlIGVmZmVjdFxuICAgICAgaXMucHJvbWlzZShlZmZlY3QpID8gcmVzb2x2ZVByb21pc2UoZWZmZWN0LCBjdXJyQ2IpIDogaXMuaGVscGVyKGVmZmVjdCkgPyBydW5Gb3JrRWZmZWN0KHdyYXBIZWxwZXIoZWZmZWN0KSwgZWZmZWN0SWQsIGN1cnJDYikgOiBpcy5pdGVyYXRvcihlZmZlY3QpID8gcmVzb2x2ZUl0ZXJhdG9yKGVmZmVjdCwgZWZmZWN0SWQsIG5hbWUsIGN1cnJDYilcblxuICAgICAgLy8gZGVjbGFyYXRpdmUgZWZmZWN0c1xuICAgICAgOiBpcy5hcnJheShlZmZlY3QpID8gcnVuUGFyYWxsZWxFZmZlY3QoZWZmZWN0LCBlZmZlY3RJZCwgY3VyckNiKSA6IChkYXRhID0gYXNFZmZlY3QudGFrZShlZmZlY3QpKSA/IHJ1blRha2VFZmZlY3QoZGF0YSwgY3VyckNiKSA6IChkYXRhID0gYXNFZmZlY3QucHV0KGVmZmVjdCkpID8gcnVuUHV0RWZmZWN0KGRhdGEsIGN1cnJDYikgOiAoZGF0YSA9IGFzRWZmZWN0LmFsbChlZmZlY3QpKSA/IHJ1bkFsbEVmZmVjdChkYXRhLCBlZmZlY3RJZCwgY3VyckNiKSA6IChkYXRhID0gYXNFZmZlY3QucmFjZShlZmZlY3QpKSA/IHJ1blJhY2VFZmZlY3QoZGF0YSwgZWZmZWN0SWQsIGN1cnJDYikgOiAoZGF0YSA9IGFzRWZmZWN0LmNhbGwoZWZmZWN0KSkgPyBydW5DYWxsRWZmZWN0KGRhdGEsIGVmZmVjdElkLCBjdXJyQ2IpIDogKGRhdGEgPSBhc0VmZmVjdC5jcHMoZWZmZWN0KSkgPyBydW5DUFNFZmZlY3QoZGF0YSwgY3VyckNiKSA6IChkYXRhID0gYXNFZmZlY3QuZm9yayhlZmZlY3QpKSA/IHJ1bkZvcmtFZmZlY3QoZGF0YSwgZWZmZWN0SWQsIGN1cnJDYikgOiAoZGF0YSA9IGFzRWZmZWN0LmpvaW4oZWZmZWN0KSkgPyBydW5Kb2luRWZmZWN0KGRhdGEsIGN1cnJDYikgOiAoZGF0YSA9IGFzRWZmZWN0LmNhbmNlbChlZmZlY3QpKSA/IHJ1bkNhbmNlbEVmZmVjdChkYXRhLCBjdXJyQ2IpIDogKGRhdGEgPSBhc0VmZmVjdC5zZWxlY3QoZWZmZWN0KSkgPyBydW5TZWxlY3RFZmZlY3QoZGF0YSwgY3VyckNiKSA6IChkYXRhID0gYXNFZmZlY3QuYWN0aW9uQ2hhbm5lbChlZmZlY3QpKSA/IHJ1bkNoYW5uZWxFZmZlY3QoZGF0YSwgY3VyckNiKSA6IChkYXRhID0gYXNFZmZlY3QuZmx1c2goZWZmZWN0KSkgPyBydW5GbHVzaEVmZmVjdChkYXRhLCBjdXJyQ2IpIDogKGRhdGEgPSBhc0VmZmVjdC5jYW5jZWxsZWQoZWZmZWN0KSkgPyBydW5DYW5jZWxsZWRFZmZlY3QoZGF0YSwgY3VyckNiKSA6IChkYXRhID0gYXNFZmZlY3QuZ2V0Q29udGV4dChlZmZlY3QpKSA/IHJ1bkdldENvbnRleHRFZmZlY3QoZGF0YSwgY3VyckNiKSA6IChkYXRhID0gYXNFZmZlY3Quc2V0Q29udGV4dChlZmZlY3QpKSA/IHJ1blNldENvbnRleHRFZmZlY3QoZGF0YSwgY3VyckNiKSA6IC8qIGFueXRoaW5nIGVsc2UgcmV0dXJuZWQgYXMgaXMgICAgICAgICovY3VyckNiKGVmZmVjdClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgY2IpIHtcbiAgICB2YXIgY2FuY2VsUHJvbWlzZSA9IHByb21pc2VbQ0FOQ0VMXTtcbiAgICBpZiAodHlwZW9mIGNhbmNlbFByb21pc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiLmNhbmNlbCA9IGNhbmNlbFByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihjYiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gY2IoZXJyb3IsIHRydWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUl0ZXJhdG9yKGl0ZXJhdG9yLCBlZmZlY3RJZCwgbmFtZSwgY2IpIHtcbiAgICBwcm9jKGl0ZXJhdG9yLCBzdWJzY3JpYmUsIGRpc3BhdGNoLCBnZXRTdGF0ZSwgdGFza0NvbnRleHQsIG9wdGlvbnMsIGVmZmVjdElkLCBuYW1lLCBjYik7XG4gIH1cblxuICBmdW5jdGlvbiBydW5UYWtlRWZmZWN0KF9yZWYyLCBjYikge1xuICAgIHZhciBjaGFubmVsID0gX3JlZjIuY2hhbm5lbCxcbiAgICAgICAgcGF0dGVybiA9IF9yZWYyLnBhdHRlcm4sXG4gICAgICAgIG1heWJlID0gX3JlZjIubWF5YmU7XG5cbiAgICBjaGFubmVsID0gY2hhbm5lbCB8fCBzdGRDaGFubmVsO1xuICAgIHZhciB0YWtlQ2IgPSBmdW5jdGlvbiB0YWtlQ2IoaW5wKSB7XG4gICAgICByZXR1cm4gaW5wIGluc3RhbmNlb2YgRXJyb3IgPyBjYihpbnAsIHRydWUpIDogaXNFbmQoaW5wKSAmJiAhbWF5YmUgPyBjYihDSEFOTkVMX0VORCkgOiBjYihpbnApO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNoYW5uZWwudGFrZSh0YWtlQ2IsIG1hdGNoZXIocGF0dGVybikpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVyciwgdHJ1ZSk7XG4gICAgfVxuICAgIGNiLmNhbmNlbCA9IHRha2VDYi5jYW5jZWw7XG4gIH1cblxuICBmdW5jdGlvbiBydW5QdXRFZmZlY3QoX3JlZjMsIGNiKSB7XG4gICAgdmFyIGNoYW5uZWwgPSBfcmVmMy5jaGFubmVsLFxuICAgICAgICBhY3Rpb24gPSBfcmVmMy5hY3Rpb24sXG4gICAgICAgIHJlc29sdmUgPSBfcmVmMy5yZXNvbHZlO1xuXG4gICAgLyoqXG4gICAgICBTY2hlZHVsZSB0aGUgcHV0IGluIGNhc2UgYW5vdGhlciBzYWdhIGlzIGhvbGRpbmcgYSBsb2NrLlxuICAgICAgVGhlIHB1dCB3aWxsIGJlIGV4ZWN1dGVkIGF0b21pY2FsbHkuIGllIG5lc3RlZCBwdXRzIHdpbGwgZXhlY3V0ZSBhZnRlclxuICAgICAgdGhpcyBwdXQgaGFzIHRlcm1pbmF0ZWQuXG4gICAgKiovXG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gKGNoYW5uZWwgPyBjaGFubmVsLnB1dCA6IGRpc3BhdGNoKShhY3Rpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNoYW5uZWwgb3IgYHB1dC5yZXNvbHZlYCB3YXMgdXNlZCB0aGVuIGJ1YmJsZSB1cCB0aGUgZXJyb3IuXG4gICAgICAgIGlmIChjaGFubmVsIHx8IHJlc29sdmUpIHJldHVybiBjYihlcnJvciwgdHJ1ZSk7XG4gICAgICAgIGxvZygnZXJyb3InLCAndW5jYXVnaHQgYXQgJyArIG5hbWUsIGVycm9yLnN0YWNrIHx8IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzb2x2ZSAmJiBpcy5wcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UocmVzdWx0LCBjYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2IocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBQdXQgZWZmZWN0cyBhcmUgbm9uIGNhbmNlbGxhYmxlc1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuQ2FsbEVmZmVjdChfcmVmNCwgZWZmZWN0SWQsIGNiKSB7XG4gICAgdmFyIGNvbnRleHQgPSBfcmVmNC5jb250ZXh0LFxuICAgICAgICBmbiA9IF9yZWY0LmZuLFxuICAgICAgICBhcmdzID0gX3JlZjQuYXJncztcblxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgLy8gY2F0Y2ggc3luY2hyb25vdXMgZmFpbHVyZXM7IHNlZSAjMTUyXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gY2IoZXJyb3IsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gaXMucHJvbWlzZShyZXN1bHQpID8gcmVzb2x2ZVByb21pc2UocmVzdWx0LCBjYikgOiBpcy5pdGVyYXRvcihyZXN1bHQpID8gcmVzb2x2ZUl0ZXJhdG9yKHJlc3VsdCwgZWZmZWN0SWQsIGZuLm5hbWUsIGNiKSA6IGNiKHJlc3VsdCk7XG4gIH1cblxuICBmdW5jdGlvbiBydW5DUFNFZmZlY3QoX3JlZjUsIGNiKSB7XG4gICAgdmFyIGNvbnRleHQgPSBfcmVmNS5jb250ZXh0LFxuICAgICAgICBmbiA9IF9yZWY1LmZuLFxuICAgICAgICBhcmdzID0gX3JlZjUuYXJncztcblxuICAgIC8vIENQUyAoaWUgbm9kZSBzdHlsZSBmdW5jdGlvbnMpIGNhbiBkZWZpbmUgdGhlaXIgb3duIGNhbmNlbGxhdGlvbiBsb2dpY1xuICAgIC8vIGJ5IHNldHRpbmcgY2FuY2VsIGZpZWxkIG9uIHRoZSBjYlxuXG4gICAgLy8gY2F0Y2ggc3luY2hyb25vdXMgZmFpbHVyZXM7IHNlZSAjMTUyXG4gICAgdHJ5IHtcbiAgICAgIHZhciBjcHNDYiA9IGZ1bmN0aW9uIGNwc0NiKGVyciwgcmVzKSB7XG4gICAgICAgIHJldHVybiBpcy51bmRlZihlcnIpID8gY2IocmVzKSA6IGNiKGVyciwgdHJ1ZSk7XG4gICAgICB9O1xuICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoY3BzQ2IpKTtcbiAgICAgIGlmIChjcHNDYi5jYW5jZWwpIHtcbiAgICAgICAgY2IuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjcHNDYi5jYW5jZWwoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGNiKGVycm9yLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBydW5Gb3JrRWZmZWN0KF9yZWY2LCBlZmZlY3RJZCwgY2IpIHtcbiAgICB2YXIgY29udGV4dCA9IF9yZWY2LmNvbnRleHQsXG4gICAgICAgIGZuID0gX3JlZjYuZm4sXG4gICAgICAgIGFyZ3MgPSBfcmVmNi5hcmdzLFxuICAgICAgICBkZXRhY2hlZCA9IF9yZWY2LmRldGFjaGVkO1xuXG4gICAgdmFyIHRhc2tJdGVyYXRvciA9IGNyZWF0ZVRhc2tJdGVyYXRvcih7IGNvbnRleHQ6IGNvbnRleHQsIGZuOiBmbiwgYXJnczogYXJncyB9KTtcblxuICAgIHRyeSB7XG4gICAgICBzdXNwZW5kKCk7XG4gICAgICB2YXIgX3Rhc2sgPSBwcm9jKHRhc2tJdGVyYXRvciwgc3Vic2NyaWJlLCBkaXNwYXRjaCwgZ2V0U3RhdGUsIHRhc2tDb250ZXh0LCBvcHRpb25zLCBlZmZlY3RJZCwgZm4ubmFtZSwgZGV0YWNoZWQgPyBudWxsIDogbm9vcCk7XG5cbiAgICAgIGlmIChkZXRhY2hlZCkge1xuICAgICAgICBjYihfdGFzayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFza0l0ZXJhdG9yLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgICB0YXNrUXVldWUuYWRkVGFzayhfdGFzayk7XG4gICAgICAgICAgY2IoX3Rhc2spO1xuICAgICAgICB9IGVsc2UgaWYgKHRhc2tJdGVyYXRvci5fZXJyb3IpIHtcbiAgICAgICAgICB0YXNrUXVldWUuYWJvcnQodGFza0l0ZXJhdG9yLl9lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IoX3Rhc2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIC8vIEZvcmsgZWZmZWN0cyBhcmUgbm9uIGNhbmNlbGxhYmxlc1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuSm9pbkVmZmVjdCh0LCBjYikge1xuICAgIGlmICh0LmlzUnVubmluZygpKSB7XG4gICAgICB2YXIgam9pbmVyID0geyB0YXNrOiB0YXNrLCBjYjogY2IgfTtcbiAgICAgIGNiLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZSh0LmpvaW5lcnMsIGpvaW5lcik7XG4gICAgICB9O1xuICAgICAgdC5qb2luZXJzLnB1c2goam9pbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdC5pc0Fib3J0ZWQoKSA/IGNiKHQuZXJyb3IoKSwgdHJ1ZSkgOiBjYih0LnJlc3VsdCgpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBydW5DYW5jZWxFZmZlY3QodGFza1RvQ2FuY2VsLCBjYikge1xuICAgIGlmICh0YXNrVG9DYW5jZWwgPT09IFNFTEZfQ0FOQ0VMTEFUSU9OKSB7XG4gICAgICB0YXNrVG9DYW5jZWwgPSB0YXNrO1xuICAgIH1cbiAgICBpZiAodGFza1RvQ2FuY2VsLmlzUnVubmluZygpKSB7XG4gICAgICB0YXNrVG9DYW5jZWwuY2FuY2VsKCk7XG4gICAgfVxuICAgIGNiKCk7XG4gICAgLy8gY2FuY2VsIGVmZmVjdHMgYXJlIG5vbiBjYW5jZWxsYWJsZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bkFsbEVmZmVjdChlZmZlY3RzLCBlZmZlY3RJZCwgY2IpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVmZmVjdHMpO1xuXG4gICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNiKGlzLmFycmF5KGVmZmVjdHMpID8gW10gOiB7fSk7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBsZXRlZENvdW50ID0gMDtcbiAgICB2YXIgY29tcGxldGVkID0gdm9pZCAwO1xuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgdmFyIGNoaWxkQ2JzID0ge307XG5cbiAgICBmdW5jdGlvbiBjaGVja0VmZmVjdEVuZCgpIHtcbiAgICAgIGlmIChjb21wbGV0ZWRDb3VudCA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgY2IoaXMuYXJyYXkoZWZmZWN0cykgPyBhcnJheS5mcm9tKF9leHRlbmRzKHt9LCByZXN1bHRzLCB7IGxlbmd0aDoga2V5cy5sZW5ndGggfSkpIDogcmVzdWx0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBjaENiQXRLZXkgPSBmdW5jdGlvbiBjaENiQXRLZXkocmVzLCBpc0Vycikge1xuICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VyciB8fCBpc0VuZChyZXMpIHx8IHJlcyA9PT0gQ0hBTk5FTF9FTkQgfHwgcmVzID09PSBUQVNLX0NBTkNFTCkge1xuICAgICAgICAgIGNiLmNhbmNlbCgpO1xuICAgICAgICAgIGNiKHJlcywgaXNFcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlcztcbiAgICAgICAgICBjb21wbGV0ZWRDb3VudCsrO1xuICAgICAgICAgIGNoZWNrRWZmZWN0RW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaENiQXRLZXkuY2FuY2VsID0gbm9vcDtcbiAgICAgIGNoaWxkQ2JzW2tleV0gPSBjaENiQXRLZXk7XG4gICAgfSk7XG5cbiAgICBjYi5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWNvbXBsZXRlZCkge1xuICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBjaGlsZENic1trZXldLmNhbmNlbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBydW5FZmZlY3QoZWZmZWN0c1trZXldLCBlZmZlY3RJZCwga2V5LCBjaGlsZENic1trZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1blJhY2VFZmZlY3QoZWZmZWN0cywgZWZmZWN0SWQsIGNiKSB7XG4gICAgdmFyIGNvbXBsZXRlZCA9IHZvaWQgMDtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVmZmVjdHMpO1xuICAgIHZhciBjaGlsZENicyA9IHt9O1xuXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBjaENiQXRLZXkgPSBmdW5jdGlvbiBjaENiQXRLZXkocmVzLCBpc0Vycikge1xuICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRXJyKSB7XG4gICAgICAgICAgLy8gUmFjZSBBdXRvIGNhbmNlbGxhdGlvblxuICAgICAgICAgIGNiLmNhbmNlbCgpO1xuICAgICAgICAgIGNiKHJlcywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRW5kKHJlcykgJiYgcmVzICE9PSBDSEFOTkVMX0VORCAmJiByZXMgIT09IFRBU0tfQ0FOQ0VMKSB7XG4gICAgICAgICAgdmFyIF9jYjtcblxuICAgICAgICAgIGNiLmNhbmNlbCgpO1xuICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgY2IoKF9jYiA9IHt9LCBfY2Jba2V5XSA9IHJlcywgX2NiKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaENiQXRLZXkuY2FuY2VsID0gbm9vcDtcbiAgICAgIGNoaWxkQ2JzW2tleV0gPSBjaENiQXRLZXk7XG4gICAgfSk7XG5cbiAgICBjYi5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBwcmV2ZW50cyB1bm5lY2Vzc2FyeSBjYW5jZWxsYXRpb25cbiAgICAgIGlmICghY29tcGxldGVkKSB7XG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkQ2JzW2tleV0uY2FuY2VsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcnVuRWZmZWN0KGVmZmVjdHNba2V5XSwgZWZmZWN0SWQsIGtleSwgY2hpbGRDYnNba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBydW5TZWxlY3RFZmZlY3QoX3JlZjcsIGNiKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gX3JlZjcuc2VsZWN0b3IsXG4gICAgICAgIGFyZ3MgPSBfcmVmNy5hcmdzO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBzdGF0ZSA9IHNlbGVjdG9yLmFwcGx5KHVuZGVmaW5lZCwgW2dldFN0YXRlKCldLmNvbmNhdChhcmdzKSk7XG4gICAgICBjYihzdGF0ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNiKGVycm9yLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBydW5DaGFubmVsRWZmZWN0KF9yZWY4LCBjYikge1xuICAgIHZhciBwYXR0ZXJuID0gX3JlZjgucGF0dGVybixcbiAgICAgICAgYnVmZmVyID0gX3JlZjguYnVmZmVyO1xuXG4gICAgdmFyIG1hdGNoID0gbWF0Y2hlcihwYXR0ZXJuKTtcbiAgICBtYXRjaC5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICBjYihldmVudENoYW5uZWwoc3Vic2NyaWJlLCBidWZmZXIgfHwgYnVmZmVycy5maXhlZCgpLCBtYXRjaCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuQ2FuY2VsbGVkRWZmZWN0KGRhdGEsIGNiKSB7XG4gICAgY2IoISFtYWluVGFzay5pc0NhbmNlbGxlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBydW5GbHVzaEVmZmVjdChjaGFubmVsLCBjYikge1xuICAgIGNoYW5uZWwuZmx1c2goY2IpO1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuR2V0Q29udGV4dEVmZmVjdChwcm9wLCBjYikge1xuICAgIGNiKHRhc2tDb250ZXh0W3Byb3BdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1blNldENvbnRleHRFZmZlY3QocHJvcHMsIGNiKSB7XG4gICAgb2JqZWN0LmFzc2lnbih0YXNrQ29udGV4dCwgcHJvcHMpO1xuICAgIGNiKCk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXdUYXNrKGlkLCBuYW1lLCBpdGVyYXRvciwgY29udCkge1xuICAgIHZhciBfZG9uZSwgX3JlZjksIF9tdXRhdG9yTWFwO1xuXG4gICAgaXRlcmF0b3IuX2RlZmVycmVkRW5kID0gbnVsbDtcbiAgICByZXR1cm4gX3JlZjkgPSB7fSwgX3JlZjlbVEFTS10gPSB0cnVlLCBfcmVmOS5pZCA9IGlkLCBfcmVmOS5uYW1lID0gbmFtZSwgX2RvbmUgPSAnZG9uZScsIF9tdXRhdG9yTWFwID0ge30sIF9tdXRhdG9yTWFwW19kb25lXSA9IF9tdXRhdG9yTWFwW19kb25lXSB8fCB7fSwgX211dGF0b3JNYXBbX2RvbmVdLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyYXRvci5fZGVmZXJyZWRFbmQpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLl9kZWZlcnJlZEVuZC5wcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlZiA9IGRlZmVycmVkKCk7XG4gICAgICAgIGl0ZXJhdG9yLl9kZWZlcnJlZEVuZCA9IGRlZjtcbiAgICAgICAgaWYgKCFpdGVyYXRvci5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgaXRlcmF0b3IuX2Vycm9yID8gZGVmLnJlamVjdChpdGVyYXRvci5fZXJyb3IpIDogZGVmLnJlc29sdmUoaXRlcmF0b3IuX3Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZi5wcm9taXNlO1xuICAgICAgfVxuICAgIH0sIF9yZWY5LmNvbnQgPSBjb250LCBfcmVmOS5qb2luZXJzID0gW10sIF9yZWY5LmNhbmNlbCA9IGNhbmNlbCwgX3JlZjkuaXNSdW5uaW5nID0gZnVuY3Rpb24gaXNSdW5uaW5nKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yLl9pc1J1bm5pbmc7XG4gICAgfSwgX3JlZjkuaXNDYW5jZWxsZWQgPSBmdW5jdGlvbiBpc0NhbmNlbGxlZCgpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvci5faXNDYW5jZWxsZWQ7XG4gICAgfSwgX3JlZjkuaXNBYm9ydGVkID0gZnVuY3Rpb24gaXNBYm9ydGVkKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yLl9pc0Fib3J0ZWQ7XG4gICAgfSwgX3JlZjkucmVzdWx0ID0gZnVuY3Rpb24gcmVzdWx0KCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yLl9yZXN1bHQ7XG4gICAgfSwgX3JlZjkuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvci5fZXJyb3I7XG4gICAgfSwgX3JlZjkuc2V0Q29udGV4dCA9IGZ1bmN0aW9uIHNldENvbnRleHQocHJvcHMpIHtcbiAgICAgIGNoZWNrKHByb3BzLCBpcy5vYmplY3QsIGNyZWF0ZVNldENvbnRleHRXYXJuaW5nKCd0YXNrJywgcHJvcHMpKTtcbiAgICAgIG9iamVjdC5hc3NpZ24odGFza0NvbnRleHQsIHByb3BzKTtcbiAgICB9LCBfZGVmaW5lRW51bWVyYWJsZVByb3BlcnRpZXMoX3JlZjksIF9tdXRhdG9yTWFwKSwgX3JlZjk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlZHV4LXNhZ2EvZXMvaW50ZXJuYWwvcHJvYy5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgaXMsIGNoZWNrLCB1aWQgYXMgbmV4dFNhZ2FJZCwgd3JhcFNhZ2FEaXNwYXRjaCwgbm9vcCwgbG9nIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgcHJvYyBmcm9tICcuL3Byb2MnO1xuXG52YXIgUlVOX1NBR0FfU0lHTkFUVVJFID0gJ3J1blNhZ2Eoc3RvcmVJbnRlcmZhY2UsIHNhZ2EsIC4uLmFyZ3MpJztcbnZhciBOT05fR0VORVJBVE9SX0VSUiA9IFJVTl9TQUdBX1NJR05BVFVSRSArICc6IHNhZ2EgYXJndW1lbnQgbXVzdCBiZSBhIEdlbmVyYXRvciBmdW5jdGlvbiEnO1xuXG5leHBvcnQgZnVuY3Rpb24gcnVuU2FnYShzdG9yZUludGVyZmFjZSwgc2FnYSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBpdGVyYXRvciA9IHZvaWQgMDtcblxuICBpZiAoaXMuaXRlcmF0b3Ioc3RvcmVJbnRlcmZhY2UpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBsb2coJ3dhcm4nLCAncnVuU2FnYShpdGVyYXRvciwgc3RvcmVJbnRlcmZhY2UpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgJyArIFJVTl9TQUdBX1NJR05BVFVSRSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gc3RvcmVJbnRlcmZhY2U7XG4gICAgc3RvcmVJbnRlcmZhY2UgPSBzYWdhO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrKHNhZ2EsIGlzLmZ1bmMsIE5PTl9HRU5FUkFUT1JfRVJSKTtcbiAgICBpdGVyYXRvciA9IHNhZ2EuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICBjaGVjayhpdGVyYXRvciwgaXMuaXRlcmF0b3IsIE5PTl9HRU5FUkFUT1JfRVJSKTtcbiAgfVxuXG4gIHZhciBfc3RvcmVJbnRlcmZhY2UgPSBzdG9yZUludGVyZmFjZSxcbiAgICAgIHN1YnNjcmliZSA9IF9zdG9yZUludGVyZmFjZS5zdWJzY3JpYmUsXG4gICAgICBkaXNwYXRjaCA9IF9zdG9yZUludGVyZmFjZS5kaXNwYXRjaCxcbiAgICAgIGdldFN0YXRlID0gX3N0b3JlSW50ZXJmYWNlLmdldFN0YXRlLFxuICAgICAgY29udGV4dCA9IF9zdG9yZUludGVyZmFjZS5jb250ZXh0LFxuICAgICAgc2FnYU1vbml0b3IgPSBfc3RvcmVJbnRlcmZhY2Uuc2FnYU1vbml0b3IsXG4gICAgICBsb2dnZXIgPSBfc3RvcmVJbnRlcmZhY2UubG9nZ2VyLFxuICAgICAgb25FcnJvciA9IF9zdG9yZUludGVyZmFjZS5vbkVycm9yO1xuXG5cbiAgdmFyIGVmZmVjdElkID0gbmV4dFNhZ2FJZCgpO1xuXG4gIGlmIChzYWdhTW9uaXRvcikge1xuICAgIC8vIG1vbml0b3JzIGFyZSBleHBlY3RlZCB0byBoYXZlIGEgY2VydGFpbiBpbnRlcmZhY2UsIGxldCdzIGZpbGwtaW4gYW55IG1pc3Npbmcgb25lc1xuICAgIHNhZ2FNb25pdG9yLmVmZmVjdFRyaWdnZXJlZCA9IHNhZ2FNb25pdG9yLmVmZmVjdFRyaWdnZXJlZCB8fCBub29wO1xuICAgIHNhZ2FNb25pdG9yLmVmZmVjdFJlc29sdmVkID0gc2FnYU1vbml0b3IuZWZmZWN0UmVzb2x2ZWQgfHwgbm9vcDtcbiAgICBzYWdhTW9uaXRvci5lZmZlY3RSZWplY3RlZCA9IHNhZ2FNb25pdG9yLmVmZmVjdFJlamVjdGVkIHx8IG5vb3A7XG4gICAgc2FnYU1vbml0b3IuZWZmZWN0Q2FuY2VsbGVkID0gc2FnYU1vbml0b3IuZWZmZWN0Q2FuY2VsbGVkIHx8IG5vb3A7XG4gICAgc2FnYU1vbml0b3IuYWN0aW9uRGlzcGF0Y2hlZCA9IHNhZ2FNb25pdG9yLmFjdGlvbkRpc3BhdGNoZWQgfHwgbm9vcDtcblxuICAgIHNhZ2FNb25pdG9yLmVmZmVjdFRyaWdnZXJlZCh7IGVmZmVjdElkOiBlZmZlY3RJZCwgcm9vdDogdHJ1ZSwgcGFyZW50RWZmZWN0SWQ6IDAsIGVmZmVjdDogeyByb290OiB0cnVlLCBzYWdhOiBzYWdhLCBhcmdzOiBhcmdzIH0gfSk7XG4gIH1cblxuICB2YXIgdGFzayA9IHByb2MoaXRlcmF0b3IsIHN1YnNjcmliZSwgd3JhcFNhZ2FEaXNwYXRjaChkaXNwYXRjaCksIGdldFN0YXRlLCBjb250ZXh0LCB7IHNhZ2FNb25pdG9yOiBzYWdhTW9uaXRvciwgbG9nZ2VyOiBsb2dnZXIsIG9uRXJyb3I6IG9uRXJyb3IgfSwgZWZmZWN0SWQsIHNhZ2EubmFtZSk7XG5cbiAgaWYgKHNhZ2FNb25pdG9yKSB7XG4gICAgc2FnYU1vbml0b3IuZWZmZWN0UmVzb2x2ZWQoZWZmZWN0SWQsIHRhc2spO1xuICB9XG5cbiAgcmV0dXJuIHRhc2s7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWR1eC1zYWdhL2VzL2ludGVybmFsL3J1blNhZ2EuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVORCB9IGZyb20gJy4vY2hhbm5lbCc7XG5pbXBvcnQgeyBtYWtlSXRlcmF0b3IsIGRlbGF5LCBpcywgZGVwcmVjYXRlIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyB0YWtlLCBmb3JrLCBjYW5jZWwsIGFjdGlvbkNoYW5uZWwsIGNhbGwgfSBmcm9tICcuL2lvJztcbmltcG9ydCB7IGJ1ZmZlcnMgfSBmcm9tICcuL2J1ZmZlcnMnO1xuXG52YXIgZG9uZSA9IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xudmFyIHFFbmQgPSB7fTtcblxuZnVuY3Rpb24gZnNtSXRlcmF0b3IoZnNtLCBxMCkge1xuICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2l0ZXJhdG9yJztcblxuICB2YXIgdXBkYXRlU3RhdGUgPSB2b2lkIDAsXG4gICAgICBxTmV4dCA9IHEwO1xuXG4gIGZ1bmN0aW9uIG5leHQoYXJnLCBlcnJvcikge1xuICAgIGlmIChxTmV4dCA9PT0gcUVuZCkge1xuICAgICAgcmV0dXJuIGRvbmU7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBxTmV4dCA9IHFFbmQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlU3RhdGUgJiYgdXBkYXRlU3RhdGUoYXJnKTtcblxuICAgICAgdmFyIF9mc20kcU5leHQgPSBmc21bcU5leHRdKCksXG4gICAgICAgICAgcSA9IF9mc20kcU5leHRbMF0sXG4gICAgICAgICAgb3V0cHV0ID0gX2ZzbSRxTmV4dFsxXSxcbiAgICAgICAgICBfdXBkYXRlU3RhdGUgPSBfZnNtJHFOZXh0WzJdO1xuXG4gICAgICBxTmV4dCA9IHE7XG4gICAgICB1cGRhdGVTdGF0ZSA9IF91cGRhdGVTdGF0ZTtcbiAgICAgIHJldHVybiBxTmV4dCA9PT0gcUVuZCA/IGRvbmUgOiBvdXRwdXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ha2VJdGVyYXRvcihuZXh0LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gbmV4dChudWxsLCBlcnJvcik7XG4gIH0sIG5hbWUsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBzYWZlTmFtZShwYXR0ZXJuT3JDaGFubmVsKSB7XG4gIGlmIChpcy5jaGFubmVsKHBhdHRlcm5PckNoYW5uZWwpKSB7XG4gICAgcmV0dXJuICdjaGFubmVsJztcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm5PckNoYW5uZWwpKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXR0ZXJuT3JDaGFubmVsLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoZW50cnkpO1xuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gU3RyaW5nKHBhdHRlcm5PckNoYW5uZWwpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YWtlRXZlcnlIZWxwZXIocGF0dGVybk9yQ2hhbm5lbCwgd29ya2VyKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIHlUYWtlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRha2UocGF0dGVybk9yQ2hhbm5lbCkgfTtcbiAgdmFyIHlGb3JrID0gZnVuY3Rpb24geUZvcmsoYWMpIHtcbiAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGZvcmsuYXBwbHkodW5kZWZpbmVkLCBbd29ya2VyXS5jb25jYXQoYXJncywgW2FjXSkpIH07XG4gIH07XG5cbiAgdmFyIGFjdGlvbiA9IHZvaWQgMCxcbiAgICAgIHNldEFjdGlvbiA9IGZ1bmN0aW9uIHNldEFjdGlvbihhYykge1xuICAgIHJldHVybiBhY3Rpb24gPSBhYztcbiAgfTtcblxuICByZXR1cm4gZnNtSXRlcmF0b3Ioe1xuICAgIHExOiBmdW5jdGlvbiBxMSgpIHtcbiAgICAgIHJldHVybiBbJ3EyJywgeVRha2UsIHNldEFjdGlvbl07XG4gICAgfSxcbiAgICBxMjogZnVuY3Rpb24gcTIoKSB7XG4gICAgICByZXR1cm4gYWN0aW9uID09PSBFTkQgPyBbcUVuZF0gOiBbJ3ExJywgeUZvcmsoYWN0aW9uKV07XG4gICAgfVxuICB9LCAncTEnLCAndGFrZUV2ZXJ5KCcgKyBzYWZlTmFtZShwYXR0ZXJuT3JDaGFubmVsKSArICcsICcgKyB3b3JrZXIubmFtZSArICcpJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YWtlTGF0ZXN0SGVscGVyKHBhdHRlcm5PckNoYW5uZWwsIHdvcmtlcikge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHZhciB5VGFrZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0YWtlKHBhdHRlcm5PckNoYW5uZWwpIH07XG4gIHZhciB5Rm9yayA9IGZ1bmN0aW9uIHlGb3JrKGFjKSB7XG4gICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmb3JrLmFwcGx5KHVuZGVmaW5lZCwgW3dvcmtlcl0uY29uY2F0KGFyZ3MsIFthY10pKSB9O1xuICB9O1xuICB2YXIgeUNhbmNlbCA9IGZ1bmN0aW9uIHlDYW5jZWwodGFzaykge1xuICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogY2FuY2VsKHRhc2spIH07XG4gIH07XG5cbiAgdmFyIHRhc2sgPSB2b2lkIDAsXG4gICAgICBhY3Rpb24gPSB2b2lkIDA7XG4gIHZhciBzZXRUYXNrID0gZnVuY3Rpb24gc2V0VGFzayh0KSB7XG4gICAgcmV0dXJuIHRhc2sgPSB0O1xuICB9O1xuICB2YXIgc2V0QWN0aW9uID0gZnVuY3Rpb24gc2V0QWN0aW9uKGFjKSB7XG4gICAgcmV0dXJuIGFjdGlvbiA9IGFjO1xuICB9O1xuXG4gIHJldHVybiBmc21JdGVyYXRvcih7XG4gICAgcTE6IGZ1bmN0aW9uIHExKCkge1xuICAgICAgcmV0dXJuIFsncTInLCB5VGFrZSwgc2V0QWN0aW9uXTtcbiAgICB9LFxuICAgIHEyOiBmdW5jdGlvbiBxMigpIHtcbiAgICAgIHJldHVybiBhY3Rpb24gPT09IEVORCA/IFtxRW5kXSA6IHRhc2sgPyBbJ3EzJywgeUNhbmNlbCh0YXNrKV0gOiBbJ3ExJywgeUZvcmsoYWN0aW9uKSwgc2V0VGFza107XG4gICAgfSxcbiAgICBxMzogZnVuY3Rpb24gcTMoKSB7XG4gICAgICByZXR1cm4gWydxMScsIHlGb3JrKGFjdGlvbiksIHNldFRhc2tdO1xuICAgIH1cbiAgfSwgJ3ExJywgJ3Rha2VMYXRlc3QoJyArIHNhZmVOYW1lKHBhdHRlcm5PckNoYW5uZWwpICsgJywgJyArIHdvcmtlci5uYW1lICsgJyknKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlSGVscGVyKGRlbGF5TGVuZ3RoLCBwYXR0ZXJuLCB3b3JrZXIpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMgPiAzID8gX2xlbjMgLSAzIDogMCksIF9rZXkzID0gMzsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICB2YXIgYWN0aW9uID0gdm9pZCAwLFxuICAgICAgY2hhbm5lbCA9IHZvaWQgMDtcblxuICB2YXIgeUFjdGlvbkNoYW5uZWwgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogYWN0aW9uQ2hhbm5lbChwYXR0ZXJuLCBidWZmZXJzLnNsaWRpbmcoMSkpIH07XG4gIHZhciB5VGFrZSA9IGZ1bmN0aW9uIHlUYWtlKCkge1xuICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdGFrZShjaGFubmVsKSB9O1xuICB9O1xuICB2YXIgeUZvcmsgPSBmdW5jdGlvbiB5Rm9yayhhYykge1xuICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogZm9yay5hcHBseSh1bmRlZmluZWQsIFt3b3JrZXJdLmNvbmNhdChhcmdzLCBbYWNdKSkgfTtcbiAgfTtcbiAgdmFyIHlEZWxheSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBjYWxsKGRlbGF5LCBkZWxheUxlbmd0aCkgfTtcblxuICB2YXIgc2V0QWN0aW9uID0gZnVuY3Rpb24gc2V0QWN0aW9uKGFjKSB7XG4gICAgcmV0dXJuIGFjdGlvbiA9IGFjO1xuICB9O1xuICB2YXIgc2V0Q2hhbm5lbCA9IGZ1bmN0aW9uIHNldENoYW5uZWwoY2gpIHtcbiAgICByZXR1cm4gY2hhbm5lbCA9IGNoO1xuICB9O1xuXG4gIHJldHVybiBmc21JdGVyYXRvcih7XG4gICAgcTE6IGZ1bmN0aW9uIHExKCkge1xuICAgICAgcmV0dXJuIFsncTInLCB5QWN0aW9uQ2hhbm5lbCwgc2V0Q2hhbm5lbF07XG4gICAgfSxcbiAgICBxMjogZnVuY3Rpb24gcTIoKSB7XG4gICAgICByZXR1cm4gWydxMycsIHlUYWtlKCksIHNldEFjdGlvbl07XG4gICAgfSxcbiAgICBxMzogZnVuY3Rpb24gcTMoKSB7XG4gICAgICByZXR1cm4gYWN0aW9uID09PSBFTkQgPyBbcUVuZF0gOiBbJ3E0JywgeUZvcmsoYWN0aW9uKV07XG4gICAgfSxcbiAgICBxNDogZnVuY3Rpb24gcTQoKSB7XG4gICAgICByZXR1cm4gWydxMicsIHlEZWxheV07XG4gICAgfVxuICB9LCAncTEnLCAndGhyb3R0bGUoJyArIHNhZmVOYW1lKHBhdHRlcm4pICsgJywgJyArIHdvcmtlci5uYW1lICsgJyknKTtcbn1cblxudmFyIGRlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIGRlcHJlY2F0aW9uV2FybmluZyhoZWxwZXJOYW1lKSB7XG4gIHJldHVybiAnaW1wb3J0IHsgJyArIGhlbHBlck5hbWUgKyAnIH0gZnJvbSBcXCdyZWR1eC1zYWdhXFwnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgaW1wb3J0IHsgJyArIGhlbHBlck5hbWUgKyAnIH0gZnJvbSBcXCdyZWR1eC1zYWdhL2VmZmVjdHNcXCcuXFxuVGhlIGxhdHRlciB3aWxsIG5vdCB3b3JrIHdpdGggeWllbGQqLCBhcyBoZWxwZXIgZWZmZWN0cyBhcmUgd3JhcHBlZCBhdXRvbWF0aWNhbGx5IGZvciB5b3UgaW4gZm9yayBlZmZlY3QuXFxuVGhlcmVmb3JlIHlpZWxkICcgKyBoZWxwZXJOYW1lICsgJyB3aWxsIHJldHVybiB0YXNrIGRlc2NyaXB0b3IgdG8geW91ciBzYWdhIGFuZCBleGVjdXRlIG5leHQgbGluZXMgb2YgY29kZS4nO1xufTtcbmV4cG9ydCB2YXIgdGFrZUV2ZXJ5ID0gZGVwcmVjYXRlKHRha2VFdmVyeUhlbHBlciwgZGVwcmVjYXRpb25XYXJuaW5nKCd0YWtlRXZlcnknKSk7XG5leHBvcnQgdmFyIHRha2VMYXRlc3QgPSBkZXByZWNhdGUodGFrZUxhdGVzdEhlbHBlciwgZGVwcmVjYXRpb25XYXJuaW5nKCd0YWtlTGF0ZXN0JykpO1xuZXhwb3J0IHZhciB0aHJvdHRsZSA9IGRlcHJlY2F0ZSh0aHJvdHRsZUhlbHBlciwgZGVwcmVjYXRpb25XYXJuaW5nKCd0aHJvdHRsZScpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlZHV4LXNhZ2EvZXMvaW50ZXJuYWwvc2FnYUhlbHBlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBxdWV1ZSA9IFtdO1xuLyoqXG4gIFZhcmlhYmxlIHRvIGhvbGQgYSBjb3VudGluZyBzZW1hcGhvcmVcbiAgLSBJbmNyZW1lbnRpbmcgYWRkcyBhIGxvY2sgYW5kIHB1dHMgdGhlIHNjaGVkdWxlciBpbiBhIGBzdXNwZW5kZWRgIHN0YXRlIChpZiBpdCdzIG5vdFxuICAgIGFscmVhZHkgc3VzcGVuZGVkKVxuICAtIERlY3JlbWVudGluZyByZWxlYXNlcyBhIGxvY2suIFplcm8gbG9ja3MgcHV0cyB0aGUgc2NoZWR1bGVyIGluIGEgYHJlbGVhc2VkYCBzdGF0ZS4gVGhpc1xuICAgIHRyaWdnZXJzIGZsdXNoaW5nIHRoZSBxdWV1ZWQgdGFza3MuXG4qKi9cbnZhciBzZW1hcGhvcmUgPSAwO1xuXG4vKipcbiAgRXhlY3V0ZXMgYSB0YXNrICdhdG9taWNhbGx5Jy4gVGFza3Mgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGV4ZWN1dGlvbiB3aWxsIGJlIHF1ZXVlZFxuICBhbmQgZmx1c2hlZCBhZnRlciB0aGlzIHRhc2sgaGFzIGZpbmlzaGVkIChhc3N1bWluZyB0aGUgc2NoZWR1bGVyIGVuZHVwIGluIGEgcmVsZWFzZWRcbiAgc3RhdGUpLlxuKiovXG5mdW5jdGlvbiBleGVjKHRhc2spIHtcbiAgdHJ5IHtcbiAgICBzdXNwZW5kKCk7XG4gICAgdGFzaygpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbGVhc2UoKTtcbiAgfVxufVxuXG4vKipcbiAgRXhlY3V0ZXMgb3IgcXVldWVzIGEgdGFzayBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mIHRoZSBzY2hlZHVsZXIgKGBzdXNwZW5kZWRgIG9yIGByZWxlYXNlZGApXG4qKi9cbmV4cG9ydCBmdW5jdGlvbiBhc2FwKHRhc2spIHtcbiAgcXVldWUucHVzaCh0YXNrKTtcblxuICBpZiAoIXNlbWFwaG9yZSkge1xuICAgIHN1c3BlbmQoKTtcbiAgICBmbHVzaCgpO1xuICB9XG59XG5cbi8qKlxuICBQdXRzIHRoZSBzY2hlZHVsZXIgaW4gYSBgc3VzcGVuZGVkYCBzdGF0ZS4gU2NoZWR1bGVkIHRhc2tzIHdpbGwgYmUgcXVldWVkIHVudGlsIHRoZVxuICBzY2hlZHVsZXIgaXMgcmVsZWFzZWQuXG4qKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kKCkge1xuICBzZW1hcGhvcmUrKztcbn1cblxuLyoqXG4gIFB1dHMgdGhlIHNjaGVkdWxlciBpbiBhIGByZWxlYXNlZGAgc3RhdGUuXG4qKi9cbmZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gIHNlbWFwaG9yZS0tO1xufVxuXG4vKipcbiAgUmVsZWFzZXMgdGhlIGN1cnJlbnQgbG9jay4gRXhlY3V0ZXMgYWxsIHF1ZXVlZCB0YXNrcyBpZiB0aGUgc2NoZWR1bGVyIGlzIGluIHRoZSByZWxlYXNlZCBzdGF0ZS5cbioqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoKCkge1xuICByZWxlYXNlKCk7XG5cbiAgdmFyIHRhc2sgPSB2b2lkIDA7XG4gIHdoaWxlICghc2VtYXBob3JlICYmICh0YXNrID0gcXVldWUuc2hpZnQoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4ZWModGFzayk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlZHV4LXNhZ2EvZXMvaW50ZXJuYWwvc2NoZWR1bGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuXG4gIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gIHZhciByZXN0ID0gZnVuY3Muc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZikge1xuICAgICAgcmV0dXJuIGYoY29tcG9zZWQpO1xuICAgIH0sIGxhc3QuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlZHV4L2VzL2NvbXBvc2UuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICdsb2Rhc2gtZXMvaXNQbGFpbk9iamVjdCc7XG5pbXBvcnQgJCRvYnNlcnZhYmxlIGZyb20gJ3N5bWJvbC1vYnNlcnZhYmxlJztcblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbmV4cG9ydCB2YXIgQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6ICdAQHJlZHV4L0lOSVQnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbcHJlbG9hZGVkU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuaGFuY2VyIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IHByZWxvYWRlZFN0YXRlO1xuICAgIHByZWxvYWRlZFN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG5cbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbJCRvYnNlcnZhYmxlXSA9IG9ic2VydmFibGUsIF9yZWYyO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVkdXgvZXMvY3JlYXRlU3RvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgY3JlYXRlU3RvcmUgZnJvbSAnLi9jcmVhdGVTdG9yZSc7XG5pbXBvcnQgY29tYmluZVJlZHVjZXJzIGZyb20gJy4vY29tYmluZVJlZHVjZXJzJztcbmltcG9ydCBiaW5kQWN0aW9uQ3JlYXRvcnMgZnJvbSAnLi9iaW5kQWN0aW9uQ3JlYXRvcnMnO1xuaW1wb3J0IGFwcGx5TWlkZGxld2FyZSBmcm9tICcuL2FwcGx5TWlkZGxld2FyZSc7XG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi91dGlscy93YXJuaW5nJztcblxuLypcbiogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4qL1xuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcbiAgd2FybmluZygnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21iaW5lUmVkdWNlcnMsIGJpbmRBY3Rpb25DcmVhdG9ycywgYXBwbHlNaWRkbGV3YXJlLCBjb21wb3NlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWR1eC9lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWR1eC9lcy91dGlscy93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSUFBQUFDQUNBTUFBQUQwNEpINUFBQUNvMUJNVkVVQUFBRC8vLzkvZjMrcXFxcS92NytabVptcXFxcTJ0cmFmbjUrcHFhbXlzcktpb3FLcXFxcXdzTENqbzZPcXFxcWZuNStscGFXcHFhbWhvYUdscGFXcHFhbWlvcUttcHFhcXFxcWpvNk9tcHFhcHFhbWpvNk9ucDZlcXFxcWtwS1NucDZlcHFhbWxwYVdscGFXbnA2ZXBxYW1scGFXbnA2ZW1wcWFvcUtpa3BLU21wcWFvcUtpa3BLU21wcWFscGFXbXBxYW9xS2ltcHFhb3FLaWxwYVducDZlb3FLaWxwYVducDZlb3FLaW5wNmVvcUtpbXBxYW9xS2ltcHFhbnA2ZW5wNmVscGFXbXBxYW5wNmVscGFXbXBxYW5wNmVscGFXbXBxYWxwYVdvcUtpbXBxYW5wNmVvcUtpbXBxYW5wNmVtcHFhb3FLaW1wcWFucDZlbHBhV21wcWFucDZlbHBhV21wcWFucDZlbHBhV21wcWFucDZlbXBxYW1wcWFucDZlbXBxYW5wNmVtcHFhbnA2ZW5wNmVtcHFhbnA2ZW5wNmVtcHFhbnA2ZW5wNmVtcHFhbnA2ZW5wNmVtcHFhbXBxYW1wcWFtcHFhbnA2ZW1wcWFtcHFhbnA2ZW1wcWFscGFXbnA2ZW1wcWFucDZlbnA2ZW1wcWFucDZlbnA2ZW1wcWFucDZlbnA2ZW1wcWFucDZlbXBxYW5wNmVucDZlbXBxYW5wNmVtcHFhbnA2ZW1wcWFucDZlbXBxYWxwYVducDZlbXBxYWxwYVducDZlbXBxYW5wNmVtcHFhbnA2ZW5wNmVtcHFhbnA2ZW5wNmVtcHFhbnA2ZWxwYVducDZlbnA2ZW5wNmVtcHFhbHBhV25wNmVtcHFhbHBhV25wNmVtcHFhbHBhV25wNmVtcHFhbHBhV25wNmVtcHFhbnA2ZW5wNmVucDZlbnA2ZWxwYVducDZlbnA2ZWxwYVducDZlbHBhV25wNmVtcHFhbHBhV21wcWFscGFXbnA2ZW1wcWFucDZlbXBxYW5wNmVscGFXbHBhV25wNmVscGFXbnA2ZW5wNmVscGFXbnA2ZW5wNmVscGFXbnA2ZW5wNmVscGFXbnA2ZW5wNmVscGFXbnA2ZW1wcWFscGFXbnA2ZWxwYVdscGFXbnA2ZWxwYVdscGFXbnA2ZWxwYVdscGFXbnA2ZWxwYVducDZkOFFMOGxBQUFBNEhSU1RsTUFBUUlEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdSb2JIQjBlSHlBaElpVW1KeWdwS3l3dExpOHdNVE0wTlRjNE9UbzdQRDArUUVGQ1JFVkdTVXBMVEUxT1QxQlJVMVZXV2x0Y1hWOWhZbU5rWldabmFHbHFhMnh0Ym05d2NuTjBkWFozZUhsNmUzeDlnSUdDaElXR2g0aUppb3VNalk2UGtKR1NrNVNWbHBlWm1wdWNuWjZnb2FPa3BhYW5xS21xcTYydXI3Q3hzck8wdHJlNHVydTh2YjYvd01IQ3c4VEZ4c2ZJeWN2TXpjN1AwTkxUMU5YVzJObmEyOTNlNE9IaTQrVGw1dWZvNmVycjdPM3U3L0R4OHZQMDlmYjMrUG42Ky96OS90Y01tdHdBQUFTOFNVUkJWQmdaN2NGcFcxUmxBQWJnWndZY2hBUUN4TEMwRkJVRHM5eHdBU3hjTWxSY2NpazEwVkpVTEZNeExUZUlUQ3ZERmxOeFNkUmNFTGZFaXNJTUdiZFNTVUZCYkNDWTU2ZWtDTUhBbVpuenZtZjU0RFgzRFI4Zkh4OGZuOGVSTlhyazFMY1hMNXlWMGo4UXB2TWZzZXBFRFp2Vi83UW0zZ0lUOWQ1UXpyYkswa09oTEJvNmk4Mmpvc3FNUUxRWDkvMG02Q3JrNHdhNll4K0pObDc0enNuK2FDMmdPelFaYktjbjYyMW80VGZtRU1samNKRloxUThhVEsralo0V2QwYVQzaXN0OEtBbXRCZC9obGE2UXRwUmVsVVlEc01TOSt6TWZPUWdYczBtZUM0YWtKVlNoTWpOdDZ6VTJjL1NDaXlJK2NLUWpwRXlpdUhmZ0lwcU45dGtnb2IrRHd2WmI0V0krSDlrVEFHRkJwUlJXRWdwWHU5bmtZQkJFcmFNd2V6ZTBjWVBOVG9aRFRHdzlSWlUraTBaQnFYbWQwQ2lTTFM3MGhKQjhpam9aaVFlQ0ozeFR6ZkY0WkJCYktSOE9BWU1wS3RzR1M1ODUrYlVrYzlEa05iWlc5NllGcXUybW9JTUxzdzdkWXFQVE5qU1pURmU1UVZDcFd3T2xYWWxDczJsczQzd2MxRmxFYVhmNzRYK1QySlpqbmhWcS9FaFpqa1MwR012MmprYkR1ekFuSmRXTlFTc0RxT0IrZWdkNGsweEpqdEZvTFl5S1NwTGd4UkxLdVpzSVY5ZW9iRzlmZVBRNXBWeU9ReHU3NkViREZ6M2h3UUhLS09pQ3R1YlNyWCszOW9GYlp5aGhnei9hNlVFUG5Ic1NMRkJXUkhGZlFza1plbFNTRmc0bHB5aHVJNVRNb0JlMU8xTUMwVTQreGVWQVNXQTV2YXJlTVRrQ3JqNmp1RTFRbEU0MW5FV3JrMFBSWWhIRjVVQlI0Q1dxNUR5Zk96OGgwb0tIeGxIY0JpZ2JTeUZWNTQvdTJQUitQc1Zsd28xY21pTURiZ1Jmb0NsbXdaM2VGVFREZUxnMTlCNU5NQXp0VGNrSXcwUHhsVFJlTk5wYnc1b3RRNjBBK3BiUmFFNGIybHZHQjY3bnpoelFLZUl3RFhZVkN0NWdzNG95R3F3QUNrYlNQSjlDd1ZNMFR4cVUyR21hRVZDeWhXWnhCa05KTXMxU0FrWCsxMm1TelZDMmdpWkpoYkxJR3BvakNtNnNwQ21LNFU3SVh6VERLcmcxZ1dZWUJQZTIwM2gvV3VGZTZFVWFMZ3VleEZUU2FJUGhVZnc5R3F2VUFzK0dWTkJRUytGTnpCODBVUDNUOENwa0c0MnpDMnFNTHFOUkVxR0tiZTRWR3VJWEMxVHFNUDVBUGZVM0dRSTZUemxCbmRuOTRWMlgxZFBHSmc1UEhEY3pjL2NONm13bVZIaW1qa2F4MjZER1Zob2xGYXIwZGRJWVJWYW9rMHRqRElOSzNXdG9oSytnV2pvTmNMY3JWUE03VGYzTmhvRG5ibE52QlZhSVNLaWp2cXFqSVdaaUEzVTFIYUltMWxGSE95MFFsbkNMdWlrTGhZUm5DNm1UK3k5Q2l0OWJkNmlMVk1pSytPZ2V0VnNKRGNJVy9FNk52clZDRTh2elM0L2RwN3dqQWRET3IyZlNqRUpLS1FxQkx2eVcxVk5HY1RoMEVYT0tVb29qb0llQURBZWxuQTJISHBKTEtlZUhZT2hnNEdGSzJoWUE3WWJ0cDZ4bEZtZ1ZNT2swWlZXblFDUEx3T3kvS2UyM1B0RGtpVmV5TGxHRHpVR1ExakUyZGYycE9tcHg4MVVJNmJCMjdYc0wwK2JNVzdCODQ5Zkg3UTNVYWxzRUJFWGwxRk0zRjErR2hKZzkxRWYxNGdESWlTK2dkclZaa1pCbVNUcE9iUnlmZEljMjhYbE9TcnU5TWdyYTlmamdKcVdjZlQwSStyQ2w1TlZTME5VUFk2R25KNmZ1L1llcVhWdzN4QXJkQlkzYStDdTl1NVUzdHhjTUV6NXErYjdMZE9kMllmYlVHQXNNRi96U3hFWFpPNDRWbDEydnFLcTZVMzcxd3JuRDI3T1dwTVpId3NmSHg4Zm5NZklmalAvdUl2alZOcXdBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbWcvdHdpdHRlci5wbmdcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgXCJmaWxlLWxvYWRlcj9uYW1lPWluZGV4Lmh0bWwhLi9pbmRleC5odG1sXCI7XG5pbXBvcnQgXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVGh1bmsgZnJvbSAncmVkdXgtdGh1bmsnO1xuaW1wb3J0IGNyZWF0ZVNhZ2FNaWRkbGV3YXJlIGZyb20gJ3JlZHV4LXNhZ2EnXG5pbXBvcnQge1Byb3ZpZGVyfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQge2NyZWF0ZVN0b3JlLCBhcHBseU1pZGRsZXdhcmV9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7cmVuZGVyfSBmcm9tICdyZWFjdC1kb20nO1xuXG5pbXBvcnQgTWFpblZpZXcgZnJvbSAnLi92aWV3JztcbmltcG9ydCBhcHBSZWR1Y2VyIGZyb20gJy4vcmVkdWNlcnMnO1xuaW1wb3J0IHJvb3RTYWdhIGZyb20gJy4vc2FnYXMnO1xuXG5jb25zdCBzYWdhTWlkZGxld2FyZSA9IGNyZWF0ZVNhZ2FNaWRkbGV3YXJlKCk7XG5jb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlKGFwcFJlZHVjZXIsIGFwcGx5TWlkZGxld2FyZShzYWdhTWlkZGxld2FyZSkpO1xuc2FnYU1pZGRsZXdhcmUucnVuKHJvb3RTYWdhKTtcblxucmVuZGVyKFxuICAgIDxQcm92aWRlciBzdG9yZT17c3RvcmV9PlxuICAgICAgICA8TWFpblZpZXcvPlxuICAgIDwvUHJvdmlkZXI+LFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jylcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9pbmRleC5qcyIsImV4cG9ydCBmdW5jdGlvbiB0b2dnbGVVc2VyKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdUT0dHTEVfVVNFUidcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUd2VldHMoY2FuZGlkYXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0dFVF9UV0VFVFMnLFxuICAgICAgICBwYXlsb2FkOiBjYW5kaWRhdGVcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hY3Rpb25zLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi4vc3R5bGUuY3NzJztcblxuY29uc3QgVHdlZXQgPSAocHJvcHMpID0+IChcbiAgICA8bGkgY2xhc3NOYW1lPXtzdHlsZXMudHdlZXRJdGVtfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50d2VldEhlYWRlcn0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy50d2VldFVzZXJ9PlxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtyZXF1aXJlKCcuLi9pbWcvdHdpdHRlci5wbmcnKX0gY2xhc3NOYW1lPXtzdHlsZXMudHdpdHRlckxvZ299Lz5cbiAgICAgICAgICAgICAgICBAe3Byb3BzLnVzZXJ9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy50d2VldERhdGV9PlxuICAgICAgICAgICAgICAgIHtwcm9wcy5kYXRlLnN1YnN0cmluZygwLCAxMCl9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnR3ZWV0VGV4dH0+XG4gICAgICAgICAgICB7cHJvcHMudGV4dH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9saT5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFR3ZWV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9Ud2VldC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVHdlZXQgZnJvbSAnLi9Ud2VldCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4uL3N0eWxlLmNzcyc7XG5cbmNvbnN0IFR3ZWV0c0NvbnRhaW5lciA9IChwcm9wcykgPT4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudHdlZXRDb250YWluZXJ9PlxuICAgICAgICA8dWwgY2xhc3NOYW1lPXtzdHlsZXMudHdlZXRDb250YWluZXJVTH0+XG4gICAgICAgICAgICB7cHJvcHMudHdlZXRzLm1hcCgodHdlZXQsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgPFR3ZWV0XG4gICAgICAgICAgICAgICAgICAgIHVzZXI9e3R3ZWV0LnVzZXJ9XG4gICAgICAgICAgICAgICAgICAgIGRhdGU9e3R3ZWV0LmRhdGV9XG4gICAgICAgICAgICAgICAgICAgIHRleHQ9e3R3ZWV0LnRleHR9XG4gICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICA8L3VsPlxuICAgIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgVHdlZXRzQ29udGFpbmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9Ud2VldHNDb250YWluZXIuanMiLCJjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgY2FuZGlkYXRlOiAnVHJ1bXAnLFxuICAgIG9wcG9uZW50OiAnSGlsYXJ5JyxcbiAgICB0d2VldHM6IFtdXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0gaW5pdGlhbFN0YXRlLCBhY3Rpb24pe1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdUT0dHTEVfVVNFUic6XG4gICAgICAgICAgICBpZiAoc3RhdGUuY2FuZGlkYXRlID09ICdUcnVtcCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlOiAnSGlsYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgb3Bwb25lbnQ6ICdUcnVtcCcsXG4gICAgICAgICAgICAgICAgICAgIHR3ZWV0czogW11cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGU6ICdUcnVtcCcsXG4gICAgICAgICAgICAgICAgb3Bwb25lbnQ6ICdIaWxhcnknLFxuICAgICAgICAgICAgICAgIHR3ZWV0czogW11cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVEX1RXRUVUUyc6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgICAgICAgICAgICB0d2VldHM6IGFjdGlvbi50d2VldHNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVkdWNlcnMuanMiLCJpbXBvcnQge3B1dCwgdGFrZUV2ZXJ5LCBjYWxsfSBmcm9tICdyZWR1eC1zYWdhL2VmZmVjdHMnXG5cbmZ1bmN0aW9uIGZldGNoVHdlZXRzKHBvbGl0aWNpYW4pIHtcbiAgICByZXR1cm4gZmV0Y2goYC90d2VldHMvJHtwb2xpdGljaWFufWAsIHtcbiAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgXCJBY2NlcHRcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICB9XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VHdlZXRzSnNvbihibG9iKSB7XG4gICAgcmV0dXJuIGJsb2IuanNvbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGdldFR3ZWV0c0FzeW5jKGFjdGlvbikge1xuICAgIGZ1bmN0aW9uIGZpbHRlcih0d2VldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlcjogdHdlZXQudXNlci5uYW1lLFxuICAgICAgICAgICAgdGV4dDogdHdlZXQudGV4dCxcbiAgICAgICAgICAgIGRhdGU6IHR3ZWV0LmNyZWF0ZWRfYXRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHR3ZWV0cyA9IHlpZWxkIGNhbGwoZmV0Y2hUd2VldHMsIGFjdGlvbi5wYXlsb2FkKVxuICAgIGNvbnN0IHR3ZWV0c0pzb24gPSB5aWVsZCBjYWxsKGdldFR3ZWV0c0pzb24sIHR3ZWV0cyk7XG5cbiAgICB5aWVsZCBwdXQoe1xuICAgICAgICB0eXBlOiAnUkVDRUlWRURfVFdFRVRTJyxcbiAgICAgICAgdHdlZXRzOiB0d2VldHNKc29uLnN0YXR1c2VzLm1hcChmaWx0ZXIpXG4gICAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiogd2F0Y2hHZXRUd2VldCgpIHtcbiAgICB5aWVsZCB0YWtlRXZlcnkoJ0dFVF9UV0VFVFMnLCBnZXRUd2VldHNBc3luYylcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NhZ2FzLmpzIiwiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge2Nvbm5lY3R9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuaW1wb3J0IFR3ZWV0c0NvbnRhaW5lciBmcm9tICcuL2NvbXBvbmVudHMvVHdlZXRzQ29udGFpbmVyJztcbmltcG9ydCB7dG9nZ2xlVXNlciwgZ2V0VHdlZXRzfSBmcm9tICcuL2FjdGlvbnMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlLmNzcyc7XG5cbmNsYXNzIE1haW5WaWV3IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuY2xpY2tpbmcgPSB0aGlzLmNsaWNraW5nLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICBjb25zdCB7Y2FuZGlkYXRlLCBkaXNwYXRjaH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBkaXNwYXRjaChnZXRUd2VldHMoY2FuZGlkYXRlKSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wcy5jYW5kaWRhdGUgIT09IHRoaXMucHJvcHMuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCB7Y2FuZGlkYXRlLCBkaXNwYXRjaH0gPSBuZXh0UHJvcHM7XG4gICAgICAgICAgICBkaXNwYXRjaChnZXRUd2VldHMoY2FuZGlkYXRlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGlja2luZygpIHtcbiAgICAgICAgY29uc3Qge2Rpc3BhdGNofSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGRpc3BhdGNoKHRvZ2dsZVVzZXIoKSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7Y2FuZGlkYXRlLCB0d2VldHMsIG9wcG9uZW50fSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jYW5kaWRhdGVDb250YWluZXJ9PlxuICAgICAgICAgICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM9e3JlcXVpcmUoYC4vaW1nLyR7Y2FuZGlkYXRlLnRvTG93ZXJDYXNlKCl9LnBuZ2ApfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXNbYHBvc2l0aW9uJHtjYW5kaWRhdGV9YF19XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxUd2VldHNDb250YWluZXIgdHdlZXRzPXt0d2VldHN9Lz5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5jbGlja2luZ31cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNhbmRpZGF0ZUJ1dHRvbn1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtvcHBvbmVudH1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IHN0YXRlID0+ICh7XG4gICAgY2FuZGlkYXRlOiBzdGF0ZS5jYW5kaWRhdGUsXG4gICAgb3Bwb25lbnQ6IHN0YXRlLm9wcG9uZW50LFxuICAgIHR3ZWV0czogc3RhdGUudHdlZXRzXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMpKE1haW5WaWV3KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3ZpZXcuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJib2R5IHtcXG4gICAgd2lkdGg6IDEwMHZoO1xcbiAgICBoZWlnaHQ6IDEwMHZ3O1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBmb250LWZhbWlseTogaGVsdmV0aWNhLCBhcmlhbCwgc2Fucy1zZXJpZjtcXG59XFxuXFxuLl8za2ZCeWl1QlpWaWlsRDNJeDR5OFJxIHtcXG4gICAgY29sb3I6ICNmOWY5Zjk7XFxuICAgIG1hcmdpbi1sZWZ0OiAyNXB4O1xcbiAgICBtYXJnaW4tdG9wOiAyMHB4O1xcbiAgICBmb250LXNpemU6IDMwcHg7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLl8xZDFWUXotQWdEdWQ0VWo1SmN0ZlR4IHtcXG4gICAgaGVpZ2h0OiA1MDBweDtcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG5cXG4uXzJCQl90anZyenNpdXY4Y0h0WDFKa3Ige1xcbiAgICBoZWlnaHQ6IDUwMHB4O1xcbiAgICBmbG9hdDogbGVmdDtcXG59XFxuXFxuLl8xZzh4ZVZYaWhheHM1NkNtekhmekNyIHtcXG4gICAgaGVpZ2h0OiAxNXB4O1xcbiAgICB3aWR0aDogMTVweDtcXG59XFxuXFxuLl8zTUJDZUh4aG1pRHQ4MDY3Y0RuN2luIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBtYXJnaW4tdG9wOiA0MHB4O1xcbiAgICBtYXJnaW4tbGVmdDogMjBweDtcXG4gICAgaGVpZ2h0OiAzNTBweDtcXG59XFxuXFxuLl8zYnlZTUk3a2NSV0ZLbExMOXBvQWxVIHtcXG4gICAgaGVpZ2h0OiAyNXB4O1xcbiAgICBjb2xvcjogZ3JheTtcXG59XFxuXFxuLkRCWnR5ZF9VVngtZFZFZzZyanU0NSB7XFxuICAgIGZsb2F0OiByaWdodDtcXG59XFxuXFxuLnBTUGVIVU93dHF3LWFrMDlVdmRfViB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLl8zZVYyYmdYZ0gzMm1ab1RVNVhaLW0wIHtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgcGFkZGluZy1sZWZ0OiAyMHB4O1xcbn1cXG5cXG4uXzMwcE9pemg5RGVFcmtCWUVnN2dUR2oge1xcbiAgICAtd2Via2l0LW1hcmdpbi1iZWZvcmU6IDA7XFxuICAgIC13ZWJraXQtbWFyZ2luLWFmdGVyOiAwO1xcbiAgICAtd2Via2l0LW1hcmdpbi1zdGFydDogMDtcXG4gICAgLXdlYmtpdC1tYXJnaW4tZW5kOiAwcHg7XFxuICAgIC13ZWJraXQtcGFkZGluZy1zdGFydDogMDtcXG59XFxuXFxuLl8zZ3hNQXZQeXBuY0xPYnEzMlloRjZhIHtcXG4gICAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAyM3B4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgbWFyZ2luOiA1cHggNXB4IDVweCA1cHg7XFxuICAgIHBhZGRpbmc6IDEwcHggMTBweCAxMHB4IDEwcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgbWF4LXdpZHRoOiA1NTBweDtcXG59XFxuXFxuLl8xc3psN1AwMENEblI3SjExSl9lRjZqIHtcXG4gICAgd2lkdGg6IDk1MHB4O1xcbiAgICBoZWlnaHQ6IDUwMHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBtYXJnaW4tdG9wOiBjYWxjKDUwdmggLSAyNTBweCk7XFxuICAgIG1hcmdpbi1sZWZ0OiBjYWxjKDUwdncgLSA0NzVweCk7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbmV4cG9ydHMubG9jYWxzID0ge1xuXHRcImNhbmRpZGF0ZUJ1dHRvblwiOiBcIl8za2ZCeWl1QlpWaWlsRDNJeDR5OFJxXCIsXG5cdFwicG9zaXRpb25IaWxhcnlcIjogXCJfMWQxVlF6LUFnRHVkNFVqNUpjdGZUeFwiLFxuXHRcInBvc2l0aW9uVHJ1bXBcIjogXCJfMkJCX3RqdnJ6c2l1djhjSHRYMUprclwiLFxuXHRcInR3aXR0ZXJMb2dvXCI6IFwiXzFnOHhlVlhpaGF4czU2Q216SGZ6Q3JcIixcblx0XCJ0d2VldENvbnRhaW5lclwiOiBcIl8zTUJDZUh4aG1pRHQ4MDY3Y0RuN2luXCIsXG5cdFwidHdlZXRIZWFkZXJcIjogXCJfM2J5WU1JN2tjUldGS2xMTDlwb0FsVVwiLFxuXHRcInR3ZWV0RGF0ZVwiOiBcIkRCWnR5ZF9VVngtZFZFZzZyanU0NVwiLFxuXHRcInR3ZWV0VXNlclwiOiBcInBTUGVIVU93dHF3LWFrMDlVdmRfVlwiLFxuXHRcInR3ZWV0VGV4dFwiOiBcIl8zZVYyYmdYZ0gzMm1ab1RVNVhaLW0wXCIsXG5cdFwidHdlZXRDb250YWluZXJVTFwiOiBcIl8zMHBPaXpoOURlRXJrQllFZzdnVEdqXCIsXG5cdFwidHdlZXRJdGVtXCI6IFwiXzNneE1BdlB5cG5jTE9icTMyWWhGNmFcIixcblx0XCJjYW5kaWRhdGVDb250YWluZXJcIjogXCJfMXN6bDdQMDBDRG5SN0oxMUpfZUY2alwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlcj9tb2R1bGVzIS4vc3R5bGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2ZianMvbGliL2NhbWVsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2VycyBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdFxuICAvLyBpbiBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBvYmouY2FsbGVlICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgY2FuXFwndCBiZSBgYXJndW1lbnRzYC4gVXNlIHJlc3QgcGFyYW1zICcgKyAnKGZ1bmN0aW9uKC4uLmFyZ3MpIHt9KSBvciBBcnJheS5mcm9tKCkgaW5zdGVhZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXG4gKlxuICogICBBIG1vbmsgYXNrZWQgSm9zaHUsIGEgWmVuIG1hc3RlciwgXCJIYXMgYSBkb2cgQnVkZGhhIG5hdHVyZT9cIlxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGl0cyBhcmd1bWVudCBoYXMgXCJhcnJheSBuYXR1cmVcIjogaXQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXG4gKiBIVE1MQ29sbGVjdGlvbiAoZS5nLiBub2RlLmNoaWxkTm9kZXMgb3Igbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgpKS5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0FycmF5TmF0dXJlKG9iaikge1xuICByZXR1cm4gKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCcuL2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJy4vZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XG5cbiAgdmFyIHdyYXAgPSBub2RlTmFtZSAmJiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKTtcbiAgaWYgKHdyYXApIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHdyYXBbMV0gKyBtYXJrdXAgKyB3cmFwWzJdO1xuXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XG4gICAgd2hpbGUgKHdyYXBEZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbWFya3VwO1xuICB9XG5cbiAgdmFyIHNjcmlwdHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgIWhhbmRsZVNjcmlwdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoLi4uKTogVW5leHBlY3RlZCA8c2NyaXB0PiBlbGVtZW50IHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjcmVhdGVBcnJheUZyb21NaXhlZChzY3JpcHRzKS5mb3JFYWNoKGhhbmRsZVNjcmlwdCk7XG4gIH1cblxuICB2YXIgbm9kZXMgPSBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwgKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byBkZXRlY3Qgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeS5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcbiAqIHNvIHdlIHdyYXAgdGhlbSwgcmVuZGVyIHRoZSB3cmFwcGVkIG5vZGVzLCB0aGVuIGV4dHJhY3QgdGhlIGRlc2lyZWQgbm9kZS5cbiAqXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXG4gKi9cblxudmFyIHNob3VsZFdyYXAgPSB7fTtcblxudmFyIHNlbGVjdFdyYXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJ0cnVlXCI+JywgJzwvc2VsZWN0PiddO1xudmFyIHRhYmxlV3JhcCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xudmFyIHRyV3JhcCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG52YXIgc3ZnV3JhcCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JywgJzwvc3ZnPiddO1xuXG52YXIgbWFya3VwV3JhcCA9IHtcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcblxuICAnYXJlYSc6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgJ2xlZ2VuZCc6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICAncGFyYW0nOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcblxuICAnb3B0Z3JvdXAnOiBzZWxlY3RXcmFwLFxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcblxuICAnY2FwdGlvbic6IHRhYmxlV3JhcCxcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxuICAndGJvZHknOiB0YWJsZVdyYXAsXG4gICd0Zm9vdCc6IHRhYmxlV3JhcCxcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxuXG4gICd0ZCc6IHRyV3JhcCxcbiAgJ3RoJzogdHJXcmFwXG59O1xuXG4vLyBJbml0aWFsaXplIHRoZSBTVkcgZWxlbWVudHMgc2luY2Ugd2Uga25vdyB0aGV5J2xsIGFsd2F5cyBuZWVkIHRvIGJlIHdyYXBwZWRcbi8vIGNvbnNpc3RlbnRseS4gSWYgdGhleSBhcmUgY3JlYXRlZCBpbnNpZGUgYSA8ZGl2PiB0aGV5IHdpbGwgYmUgaW5pdGlhbGl6ZWQgaW5cbi8vIHRoZSB3cm9uZyBuYW1lc3BhY2UgKGFuZCB3aWxsIG5vdCBkaXNwbGF5KS5cbnZhciBzdmdFbGVtZW50cyA9IFsnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAndGV4dCcsICd0c3BhbiddO1xuc3ZnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgbWFya3VwV3JhcFtub2RlTmFtZV0gPSBzdmdXcmFwO1xuICBzaG91bGRXcmFwW25vZGVOYW1lXSA9IHRydWU7XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGlmICghbWFya3VwV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBub2RlTmFtZSA9ICcqJztcbiAgfVxuICBpZiAoIXNob3VsZFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnKicpIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzwnICsgbm9kZU5hbWUgKyAnPjwvJyArIG5vZGVOYW1lICsgJz4nO1xuICAgIH1cbiAgICBzaG91bGRXcmFwW25vZGVOYW1lXSA9ICFkdW1teU5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlLldpbmRvdyAmJiBzY3JvbGxhYmxlIGluc3RhbmNlb2Ygc2Nyb2xsYWJsZS5XaW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogc2Nyb2xsYWJsZS5wYWdlWE9mZnNldCB8fCBzY3JvbGxhYmxlLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogc2Nyb2xsYWJsZS5wYWdlWU9mZnNldCB8fCBzY3JvbGxhYmxlLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9oeXBoZW5hdGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9pc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICovXG5cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHwgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImluZGV4Lmh0bWxcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2ZpbGUtbG9hZGVyP25hbWU9aW5kZXguaHRtbCEuL2luZGV4Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBjdXN0b21TdGF0aWNzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5c1tpXV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5c1tpXV0gJiYgKCFjdXN0b21TdGF0aWNzIHx8ICFjdXN0b21TdGF0aWNzW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbXBvbmVudFtrZXlzW2ldXSA9IHNvdXJjZUNvbXBvbmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vaW52YXJpYW50L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBnZXRQcm90b3R5cGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoLWVzL19nZXRSYXdUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoLWVzL19vdmVyQXJnLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoLWVzL19yb290LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUpO1xuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNoaW0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBpZiAoc2VjcmV0ID09PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgLy8gSXQgaXMgc3RpbGwgc2FmZSB3aGVuIGNhbGxlZCBmcm9tIFJlYWN0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH07XG4gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH07XG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdERPTScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQVJJQURPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7XG4gICAgLy8gR2xvYmFsIFN0YXRlcyBhbmQgUHJvcGVydGllc1xuICAgICdhcmlhLWN1cnJlbnQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWRldGFpbHMnOiAwLFxuICAgICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgICAnYXJpYS1oaWRkZW4nOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICAgJ2FyaWEtbGFiZWwnOiAwLFxuICAgICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gICAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAgICdhcmlhLWNoZWNrZWQnOiAwLFxuICAgICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAgICdhcmlhLW1vZGFsJzogMCxcbiAgICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAgICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAgICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAgICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgICAnYXJpYS1zb3J0JzogMCxcbiAgICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAgICdhcmlhLXZhbHVlbm93JzogMCxcbiAgICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAgIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgICAnYXJpYS1hdG9taWMnOiAwLFxuICAgICdhcmlhLWJ1c3knOiAwLFxuICAgICdhcmlhLWxpdmUnOiAwLFxuICAgICdhcmlhLXJlbGV2YW50JzogMCxcbiAgICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAgICdhcmlhLWNvbGNvdW50JzogMCxcbiAgICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAgICdhcmlhLWZsb3d0byc6IDAsXG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICAgJ2FyaWEtb3ducyc6IDAsXG4gICAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAgICdhcmlhLXJvd2NvdW50JzogMCxcbiAgICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICAgJ2FyaWEtc2V0c2l6ZSc6IDBcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHt9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBUklBRE9NUHJvcGVydHlDb25maWc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL0FSSUFET01Qcm9wZXJ0eUNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHtcbiAgZm9jdXNET01Db21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBmb2N1c05vZGUoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcykpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9Gb2N1c1V0aWxzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9BdXRvRm9jdXNVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljSW5wdXRFdmVudCcpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkJlZm9yZUlucHV0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5nZXRQb29sZWQobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RvcFRleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENvbXBvc2l0aW9uRW5kJyB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoJy4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZScpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciB0ZW1wU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgdHJ5IHtcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgdGVtcFN0eWxlLmZvbnQgPSAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcbiAgfVxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4lcyAnICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSwgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIGNoZWNrUmVuZGVyTWVzc2FnZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICB2YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGNvbXBvbmVudCkge1xuICAgIHZhciBvd25lcjtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgIH1cbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYSBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgZm9yIHVzZSBhcyBpbmxpbmUgc3R5bGVzOlxuICAgKlxuICAgKiAgID4gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHt3aWR0aDogJzIwMHB4JywgaGVpZ2h0OiAwfSlcbiAgICogICBcIndpZHRoOjIwMHB4O2hlaWdodDowO1wiXG4gICAqXG4gICAqIFVuZGVmaW5lZCB2YWx1ZXMgYXJlIGlnbm9yZWQgc28gdGhhdCBkZWNsYXJhdGl2ZSBwcm9ncmFtbWluZyBpcyBlYXNpZXIuXG4gICAqIFRoZSByZXN1bHQgc2hvdWxkIGJlIEhUTUwtZXNjYXBlZCBiZWZvcmUgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcywgY29tcG9uZW50KSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWFsaXplZCArPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGNvbXBvbmVudCkgKyAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAgICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cbiAgc2V0VmFsdWVGb3JTdHlsZXM6IGZ1bmN0aW9uIChub2RlLCBzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogY29tcG9uZW50Ll9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIHN0eWxlcycsXG4gICAgICAgIHBheWxvYWQ6IHN0eWxlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0JyB8fCBzdHlsZU5hbWUgPT09ICdjc3NGbG9hdCcpIHtcbiAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVGbG9hdEFjY2Vzc29yO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgJiYgQ1NTUHJvcGVydHkuc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zW3N0eWxlTmFtZV07XG4gICAgICAgIGlmIChleHBhbnNpb24pIHtcbiAgICAgICAgICAvLyBTaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBJRTggd29uJ3QgbGlrZSB1bnNldHRpbmcsIHNvIHVuc2V0IGVhY2hcbiAgICAgICAgICAvLyBjb21wb25lbnQgdG8gcGxhY2F0ZSBpdFxuICAgICAgICAgIGZvciAodmFyIGluZGl2aWR1YWxTdHlsZU5hbWUgaW4gZXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBzdHlsZVtpbmRpdmlkdWFsU3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2hhbmdlJykge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICAvLyBJRTEwKyBmaXJlIGlucHV0IGV2ZW50cyB0byBvZnRlbiwgc3VjaCB3aGVuIGEgcGxhY2Vob2xkZXJcbiAgLy8gY2hhbmdlcyBvciB3aGVuIGFuIGlucHV0IHdpdGggYSBwbGFjZWhvbGRlciBpcyBmb2N1c2VkLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDExKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcbiAgICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLnNldC5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbn07XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcblxuICAvLyBOb3QgZ3VhcmRlZCBpbiBhIGNhbkRlZmluZVByb3BlcnR5IGNoZWNrOiBJRTggc3VwcG9ydHMgZGVmaW5lUHJvcGVydHkgb25seVxuICAvLyBvbiBET00gZWxlbWVudHNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGlmIChhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuXG4gIGlmIChhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0Jykge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOS0xMSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcFNlbGVjdGlvbkNoYW5nZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5VXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJbnN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDbGljaycpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICB2YXIgdmFsdWUgPSAnJyArIG5vZGUudmFsdWU7XG4gIGlmIChub2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChkb2VzQ2hhbmdlRXZlbnRCdWJibGUpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFODtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gICAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXRJbnN0LCB0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VFdmVudFBsdWdpbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlTm9kZXNGcm9tTWFya3VwID0gcmVxdWlyZSgnZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIERhbmdlciA9IHtcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzU2JykgOiB2b2lkIDA7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IF9wcm9kSW52YXJpYW50KCc1NycpIDogdm9pZCAwO1xuICAgICEob2xkQ2hpbGQubm9kZU5hbWUgIT09ICdIVE1MJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSA8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlIGFuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpLicpIDogX3Byb2RJbnZhcmlhbnQoJzU4JykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9EYW5nZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG5cbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IFsnUmVzcG9uZGVyRXZlbnRQbHVnaW4nLCAnU2ltcGxlRXZlbnRQbHVnaW4nLCAnVGFwRXZlbnRQbHVnaW4nLCAnRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJywgJ0NoYW5nZUV2ZW50UGx1Z2luJywgJ1NlbGVjdEV2ZW50UGx1Z2luJywgJ0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZpbmcgdG8gYSBub2RlIGZyb20gb3V0c2lkZSB0aGUgd2luZG93LlxuICAgICAgZnJvbSA9IG51bGw7XG4gICAgICB0byA9IHRhcmdldEluc3Q7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tTm9kZTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHJvb3RcbiAqL1xuZnVuY3Rpb24gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHJvb3QpIHtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3N0YXJ0VGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5fYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChuZXcgUmVnRXhwKCdeKGRhdGF8YXJpYSktWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpKSxcbiAgUHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhY2NlcHQ6IDAsXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBhY2Nlc3NLZXk6IDAsXG4gICAgYWN0aW9uOiAwLFxuICAgIGFsbG93RnVsbFNjcmVlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IDAsXG4gICAgYWx0OiAwLFxuICAgIC8vIHNwZWNpZmllcyB0YXJnZXQgY29udGV4dCBmb3IgbGlua3Mgd2l0aCBgcHJlbG9hZGAgdHlwZVxuICAgIGFzOiAwLFxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvQ29tcGxldGU6IDAsXG4gICAgLy8gYXV0b0ZvY3VzIGlzIHBvbHlmaWxsZWQvbm9ybWFsaXplZCBieSBBdXRvRm9jdXNVdGlsc1xuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNlbGxQYWRkaW5nOiAwLFxuICAgIGNlbGxTcGFjaW5nOiAwLFxuICAgIGNoYXJTZXQ6IDAsXG4gICAgY2hhbGxlbmdlOiAwLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2l0ZTogMCxcbiAgICBjbGFzc0lEOiAwLFxuICAgIGNsYXNzTmFtZTogMCxcbiAgICBjb2xzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIGNvbnRlbnQ6IDAsXG4gICAgY29udGVudEVkaXRhYmxlOiAwLFxuICAgIGNvbnRleHRNZW51OiAwLFxuICAgIGNvbnRyb2xzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IDAsXG4gICAgY3Jvc3NPcmlnaW46IDAsXG4gICAgZGF0YTogMCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiAwLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogMCxcbiAgICBkaXNhYmxlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiAwLFxuICAgIGVuY1R5cGU6IDAsXG4gICAgZm9ybTogMCxcbiAgICBmb3JtQWN0aW9uOiAwLFxuICAgIGZvcm1FbmNUeXBlOiAwLFxuICAgIGZvcm1NZXRob2Q6IDAsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1UYXJnZXQ6IDAsXG4gICAgZnJhbWVCb3JkZXI6IDAsXG4gICAgaGVhZGVyczogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWdoOiAwLFxuICAgIGhyZWY6IDAsXG4gICAgaHJlZkxhbmc6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgaWNvbjogMCxcbiAgICBpZDogMCxcbiAgICBpbnB1dE1vZGU6IDAsXG4gICAgaW50ZWdyaXR5OiAwLFxuICAgIGlzOiAwLFxuICAgIGtleVBhcmFtczogMCxcbiAgICBrZXlUeXBlOiAwLFxuICAgIGtpbmQ6IDAsXG4gICAgbGFiZWw6IDAsXG4gICAgbGFuZzogMCxcbiAgICBsaXN0OiAwLFxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvdzogMCxcbiAgICBtYW5pZmVzdDogMCxcbiAgICBtYXJnaW5IZWlnaHQ6IDAsXG4gICAgbWFyZ2luV2lkdGg6IDAsXG4gICAgbWF4OiAwLFxuICAgIG1heExlbmd0aDogMCxcbiAgICBtZWRpYTogMCxcbiAgICBtZWRpYUdyb3VwOiAwLFxuICAgIG1ldGhvZDogMCxcbiAgICBtaW46IDAsXG4gICAgbWluTGVuZ3RoOiAwLFxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiAwLFxuICAgIG5vbmNlOiAwLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wdGltdW06IDAsXG4gICAgcGF0dGVybjogMCxcbiAgICBwbGFjZWhvbGRlcjogMCxcbiAgICBwbGF5c0lubGluZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcG9zdGVyOiAwLFxuICAgIHByZWxvYWQ6IDAsXG4gICAgcHJvZmlsZTogMCxcbiAgICByYWRpb0dyb3VwOiAwLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZWZlcnJlclBvbGljeTogMCxcbiAgICByZWw6IDAsXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJldmVyc2VkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByb2xlOiAwLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNhbmRib3g6IDAsXG4gICAgc2NvcGU6IDAsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzY3JvbGxpbmc6IDAsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiAwLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiAwLFxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IDAsXG4gICAgc3JjOiAwLFxuICAgIHNyY0RvYzogMCxcbiAgICBzcmNMYW5nOiAwLFxuICAgIHNyY1NldDogMCxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc3RlcDogMCxcbiAgICBzdHlsZTogMCxcbiAgICBzdW1tYXJ5OiAwLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIHRhcmdldDogMCxcbiAgICB0aXRsZTogMCxcbiAgICAvLyBTZXR0aW5nIC50eXBlIHRocm93cyBvbiBub24tPGlucHV0PiB0YWdzXG4gICAgdHlwZTogMCxcbiAgICB1c2VNYXA6IDAsXG4gICAgdmFsdWU6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgd21vZGU6IDAsXG4gICAgd3JhcDogMCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiAwLFxuICAgIGRhdGF0eXBlOiAwLFxuICAgIGlubGlzdDogMCxcbiAgICBwcmVmaXg6IDAsXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IDAsXG4gICAgcmVzb3VyY2U6IDAsXG4gICAgJ3R5cGVvZic6IDAsXG4gICAgdm9jYWI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGF1dG9DYXBpdGFsaXplIGFuZCBhdXRvQ29ycmVjdCBhcmUgc3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yXG4gICAgLy8ga2V5Ym9hcmQgaGludHMuXG4gICAgYXV0b0NhcGl0YWxpemU6IDAsXG4gICAgYXV0b0NvcnJlY3Q6IDAsXG4gICAgLy8gYXV0b1NhdmUgYWxsb3dzIFdlYktpdC9CbGluayB0byBwZXJzaXN0IHZhbHVlcyBvZiBpbnB1dCBmaWVsZHMgb24gcGFnZSByZWxvYWRzXG4gICAgYXV0b1NhdmU6IDAsXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xuICAgIGNvbG9yOiAwLFxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1Qcm9wOiAwLFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaXRlbVR5cGU6IDAsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXG4gICAgaXRlbUlEOiAwLFxuICAgIGl0ZW1SZWY6IDAsXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XG4gICAgLy8gc2VhcmNoIGZpZWxkcyBpbiBXZWJLaXQvQmxpbmtcbiAgICByZXN1bHRzOiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcbiAgICAvLyBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgb24gSUU8MTBcbiAgICBzZWN1cml0eTogMCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXG4gICAgdW5zZWxlY3RhYmxlOiAwXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge30sXG4gIERPTU11dGF0aW9uTWV0aG9kczoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgLy8gTnVtYmVyIGlucHV0cyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgZHVlIHRvIHNvbWUgZWRnZSBjYXNlcyBpblxuICAgICAgLy8gQ2hyb21lLiBMZXQgZXZlcnl0aGluZyBlbHNlIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIGFzIG5vcm1hbC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1MyNpc3N1ZWNvbW1lbnQtMjM2MDc0MzI2XG4gICAgICBpZiAobm9kZS50eXBlICE9PSAnbnVtYmVyJyB8fCBub2RlLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsaWRpdHkgJiYgIW5vZGUudmFsaWRpdHkuYmFkSW5wdXQgJiYgbm9kZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IG5vZGUpIHtcbiAgICAgICAgLy8gRG9uJ3QgYXNzaWduIGFuIGF0dHJpYnV0ZSBpZiB2YWxpZGF0aW9uIHJlcG9ydHMgYmFkXG4gICAgICAgIC8vIGlucHV0LiBDaHJvbWUgd2lsbCBjbGVhciB0aGUgdmFsdWUuIEFkZGl0aW9uYWxseSwgZG9uJ3RcbiAgICAgICAgLy8gb3BlcmF0ZSBvbiBpbnB1dHMgdGhhdCBoYXZlIGZvY3VzLCBvdGhlcndpc2UgQ2hyb21lIG1pZ2h0XG4gICAgICAgIC8vIHN0cmlwIG9mZiB0cmFpbGluZyBkZWNpbWFsIHBsYWNlcyBhbmQgY2F1c2UgdGhlIHVzZXInc1xuICAgICAgICAvLyBjdXJzb3IgcG9zaXRpb24gdG8ganVtcCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW4gUmVhY3RET01JbnB1dCwgd2UgaGF2ZSBhbiBvbkJsdXIgZXZlbnQgdGhhdCB3aWxsIHRyaWdnZXJcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBhZ2FpbiB3aGVuIGZvY3VzIGlzIGxvc3QuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xuXG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0YW5jZXMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIGtleVVuaXF1ZSA9IGNoaWxkSW5zdGFuY2VzW25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICB9XG4gICAgaWYgKCFrZXlVbmlxdWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBrZXlVbmlxdWUpIHtcbiAgICBjaGlsZEluc3RhbmNlc1tuYW1lXSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoY2hpbGQsIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogUmVhY3RDaGlsZFJlY29uY2lsZXIgcHJvdmlkZXMgaGVscGVycyBmb3IgaW5pdGlhbGl6aW5nIG9yIHVwZGF0aW5nIGEgc2V0IG9mXG4gKiBjaGlsZHJlbi4gSXRzIG91dHB1dCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyBpdCBvbnRvIFJlYWN0TXVsdGlDaGlsZCB3aGljaFxuICogZG9lcyBkaWZmZWQgcmVvcmRlcmluZyBhbmQgaW5zZXJ0aW9uLlxuICovXG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIH0sIGNoaWxkSW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBpbnN0YW50aWF0ZUNoaWxkLCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gYW5kIHJldHVybnMgYSBuZXcgc2V0IG9mIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q2hpbGRyZW4gRmxhdCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gICkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgd2F5IHRvIHRyYWNrIG1vdmVzIGhlcmUgYnV0IGlmIHdlIHVzZSBpdGVyYXRvcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGZvci4uaW4gd2UgY2FuIHppcCB0aGUgaXRlcmF0b3JzIGFuZCBjaGVjayBpZiBhbiBpdGVtIGhhc1xuICAgIC8vIG1vdmVkLlxuICAgIC8vIFRPRE86IElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHJldHVybiB0aGUgcHJldkNoaWxkcmVuIG9iamVjdCBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHF1aWNrbHkgYmFpbG91dCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIHByZXZDaGlsZDtcbiAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q2hpbGQgJiYgcHJldkNoaWxkLl9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgIGlmIChwcmV2Q2hpbGQgIT0gbnVsbCAmJiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDaGlsZCwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gcHJldkNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XG4gICAgICAgIC8vIENyZWF0aW5nIG1vdW50IGltYWdlIG5vdyBlbnN1cmVzIHJlZnMgYXJlIHJlc29sdmVkIGluIHJpZ2h0IG9yZGVyXG4gICAgICAgIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzEwMSBmb3IgZXhwbGFuYXRpb24pLlxuICAgICAgICB2YXIgbmV4dENoaWxkTW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChuZXh0Q2hpbGRJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobmV4dENoaWxkTW91bnRJbWFnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVubW91bnQgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHJlbmRlcmVkQ2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAocmVuZGVyZWRDaGlsZHJlbiwgc2FmZWx5KSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiByZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgICBpZiAocmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHJlbmRlcmVkQ2hpbGQsIHNhZmVseSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3ROb2RlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0Tm9kZVR5cGVzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG59XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIENvbXBvc2l0ZVR5cGVzID0ge1xuICBJbXB1cmVDbGFzczogMCxcbiAgUHVyZUNsYXNzOiAxLFxuICBTdGF0ZWxlc3NGdW5jdGlvbmFsOiAyXG59O1xuXG5mdW5jdGlvbiBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KSB7fVxuU3RhdGVsZXNzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBDb21wb25lbnQgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgdmFyIGVsZW1lbnQgPSBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xuICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmZ1bmN0aW9uIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCksICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBTZXBhcmF0ZWQgaW50byBhIGZ1bmN0aW9uIHRvIGNvbnRhaW4gZGVvcHRpbWl6YXRpb25zIGNhdXNlZCBieSB0cnkvZmluYWxseS5cbmZ1bmN0aW9uIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZuLCBkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGRlYnVnSUQgPT09IDApIHtcbiAgICAvLyBUb3AtbGV2ZWwgd3JhcHBlcnMgKHNlZSBSZWFjdE1vdW50KSBhbmQgZW1wdHkgY29tcG9uZW50cyAoc2VlXG4gICAgLy8gUmVhY3RET01FbXB0eUNvbXBvbmVudCkgYXJlIGludmlzaWJsZSB0byBob29rcyBhbmQgZGV2dG9vbHMuXG4gICAgLy8gQm90aCBhcmUgaW1wbGVtZW50YXRpb24gZGV0YWlscyB0aGF0IHNob3VsZCBnbyBhd2F5IGluIHRoZSBmdXR1cmUuXG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLSBUaGUgTGlmZS1DeWNsZSBvZiBhIENvbXBvc2l0ZSBDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXG4gKiAgIC0gY29tcG9uZW50V2lsbE1vdW50XG4gKiAgIC0gcmVuZGVyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXJdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XG4gKlxuICogICAgICAgVXBkYXRlIFBoYXNlczpcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXG4gKiAgICAgICAtIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcbiAqICAgICAgICAgICAtIHJlbmRlclxuICogICAgICAgICAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzIG9yIHJlY2VpdmUgcHJvcHMgcGhhc2VzXVxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxuICpcbiAqICAgICAtIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxuICogLSAoZGVzdHJveWVkKTogVGhlIGluc3RhbmNlIGlzIG5vdyBibGFuaywgcmVsZWFzZWQgYnkgUmVhY3QgYW5kIHJlYWR5IGZvciBHQy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQW4gaW5jcmVtZW50aW5nIElEIGFzc2lnbmVkIHRvIGVhY2ggY29tcG9uZW50IHdoZW4gaXQgaXMgbW91bnRlZC4gVGhpcyBpc1xuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG5leHRNb3VudElEID0gMTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlUXVldWVcbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICAvLyBDb21wb25lbnRXaWxsVW5tb3VudCBzaGFsbCBvbmx5IGJlIGNhbGxlZCBvbmNlXG4gICAgdGhpcy5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSBmYWxzZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aGlzLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0UGFyZW50XG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdENvbnRhaW5lckluZm9cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICB2YXIgdXBkYXRlUXVldWUgPSB0cmFuc2FjdGlvbi5nZXRVcGRhdGVRdWV1ZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGRvQ29uc3RydWN0ID0gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCk7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnQoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIC8vIFN1cHBvcnQgZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgaWYgKCFkb0NvbnN0cnVjdCAmJiAoaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0O1xuICAgICAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCByZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgIShpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KGluc3QpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDUnLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaW5zdCA9IG5ldyBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5JbXB1cmVDbGFzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcbiAgICAgIC8vIHdhcm5pbmcgbm93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc011dGF0ZWQgPSBpbnN0LnByb3BzICE9PSBwdWJsaWNQcm9wcztcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LnByb3BzID09PSB1bmRlZmluZWQgfHwgIXByb3BzTXV0YXRlZCwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyAndXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8IGluc3Quc3RhdGUsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdC5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LnByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuY29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSAnICsgJ3N0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDYnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgbWFya3VwO1xuICAgIGlmIChpbnN0LnVuc3RhYmxlX2hhbmRsZUVycm9yKSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZyhyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSwgX3RoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50OiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcjogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGlmIChkb0NvbnN0cnVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY3RvcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGNhbiBzdGlsbCBiZSBhbiBpbnN0YW5jZSBpbiBjYXNlIG9mIGZhY3RvcnkgY29tcG9uZW50c1xuICAgIC8vIGJ1dCB3ZSdsbCBjb3VudCB0aGlzIGFzIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGFzIHRoZSBtb3JlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB9XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nOiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbWFya3VwO1xuICAgIHZhciBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuICAgIHRyeSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFJvbGwgYmFjayB0byBjaGVja3BvaW50LCBoYW5kbGUgZXJyb3IgKHdoaWNoIG1heSBhZGQgaXRlbXMgdG8gdGhlIHRyYW5zYWN0aW9uKSwgYW5kIHRha2UgYSBuZXcgY2hlY2twb2ludFxuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG4gICAgICB0aGlzLl9pbnN0YW5jZS51bnN0YWJsZV9oYW5kbGVFcnJvcihlKTtcbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUodGhpcy5faW5zdGFuY2UucHJvcHMsIHRoaXMuX2luc3RhbmNlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgY2hlY2twb2ludCA9IHRyYW5zYWN0aW9uLmNoZWNrcG9pbnQoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQudW5tb3VudENvbXBvbmVudCh0cnVlKTtcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuXG4gICAgICAvLyBUcnkgYWdhaW4gLSB3ZSd2ZSBpbmZvcm1lZCB0aGUgY29tcG9uZW50IGFib3V0IHRoZSBlcnJvciwgc28gdGhleSBjYW4gcmVuZGVyIGFuIGVycm9yIG1lc3NhZ2UgdGhpcyB0aW1lLlxuICAgICAgLy8gSWYgdGhpcyB0aHJvd3MgYWdhaW4sIHRoZSBlcnJvciB3aWxsIGJ1YmJsZSB1cCAoYW5kIGNhbiBiZSBjYXVnaHQgYnkgYSBoaWdoZXIgZXJyb3IgYm91bmRhcnkpLlxuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50OiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGRlYnVnSUQgPSAwO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgfSwgZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cbiAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcbiAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZWAgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgd2Ugbm93IHJlbmRlclxuICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShyZW5kZXJlZEVsZW1lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KHJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgKTtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xuXG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBkZWJ1Z0lEKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xuICAgICAgICB2YXIgY2hpbGREZWJ1Z0lEcyA9IGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdO1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZSh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50ICYmICFpbnN0Ll9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSB0cnVlO1xuXG4gICAgICBpZiAoc2FmZWx5KSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXROYW1lKCkgKyAnLmNvbXBvbmVudFdpbGxVbm1vdW50KCknO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQuYmluZChpbnN0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgc2FmZWx5KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBlbmRpbmcgZmllbGRzXG4gICAgLy8gRXZlbiBpZiB0aGlzIGNvbXBvbmVudCBpcyBzY2hlZHVsZWQgZm9yIGFub3RoZXIgdXBkYXRlIGluIFJlYWN0VXBkYXRlcyxcbiAgICAvLyBpdCB3b3VsZCBzdGlsbCBiZSBpZ25vcmVkIGJlY2F1c2UgdGhlc2UgZmllbGRzIGFyZSByZXNldC5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIC8vIFRoZXNlIGZpZWxkcyBkbyBub3QgcmVhbGx5IG5lZWQgdG8gYmUgcmVzZXQgc2luY2UgdGhpcyBvYmplY3QgaXMgbm9cbiAgICAvLyBsb25nZXIgYWNjZXNzaWJsZS5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gRGVsZXRlIHRoZSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgdG8gdGhpcyBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIC8vIHdoaWNoIGFsbG93IHRoZSBpbnRlcm5hbHMgdG8gYmUgcHJvcGVybHkgY2xlYW5lZCB1cCBldmVuIGlmIHRoZSB1c2VyXG4gICAgLy8gbGVha3MgYSByZWZlcmVuY2UgdG8gdGhlIHB1YmxpYyBpbnN0YW5jZS5cbiAgICBSZWFjdEluc3RhbmNlTWFwLnJlbW92ZShpbnN0KTtcblxuICAgIC8vIFNvbWUgZXhpc3RpbmcgY29tcG9uZW50cyByZWx5IG9uIGluc3QucHJvcHMgZXZlbiBhZnRlciB0aGV5J3ZlIGJlZW5cbiAgICAvLyBkZXN0cm95ZWQgKGluIGV2ZW50IGhhbmRsZXJzKS5cbiAgICAvLyBUT0RPOiBpbnN0LnByb3BzID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LnN0YXRlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LmNvbnRleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2BcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYXNrQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgIH1cbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHt9O1xuICAgIGZvciAodmFyIGNvbnRleHROYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYCwgYW5kIGFzc2VydHMgdGhhdCB0aGV5IGFyZSB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHRoaXMuX21hc2tDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgIGlmIChDb21wb25lbnQuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbnRleHRcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIChjdXJyZW50Q29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIGNoaWxkQ29udGV4dDtcblxuICAgIGlmIChpbnN0LmdldENoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgISh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA3JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICEobmFtZSBpbiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwOCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hc3NpZ24oe30sIGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IHRoZSBjb250ZXh0IHR5cGVzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBjb250ZXh0IGZpZWxkIHRvIGEgUmVhY3RQcm9wVHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAodHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIHRoaXMuZ2V0TmFtZSgpLCBudWxsLCB0aGlzLl9kZWJ1Z0lEKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgIT09IG51bGwgfHwgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQXR0ZW1wdGVkIHRvIHVwZGF0ZSBjb21wb25lbnQgYCVzYCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkIChvciBmYWlsZWQgdG8gbW91bnQpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEzNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdmFyIHdpbGxSZWNlaXZlID0gZmFsc2U7XG4gICAgdmFyIG5leHRDb250ZXh0O1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkIG9yIG5vdFxuICAgIGlmICh0aGlzLl9jb250ZXh0ID09PSBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlByb3BzID0gcHJldlBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gTm90IGEgc2ltcGxlIHN0YXRlIHVwZGF0ZSBidXQgYSBwcm9wcyB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgIT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgIC8vIF9wZW5kaW5nU3RhdGVRdWV1ZSB3aGljaCB3aWxsIGVuc3VyZSB0aGF0IGFueSBzdGF0ZSB1cGRhdGVzIGdldHNcbiAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG4gICAgaWYgKHdpbGxSZWNlaXZlICYmIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgaWYgKGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3MpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSAhc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSB8fCAhc2hhbGxvd0VxdWFsKGluc3Quc3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgICAvLyBXaWxsIHNldCBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAuXG4gICAgICB0aGlzLl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlKG5leHRQYXJlbnRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCBuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBkZXRlcm1pbmVkIHRoYXQgYSBjb21wb25lbnQgc2hvdWxkIG5vdCB1cGRhdGUsIHdlIHN0aWxsIHdhbnRcbiAgICAgIC8vIHRvIHNldCBwcm9wcyBhbmQgc3RhdGUgYnV0IHdlIHNob3J0Y3V0IHRoZSByZXN0IG9mIHRoZSB1cGRhdGUuXG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRQYXJlbnRFbGVtZW50O1xuICAgICAgdGhpcy5fY29udGV4dCA9IG5leHRVbm1hc2tlZENvbnRleHQ7XG4gICAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIH1cbiAgfSxcblxuICBfcHJvY2Vzc1BlbmRpbmdTdGF0ZTogZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZTtcbiAgICB2YXIgcmVwbGFjZSA9IHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGU7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgIGlmICghcXVldWUpIHtcbiAgICAgIHJldHVybiBpbnN0LnN0YXRlO1xuICAgIH1cblxuICAgIGlmIChyZXBsYWNlICYmIHF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHF1ZXVlWzBdO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSBfYXNzaWduKHt9LCByZXBsYWNlID8gcXVldWVbMF0gOiBpbnN0LnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICBfYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBfdGhpczIuX2RlYnVnSUQsICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjb21wb25lbnQncyBgcmVuZGVyYCBtZXRob2QgYW5kIHVwZGF0ZSB0aGUgRE9NIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgdmFyIHByZXZSZW5kZXJlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBuZXh0UmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG5cbiAgICB2YXIgZGVidWdJRCA9IDA7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRIb3N0Tm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBmYWxzZSk7XG5cbiAgICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUobmV4dFJlbmRlcmVkRWxlbWVudCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xuICAgICAgKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICAgIHZhciBuZXh0TWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgdGhpcy5faG9zdFBhcmVudCwgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCksIGRlYnVnSUQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIHZhciBjaGlsZERlYnVnSURzID0gY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW107XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGRlbiBpbiBzaGFsbG93IHJlbmRlcmluZy5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnN0LnJlbmRlcigpO1xuICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgcmVuZGVyZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgfHwgdGhpcy5fY29tcG9zaXRlVHlwZSAhPT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCkge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9XG4gICAgIShcbiAgICAvLyBUT0RPOiBBbiBgaXNWYWxpZE5vZGVgIGZ1bmN0aW9uIHdvdWxkIHByb2JhYmx5IGJlIG1vcmUgYXBwcm9wcmlhdGVcbiAgICByZW5kZXJlZEVsZW1lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRFbGVtZW50ID09PSBmYWxzZSB8fCBSZWFjdC5pc1ZhbGlkRWxlbWVudChyZW5kZXJlZEVsZW1lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwOScsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVkRWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTAnKSA6IHZvaWQgMDtcbiAgICB2YXIgcHVibGljQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQgJiYgY29tcG9uZW50LmdldE5hbWUgPyBjb21wb25lbnQuZ2V0TmFtZSgpIDogJ2EgY29tcG9uZW50JztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHB1YmxpY0NvbXBvbmVudEluc3RhbmNlICE9IG51bGwgfHwgY29tcG9uZW50Ll9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMgJyArICcoU2VlIHJlZiBcIiVzXCIgaW4gJXMgY3JlYXRlZCBieSAlcykuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4nLCByZWYsIGNvbXBvbmVudE5hbWUsIHRoaXMuZ2V0TmFtZSgpKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgcmVmc1tyZWZdID0gcHVibGljQ29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzO1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XG4gICAqIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcbiAgICogaXMgZXhwb3NlZCBieSByZWZzIGFuZCByZXR1cm5lZCBieSByZW5kZXIuIENhbiBiZSBudWxsIGZvciBzdGF0ZWxlc3NcbiAgICogY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHRoZSBwdWJsaWMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5fY29tcG9zaXRlVHlwZSA9PT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8vIFN0dWJcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKCcuL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcbiAgcmVuZGVyOiBSZWFjdE1vdW50LnJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3Qoe1xuICAgIENvbXBvbmVudFRyZWU6IHtcbiAgICAgIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICAvLyBpbnN0IGlzIGFuIGludGVybmFsIGluc3RhbmNlIChidXQgY291bGQgYmUgYSBjb21wb3NpdGUpXG4gICAgICAgIGlmIChpbnN0Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdCkge1xuICAgICAgICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyXG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiBkZXZ0b29scyBpcyBub3QgaW5zdGFsbGVkXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCBoYXZlIHRoZSBpc3N1ZSB3aXRoIGRldnRvb2xzIGxvYWRlZCBvdmVyIGZpbGU6Ly9cbiAgICAgICAgdmFyIHNob3dGaWxlVXJsTWVzc2FnZSA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAoc2hvd0ZpbGVVcmxNZXNzYWdlID8gJ2FuZCB1c2UgYW4gSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgYSBmaWxlOiBVUkwpICcgOiAnJykgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXN0RnVuYyA9IGZ1bmN0aW9uIHRlc3RGbigpIHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCh0ZXN0RnVuYy5uYW1lIHx8IHRlc3RGdW5jLnRvU3RyaW5nKCkpLmluZGV4T2YoJ3Rlc3RGbicpICE9PSAtMSwgJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYSBtaW5pZmllZCBjb3B5IG9mIHRoZSBkZXZlbG9wbWVudCBidWlsZCAnICsgJ29mIFJlYWN0LiBXaGVuIGRlcGxveWluZyBSZWFjdCBhcHBzIHRvIHByb2R1Y3Rpb24sIG1ha2Ugc3VyZSB0byB1c2UgJyArICd0aGUgcHJvZHVjdGlvbiBidWlsZCB3aGljaCBza2lwcyBkZXZlbG9wbWVudCB3YXJuaW5ncyBhbmQgaXMgZmFzdGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LW1pbmlmaWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuXG4gICAgLy8gSWYgd2UncmUgaW4gSUU4LCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGluIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgcHJvdmlkZVxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHByZXZlbnRpbmcgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgdmFyIGllQ29tcGF0aWJpbGl0eU1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgODtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpZUNvbXBhdGliaWxpdHlNb2RlLCAnSW50ZXJuZXQgRXhwbG9yZXIgaXMgcnVubmluZyBpbiBjb21wYXRpYmlsaXR5IG1vZGU7IHBsZWFzZSBhZGQgdGhlICcgKyAnZm9sbG93aW5nIHRhZyB0byB5b3VyIEhUTUwgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nOiAnICsgJzxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiSUU9ZWRnZVwiIC8+JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcbiAgICAvLyBzaGltc1xuICAgIEFycmF5LmlzQXJyYXksIEFycmF5LnByb3RvdHlwZS5ldmVyeSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBBcnJheS5wcm90b3R5cGUubWFwLCBEYXRlLm5vdywgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIE9iamVjdC5rZXlzLCBTdHJpbmcucHJvdG90eXBlLnRyaW1dO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmUgb3IgbW9yZSBFUzUgc2hpbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscycpIDogdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuICB2YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2snKTtcbiAgdmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rJyk7XG4gIHZhciBSZWFjdERPTUludmFsaWRBUklBSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnZhbGlkQVJJQUhvb2snKTtcblxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2spO1xuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2spO1xuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTUludmFsaWRBUklBSG9vayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZSgnLi9SZWFjdERPTUlucHV0Jyk7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0YXJlYScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG52YXIgZGVsZXRlTGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5kZWxldGVMaXN0ZW5lcjtcbnZhciBnZXROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2U7XG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG87XG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogbnVsbFxufTtcblxuLy8gTm9kZSB0eXBlIGZvciBkb2N1bWVudCBmcmFnbWVudHMgKE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkuXG52YXIgRE9DX0ZSQUdNRU5UX1RZUEUgPSAxMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBmcmllbmRseVN0cmluZ2lmeShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuICdbJyArIG9iai5tYXAoZnJpZW5kbHlTdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIHZhciBrZXlFc2NhcGVkID0gL15bYS16JF9dW1xcdyRfXSokL2kudGVzdChrZXkpID8ga2V5IDogSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgICBwYWlycy5wdXNoKGtleUVzY2FwZWQgKyAnOiAnICsgZnJpZW5kbHlTdHJpbmdpZnkob2JqW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd7JyArIHBhaXJzLmpvaW4oJywgJykgKyAnfSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnW2Z1bmN0aW9uIG9iamVjdF0nO1xuICB9XG4gIC8vIERpZmZlcnMgZnJvbSBKU09OLnN0cmluZ2lmeSBpbiB0aGF0IHVuZGVmaW5lZCBiZWNhdXNlIHVuZGVmaW5lZCBhbmQgdGhhdFxuICAvLyBpbmYgYW5kIG5hbiBkb24ndCBiZWNvbWUgbnVsbFxuICByZXR1cm4gU3RyaW5nKG9iaik7XG59XG5cbnZhciBzdHlsZU11dGF0aW9uV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUoc3R5bGUxLCBzdHlsZTIsIGNvbXBvbmVudCkge1xuICBpZiAoc3R5bGUxID09IG51bGwgfHwgc3R5bGUyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNoYWxsb3dFcXVhbChzdHlsZTEsIHN0eWxlMikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5fdGFnO1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVyKSB7XG4gICAgb3duZXJOYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvd25lck5hbWUgKyAnfCcgKyBjb21wb25lbnROYW1lO1xuXG4gIGlmIChzdHlsZU11dGF0aW9uV2FybmluZy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0eWxlTXV0YXRpb25XYXJuaW5nW2hhc2hdID0gdHJ1ZTtcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2Alc2Agd2FzIHBhc3NlZCBhIHN0eWxlIG9iamVjdCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gbXV0YXRlZC4gJyArICdNdXRhdGluZyBgc3R5bGVgIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIGNsb25pbmcgaXQgYmVmb3JlaGFuZC4gQ2hlY2sgJyArICd0aGUgYHJlbmRlcmAgJXMuIFByZXZpb3VzIHN0eWxlOiAlcy4gTXV0YXRlZCBzdHlsZTogJXMuJywgY29tcG9uZW50TmFtZSwgb3duZXIgPyAnb2YgYCcgKyBvd25lck5hbWUgKyAnYCcgOiAndXNpbmcgPCcgKyBjb21wb25lbnROYW1lICsgJz4nLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTEpLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTIpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHMoY29tcG9uZW50LCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbY29tcG9uZW50Ll90YWddKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiBfcHJvZEludmFyaWFudCgnMTM3JywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IF9wcm9kSW52YXJpYW50KCc2MCcpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiBfcHJvZEludmFyaWFudCgnNjEnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLmlubmVySFRNTCA9PSBudWxsLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMub25Gb2N1c0luID09IG51bGwgJiYgcHJvcHMub25Gb2N1c091dCA9PSBudWxsLCAnUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc2MicsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyLCB0cmFuc2FjdGlvbikge1xuICBpZiAodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSUU4IGhhcyBubyBBUEkgZm9yIGV2ZW50IGNhcHR1cmluZyBhbmQgdGhlIGBvblNjcm9sbGAgZXZlbnQgZG9lc24ndFxuICAgIC8vIGJ1YmJsZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhyZWdpc3RyYXRpb25OYW1lICE9PSAnb25TY3JvbGwnIHx8IGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpLCAnVGhpcyBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50JykgOiB2b2lkIDA7XG4gIH1cbiAgdmFyIGNvbnRhaW5lckluZm8gPSBpbnN0Ll9ob3N0Q29udGFpbmVySW5mbztcbiAgdmFyIGlzRG9jdW1lbnRGcmFnbWVudCA9IGNvbnRhaW5lckluZm8uX25vZGUgJiYgY29udGFpbmVySW5mby5fbm9kZS5ub2RlVHlwZSA9PT0gRE9DX0ZSQUdNRU5UX1RZUEU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50RnJhZ21lbnQgPyBjb250YWluZXJJbmZvLl9ub2RlIDogY29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGluc3Q6IGluc3QsXG4gICAgcmVnaXN0cmF0aW9uTmFtZTogcmVnaXN0cmF0aW9uTmFtZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHB1dExpc3RlbmVyKCkge1xuICB2YXIgbGlzdGVuZXJUb1B1dCA9IHRoaXM7XG4gIEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaW5zdCwgbGlzdGVuZXJUb1B1dC5yZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lclRvUHV0Lmxpc3RlbmVyKTtcbn1cblxuZnVuY3Rpb24gaW5wdXRQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01JbnB1dC5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiB0ZXh0YXJlYVBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTVRleHRhcmVhLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIG9wdGlvblBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTU9wdGlvbi5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG52YXIgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYgPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHZhciBoYXNFeGlzdGluZ0NvbnRlbnQgPSB0aGlzLl9jb250ZW50RGVidWdJRCAhPSBudWxsO1xuICAgIHZhciBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICAvLyBUaGlzIElEIHJlcHJlc2VudHMgdGhlIGlubGluZWQgY2hpbGQgdGhhdCBoYXMgbm8gYmFja2luZyBpbnN0YW5jZTpcbiAgICB2YXIgY29udGVudERlYnVnSUQgPSAtZGVidWdJRDtcblxuICAgIGlmIChjb250ZW50ID09IG51bGwpIHtcbiAgICAgIGlmIChoYXNFeGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudCh0aGlzLl9jb250ZW50RGVidWdJRCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIFN0cmluZyhjb250ZW50KSwgdGhpcywgdGhpcy5fYW5jZXN0b3JJbmZvKTtcbiAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IGNvbnRlbnREZWJ1Z0lEO1xuICAgIGlmIChoYXNFeGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVNb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCwgY29udGVudCwgZGVidWdJRCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCk7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBbY29udGVudERlYnVnSURdKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50c0xvY2FsKCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBfcHJvZEludmFyaWFudCgnNjMnKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGUgPSBnZXROb2RlKGluc3QpO1xuICAhbm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmFwQnViYmxlZEV2ZW50KC4uLik6IFJlcXVpcmVzIG5vZGUgdG8gYmUgcmVuZGVyZWQuJykgOiBfcHJvZEludmFyaWFudCgnNjQnKSA6IHZvaWQgMDtcblxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG5cbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMucHVzaChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gICdhcmVhJzogdHJ1ZSxcbiAgJ2Jhc2UnOiB0cnVlLFxuICAnYnInOiB0cnVlLFxuICAnY29sJzogdHJ1ZSxcbiAgJ2VtYmVkJzogdHJ1ZSxcbiAgJ2hyJzogdHJ1ZSxcbiAgJ2ltZyc6IHRydWUsXG4gICdpbnB1dCc6IHRydWUsXG4gICdrZXlnZW4nOiB0cnVlLFxuICAnbGluayc6IHRydWUsXG4gICdtZXRhJzogdHJ1ZSxcbiAgJ3BhcmFtJzogdHJ1ZSxcbiAgJ3NvdXJjZSc6IHRydWUsXG4gICd0cmFjayc6IHRydWUsXG4gICd3YnInOiB0cnVlXG59O1xuXG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gICdsaXN0aW5nJzogdHJ1ZSxcbiAgJ3ByZSc6IHRydWUsXG4gICd0ZXh0YXJlYSc6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICAnbWVudWl0ZW0nOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxuLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IHt9O1xudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkVGFnQ2FjaGUsIHRhZykpIHtcbiAgICAhVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHRhZzogJXMnLCB0YWcpIDogX3Byb2RJbnZhcmlhbnQoJzY1JywgdGFnKSA6IHZvaWQgMDtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPj0gMCB8fCBwcm9wcy5pcyAhPSBudWxsO1xufVxuXG52YXIgZ2xvYmFsSWRDb3VudGVyID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFJlYWN0IGNsYXNzIHRoYXQgaXMgaWRlbXBvdGVudCBhbmQgY2FwYWJsZSBvZiBjb250YWluaW5nIG90aGVyXG4gKiBSZWFjdCBjb21wb25lbnRzLiBJdCBhY2NlcHRzIGV2ZW50IGxpc3RlbmVycyBhbmQgRE9NIHByb3BlcnRpZXMgdGhhdCBhcmVcbiAqIHZhbGlkIGFjY29yZGluZyB0byBgRE9NUHJvcGVydHlgLlxuICpcbiAqICAtIEV2ZW50IGxpc3RlbmVyczogYG9uQ2xpY2tgLCBgb25Nb3VzZURvd25gLCBldGMuXG4gKiAgLSBET00gcHJvcGVydGllczogYGNsYXNzTmFtZWAsIGBuYW1lYCwgYHRpdGxlYCwgZXRjLlxuICpcbiAqIFRoZSBgc3R5bGVgIHByb3BlcnR5IGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmcm9tIHRoZSBET00gQVBJLiBJdCBhY2NlcHRzIGFuXG4gKiBvYmplY3QgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgUmVhY3RET01Db21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0TXVsdGlDaGlsZFxuICovXG5mdW5jdGlvbiBSZWFjdERPTUNvbXBvbmVudChlbGVtZW50KSB7XG4gIHZhciB0YWcgPSBlbGVtZW50LnR5cGU7XG4gIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5fdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIHRoaXMuX25hbWVzcGFjZVVSSSA9IG51bGw7XG4gIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgdGhpcy5fZG9tSUQgPSAwO1xuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG4gIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG4gIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG4gIHRoaXMuX2ZsYWdzID0gMDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0aGlzLl9hbmNlc3RvckluZm8gPSBudWxsO1xuICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHJvb3QgdGFnIG1hcmt1cCB0aGVuIHJlY3Vyc2VzLiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGFuZFxuICAgKiBpcyBub3QgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9SZWFjdERPTUNvbXBvbmVudH0gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wdXRlZCBtYXJrdXAuXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBnbG9iYWxJZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgICAgICBsaXN0ZW5lcnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgUmVhY3RET01PcHRpb24ubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIFJlYWN0RE9NU2VsZWN0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgcHJvcHMpO1xuXG4gICAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAgIC8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbiAgICB2YXIgbmFtZXNwYWNlVVJJO1xuICAgIHZhciBwYXJlbnRUYWc7XG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdFBhcmVudC5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gaG9zdFBhcmVudC5fdGFnO1xuICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdENvbnRhaW5lckluZm8uX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RDb250YWluZXJJbmZvLl90YWc7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCBuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmIHBhcmVudFRhZyA9PT0gJ2ZvcmVpZ25vYmplY3QnKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLmh0bWw7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5zdmc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RhZyA9PT0gJ21hdGgnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMubWF0aG1sO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudEluZm87XG4gICAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCBudWxsLCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEluZm8sIHRoaXMuX3RhZywgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIG1vdW50SW1hZ2U7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgZWw7XG4gICAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8JyArIHR5cGUgKyAnPjwvJyArIHR5cGUgKyAnPic7XG4gICAgICAgICAgZWwgPSBkaXYucmVtb3ZlQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLmlzKSB7XG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSwgcHJvcHMuaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjdWFzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgICAgICAvLyBhbmQgZGlzY3Vzc2lvbiBpbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjc2MjQwXG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgZWwpO1xuICAgICAgdGhpcy5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2RlcztcbiAgICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9yUm9vdChlbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKG51bGwsIHByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShlbCk7XG4gICAgICB0aGlzLl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4odHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSk7XG4gICAgICBtb3VudEltYWdlID0gbGF6eVRyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWdPcGVuID0gdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbiwgcHJvcHMpO1xuICAgICAgdmFyIHRhZ0NvbnRlbnQgPSB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCk7XG4gICAgICBpZiAoIXRhZ0NvbnRlbnQgJiYgb21pdHRlZENsb3NlVGFnc1t0aGlzLl90YWddKSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJy8+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJz4nICsgdGFnQ29udGVudCArICc8LycgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlICsgJz4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5wdXRQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodGV4dGFyZWFQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG9wdGlvblBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtb3VudEltYWdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIG9wZW4gdGFnIGFuZCBhbGwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXG4gICAqL1xuICBfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVyczogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcykge1xuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBTZWUgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gc3R5bGUgYmxvY2tcbiAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgcHJvcHMuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wVmFsdWUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmt1cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90YWcgIT0gbnVsbCAmJiBpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIHByb3BzKSkge1xuICAgICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XG4gICAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcbiAgICB9XG4gICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9kb21JRCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlSFRNTChsYXp5VHJlZSwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIHRleHQgYXJlYSB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIHRleHRhcmVhIHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIGlmIChjb250ZW50VG9Vc2UgIT09ICcnKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVUZXh0KGxhenlUcmVlLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdW50SW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgbW91bnRJbWFnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyBhIG5leHQgZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gY29tcG9uZW50IGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWxsb2NhdGVkIGFuZFxuICAgKiBhdHRhY2hlZCB0byB0aGUgRE9NLiBSZWNvbmNpbGVzIHRoZSByb290IERPTSBub2RlLCB0aGVuIHJlY3Vyc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCkge1xuICAgIHZhciBsYXN0UHJvcHMgPSBwcmV2RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgICAvLyBoYXBwZW4gYWZ0ZXIgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcEtleTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZVVwZGF0ZXM7XG4gICAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIHZhciBsYXN0U3R5bGUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChsYXN0UHJvcHNbcHJvcEtleV0pIHtcbiAgICAgICAgICAvLyBPbmx5IGNhbGwgZGVsZXRlTGlzdGVuZXIgaWYgdGhlcmUgd2FzIGEgbGlzdGVuZXIgcHJldmlvdXNseSBvclxuICAgICAgICAgIC8vIGVsc2Ugd2lsbERlbGV0ZUxpc3RlbmVyIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2Fzbid0IGFjdHVhbGx5IGFcbiAgICAgICAgICAvLyBsaXN0ZW5lciAoZS5nLiwgb25DbGljaz17bnVsbH0pXG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBsYXN0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBnZXROb2RlKHRoaXMpO1xuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMoZ2V0Tm9kZSh0aGlzKSwgc3R5bGVVcGRhdGVzLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIF91cGRhdGVET01DaGlsZHJlbjogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbmV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFsbCBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGluc3RhbmNlLiBEb2VzIG5vdCByZW1vdmUgZnJvbVxuICAgKiB0aGUgRE9NLiBUaGF0IG11c3QgYmUgZG9uZSBieSB0aGUgcGFyZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnRzIGxpa2UgPGh0bWw+IDxoZWFkPiBhbmQgPGJvZHk+IGNhbid0IGJlIHJlbW92ZWQgb3IgYWRkZWRcbiAgICAgICAgICogZWFzaWx5IGluIGEgY3Jvc3MtYnJvd3NlciB3YXksIGhvd2V2ZXIgaXQncyB2YWx1YWJsZSB0byBiZSBhYmxlIHRvXG4gICAgICAgICAqIHRha2UgYWR2YW50YWdlIG9mIFJlYWN0J3MgcmVjb25jaWxpYXRpb24gZm9yIHN0eWxpbmcgYW5kIDx0aXRsZT5cbiAgICAgICAgICogbWFuYWdlbWVudC4gU28gd2UganVzdCBkb2N1bWVudCBpdCBhbmQgdGhyb3cgaW4gZGFuZ2Vyb3VzIGNhc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzwlcz4gdHJpZWQgdG8gdW5tb3VudC4gQmVjYXVzZSBvZiBjcm9zcy1icm93c2VyIHF1aXJrcyBpdCBpcyBpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCA8aGVhZD4sIGFuZCA8Ym9keT4pIHJlbGlhYmx5IGFuZCBlZmZpY2llbnRseS4gVG8gZml4IHRoaXMsIGhhdmUgYSBzaW5nbGUgdG9wLWxldmVsIGNvbXBvbmVudCB0aGF0IG5ldmVyIHVubW91bnRzIHJlbmRlciB0aGVzZSBlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogX3Byb2RJbnZhcmlhbnQoJzY2JywgdGhpcy5fdGFnKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oc2FmZWx5KTtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gICAgRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMpO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX2RvbUlEID0gMDtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH1cblxufTtcblxuX2Fzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG5cbmZ1bmN0aW9uIFJlYWN0RE9NQ29udGFpbmVySW5mbyh0b3BMZXZlbFdyYXBwZXIsIG5vZGUpIHtcbiAgdmFyIGluZm8gPSB7XG4gICAgX3RvcExldmVsV3JhcHBlcjogdG9wTGV2ZWxXcmFwcGVyLFxuICAgIF9pZENvdW50ZXI6IDEsXG4gICAgX293bmVyRG9jdW1lbnQ6IG5vZGUgPyBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFID8gbm9kZSA6IG5vZGUub3duZXJEb2N1bWVudCA6IG51bGwsXG4gICAgX25vZGU6IG5vZGUsXG4gICAgX3RhZzogbm9kZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGwsXG4gICAgX25hbWVzcGFjZVVSSTogbm9kZSA/IG5vZGUubmFtZXNwYWNlVVJJIDogbnVsbFxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluZm8uX2FuY2VzdG9ySW5mbyA9IG5vZGUgPyB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCBpbmZvLl90YWcsIG51bGwpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbnRhaW5lckluZm87XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29udGFpbmVySW5mby5qc1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgLy8gUmVhY3RDb21wb3NpdGVDb21wb25lbnQgdXNlcyB0aGlzOlxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG4gIHRoaXMuX2RvbUlEID0gMDtcbn07XG5fYXNzaWduKFJlYWN0RE9NRW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gZG9tSUQ7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBub2RlVmFsdWUgPSAnIHJlYWN0LWVtcHR5OiAnICsgdGhpcy5fZG9tSUQgKyAnICc7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChub2RlVmFsdWUpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBub2RlKTtcbiAgICAgIHJldHVybiBET01MYXp5VHJlZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaW5zZXJ0IGEgY29tbWVudCBub2RlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvblxuICAgICAgICAvLyB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuXG4gICAgICAgIC8vIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnPCEtLScgKyBub2RlVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01FbXB0eUNvbXBvbmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01FbXB0eUNvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHtcbiAgdXNlQ3JlYXRlRWxlbWVudDogdHJ1ZSxcbiAgdXNlRmliZXI6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmVhdHVyZUZsYWdzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudEluc3QsIHVwZGF0ZXMpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHBhcmVudEluc3QpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyhub2RlLCB1cGRhdGVzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9ucztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICBtYXg6IHVuZGVmaW5lZFxuICAgIH0sIHByb3BzLCB7XG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG5cbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdCksXG4gICAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKCFpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogU2hvdWxkbid0IHRoaXMgYmUgZ2V0Q2hlY2tlZChwcm9wcyk/XG4gICAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLCAnY2hlY2tlZCcsIGNoZWNrZWQgfHwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBub2RlLnZhbHVlID09PSAnJykge1xuICAgICAgICBub2RlLnZhbHVlID0gJzAnO1xuICAgICAgICAvLyBOb3RlOiBJRTkgcmVwb3J0cyBhIG51bWJlciBpbnB1dHMgYXMgJ3RleHQnLCBzbyBjaGVjayBwcm9wcyBpbnN0ZWFkLlxuICAgICAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBTaW11bGF0ZSBgaW5wdXQudmFsdWVBc051bWJlcmAuIElFOSBkb2VzIG5vdCBzdXBwb3J0IGl0XG4gICAgICAgIHZhciB2YWx1ZUFzTnVtYmVyID0gcGFyc2VGbG9hdChub2RlLnZhbHVlLCAxMCkgfHwgMDtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgaWYgKHZhbHVlICE9IHZhbHVlQXNOdW1iZXIpIHtcbiAgICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgICAgICBub2RlLnZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbm9kZS52YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuICAgICAgICAvLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4gICAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4gICAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG4gICAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcblxuICAgIC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZS4gV2Ugd29uJ3QgZG8gYW55dGhpbmcgaWYgd2UncmUgd29ya2luZyBvblxuICAgIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gICAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gICAgLy8gcmVtb3ZlcyBicm93c2VyLWRlZmF1bHQgdmFsdWVzIChlZyBcIlN1Ym1pdCBRdWVyeVwiKSB3aGVuIG5vIHZhbHVlIGlzXG4gICAgLy8gcHJvdmlkZWQuXG5cbiAgICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICBjYXNlICdkYXRldGltZS1sb2NhbCc6XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnO1xuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gICAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgIGlmIChuYW1lICE9PSAnJykge1xuICAgICAgbm9kZS5uYW1lID0gJyc7XG4gICAgfVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIC8vIEhlcmUgd2UgdXNlIGFzYXAgdG8gd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoXG4gIC8vIGlzIGltcG9ydGFudCB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuXG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvdGhlck5vZGUpO1xuICAgICAgIW90aGVySW5zdGFuY2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTAnKSA6IHZvaWQgMDtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIG90aGVySW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlucHV0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUlucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcbiAgaWYgKHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIEFSSUEgYXR0cmlidXRlICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHMoZGVidWdJRCwgZWxlbWVudCkge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKGRlYnVnSUQsIGVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RET01JbnZhbGlkQVJJQUhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnZhbGlkQVJJQUhvb2s7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgIT09ICd0ZXh0YXJlYScgJiYgZWxlbWVudC50eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5wcm9wcyAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyB0aGUgZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbikge1xuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGhvc3RQYXJlbnQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnXG4gICAgdmFyIHNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0UGFyZW50ID0gaG9zdFBhcmVudDtcblxuICAgICAgaWYgKHNlbGVjdFBhcmVudC5fdGFnID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgICAgIHNlbGVjdFBhcmVudCA9IHNlbGVjdFBhcmVudC5faG9zdFBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdFBhcmVudCAhPSBudWxsICYmIHNlbGVjdFBhcmVudC5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICBzZWxlY3RWYWx1ZSA9IFJlYWN0RE9NU2VsZWN0LmdldFNlbGVjdFZhbHVlQ29udGV4dChzZWxlY3RQYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBudWxsIChlLmcuLCBubyBzcGVjaWZpZWQgdmFsdWUgb3IgYWZ0ZXIgaW5pdGlhbCBtb3VudClcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0PiksIHdlIGRvbid0IGNoYW5nZSBwcm9wcy5zZWxlY3RlZFxuICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBob3N0UHJvcHMuc2VsZWN0ZWQgPSBpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NT3B0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTU9wdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Jyk7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSW4gRmlyZWZveCwgcmFuZ2Uuc3RhcnRDb250YWluZXIgYW5kIHJhbmdlLmVuZENvbnRhaW5lciBjYW4gYmUgXCJhbm9ueW1vdXNcbiAgLy8gZGl2c1wiLCBlLmcuIHRoZSB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91c1xuICAvLyBkaXZzIGRvIG5vdCBzZWVtIHRvIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZFxuICAvLyBlcnJvclwiIGlmIGFueSBvZiBpdHMgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZVxuICAvLyB3YXkgdG8gYXZvaWQgZXJyb3JpbmcgaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yXG4gIC8vIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmQgY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICBjdXJyZW50UmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXG4gIC8vIHRoaXMgdmFsdWUgd3JvbmcuXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQodGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0ZW1wUmFuZ2Uuc3RhcnRPZmZzZXQsIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQpO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc0JhY2t3YXJkID8gZW5kIDogc3RhcnQsXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldElFT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xuICB2YXIgc3RhcnQsIGVuZDtcblxuICBpZiAob2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBzdGFydDtcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xuICAgIGVuZCA9IG9mZnNldHMuc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuICB9XG5cbiAgcmFuZ2UubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcbiAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICByYW5nZS5zZWxlY3QoKTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdXNlSUVPZmZzZXRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdzZWxlY3Rpb24nIGluIGRvY3VtZW50ICYmICEoJ2dldFNlbGVjdGlvbicgaW4gd2luZG93KTtcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBnZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBnZXRJRU9mZnNldHMgOiBnZXRNb2Rlcm5PZmZzZXRzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAgICovXG4gIHNldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IHNldElFT2Zmc2V0cyA6IHNldE1vZGVybk9mZnNldHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGJldHdlZW4gY29tbWVudCBub2RlcyBzbyB0aGF0IHRoZXlcbiAqIGNhbiB1bmRlcmdvIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG5cbiAgLy8gUHJvcGVydGllc1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHRoaXMuX3N0cmluZ1RleHQsIHRoaXMsIHBhcmVudEluZm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB2YXIgb3BlbmluZ1ZhbHVlID0gJyByZWFjdC10ZXh0OiAnICsgZG9tSUQgKyAnICc7XG4gICAgdmFyIGNsb3NpbmdWYWx1ZSA9ICcgL3JlYWN0LXRleHQgJztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG9wZW5pbmdWYWx1ZSk7XG4gICAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY2xvc2luZ1ZhbHVlKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKG9wZW5pbmdDb21tZW50KSk7XG4gICAgICBpZiAodGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuX3N0cmluZ1RleHQpKSk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShjbG9zaW5nQ29tbWVudCkpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBvcGVuaW5nQ29tbWVudCk7XG4gICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IGNsb3NpbmdDb21tZW50O1xuICAgICAgcmV0dXJuIGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgZm9yIHRoZSByZWFzb25zIHN0YXRlZFxuICAgICAgICAvLyBhYm92ZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyXG4gICAgICAgIC8vIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cbiAgICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzwhLS0nICsgb3BlbmluZ1ZhbHVlICsgJy0tPicgKyBlc2NhcGVkVGV4dCArICc8IS0tJyArIGNsb3NpbmdWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gbmV4dFRleHQgVGhlIG5leHQgdGV4dCBjb250ZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0VGV4dDtcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgLy8gVE9ETzogU2F2ZSB0aGlzIGFzIHBlbmRpbmcgcHJvcHMgYW5kIHVzZSBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnlcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XG4gICAgICAgIHRoaXMuX3N0cmluZ1RleHQgPSBuZXh0U3RyaW5nVGV4dDtcbiAgICAgICAgdmFyIGNvbW1lbnROb2RlcyA9IHRoaXMuZ2V0SG9zdE5vZGUoKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnJlcGxhY2VEZWxpbWl0ZWRUZXh0KGNvbW1lbnROb2Rlc1swXSwgY29tbWVudE5vZGVzWzFdLCBuZXh0U3RyaW5nVGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3ROb2RlID0gdGhpcy5fY29tbWVudE5vZGVzO1xuICAgIGlmIChob3N0Tm9kZSkge1xuICAgICAgcmV0dXJuIGhvc3ROb2RlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Nsb3NpbmdDb21tZW50KSB7XG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICAgIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAhKG5vZGUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBjbG9zaW5nIGNvbW1lbnQgZm9yIHRleHQgY29tcG9uZW50ICVzJywgdGhpcy5fZG9tSUQpIDogX3Byb2RJbnZhcmlhbnQoJzY3JywgdGhpcy5fZG9tSUQpIDogdm9pZCAwO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyAvcmVhY3QtdGV4dCAnKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBob3N0Tm9kZSA9IFt0aGlzLl9ob3N0Tm9kZSwgdGhpcy5fY2xvc2luZ0NvbW1lbnRdO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IGhvc3ROb2RlO1xuICAgIHJldHVybiBob3N0Tm9kZTtcbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbnZhciBSZWFjdERPTVRleHRhcmVhID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiBfcHJvZEludmFyaWFudCgnOTEnKSA6IHZvaWQgMDtcblxuICAgIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gICAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gICAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rQmVuIHNlZW1lZCB0byBsaWtlIHRoaXMgc29sdXRpb24uXG4gICAgLy8gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWQgdG8gYmUgYSBzdHJpbmcuXG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBjaGlsZHJlbjogJycgKyBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgdGV4dGFyZWFgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiBfcHJvZEludmFyaWFudCgnOTInKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzkzJykgOiB2b2lkIDA7XG4gICAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbFZhbHVlOiAnJyArIGluaXRpYWxWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50O1xuXG4gICAgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcbiAgICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAgIC8vIHdpbGwgcG9wdWxhdGUgdGV4dENvbnRlbnQgYXMgd2VsbC5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXG4gICAgaWYgKHRleHRDb250ZW50ID09PSBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRleHRhcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RBKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcblxuICB2YXIgZGVwdGhBID0gMDtcbiAgZm9yICh2YXIgdGVtcEEgPSBpbnN0QTsgdGVtcEE7IHRlbXBBID0gdGVtcEEuX2hvc3RQYXJlbnQpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gdGVtcEIuX2hvc3RQYXJlbnQpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGRlcHRoQS0tO1xuICB9XG5cbiAgLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBpbnN0QS5faG9zdFBhcmVudDtcbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cbmZ1bmN0aW9uIGlzQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2lzQW5jZXN0b3I6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzUnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuXG4gIHdoaWxlIChpbnN0Qikge1xuICAgIGlmIChpbnN0QiA9PT0gaW5zdEEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0UGFyZW50SW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzYnKSA6IHZvaWQgMDtcblxuICByZXR1cm4gaW5zdC5faG9zdFBhcmVudDtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAoZnJvbSAmJiBmcm9tICE9PSBjb21tb24pIHtcbiAgICBwYXRoRnJvbS5wdXNoKGZyb20pO1xuICAgIGZyb20gPSBmcm9tLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRvICYmIHRvICE9PSBjb21tb24pIHtcbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSB0by5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yIChpID0gcGF0aFRvLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9baV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBbmNlc3RvcjogaXNBbmNlc3RvcixcbiAgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3I6IGdldExvd2VzdENvbW1vbkFuY2VzdG9yLFxuICBnZXRQYXJlbnRJbnN0YW5jZTogZ2V0UGFyZW50SW5zdGFuY2UsXG4gIHRyYXZlcnNlVHdvUGhhc2U6IHRyYXZlcnNlVHdvUGhhc2UsXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogdHJhdmVyc2VFbnRlckxlYXZlXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZSxcblxuICAgIGF1dG9Gb2N1czogdHJ1ZSxcbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgdmFsdWVMaW5rOiB0cnVlLFxuICAgIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICAgIGNoZWNrZWRMaW5rOiB0cnVlLFxuICAgIGlubmVySFRNTDogdHJ1ZSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgb25Gb2N1c0luOiB0cnVlLFxuICAgIG9uRm9jdXNPdXQ6IHRydWVcbiAgfTtcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8IHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICBpZiAoc3RhbmRhcmROYW1lICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBET00gcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ3Vlc3Mgd2hpY2ggcHJvcCB0aGUgdXNlciBpbnRlbmRlZC5cbiAgICAgIC8vIEl0IGlzIGxpa2VseSB0aGF0IHRoZSB1c2VyIHdhcyBqdXN0IGJsaW5kbHkgc3ByZWFkaW5nL2ZvcndhcmRpbmcgcHJvcHNcbiAgICAgIC8vIENvbXBvbmVudHMgc2hvdWxkIGJlIGNhcmVmdWwgdG8gb25seSByZW5kZXIgdmFsaWQgcHJvcHMvYXR0cmlidXRlcy5cbiAgICAgIC8vIFdhcm5pbmcgd2lsbCBiZSBpbnZva2VkIGluIHdhcm5Vbmtub3duUHJvcGVydGllcyB0byBhbGxvdyBncm91cGluZy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3AgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGlzIHByb3AgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoZXNlIHByb3BzIGZyb20gdGhlIGVsZW1lbnQuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXMoZGVidWdJRCwgZWxlbWVudCk7XG59XG5cbnZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2s7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSByZXF1aXJlKCcuL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2snKTtcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2snKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhvb2tzID0gW107XG52YXIgZGlkSG9va1Rocm93Rm9yRXZlbnQgPSB7fTtcblxuZnVuY3Rpb24gY2FsbEhvb2soZXZlbnQsIGZuLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIHRyeSB7XG4gICAgZm4uY2FsbChjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSwgJ0V4Y2VwdGlvbiB0aHJvd24gYnkgaG9vayB3aGlsZSBoYW5kbGluZyAlczogJXMnLCBldmVudCwgZSArICdcXG4nICsgZS5zdGFjaykgOiB2b2lkIDA7XG4gICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXZlbnQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgdmFyIGZuID0gaG9va1tldmVudF07XG4gICAgaWYgKGZuKSB7XG4gICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmbHVzaEhpc3RvcnkgPSBbXTtcbnZhciBsaWZlQ3ljbGVUaW1lclN0YWNrID0gW107XG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG52YXIgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gMDtcbnZhciBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xudmFyIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xudmFyIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xuXG52YXIgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KCkge1xuICBSZWFjdENvbXBvbmVudFRyZWVIb29rLnB1cmdlVW5tb3VudGVkQ29tcG9uZW50cygpO1xuICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5jbGVhckhpc3RvcnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpIHtcbiAgcmV0dXJuIHJlZ2lzdGVyZWRJRHMucmVkdWNlKGZ1bmN0aW9uICh0cmVlLCBpZCkge1xuICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB0cmVlW2lkXSA9IHtcbiAgICAgIGRpc3BsYXlOYW1lOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKSxcbiAgICAgIHRleHQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VGV4dChpZCksXG4gICAgICB1cGRhdGVDb3VudDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRVcGRhdGVDb3VudChpZCksXG4gICAgICBjaGlsZElEczogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDaGlsZElEcyhpZCksXG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUgb3duZXJzIGJ1dCB0aGlzIGlzIGNsb3NlIGVub3VnaC5cbiAgICAgIG93bmVySUQ6IG93bmVySUQgfHwgcGFyZW50SUQgJiYgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKHBhcmVudElEKSB8fCAwLFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElEXG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiByZXNldE1lYXN1cmVtZW50cygpIHtcbiAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgcHJldmlvdXNNZWFzdXJlbWVudHMgPSBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHM7XG4gIHZhciBwcmV2aW91c09wZXJhdGlvbnMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5nZXRIaXN0b3J5KCk7XG5cbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSAwO1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xuICAgIGNsZWFySGlzdG9yeSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcmV2aW91c01lYXN1cmVtZW50cy5sZW5ndGggfHwgcHJldmlvdXNPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIHZhciByZWdpc3RlcmVkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRSZWdpc3RlcmVkSURzKCk7XG4gICAgZmx1c2hIaXN0b3J5LnB1c2goe1xuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBwcmV2aW91c1N0YXJ0VGltZSxcbiAgICAgIG1lYXN1cmVtZW50czogcHJldmlvdXNNZWFzdXJlbWVudHMgfHwgW10sXG4gICAgICBvcGVyYXRpb25zOiBwcmV2aW91c09wZXJhdGlvbnMgfHwgW10sXG4gICAgICB0cmVlU25hcHNob3Q6IGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKVxuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJIaXN0b3J5KCk7XG4gIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjaGVja0RlYnVnSUQoZGVidWdJRCkge1xuICB2YXIgYWxsb3dSb290ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICBpZiAoYWxsb3dSb290ICYmIGRlYnVnSUQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWJ1Z0lEKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG5mdW5jdGlvbiBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgIT09IHRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ1dlIGRpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0b3Agd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuIFBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBSZWFjdC4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcbiAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIGN1cnJlbnRUaW1lclN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb25cbiAgICB9KTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lciA9IHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lclN0YXJ0VGltZSxcbiAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZTogcGVyZm9ybWFuY2VOb3coKSxcbiAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxuICAgIHRpbWVyVHlwZTogY3VycmVudFRpbWVyVHlwZVxuICB9O1xuICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgX2xpZmVDeWNsZVRpbWVyU3RhY2skID0gbGlmZUN5Y2xlVGltZXJTdGFjay5wb3AoKSxcbiAgICAgIHN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5zdGFydFRpbWUsXG4gICAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5uZXN0ZWRGbHVzaFN0YXJ0VGltZSxcbiAgICAgIGRlYnVnSUQgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuZGVidWdJRCxcbiAgICAgIHRpbWVyVHlwZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC50aW1lclR5cGU7XG5cbiAgdmFyIG5lc3RlZEZsdXNoRHVyYXRpb24gPSBwZXJmb3JtYW5jZU5vdygpIC0gbmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiArPSBuZXN0ZWRGbHVzaER1cmF0aW9uO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxudmFyIGxhc3RNYXJrVGltZVN0YW1wID0gMDtcbnZhciBjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBzaG91bGRNYXJrKGRlYnVnSUQpIHtcbiAgaWYgKCFpc1Byb2ZpbGluZyB8fCAhY2FuVXNlUGVyZm9ybWFuY2VNZWFzdXJlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGRlYnVnSUQpO1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaXNIb3N0RWxlbWVudCA9IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnO1xuICBpZiAoaXNIb3N0RWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFya0JlZ2luKGRlYnVnSUQsIG1hcmtUeXBlKSB7XG4gIGlmICghc2hvdWxkTWFyayhkZWJ1Z0lEKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXJrTmFtZSA9IGRlYnVnSUQgKyAnOjonICsgbWFya1R5cGU7XG4gIGxhc3RNYXJrVGltZVN0YW1wID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgcGVyZm9ybWFuY2UubWFyayhtYXJrTmFtZSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtFbmQoZGVidWdJRCwgbWFya1R5cGUpIHtcbiAgaWYgKCFzaG91bGRNYXJrKGRlYnVnSUQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hcmtOYW1lID0gZGVidWdJRCArICc6OicgKyBtYXJrVHlwZTtcbiAgdmFyIGRpc3BsYXlOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShkZWJ1Z0lEKSB8fCAnVW5rbm93bic7XG5cbiAgLy8gQ2hyb21lIGhhcyBhbiBpc3N1ZSBvZiBkcm9wcGluZyBtYXJrZXJzIHJlY29yZGVkIHRvbyBmYXN0OlxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02NDA2NTJcbiAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgd2Ugd2lsbCBub3QgcmVwb3J0IHZlcnkgc21hbGwgbWVhc3VyZW1lbnRzLlxuICAvLyBJIGRldGVybWluZWQgdGhlIG1hZ2ljIG51bWJlciBieSB0d2Vha2luZyBpdCBiYWNrIGFuZCBmb3J0aC5cbiAgLy8gMC4wNW1zIHdhcyBlbm91Z2ggdG8gcHJldmVudCB0aGUgaXNzdWUsIGJ1dCBJIHNldCBpdCB0byAwLjFtcyB0byBiZSBzYWZlLlxuICAvLyBXaGVuIHRoZSBidWcgaXMgZml4ZWQsIHdlIGNhbiBgbWVhc3VyZSgpYCB1bmNvbmRpdGlvbmFsbHkgaWYgd2Ugd2FudCB0by5cbiAgdmFyIHRpbWVTdGFtcCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGlmICh0aW1lU3RhbXAgLSBsYXN0TWFya1RpbWVTdGFtcCA+IDAuMSkge1xuICAgIHZhciBtZWFzdXJlbWVudE5hbWUgPSBkaXNwbGF5TmFtZSArICcgWycgKyBtYXJrVHlwZSArICddJztcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVtZW50TmFtZSwgbWFya05hbWUpO1xuICB9XG5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrTmFtZSk7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMobWVhc3VyZW1lbnROYW1lKTtcbn1cblxudmFyIFJlYWN0RGVidWdUb29sID0ge1xuICBhZGRIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2tzLnB1c2goaG9vayk7XG4gIH0sXG4gIHJlbW92ZUhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhvb2tzW2ldID09PSBob29rKSB7XG4gICAgICAgIGhvb2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaXNQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNQcm9maWxpbmc7XG4gIH0sXG4gIGJlZ2luUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSB0cnVlO1xuICAgIGZsdXNoSGlzdG9yeS5sZW5ndGggPSAwO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayk7XG4gIH0sXG4gIGVuZFByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc1Byb2ZpbGluZyA9IGZhbHNlO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlSG9vayhSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayk7XG4gIH0sXG4gIGdldEZsdXNoSGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbHVzaEhpc3Rvcnk7XG4gIH0sXG4gIG9uQmVnaW5GbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmcrKztcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIHBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luRmx1c2gnKTtcbiAgfSxcbiAgb25FbmRGbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgY3VycmVudEZsdXNoTmVzdGluZy0tO1xuICAgIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25FbmRGbHVzaCcpO1xuICB9LFxuICBvbkJlZ2luTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25FbmRMaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQnKTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQnKTtcbiAgfSxcbiAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKG9wZXJhdGlvbi5pbnN0YW5jZUlEKTtcbiAgICBlbWl0RXZlbnQoJ29uSG9zdE9wZXJhdGlvbicsIG9wZXJhdGlvbik7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uU2V0U3RhdGUnKTtcbiAgfSxcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hpbGREZWJ1Z0lEcy5mb3JFYWNoKGNoZWNrRGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvblNldENoaWxkcmVuJywgZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGNoZWNrRGVidWdJRChwYXJlbnREZWJ1Z0lELCB0cnVlKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgJ21vdW50Jyk7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgJ21vdW50Jyk7XG4gICAgZW1pdEV2ZW50KCdvbk1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCwgZWxlbWVudCk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICd1cGRhdGUnKTtcbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgJ3VwZGF0ZScpO1xuICAgIGVtaXRFdmVudCgnb25VcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndW5tb3VudCcpO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgJ3VubW91bnQnKTtcbiAgICBlbWl0RXZlbnQoJ29uVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvblRlc3RFdmVudDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25UZXN0RXZlbnQnKTtcbiAgfVxufTtcblxuLy8gVE9ETyByZW1vdmUgdGhlc2Ugd2hlbiBSTi93d3cgZ2V0cyB1cGRhdGVkXG5SZWFjdERlYnVnVG9vbC5hZGREZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vaztcblJlYWN0RGVidWdUb29sLnJlbW92ZURldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rO1xuXG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2spO1xuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdENvbXBvbmVudFRyZWVIb29rKTtcbnZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG5pZiAoL1s/Jl1yZWFjdF9wZXJmXFxiLy50ZXN0KHVybCkpIHtcbiAgUmVhY3REZWJ1Z1Rvb2wuYmVnaW5Qcm9maWxpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlYnVnVG9vbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWJ1Z1Rvb2wuanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbl9hc3NpZ24oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfVxufSk7XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXG4gICAqIGFuZCBmcmllbmRzIGFyZSBiYXRjaGVkIHN1Y2ggdGhhdCBjb21wb25lbnRzIGFyZW4ndCB1cGRhdGVkIHVubmVjZXNzYXJpbHkuXG4gICAqL1xuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzO1xuXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhhLCBiLCBjLCBkLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEFSSUFET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vQVJJQURPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQmVmb3JlSW5wdXRFdmVudFBsdWdpbicpO1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9DaGFuZ2VFdmVudFBsdWdpbicpO1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gcmVxdWlyZSgnLi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlcicpO1xudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJyk7XG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9IVE1MRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NRW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRyZWVUcmF2ZXJzYWwgPSByZXF1aXJlKCcuL1JlYWN0RE9NVHJlZVRyYXZlcnNhbCcpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbicpO1xudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9TVkdET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TZWxlY3RFdmVudFBsdWdpbicpO1xudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TaW1wbGVFdmVudFBsdWdpbicpO1xuXG52YXIgYWxyZWFkeUluamVjdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluamVjdCgpIHtcbiAgaWYgKGFscmVhZHlJbmplY3RlZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgY3VycmVudGx5IHRydWUgYmVjYXVzZSB0aGVzZSBpbmplY3Rpb25zIGFyZSBzaGFyZWQgYmV0d2VlblxuICAgIC8vIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIgcGFja2FnZS4gVGhleSBzaG91bGQgYmUgYnVpbHQgaW5kZXBlbmRlbnRseVxuICAgIC8vIGFuZCBub3Qgc2hhcmUgYW55IGluamVjdGlvbiBzdGF0ZS4gVGhlbiB0aGlzIHByb2JsZW0gd2lsbCBiZSBzb2x2ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGFscmVhZHlJbmplY3RlZCA9IHRydWU7XG5cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRFbWl0dGVyLmluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcihSZWFjdEV2ZW50TGlzdGVuZXIpO1xuXG4gIC8qKlxuICAgKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RUcmVlVHJhdmVyc2FsKFJlYWN0RE9NVHJlZVRyYXZlcnNhbCk7XG5cbiAgLyoqXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICAgKiB0aGVtKS5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gICAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzcyhSZWFjdERPTUNvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhBUklBRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRW1wdHlDb21wb25lbnQuaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5KGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBuZXcgUmVhY3RET01FbXB0eUNvbXBvbmVudChpbnN0YW50aWF0ZSk7XG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFbGVtZW50U3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0ge1xuXG4gIC8qKlxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRFbWl0dGVyTWl4aW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24nKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50KGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QuX2hvc3RQYXJlbnQpIHtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgdmFyIGNvbnRhaW5lciA9IHJvb3ROb2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuX2Fzc2lnbihUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRvcExldmVsVHlwZSA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgfVxufSk7XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLCBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdGFyZ2V0SW5zdDtcbiAgZG8ge1xuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGFuY2VzdG9yICYmIGZpbmRQYXJlbnQoYW5jZXN0b3IpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxWYWx1ZU1vbml0b3IoY2IpIHtcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgY2Ioc2Nyb2xsUG9zaXRpb24pO1xufVxuXG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0ge1xuICBfZW5hYmxlZDogdHJ1ZSxcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxuXG4gIFdJTkRPV19IQU5ETEU6IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHdpbmRvdyA6IG51bGwsXG5cbiAgc2V0SGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uIChoYW5kbGVUb3BMZXZlbCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbiAgfSxcblxuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSxcblxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICBtb25pdG9yU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gc2Nyb2xsVmFsdWVNb25pdG9yLmJpbmQobnVsbCwgcmVmcmVzaCk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAnc2Nyb2xsJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCFSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYm9va0tlZXBpbmcgPSBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcuZ2V0UG9vbGVkKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucmVsZWFzZShib29rS2VlcGluZyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGlzdG9yeSA9IFtdO1xuXG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSB7XG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgIGhpc3RvcnkucHVzaChvcGVyYXRpb24pO1xuICB9LFxuICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suX3ByZXZlbnRDbGVhcmluZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdHMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGlzdG9yeSA9IFtdO1xuICB9LFxuICBnZXRIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhpc3Rvcnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2s7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RDb21wb25lbnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5pbmplY3Rpb24sXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5VdGlsczogRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24sXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcbiAgSG9zdENvbXBvbmVudDogUmVhY3RIb3N0Q29tcG9uZW50LmluamVjdGlvbixcbiAgVXBkYXRlczogUmVhY3RVcGRhdGVzLmluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluamVjdGlvbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbmplY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSW52YWxpZFNldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFwcm9jZXNzaW5nQ2hpbGRDb250ZXh0LCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSB7XG4gIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IHRydWU7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSBmYWxzZTtcbiAgfSxcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHdhcm5JbnZhbGlkU2V0U3RhdGUoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcblxudmFyIFRBR19FTkQgPSAvXFwvPz4vO1xudmFyIENPTU1FTlRfU1RBUlQgPSAvXjxcXCFcXC1cXC0vO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgY2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG5cbiAgICAvLyBBZGQgY2hlY2tzdW0gKGhhbmRsZSBib3RoIHBhcmVudCB0YWdzLCBjb21tZW50cyBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MpXG4gICAgaWYgKENPTU1FTlRfU1RBUlQudGVzdChtYXJrdXApKSB7XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoVEFHX0VORCwgJyAnICsgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUgKyAnPVwiJyArIGNoZWNrc3VtICsgJ1wiJCYnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCByb290IFJlYWN0IGVsZW1lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcbiAgICovXG4gIGNhblJldXNlTWFya3VwOiBmdW5jdGlvbiAobWFya3VwLCBlbGVtZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nQ2hlY2tzdW0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgZXhpc3RpbmdDaGVja3N1bSA9IGV4aXN0aW5nQ2hlY2tzdW0gJiYgcGFyc2VJbnQoZXhpc3RpbmdDaGVja3N1bSwgMTApO1xuICAgIHZhciBtYXJrdXBDaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwQ2hlY2tzdW0gPT09IGV4aXN0aW5nQ2hlY2tzdW07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNYXJrdXBDaGVja3N1bTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkUmVjb25jaWxlcicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtYXJrdXAgdG8gYmUgcmVuZGVyZWQgYW5kIGluc2VydGVkIGF0IGEgc3VwcGxpZWQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZUluc2VydE1hcmt1cChtYXJrdXAsIGFmdGVyTm9kZSwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0lOU0VSVF9NQVJLVVAnLFxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtb3ZpbmcgYW4gZXhpc3RpbmcgZWxlbWVudCB0byBhbm90aGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTU9WRV9FWElTVElORycsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUoY2hpbGQpLFxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdSRU1PVkVfTk9ERScsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBub2RlLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIG1hcmt1cCBvZiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VTZXRNYXJrdXAobWFya3VwKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnU0VUX01BUktVUCcsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlVGV4dENvbnRlbnQodGV4dENvbnRlbnQpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdURVhUX0NPTlRFTlQnLFxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIFB1c2ggYW4gdXBkYXRlLCBpZiBhbnksIG9udG8gdGhlIHF1ZXVlLiBDcmVhdGVzIGEgbmV3IHF1ZXVlIGlmIG5vbmUgaXNcbiAqIHBhc3NlZCBhbmQgYWx3YXlzIHJldHVybnMgdGhlIHF1ZXVlLiBNdXRhdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIGlmICh1cGRhdGUpIHtcbiAgICBxdWV1ZSA9IHF1ZXVlIHx8IFtdO1xuICAgIHF1ZXVlLnB1c2godXBkYXRlKTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZShpbnN0LCB1cGRhdGVRdWV1ZSkge1xuICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMoaW5zdCwgdXBkYXRlUXVldWUpO1xufVxuXG52YXIgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGdldERlYnVnSUQgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghaW5zdC5fZGVidWdJRCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIEFSVC1saWtlIGluc3RhbmNlcy4gVE9ETzogVGhpcyBpcyBzaWxseS9ncm9zcy5cbiAgICAgIHZhciBpbnRlcm5hbDtcbiAgICAgIGlmIChpbnRlcm5hbCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpKSB7XG4gICAgICAgIGluc3QgPSBpbnRlcm5hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3QuX2RlYnVnSUQ7XG4gIH07XG4gIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIGRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgIC8vIFRPRE86IFJlYWN0IE5hdGl2ZSBlbXB0eSBjb21wb25lbnRzIGFyZSBhbHNvIG11bHRpY2hpbGQuXG4gICAgLy8gVGhpcyBtZWFucyB0aGV5IHN0aWxsIGdldCBpbnRvIHRoaXMgbWV0aG9kIGJ1dCBkb24ndCBoYXZlIF9kZWJ1Z0lELlxuICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZHJlbiA/IE9iamVjdC5rZXlzKGNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5ba2V5XS5fZGVidWdJRDtcbiAgICAgIH0pIDogW10pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24gKG5leHRDb250ZW50KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VUZXh0Q29udGVudChuZXh0Q29udGVudCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VTZXRNYXJrdXAobmV4dE1hcmt1cCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIEhvb2sgdXNlZCBieSBSZWFjdCBBUlRcbiAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIgcmVtb3ZlZE5vZGVzID0ge307XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IG51bGw7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAvLyBgbmV4dE1vdW50SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIG5ld2x5IG1vdW50ZWQgY2hpbGQuXG4gICAgICB2YXIgbmV4dE1vdW50SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RQbGFjZWROb2RlID0gbnVsbDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCBsYXN0SW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICAvLyBUaGUgYHJlbW92ZWROb2Rlc2AgbG9vcCBiZWxvdyB3aWxsIGFjdHVhbGx5IHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX21vdW50Q2hpbGRBdEluZGV4KG5leHRDaGlsZCwgbW91bnRJbWFnZXNbbmV4dE1vdW50SW5kZXhdLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICAgIG5leHRNb3VudEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIGxhc3RQbGFjZWROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKG5leHRDaGlsZCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdLCByZW1vdmVkTm9kZXNbbmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC4gSXQgZG9lcyBub3QgYWN0dWFsbHkgcGVyZm9ybSBhbnlcbiAgICAgKiBiYWNrZW5kIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpIHtcbiAgICAgIHJldHVybiBtYWtlSW5zZXJ0TWFya3VwKG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICByZXR1cm4gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgaW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQsIG5vZGUpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RNdWx0aUNoaWxkLmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBvd25lci5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkT3duZXIob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQgYnkgcmVmIHRvIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBieSB3aGljaCB0byByZWZlciB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0byByZWNvcmQgdGhlIHJlZi5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYWRkQ29tcG9uZW50QXNSZWZUbzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFpc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTE5JykgOiB2b2lkIDA7XG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdGhlIHJlZiBpcyByZWNvcmRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIWlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSByZW1vdmluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTIwJykgOiB2b2lkIDA7XG4gICAgdmFyIG93bmVyUHVibGljSW5zdGFuY2UgPSBvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAncyBvd25lciBpcyBzdGlsbCBhbGl2ZSBhbmQgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWZcbiAgICAvLyBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxuICAgIGlmIChvd25lclB1YmxpY0luc3RhbmNlICYmIG93bmVyUHVibGljSW5zdGFuY2UucmVmc1tyZWZdID09PSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSkge1xuICAgICAgb3duZXIuZGV0YWNoUmVmKHJlZik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RPd25lcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RPd25lci5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbU0VMRUNUSU9OX1JFU1RPUkFUSU9OLCBFVkVOVF9TVVBQUkVTU0lPTiwgT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbih1c2VDcmVhdGVFbGVtZW50KSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdERPTVRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSB1c2VDcmVhdGVFbGVtZW50O1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXk8b2JqZWN0Pn0gTGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RVcGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSBjdXJyZW50IHRyYW5zYWN0aW9uIHN0YXRlIC0tIGlmIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGlzIG1ldGhvZCBpc1xuICAgKiBwYXNzZWQgdG8gYHJvbGxiYWNrYCwgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVzZXQgdG8gdGhhdCBzdGF0ZS5cbiAgICovXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZWFjdE1vdW50UmVhZHkgaXMgdGhlIG91ciBvbmx5IHN0YXRlZnVsIHdyYXBwZXJcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHkuY2hlY2twb2ludCgpO1xuICB9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoY2hlY2twb2ludCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbl9hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXG5cbiAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICB2YXIgcHJldlJlZiA9IG51bGw7XG4gIHZhciBwcmV2T3duZXIgPSBudWxsO1xuICBpZiAocHJldkVsZW1lbnQgIT09IG51bGwgJiYgdHlwZW9mIHByZXZFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHByZXZSZWYgPSBwcmV2RWxlbWVudC5yZWY7XG4gICAgcHJldk93bmVyID0gcHJldkVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIG5leHRSZWYgPSBudWxsO1xuICB2YXIgbmV4dE93bmVyID0gbnVsbDtcbiAgaWYgKG5leHRFbGVtZW50ICE9PSBudWxsICYmIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBuZXh0UmVmID0gbmV4dEVsZW1lbnQucmVmO1xuICAgIG5leHRPd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBwcmV2UmVmICE9PSBuZXh0UmVmIHx8XG4gIC8vIElmIG93bmVyIGNoYW5nZXMgYnV0IHdlIGhhdmUgYW4gdW5jaGFuZ2VkIGZ1bmN0aW9uIHJlZiwgZG9uJ3QgdXBkYXRlIHJlZnNcbiAgdHlwZW9mIG5leHRSZWYgPT09ICdzdHJpbmcnICYmIG5leHRPd25lciAhPT0gcHJldk93bmVyO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlZi5qc1xuLy8gbW9kdWxlIGlkID0gMTg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbnZhciBub29wQ2FsbGJhY2tRdWV1ZSA9IHtcbiAgZW5xdWV1ZTogZnVuY3Rpb24gKCkge31cbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBuZXcgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0aGlzKTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBub29wQ2FsbGJhY2tRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBSZWFjdCBhc3luYyBldmVudHMuXG4gICAqL1xuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7fSxcblxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7fSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKCkge31cbn07XG5cbl9hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHVwZGF0ZSBxdWV1ZSB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICogSXQgZGVsZWdhdGVzIHRvIFJlYWN0VXBkYXRlUXVldWUgd2hpbGUgc2VydmVyIHJlbmRlcmluZyBpcyBpbiBwcm9ncmVzcyBhbmRcbiAqIHN3aXRjaGVzIHRvIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgY29tcGxldGVkLlxuICogQGNsYXNzIFJlYWN0U2VydmVyVXBkYXRlUXVldWVcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKi9cblxudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlYWN0U2VydmVyVXBkYXRlUXVldWUodHJhbnNhY3Rpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSk7XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmlzTW91bnRlZCA9IGZ1bmN0aW9uIGlzTW91bnRlZChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVDYWxsYmFjayA9IGZ1bmN0aW9uIGVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVGb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVNldFN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzE1LjUuNCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1JlYWN0VmVyc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLy8gV2UgdXNlIGF0dHJpYnV0ZXMgZm9yIGV2ZXJ5dGhpbmcgU1ZHIHNvIGxldCdzIGF2b2lkIHNvbWUgZHVwbGljYXRpb24gYW5kIHJ1blxuLy8gY29kZSBpbnN0ZWFkLlxuLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHNwZWNpZmllZCBpbiB0aGUgSFRNTCBjb25maWcgYWxyZWFkeSBzbyB3ZSBleGNsdWRlIGhlcmUuXG4vLyAtIGNsYXNzIChhcyBjbGFzc05hbWUpXG4vLyAtIGNvbG9yXG4vLyAtIGhlaWdodFxuLy8gLSBpZFxuLy8gLSBsYW5nXG4vLyAtIG1heFxuLy8gLSBtZWRpYVxuLy8gLSBtZXRob2Rcbi8vIC0gbWluXG4vLyAtIG5hbWVcbi8vIC0gc3R5bGVcbi8vIC0gdGFyZ2V0XG4vLyAtIHR5cGVcbi8vIC0gd2lkdGhcbnZhciBBVFRSUyA9IHtcbiAgYWNjZW50SGVpZ2h0OiAnYWNjZW50LWhlaWdodCcsXG4gIGFjY3VtdWxhdGU6IDAsXG4gIGFkZGl0aXZlOiAwLFxuICBhbGlnbm1lbnRCYXNlbGluZTogJ2FsaWdubWVudC1iYXNlbGluZScsXG4gIGFsbG93UmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6IDAsXG4gIGFtcGxpdHVkZTogMCxcbiAgYXJhYmljRm9ybTogJ2FyYWJpYy1mb3JtJyxcbiAgYXNjZW50OiAwLFxuICBhdHRyaWJ1dGVOYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZVR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b1JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6IDAsXG4gIGJhc2VGcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZVByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJhc2VsaW5lU2hpZnQ6ICdiYXNlbGluZS1zaGlmdCcsXG4gIGJib3g6IDAsXG4gIGJlZ2luOiAwLFxuICBiaWFzOiAwLFxuICBieTogMCxcbiAgY2FsY01vZGU6ICdjYWxjTW9kZScsXG4gIGNhcEhlaWdodDogJ2NhcC1oZWlnaHQnLFxuICBjbGlwOiAwLFxuICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXG4gIGNsaXBSdWxlOiAnY2xpcC1ydWxlJyxcbiAgY2xpcFBhdGhVbml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjb2xvckludGVycG9sYXRpb246ICdjb2xvci1pbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsXG4gIGNvbG9yUHJvZmlsZTogJ2NvbG9yLXByb2ZpbGUnLFxuICBjb2xvclJlbmRlcmluZzogJ2NvbG9yLXJlbmRlcmluZycsXG4gIGNvbnRlbnRTY3JpcHRUeXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50U3R5bGVUeXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogMCxcbiAgY3g6IDAsXG4gIGN5OiAwLFxuICBkOiAwLFxuICBkZWNlbGVyYXRlOiAwLFxuICBkZXNjZW50OiAwLFxuICBkaWZmdXNlQ29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246IDAsXG4gIGRpc3BsYXk6IDAsXG4gIGRpdmlzb3I6IDAsXG4gIGRvbWluYW50QmFzZWxpbmU6ICdkb21pbmFudC1iYXNlbGluZScsXG4gIGR1cjogMCxcbiAgZHg6IDAsXG4gIGR5OiAwLFxuICBlZGdlTW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAwLFxuICBlbmFibGVCYWNrZ3JvdW5kOiAnZW5hYmxlLWJhY2tncm91bmQnLFxuICBlbmQ6IDAsXG4gIGV4cG9uZW50OiAwLFxuICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6IDAsXG4gIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgZmlsbFJ1bGU6ICdmaWxsLXJ1bGUnLFxuICBmaWx0ZXI6IDAsXG4gIGZpbHRlclJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlclVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZENvbG9yOiAnZmxvb2QtY29sb3InLFxuICBmbG9vZE9wYWNpdHk6ICdmbG9vZC1vcGFjaXR5JyxcbiAgZm9jdXNhYmxlOiAwLFxuICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gIGZvbnRTaXplQWRqdXN0OiAnZm9udC1zaXplLWFkanVzdCcsXG4gIGZvbnRTdHJldGNoOiAnZm9udC1zdHJldGNoJyxcbiAgZm9udFN0eWxlOiAnZm9udC1zdHlsZScsXG4gIGZvbnRWYXJpYW50OiAnZm9udC12YXJpYW50JyxcbiAgZm9udFdlaWdodDogJ2ZvbnQtd2VpZ2h0JyxcbiAgZm9ybWF0OiAwLFxuICBmcm9tOiAwLFxuICBmeDogMCxcbiAgZnk6IDAsXG4gIGcxOiAwLFxuICBnMjogMCxcbiAgZ2x5cGhOYW1lOiAnZ2x5cGgtbmFtZScsXG4gIGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsOiAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsXG4gIGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDogJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJyxcbiAgZ2x5cGhSZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudFVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6IDAsXG4gIGhvcml6QWR2WDogJ2hvcml6LWFkdi14JyxcbiAgaG9yaXpPcmlnaW5YOiAnaG9yaXotb3JpZ2luLXgnLFxuICBpZGVvZ3JhcGhpYzogMCxcbiAgaW1hZ2VSZW5kZXJpbmc6ICdpbWFnZS1yZW5kZXJpbmcnLFxuICAnaW4nOiAwLFxuICBpbjI6IDAsXG4gIGludGVyY2VwdDogMCxcbiAgazogMCxcbiAgazE6IDAsXG4gIGsyOiAwLFxuICBrMzogMCxcbiAgazQ6IDAsXG4gIGtlcm5lbE1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbFVuaXRMZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogMCxcbiAga2V5UG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5U3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXlUaW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoQWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyU3BhY2luZzogJ2xldHRlci1zcGFjaW5nJyxcbiAgbGlnaHRpbmdDb2xvcjogJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgbGltaXRpbmdDb25lQW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAwLFxuICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgbWFya2VyTWlkOiAnbWFya2VyLW1pZCcsXG4gIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgbWFya2VySGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VyVW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcldpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAwLFxuICBtYXNrQ29udGVudFVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2tVbml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogMCxcbiAgbW9kZTogMCxcbiAgbnVtT2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6IDAsXG4gIG9wYWNpdHk6IDAsXG4gIG9wZXJhdG9yOiAwLFxuICBvcmRlcjogMCxcbiAgb3JpZW50OiAwLFxuICBvcmllbnRhdGlvbjogMCxcbiAgb3JpZ2luOiAwLFxuICBvdmVyZmxvdzogMCxcbiAgb3ZlcmxpbmVQb3NpdGlvbjogJ292ZXJsaW5lLXBvc2l0aW9uJyxcbiAgb3ZlcmxpbmVUaGlja25lc3M6ICdvdmVybGluZS10aGlja25lc3MnLFxuICBwYWludE9yZGVyOiAncGFpbnQtb3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlLTEnLFxuICBwYXRoTGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5Db250ZW50VW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVyblRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJuVW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyRXZlbnRzOiAncG9pbnRlci1ldmVudHMnLFxuICBwb2ludHM6IDAsXG4gIHBvaW50c0F0WDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c0F0WTogJ3BvaW50c0F0WScsXG4gIHBvaW50c0F0WjogJ3BvaW50c0F0WicsXG4gIHByZXNlcnZlQWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmVVbml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcjogMCxcbiAgcmFkaXVzOiAwLFxuICByZWZYOiAncmVmWCcsXG4gIHJlZlk6ICdyZWZZJyxcbiAgcmVuZGVyaW5nSW50ZW50OiAncmVuZGVyaW5nLWludGVudCcsXG4gIHJlcGVhdENvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXREdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZEV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZEZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc3RhcnQ6IDAsXG4gIHJlc3VsdDogMCxcbiAgcm90YXRlOiAwLFxuICByeDogMCxcbiAgcnk6IDAsXG4gIHNjYWxlOiAwLFxuICBzZWVkOiAwLFxuICBzaGFwZVJlbmRlcmluZzogJ3NoYXBlLXJlbmRlcmluZycsXG4gIHNsb3BlOiAwLFxuICBzcGFjaW5nOiAwLFxuICBzcGVjdWxhckNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyRXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6IDAsXG4gIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0T2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGREZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogMCxcbiAgc3RlbXY6IDAsXG4gIHN0aXRjaFRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdoUG9zaXRpb246ICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaFRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAwLFxuICBzdHJva2U6IDAsXG4gIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICBzdHJva2VEYXNob2Zmc2V0OiAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICBzdHJva2VMaW5lY2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICBzdHJva2VMaW5lam9pbjogJ3N0cm9rZS1saW5lam9pbicsXG4gIHN0cm9rZU1pdGVybGltaXQ6ICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgc3VyZmFjZVNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtTGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxlVmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXRYOiAndGFyZ2V0WCcsXG4gIHRhcmdldFk6ICd0YXJnZXRZJyxcbiAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgdGV4dERlY29yYXRpb246ICd0ZXh0LWRlY29yYXRpb24nLFxuICB0ZXh0UmVuZGVyaW5nOiAndGV4dC1yZW5kZXJpbmcnLFxuICB0ZXh0TGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRvOiAwLFxuICB0cmFuc2Zvcm06IDAsXG4gIHUxOiAwLFxuICB1MjogMCxcbiAgdW5kZXJsaW5lUG9zaXRpb246ICd1bmRlcmxpbmUtcG9zaXRpb24nLFxuICB1bmRlcmxpbmVUaGlja25lc3M6ICd1bmRlcmxpbmUtdGhpY2tuZXNzJyxcbiAgdW5pY29kZTogMCxcbiAgdW5pY29kZUJpZGk6ICd1bmljb2RlLWJpZGknLFxuICB1bmljb2RlUmFuZ2U6ICd1bmljb2RlLXJhbmdlJyxcbiAgdW5pdHNQZXJFbTogJ3VuaXRzLXBlci1lbScsXG4gIHZBbHBoYWJldGljOiAndi1hbHBoYWJldGljJyxcbiAgdkhhbmdpbmc6ICd2LWhhbmdpbmcnLFxuICB2SWRlb2dyYXBoaWM6ICd2LWlkZW9ncmFwaGljJyxcbiAgdk1hdGhlbWF0aWNhbDogJ3YtbWF0aGVtYXRpY2FsJyxcbiAgdmFsdWVzOiAwLFxuICB2ZWN0b3JFZmZlY3Q6ICd2ZWN0b3ItZWZmZWN0JyxcbiAgdmVyc2lvbjogMCxcbiAgdmVydEFkdlk6ICd2ZXJ0LWFkdi15JyxcbiAgdmVydE9yaWdpblg6ICd2ZXJ0LW9yaWdpbi14JyxcbiAgdmVydE9yaWdpblk6ICd2ZXJ0LW9yaWdpbi15JyxcbiAgdmlld0JveDogJ3ZpZXdCb3gnLFxuICB2aWV3VGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6IDAsXG4gIHdpZHRoczogMCxcbiAgd29yZFNwYWNpbmc6ICd3b3JkLXNwYWNpbmcnLFxuICB3cml0aW5nTW9kZTogJ3dyaXRpbmctbW9kZScsXG4gIHg6IDAsXG4gIHhIZWlnaHQ6ICd4LWhlaWdodCcsXG4gIHgxOiAwLFxuICB4MjogMCxcbiAgeENoYW5uZWxTZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgeGxpbmtBcmNyb2xlOiAneGxpbms6YXJjcm9sZScsXG4gIHhsaW5rSHJlZjogJ3hsaW5rOmhyZWYnLFxuICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgeGxpbmtTaG93OiAneGxpbms6c2hvdycsXG4gIHhsaW5rVGl0bGU6ICd4bGluazp0aXRsZScsXG4gIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICB4bWxCYXNlOiAneG1sOmJhc2UnLFxuICB4bWxuczogMCxcbiAgeG1sbnNYbGluazogJ3htbG5zOnhsaW5rJyxcbiAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnLFxuICB5OiAwLFxuICB5MTogMCxcbiAgeTI6IDAsXG4gIHlDaGFubmVsU2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogMCxcbiAgem9vbUFuZFBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHt9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7fVxufTtcblxuT2JqZWN0LmtleXMoQVRUUlMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW2tleV0gPSAwO1xuICBpZiAoQVRUUlNba2V5XSkge1xuICAgIFNWR0RPTVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzW2tleV0gPSBBVFRSU1trZXldO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDE5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uU2VsZWN0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25TZWxlY3RDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29udGV4dE1lbnUnLCAndG9wRm9jdXMnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nLCAndG9wTW91c2VVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vLyBUcmFjayB3aGV0aGVyIGEgbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbi8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxudmFyIGhhc0xpc3RlbmVyID0gZmFsc2U7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxuICAgICAgdG9wOiByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKCFoYXNMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uU2VsZWN0Jykge1xuICAgICAgaGFzTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RFdmVudFBsdWdpbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNBbmltYXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0ZvY3VzRXZlbnQnKTtcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRHJhZ0V2ZW50Jyk7XG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVG91Y2hFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVHJhbnNpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1doZWVsRXZlbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFR1cm5zXG4gKiBbJ2Fib3J0JywgLi4uXVxuICogaW50b1xuICogZXZlbnRUeXBlcyA9IHtcbiAqICAgJ2Fib3J0Jzoge1xuICogICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gKiAgICAgICBidWJibGVkOiAnb25BYm9ydCcsXG4gKiAgICAgICBjYXB0dXJlZDogJ29uQWJvcnRDYXB0dXJlJyxcbiAqICAgICB9LFxuICogICAgIGRlcGVuZGVuY2llczogWyd0b3BBYm9ydCddLFxuICogICB9LFxuICogICAuLi5cbiAqIH07XG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gKiAgICd0b3BBYm9ydCc6IHsgc2FtZUNvbmZpZyB9XG4gKiB9O1xuICovXG52YXIgZXZlbnRUeXBlcyA9IHt9O1xudmFyIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHt9O1xuWydhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2JsdXInLCAnY2FuUGxheScsICdjYW5QbGF5VGhyb3VnaCcsICdjbGljaycsICdjb250ZXh0TWVudScsICdjb3B5JywgJ2N1dCcsICdkb3VibGVDbGljaycsICdkcmFnJywgJ2RyYWdFbmQnLCAnZHJhZ0VudGVyJywgJ2RyYWdFeGl0JywgJ2RyYWdMZWF2ZScsICdkcmFnT3ZlcicsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdkdXJhdGlvbkNoYW5nZScsICdlbXB0aWVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlcnJvcicsICdmb2N1cycsICdpbnB1dCcsICdpbnZhbGlkJywgJ2tleURvd24nLCAna2V5UHJlc3MnLCAna2V5VXAnLCAnbG9hZCcsICdsb2FkZWREYXRhJywgJ2xvYWRlZE1ldGFkYXRhJywgJ2xvYWRTdGFydCcsICdtb3VzZURvd24nLCAnbW91c2VNb3ZlJywgJ21vdXNlT3V0JywgJ21vdXNlT3ZlcicsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsICdwcm9ncmVzcycsICdyYXRlQ2hhbmdlJywgJ3Jlc2V0JywgJ3Njcm9sbCcsICdzZWVrZWQnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1Ym1pdCcsICdzdXNwZW5kJywgJ3RpbWVVcGRhdGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXG4gIH07XG4gIGV2ZW50VHlwZXNbZXZlbnRdID0gdHlwZTtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcEV2ZW50XSA9IHR5cGU7XG59KTtcblxudmFyIG9uQ2xpY2tMaXN0ZW5lcnMgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGljdGlvbmFyeUtleShpbnN0KSB7XG4gIC8vIFByZXZlbnRzIFY4IHBlcmZvcm1hbmNlIGlzc3VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHJldHVybiAnLicgKyBpbnN0Ll9yb290Tm9kZUlEO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSAndG9wQWJvcnQnOlxuICAgICAgY2FzZSAndG9wQ2FuUGxheSc6XG4gICAgICBjYXNlICd0b3BDYW5QbGF5VGhyb3VnaCc6XG4gICAgICBjYXNlICd0b3BEdXJhdGlvbkNoYW5nZSc6XG4gICAgICBjYXNlICd0b3BFbXB0aWVkJzpcbiAgICAgIGNhc2UgJ3RvcEVuY3J5cHRlZCc6XG4gICAgICBjYXNlICd0b3BFbmRlZCc6XG4gICAgICBjYXNlICd0b3BFcnJvcic6XG4gICAgICBjYXNlICd0b3BJbnB1dCc6XG4gICAgICBjYXNlICd0b3BJbnZhbGlkJzpcbiAgICAgIGNhc2UgJ3RvcExvYWQnOlxuICAgICAgY2FzZSAndG9wTG9hZGVkRGF0YSc6XG4gICAgICBjYXNlICd0b3BMb2FkZWRNZXRhZGF0YSc6XG4gICAgICBjYXNlICd0b3BMb2FkU3RhcnQnOlxuICAgICAgY2FzZSAndG9wUGF1c2UnOlxuICAgICAgY2FzZSAndG9wUGxheSc6XG4gICAgICBjYXNlICd0b3BQbGF5aW5nJzpcbiAgICAgIGNhc2UgJ3RvcFByb2dyZXNzJzpcbiAgICAgIGNhc2UgJ3RvcFJhdGVDaGFuZ2UnOlxuICAgICAgY2FzZSAndG9wUmVzZXQnOlxuICAgICAgY2FzZSAndG9wU2Vla2VkJzpcbiAgICAgIGNhc2UgJ3RvcFNlZWtpbmcnOlxuICAgICAgY2FzZSAndG9wU3RhbGxlZCc6XG4gICAgICBjYXNlICd0b3BTdWJtaXQnOlxuICAgICAgY2FzZSAndG9wU3VzcGVuZCc6XG4gICAgICBjYXNlICd0b3BUaW1lVXBkYXRlJzpcbiAgICAgIGNhc2UgJ3RvcFZvbHVtZUNoYW5nZSc6XG4gICAgICBjYXNlICd0b3BXYWl0aW5nJzpcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENsaWNrJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BEb3VibGVDbGljayc6XG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgY2FzZSAndG9wTW91c2VNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgLy8gVE9ETzogRGlzYWJsZWQgZWxlbWVudHMgc2hvdWxkIG5vdCByZXNwb25kIHRvIG1vdXNlIGV2ZW50c1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wTW91c2VPdXQnOlxuICAgICAgY2FzZSAndG9wTW91c2VPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wRHJhZyc6XG4gICAgICBjYXNlICd0b3BEcmFnRW5kJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbnRlcic6XG4gICAgICBjYXNlICd0b3BEcmFnRXhpdCc6XG4gICAgICBjYXNlICd0b3BEcmFnTGVhdmUnOlxuICAgICAgY2FzZSAndG9wRHJhZ092ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ1N0YXJ0JzpcbiAgICAgIGNhc2UgJ3RvcERyb3AnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRvdWNoQ2FuY2VsJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoRW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoTW92ZSc6XG4gICAgICBjYXNlICd0b3BUb3VjaFN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uRW5kJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkl0ZXJhdGlvbic6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25TdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUcmFuc2l0aW9uRW5kJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BTY3JvbGwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BXaGVlbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvcHknOlxuICAgICAgY2FzZSAndG9wQ3V0JzpcbiAgICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgIUV2ZW50Q29uc3RydWN0b3IgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLicsIHRvcExldmVsVHlwZSkgOiBfcHJvZEludmFyaWFudCgnODYnLCB0b3BMZXZlbFR5cGUpIDogdm9pZCAwO1xuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkNsaWNrJyAmJiAhaXNJbnRlcmFjdGl2ZShpbnN0Ll90YWcpKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICBpZiAoIW9uQ2xpY2tMaXN0ZW5lcnNba2V5XSkge1xuICAgICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25DbGljaycgJiYgIWlzSW50ZXJhY3RpdmUoaW5zdC5fdGFnKSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0ucmVtb3ZlKCk7XG4gICAgICBkZWxldGUgb25DbGlja0xpc3RlbmVyc1trZXldO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQW5pbWF0aW9uRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRLZXknKTtcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVG91Y2hFdmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljVG91Y2hFdmVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGkgKyA0MDk2LCBtKTtcbiAgICBmb3IgKDsgaSA8IG47IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qc1xuLy8gbW9kdWxlIGlkID0gMjAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcbnZhciBzdHlsZVdhcm5pbmdzID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gQWxsb3cgJzAnIHRvIHBhc3MgdGhyb3VnaCB3aXRob3V0IHdhcm5pbmcuIDAgaXMgYWxyZWFkeSBzcGVjaWFsIGFuZFxuICAgICAgLy8gZG9lc24ndCByZXF1aXJlIHVuaXRzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHdhcm4gYWJvdXQgaXQuXG4gICAgICBpZiAoY29tcG9uZW50ICYmIHZhbHVlICE9PSAnMCcpIHtcbiAgICAgICAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IG93bmVyLmdldE5hbWUoKSA6IG51bGw7XG4gICAgICAgIGlmIChvd25lck5hbWUgJiYgIXN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXSkge1xuICAgICAgICAgIHN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgIHZhciB3YXJuaW5ncyA9IHN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXTtcbiAgICAgICAgICB3YXJuZWQgPSB3YXJuaW5nc1tuYW1lXTtcbiAgICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgICAgd2FybmluZ3NbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYSBgJXNgIHRhZyAob3duZXI6IGAlc2ApIHdhcyBwYXNzZWQgYSBudW1lcmljIHN0cmluZyB2YWx1ZSAnICsgJ2ZvciBDU1MgcHJvcGVydHkgYCVzYCAodmFsdWU6IGAlc2ApIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCAnICsgJ2FzIGEgdW5pdGxlc3MgbnVtYmVyIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3QuJywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC50eXBlLCBvd25lck5hbWUgfHwgJ3Vua25vd24nLCBuYW1lLCB2YWx1ZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICsgJ3B4Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkYW5nZXJvdXNTdHlsZVZhbHVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG5cbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20uZmluZGRvbW5vZGVcbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuXG4gIHZhciBpbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgcmV0dXJuIGluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSA6IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZERPTU5vZGUgd2FzIGNhbGxlZCBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQ0JykgOiB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc0NScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogdm9pZCAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZERPTU5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL2ZpbmRET01Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9SZWFjdENvbXBvbmVudH0gY2hpbGQgUmVhY3QgY2hpbGQgY29tcG9uZW50LlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxuICogQHBhcmFtIHtudW1iZXI9fSBzZWxmRGVidWdJRCBPcHRpb25hbCBkZWJ1Z0lEIG9mIHRoZSBjdXJyZW50IGludGVybmFsIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgaWYgKHRyYXZlcnNlQ29udGV4dCAmJiB0eXBlb2YgdHJhdmVyc2VDb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXN1bHQgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gICAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWtleVVuaXF1ZSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XG4gICAgICByZXN1bHRbbmFtZV0gPSBjaGlsZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4sIHNlbGZEZWJ1Z0lEKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpO1xuICAgIH0sIHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL2ZsYXR0ZW5DaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgJ0VzYyc6ICdFc2NhcGUnLFxuICAnU3BhY2ViYXInOiAnICcsXG4gICdMZWZ0JzogJ0Fycm93TGVmdCcsXG4gICdVcCc6ICdBcnJvd1VwJyxcbiAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAnRG93bic6ICdBcnJvd0Rvd24nLFxuICAnRGVsJzogJ0RlbGV0ZScsXG4gICdXaW4nOiAnT1MnLFxuICAnTWVudSc6ICdDb250ZXh0TWVudScsXG4gICdBcHBzJzogJ0NvbnRleHRNZW51JyxcbiAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgJ01velByaW50YWJsZUtleSc6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsIDExMzogJ0YyJywgMTE0OiAnRjMnLCAxMTU6ICdGNCcsIDExNjogJ0Y1JywgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL2dldEV2ZW50S2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL2dldEl0ZXJhdG9yRm4uanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LWRvbS9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMjEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1kb20vbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBzdG9yZVNoYXBlLCBzdWJzY3JpcHRpb25TaGFwZSB9IGZyb20gJy4uL3V0aWxzL1Byb3BUeXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxudmFyIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpIHtcbiAgaWYgKGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gdHJ1ZTtcblxuICB3YXJuaW5nKCc8UHJvdmlkZXI+IGRvZXMgbm90IHN1cHBvcnQgY2hhbmdpbmcgYHN0b3JlYCBvbiB0aGUgZmx5LiAnICsgJ0l0IGlzIG1vc3QgbGlrZWx5IHRoYXQgeW91IHNlZSB0aGlzIGVycm9yIGJlY2F1c2UgeW91IHVwZGF0ZWQgdG8gJyArICdSZWR1eCAyLnggYW5kIFJlYWN0IFJlZHV4IDIueCB3aGljaCBubyBsb25nZXIgaG90IHJlbG9hZCByZWR1Y2VycyAnICsgJ2F1dG9tYXRpY2FsbHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yZWR1eC9yZWxlYXNlcy8nICsgJ3RhZy92Mi4wLjAgZm9yIHRoZSBtaWdyYXRpb24gaW5zdHJ1Y3Rpb25zLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXIoKSB7XG4gIHZhciBfUHJvdmlkZXIkY2hpbGRDb250ZXg7XG5cbiAgdmFyIHN0b3JlS2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnc3RvcmUnO1xuICB2YXIgc3ViS2V5ID0gYXJndW1lbnRzWzFdO1xuXG4gIHZhciBzdWJzY3JpcHRpb25LZXkgPSBzdWJLZXkgfHwgc3RvcmVLZXkgKyAnU3Vic2NyaXB0aW9uJztcblxuICB2YXIgUHJvdmlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgICBQcm92aWRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbc3RvcmVLZXldID0gdGhpc1tzdG9yZUtleV0sIF9yZWZbc3Vic2NyaXB0aW9uS2V5XSA9IG51bGwsIF9yZWY7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvdmlkZXIpO1xuXG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgICAgX3RoaXNbc3RvcmVLZXldID0gcHJvcHMuc3RvcmU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBDaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJvdmlkZXI7XG4gIH0oQ29tcG9uZW50KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgICAgaWYgKHRoaXNbc3RvcmVLZXldICE9PSBuZXh0UHJvcHMuc3RvcmUpIHtcbiAgICAgICAgd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICAgIHN0b3JlOiBzdG9yZVNoYXBlLmlzUmVxdWlyZWQsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRcbiAgfTtcbiAgUHJvdmlkZXIuY2hpbGRDb250ZXh0VHlwZXMgPSAoX1Byb3ZpZGVyJGNoaWxkQ29udGV4ID0ge30sIF9Qcm92aWRlciRjaGlsZENvbnRleFtzdG9yZUtleV0gPSBzdG9yZVNoYXBlLmlzUmVxdWlyZWQsIF9Qcm92aWRlciRjaGlsZENvbnRleFtzdWJzY3JpcHRpb25LZXldID0gc3Vic2NyaXB0aW9uU2hhcGUsIF9Qcm92aWRlciRjaGlsZENvbnRleCk7XG4gIFByb3ZpZGVyLmRpc3BsYXlOYW1lID0gJ1Byb3ZpZGVyJztcblxuICByZXR1cm4gUHJvdmlkZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVByb3ZpZGVyKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1yZWR1eC9lcy9jb21wb25lbnRzL1Byb3ZpZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgY29ubmVjdEFkdmFuY2VkIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbmltcG9ydCBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwRGlzcGF0Y2hUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwU3RhdGVUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWVyZ2VQcm9wc0ZhY3RvcmllcyBmcm9tICcuL21lcmdlUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknO1xuXG4vKlxuICBjb25uZWN0IGlzIGEgZmFjYWRlIG92ZXIgY29ubmVjdEFkdmFuY2VkLiBJdCB0dXJucyBpdHMgYXJncyBpbnRvIGEgY29tcGF0aWJsZVxuICBzZWxlY3RvckZhY3RvcnksIHdoaWNoIGhhcyB0aGUgc2lnbmF0dXJlOlxuXG4gICAgKGRpc3BhdGNoLCBvcHRpb25zKSA9PiAobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpID0+IG5leHRGaW5hbFByb3BzXG4gIFxuICBjb25uZWN0IHBhc3NlcyBpdHMgYXJncyB0byBjb25uZWN0QWR2YW5jZWQgYXMgb3B0aW9ucywgd2hpY2ggd2lsbCBpbiB0dXJuIHBhc3MgdGhlbSB0b1xuICBzZWxlY3RvckZhY3RvcnkgZWFjaCB0aW1lIGEgQ29ubmVjdCBjb21wb25lbnQgaW5zdGFuY2UgaXMgaW5zdGFudGlhdGVkIG9yIGhvdCByZWxvYWRlZC5cblxuICBzZWxlY3RvckZhY3RvcnkgcmV0dXJucyBhIGZpbmFsIHByb3BzIHNlbGVjdG9yIGZyb20gaXRzIG1hcFN0YXRlVG9Qcm9wcyxcbiAgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcywgbWVyZ2VQcm9wcyxcbiAgbWVyZ2VQcm9wc0ZhY3RvcmllcywgYW5kIHB1cmUgYXJncy5cblxuICBUaGUgcmVzdWx0aW5nIGZpbmFsIHByb3BzIHNlbGVjdG9yIGlzIGNhbGxlZCBieSB0aGUgQ29ubmVjdCBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbmV2ZXJcbiAgaXQgcmVjZWl2ZXMgbmV3IHByb3BzIG9yIHN0b3JlIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGFyZywgZmFjdG9yaWVzLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSBmYWN0b3JpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFjdG9yaWVzW2ldKGFyZyk7XG4gICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgb2YgdHlwZSAnICsgdHlwZW9mIGFyZyArICcgZm9yICcgKyBuYW1lICsgJyBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICcgKyBvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lICsgJy4nKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuLy8gY3JlYXRlQ29ubmVjdCB3aXRoIGRlZmF1bHQgYXJncyBidWlsZHMgdGhlICdvZmZpY2lhbCcgY29ubmVjdCBiZWhhdmlvci4gQ2FsbGluZyBpdCB3aXRoXG4vLyBkaWZmZXJlbnQgb3B0aW9ucyBvcGVucyB1cCBzb21lIHRlc3RpbmcgYW5kIGV4dGVuc2liaWxpdHkgc2NlbmFyaW9zXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29ubmVjdCgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgX3JlZiRjb25uZWN0SE9DID0gX3JlZi5jb25uZWN0SE9DLFxuICAgICAgY29ubmVjdEhPQyA9IF9yZWYkY29ubmVjdEhPQyA9PT0gdW5kZWZpbmVkID8gY29ubmVjdEFkdmFuY2VkIDogX3JlZiRjb25uZWN0SE9DLFxuICAgICAgX3JlZiRtYXBTdGF0ZVRvUHJvcHNGID0gX3JlZi5tYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YsXG4gICAgICBfcmVmJG1hcERpc3BhdGNoVG9Qcm8gPSBfcmVmLm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWFwRGlzcGF0Y2hUb1BybyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWFwRGlzcGF0Y2hUb1BybyxcbiAgICAgIF9yZWYkbWVyZ2VQcm9wc0ZhY3RvciA9IF9yZWYubWVyZ2VQcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1lcmdlUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1lcmdlUHJvcHNGYWN0b3IgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNZXJnZVByb3BzRmFjdG9yaWVzIDogX3JlZiRtZXJnZVByb3BzRmFjdG9yLFxuICAgICAgX3JlZiRzZWxlY3RvckZhY3RvcnkgPSBfcmVmLnNlbGVjdG9yRmFjdG9yeSxcbiAgICAgIHNlbGVjdG9yRmFjdG9yeSA9IF9yZWYkc2VsZWN0b3JGYWN0b3J5ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IDogX3JlZiRzZWxlY3RvckZhY3Rvcnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9LFxuICAgICAgICBfcmVmMiRwdXJlID0gX3JlZjIucHVyZSxcbiAgICAgICAgcHVyZSA9IF9yZWYyJHB1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmMiRwdXJlLFxuICAgICAgICBfcmVmMiRhcmVTdGF0ZXNFcXVhbCA9IF9yZWYyLmFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYyJGFyZVN0YXRlc0VxdWFsID09PSB1bmRlZmluZWQgPyBzdHJpY3RFcXVhbCA6IF9yZWYyJGFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBfcmVmMiRhcmVPd25Qcm9wc0VxdWEgPSBfcmVmMi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZjIkYXJlT3duUHJvcHNFcXVhID09PSB1bmRlZmluZWQgPyBzaGFsbG93RXF1YWwgOiBfcmVmMiRhcmVPd25Qcm9wc0VxdWEsXG4gICAgICAgIF9yZWYyJGFyZVN0YXRlUHJvcHNFcSA9IF9yZWYyLmFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZjIkYXJlU3RhdGVQcm9wc0VxID09PSB1bmRlZmluZWQgPyBzaGFsbG93RXF1YWwgOiBfcmVmMiRhcmVTdGF0ZVByb3BzRXEsXG4gICAgICAgIF9yZWYyJGFyZU1lcmdlZFByb3BzRSA9IF9yZWYyLmFyZU1lcmdlZFByb3BzRXF1YWwsXG4gICAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBfcmVmMiRhcmVNZXJnZWRQcm9wc0UgPT09IHVuZGVmaW5lZCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYyJGFyZU1lcmdlZFByb3BzRSxcbiAgICAgICAgZXh0cmFPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ3B1cmUnLCAnYXJlU3RhdGVzRXF1YWwnLCAnYXJlT3duUHJvcHNFcXVhbCcsICdhcmVTdGF0ZVByb3BzRXF1YWwnLCAnYXJlTWVyZ2VkUHJvcHNFcXVhbCddKTtcblxuICAgIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWF0Y2gobWFwU3RhdGVUb1Byb3BzLCBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICB2YXIgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hdGNoKG1hcERpc3BhdGNoVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgdmFyIGluaXRNZXJnZVByb3BzID0gbWF0Y2gobWVyZ2VQcm9wcywgbWVyZ2VQcm9wc0ZhY3RvcmllcywgJ21lcmdlUHJvcHMnKTtcblxuICAgIHJldHVybiBjb25uZWN0SE9DKHNlbGVjdG9yRmFjdG9yeSwgX2V4dGVuZHMoe1xuICAgICAgLy8gdXNlZCBpbiBlcnJvciBtZXNzYWdlc1xuICAgICAgbWV0aG9kTmFtZTogJ2Nvbm5lY3QnLFxuXG4gICAgICAvLyB1c2VkIHRvIGNvbXB1dGUgQ29ubmVjdCdzIGRpc3BsYXlOYW1lIGZyb20gdGhlIHdyYXBwZWQgY29tcG9uZW50J3MgZGlzcGxheU5hbWUuXG4gICAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gJ0Nvbm5lY3QoJyArIG5hbWUgKyAnKSc7XG4gICAgICB9LFxuXG4gICAgICAvLyBpZiBtYXBTdGF0ZVRvUHJvcHMgaXMgZmFsc3ksIHRoZSBDb25uZWN0IGNvbXBvbmVudCBkb2Vzbid0IHN1YnNjcmliZSB0byBzdG9yZSBzdGF0ZSBjaGFuZ2VzXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKSxcblxuICAgICAgLy8gcGFzc2VkIHRocm91Z2ggdG8gc2VsZWN0b3JGYWN0b3J5XG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzOiBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wczogaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzOiBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIHB1cmU6IHB1cmUsXG4gICAgICBhcmVTdGF0ZXNFcXVhbDogYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsOiBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsOiBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsOiBhcmVNZXJnZWRQcm9wc0VxdWFsXG5cbiAgICB9LCBleHRyYU9wdGlvbnMpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQ29ubmVjdCgpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9jb25uZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgd3JhcE1hcFRvUHJvcHNDb25zdGFudCwgd3JhcE1hcFRvUHJvcHNGdW5jIH0gZnJvbSAnLi93cmFwTWFwVG9Qcm9wcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbihtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJykgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nKG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHsgZGlzcGF0Y2g6IGRpc3BhdGNoIH07XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzT2JqZWN0KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdvYmplY3QnID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpO1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgW3doZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nLCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3RdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanNcbi8vIG1vZHVsZSBpZCA9IDIxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uKG1hcFN0YXRlVG9Qcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBTdGF0ZVRvUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmcobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgW3doZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWFwU3RhdGVUb1Byb3BzSXNNaXNzaW5nXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHZlcmlmeVBsYWluT2JqZWN0IGZyb20gJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb3duUHJvcHMsIHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgICBwdXJlID0gX3JlZi5wdXJlLFxuICAgICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gX3JlZi5hcmVNZXJnZWRQcm9wc0VxdWFsO1xuXG4gICAgdmFyIGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgICB2YXIgbWVyZ2VkUHJvcHMgPSB2b2lkIDA7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICB2YXIgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghcHVyZSB8fCAhYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSkgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNSdW5PbmNlID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KG1lcmdlZFByb3BzLCBkaXNwbGF5TmFtZSwgJ21lcmdlUHJvcHMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24obWVyZ2VQcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1lcmdlUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWVyZ2VQcm9wc0lzT21pdHRlZChtZXJnZVByb3BzKSB7XG4gIHJldHVybiAhbWVyZ2VQcm9wcyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1lcmdlUHJvcHM7XG4gIH0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24sIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gMjE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IHZlcmlmeVN1YnNlbGVjdG9ycyBmcm9tICcuL3ZlcmlmeVN1YnNlbGVjdG9ycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykge1xuICAgIHJldHVybiBtZXJnZVByb3BzKG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpLCBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKSwgb3duUHJvcHMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBfcmVmKSB7XG4gIHZhciBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYuYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZi5hcmVTdGF0ZVByb3BzRXF1YWw7XG5cbiAgdmFyIGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIG93blByb3BzID0gdm9pZCAwO1xuICB2YXIgc3RhdGVQcm9wcyA9IHZvaWQgMDtcbiAgdmFyIGRpc3BhdGNoUHJvcHMgPSB2b2lkIDA7XG4gIHZhciBtZXJnZWRQcm9wcyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcblxuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICB2YXIgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICB2YXIgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG5cbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG5cbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICB2YXIgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgdmFyIHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChuZXh0U3RhdGUsIHN0YXRlKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcblxuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpO1xuICAgIGlmIChwcm9wc0NoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XG4gIH07XG59XG5cbi8vIFRPRE86IEFkZCBtb3JlIGNvbW1lbnRzXG5cbi8vIElmIHB1cmUgaXMgdHJ1ZSwgdGhlIHNlbGVjdG9yIHJldHVybmVkIGJ5IHNlbGVjdG9yRmFjdG9yeSB3aWxsIG1lbW9pemUgaXRzIHJlc3VsdHMsXG4vLyBhbGxvd2luZyBjb25uZWN0QWR2YW5jZWQncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLiBJZiBmYWxzZSwgdGhlIHNlbGVjdG9yIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ld1xuLy8gb2JqZWN0IGFuZCBzaG91bGRDb21wb25lbnRVcGRhdGUgd2lsbCBhbHdheXMgcmV0dXJuIHRydWUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIF9yZWYyKSB7XG4gIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gX3JlZjIuaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBfcmVmMi5pbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMgPSBfcmVmMi5pbml0TWVyZ2VQcm9wcyxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnaW5pdE1hcFN0YXRlVG9Qcm9wcycsICdpbml0TWFwRGlzcGF0Y2hUb1Byb3BzJywgJ2luaXRNZXJnZVByb3BzJ10pO1xuXG4gIHZhciBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgdmFyIG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgb3B0aW9ucy5kaXNwbGF5TmFtZSk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGYWN0b3J5ID0gb3B0aW9ucy5wdXJlID8gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkgOiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5O1xuXG4gIHJldHVybiBzZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi4vdXRpbHMvd2FybmluZyc7XG5cbmZ1bmN0aW9uIHZlcmlmeShzZWxlY3RvciwgbWV0aG9kTmFtZSwgZGlzcGxheU5hbWUpIHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSBmb3IgJyArIG1ldGhvZE5hbWUgKyAnIGluICcgKyBkaXNwbGF5TmFtZSArICcuJyk7XG4gIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ21hcFN0YXRlVG9Qcm9wcycgfHwgbWV0aG9kTmFtZSA9PT0gJ21hcERpc3BhdGNoVG9Qcm9wcycpIHtcbiAgICBpZiAoIXNlbGVjdG9yLmhhc093blByb3BlcnR5KCdkZXBlbmRzT25Pd25Qcm9wcycpKSB7XG4gICAgICB3YXJuaW5nKCdUaGUgc2VsZWN0b3IgZm9yICcgKyBtZXRob2ROYW1lICsgJyBvZiAnICsgZGlzcGxheU5hbWUgKyAnIGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy4nKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2ZXJpZnkobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJywgZGlzcGxheU5hbWUpO1xuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJywgZGlzcGxheU5hbWUpO1xuICB2ZXJpZnkobWVyZ2VQcm9wcywgJ21lcmdlUHJvcHMnLCBkaXNwbGF5TmFtZSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMjIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8vIGVuY2Fwc3VsYXRlcyB0aGUgc3Vic2NyaXB0aW9uIGxvZ2ljIGZvciBjb25uZWN0aW5nIGEgY29tcG9uZW50IHRvIHRoZSByZWR1eCBzdG9yZSwgYXNcbi8vIHdlbGwgYXMgbmVzdGluZyBzdWJzY3JpcHRpb25zIG9mIGRlc2NlbmRhbnQgY29tcG9uZW50cywgc28gdGhhdCB3ZSBjYW4gZW5zdXJlIHRoZVxuLy8gYW5jZXN0b3IgY29tcG9uZW50cyByZS1yZW5kZXIgYmVmb3JlIGRlc2NlbmRhbnRzXG5cbnZhciBDTEVBUkVEID0gbnVsbDtcbnZhciBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHt9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIC8vIHRoZSBjdXJyZW50L25leHQgcGF0dGVybiBpcyBjb3BpZWQgZnJvbSByZWR1eCdzIGNyZWF0ZVN0b3JlIGNvZGUuXG4gIC8vIFRPRE86IHJlZmFjdG9yK2V4cG9zZSB0aGF0IGNvZGUgdG8gYmUgcmV1c2FibGUgaGVyZT9cbiAgdmFyIGN1cnJlbnQgPSBbXTtcbiAgdmFyIG5leHQgPSBbXTtcblxuICByZXR1cm4ge1xuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIG5leHQgPSBDTEVBUkVEO1xuICAgICAgY3VycmVudCA9IENMRUFSRUQ7XG4gICAgfSxcbiAgICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50ID0gbmV4dDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpXSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgaWYgKG5leHQgPT09IGN1cnJlbnQpIG5leHQgPSBjdXJyZW50LnNsaWNlKCk7XG4gICAgICBuZXh0LnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghaXNTdWJzY3JpYmVkIHx8IGN1cnJlbnQgPT09IENMRUFSRUQpIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG5leHQgPT09IGN1cnJlbnQpIG5leHQgPSBjdXJyZW50LnNsaWNlKCk7XG4gICAgICAgIG5leHQuc3BsaWNlKG5leHQuaW5kZXhPZihsaXN0ZW5lciksIDEpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViLCBvblN0YXRlQ2hhbmdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNjcmlwdGlvbik7XG5cbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5wYXJlbnRTdWIgPSBwYXJlbnRTdWI7XG4gICAgdGhpcy5vblN0YXRlQ2hhbmdlID0gb25TdGF0ZUNoYW5nZTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gIH1cblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZE5lc3RlZFN1YiA9IGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcikge1xuICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5ub3RpZnlOZXN0ZWRTdWJzID0gZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmlzU3Vic2NyaWJlZCA9IGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnVuc3Vic2NyaWJlKTtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSB0aGlzLnBhcmVudFN1YiA/IHRoaXMucGFyZW50U3ViLmFkZE5lc3RlZFN1Yih0aGlzLm9uU3RhdGVDaGFuZ2UpIDogdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5vblN0YXRlQ2hhbmdlKTtcblxuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50cnlVbnN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdWJzY3JpcHRpb247XG59KCk7XG5cbmV4cG9ydCB7IFN1YnNjcmlwdGlvbiBhcyBkZWZhdWx0IH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy9TdWJzY3JpcHRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC1yZWR1eC9lcy91dGlscy9zaGFsbG93RXF1YWwuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVW5lc2NhcGUgYW5kIHVud3JhcCBrZXkgZm9yIGh1bWFuLXJlYWRhYmxlIGRpc3BsYXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIHVuZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdW5lc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoa2V5KSB7XG4gIHZhciB1bmVzY2FwZVJlZ2V4ID0gLyg9MHw9MikvZztcbiAgdmFyIHVuZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPTAnOiAnPScsXG4gICAgJz0yJzogJzonXG4gIH07XG4gIHZhciBrZXlTdWJzdHJpbmcgPSBrZXlbMF0gPT09ICcuJyAmJiBrZXlbMV0gPT09ICckJyA/IGtleS5zdWJzdHJpbmcoMikgOiBrZXkuc3Vic3RyaW5nKDEpO1xuXG4gIHJldHVybiAoJycgKyBrZXlTdWJzdHJpbmcpLnJlcGxhY2UodW5lc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xufVxuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSB7XG4gIGVzY2FwZTogZXNjYXBlLFxuICB1bmVzY2FwZTogdW5lc2NhcGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5RXNjYXBlVXRpbHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9saWIvS2V5RXNjYXBlVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDIyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogX3Byb2RJbnZhcmlhbnQoJzI1JykgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIC8vIENhc3RpbmcgYXMgYW55IHNvIHRoYXQgZmxvdyBpZ25vcmVzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gYW5kIHRydXN0c1xuICAvLyBpdCB0byBtYXRjaCB0aGUgdHlwZSB3ZSBkZWNsYXJlZFxuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Gb3JFYWNoQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWw6IG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwsXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIE1JWElOU19LRVkgPSAnbWl4aW5zJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxuLy8gaGF2ZSAubmFtZSBzZXQgdG8gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGJlaW5nIGFzc2lnbmVkIHRvLlxuZnVuY3Rpb24gaWRlbnRpdHkoZm4pIHtcbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gKi9cblxuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgaG9zdCBjb21wb25lbnRzLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiAnREVGSU5FX09OQ0UnLFxuXG4gIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAqXG4gICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAqICAgICB9KTtcbiAgICogICB9XG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgKiB1cGRhdGUuXG4gICAqXG4gICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiAnREVGSU5FX09OQ0UnLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAqXG4gICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogJ09WRVJSSURFX0JBU0UnXG5cbn07XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICovXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIH0sXG4gIG1peGluczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsICdjaGlsZENvbnRleHQnKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xuICB9LFxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCAnY29udGV4dCcpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLCBnZXREZWZhdWx0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgfVxuICB9LFxuICBwcm9wVHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gIH0sXG4gIHN0YXRpY3M6IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgfSxcbiAgYXV0b2JpbmQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIGludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG9ubHkgaW4gX19ERVZfX1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gJ09WRVJSSURFX0JBU0UnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzczJywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknIHx8IHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc0JywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gKi9cbmZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gIGlmICghc3BlYykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgdHlwZW9mU3BlYyA9IHR5cGVvZiBzcGVjO1xuICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGlzTWl4aW5WYWxpZCwgJyVzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIGluY2x1ZGUgYSBtaXhpbiB0aGF0IGlzIGVpdGhlciBudWxsICcgKyAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICsgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIHNwZWMgPT09IG51bGwgPyBudWxsIDogdHlwZW9mU3BlYykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgISh0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NScpIDogdm9pZCAwO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc2JykgOiB2b2lkIDA7XG5cbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgYXV0b0JpbmRQYWlycyA9IHByb3RvLl9fcmVhY3RBdXRvQmluZFBhaXJzO1xuXG4gIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9IGlzRnVuY3Rpb24gJiYgIWlzUmVhY3RDbGFzc01ldGhvZCAmJiAhaXNBbHJlYWR5RGVmaW5lZCAmJiBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgIGF1dG9CaW5kUGFpcnMucHVzaChuYW1lLCBwcm9wZXJ0eSk7XG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICEoaXNSZWFjdENsYXNzTWV0aG9kICYmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzIHdoZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NycsIHNwZWNQb2xpY3ksIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICBpZiAoIXN0YXRpY3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG4gICAgISFpc1Jlc2VydmVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCBwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3Rvci4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OCcsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICAhIWlzSW5oZXJpdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzknLCBuYW1lKSA6IHZvaWQgMDtcbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAhKG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLicpIDogX3Byb2RJbnZhcmlhbnQoJzgwJykgOiB2b2lkIDA7XG5cbiAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IFRyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byBnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzIHdpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogX3Byb2RJbnZhcmlhbnQoJzgxJywga2V5KSA6IHZvaWQgMDtcbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICB2YXIgYyA9IHt9O1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICsgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgIH1cbiAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG4vKipcbiAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICB2YXIgcGFpcnMgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcbiAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICovXG52YXIgUmVhY3RDbGFzc01peGluID0ge1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuaXNNb3VudGVkKHRoaXMpO1xuICB9XG59O1xuXG52YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuX2Fzc2lnbihSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENsYXNzTWl4aW4pO1xuXG52YXIgZGlkV2FybkRlcHJlY2F0ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENsYXNzXG4gKi9cbnZhciBSZWFjdENsYXNzID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbiAoc3BlYykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuRGVwcmVjYXRlZCwgJyVzOiBSZWFjdC5jcmVhdGVDbGFzcyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiAxNi4gJyArICdVc2UgcGxhaW4gSmF2YVNjcmlwdCBjbGFzc2VzIGluc3RlYWQuIElmIHlvdVxcJ3JlIG5vdCB5ZXQgcmVhZHkgdG8gJyArICdtaWdyYXRlLCBjcmVhdGUtcmVhY3QtY2xhc3MgaXMgYXZhaWxhYmxlIG9uIG5wbSBhcyBhICcgKyAnZHJvcC1pbiByZXBsYWNlbWVudC4nLCBzcGVjICYmIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBkaWRXYXJuRGVwcmVjYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gVG8ga2VlcCBvdXIgd2FybmluZ3MgbW9yZSB1bmRlcnN0YW5kYWJsZSwgd2UnbGwgdXNlIGEgbGl0dGxlIGhhY2sgaGVyZSB0b1xuICAgIC8vIGVuc3VyZSB0aGF0IENvbnN0cnVjdG9yLm5hbWUgIT09ICdDb25zdHJ1Y3RvcicuIFRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndFxuICAgIC8vIHVubmVjZXNzYXJpbHkgaWRlbnRpZnkgYSBjbGFzcyB3aXRob3V0IGRpc3BsYXlOYW1lIGFzICdDb25zdHJ1Y3RvcicuXG4gICAgdmFyIENvbnN0cnVjdG9yID0gaWRlbnRpdHkoZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCc4MicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH0pO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpIDogX3Byb2RJbnZhcmlhbnQoJzgzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgSFRNTCB0YWcgZWxlbWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHtcbiAgYTogY3JlYXRlRE9NRmFjdG9yeSgnYScpLFxuICBhYmJyOiBjcmVhdGVET01GYWN0b3J5KCdhYmJyJyksXG4gIGFkZHJlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ2FkZHJlc3MnKSxcbiAgYXJlYTogY3JlYXRlRE9NRmFjdG9yeSgnYXJlYScpLFxuICBhcnRpY2xlOiBjcmVhdGVET01GYWN0b3J5KCdhcnRpY2xlJyksXG4gIGFzaWRlOiBjcmVhdGVET01GYWN0b3J5KCdhc2lkZScpLFxuICBhdWRpbzogY3JlYXRlRE9NRmFjdG9yeSgnYXVkaW8nKSxcbiAgYjogY3JlYXRlRE9NRmFjdG9yeSgnYicpLFxuICBiYXNlOiBjcmVhdGVET01GYWN0b3J5KCdiYXNlJyksXG4gIGJkaTogY3JlYXRlRE9NRmFjdG9yeSgnYmRpJyksXG4gIGJkbzogY3JlYXRlRE9NRmFjdG9yeSgnYmRvJyksXG4gIGJpZzogY3JlYXRlRE9NRmFjdG9yeSgnYmlnJyksXG4gIGJsb2NrcXVvdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jsb2NrcXVvdGUnKSxcbiAgYm9keTogY3JlYXRlRE9NRmFjdG9yeSgnYm9keScpLFxuICBicjogY3JlYXRlRE9NRmFjdG9yeSgnYnInKSxcbiAgYnV0dG9uOiBjcmVhdGVET01GYWN0b3J5KCdidXR0b24nKSxcbiAgY2FudmFzOiBjcmVhdGVET01GYWN0b3J5KCdjYW52YXMnKSxcbiAgY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnY2FwdGlvbicpLFxuICBjaXRlOiBjcmVhdGVET01GYWN0b3J5KCdjaXRlJyksXG4gIGNvZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvZGUnKSxcbiAgY29sOiBjcmVhdGVET01GYWN0b3J5KCdjb2wnKSxcbiAgY29sZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbGdyb3VwJyksXG4gIGRhdGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGEnKSxcbiAgZGF0YWxpc3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGFsaXN0JyksXG4gIGRkOiBjcmVhdGVET01GYWN0b3J5KCdkZCcpLFxuICBkZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlbCcpLFxuICBkZXRhaWxzOiBjcmVhdGVET01GYWN0b3J5KCdkZXRhaWxzJyksXG4gIGRmbjogY3JlYXRlRE9NRmFjdG9yeSgnZGZuJyksXG4gIGRpYWxvZzogY3JlYXRlRE9NRmFjdG9yeSgnZGlhbG9nJyksXG4gIGRpdjogY3JlYXRlRE9NRmFjdG9yeSgnZGl2JyksXG4gIGRsOiBjcmVhdGVET01GYWN0b3J5KCdkbCcpLFxuICBkdDogY3JlYXRlRE9NRmFjdG9yeSgnZHQnKSxcbiAgZW06IGNyZWF0ZURPTUZhY3RvcnkoJ2VtJyksXG4gIGVtYmVkOiBjcmVhdGVET01GYWN0b3J5KCdlbWJlZCcpLFxuICBmaWVsZHNldDogY3JlYXRlRE9NRmFjdG9yeSgnZmllbGRzZXQnKSxcbiAgZmlnY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnZmlnY2FwdGlvbicpLFxuICBmaWd1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ3VyZScpLFxuICBmb290ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvb3RlcicpLFxuICBmb3JtOiBjcmVhdGVET01GYWN0b3J5KCdmb3JtJyksXG4gIGgxOiBjcmVhdGVET01GYWN0b3J5KCdoMScpLFxuICBoMjogY3JlYXRlRE9NRmFjdG9yeSgnaDInKSxcbiAgaDM6IGNyZWF0ZURPTUZhY3RvcnkoJ2gzJyksXG4gIGg0OiBjcmVhdGVET01GYWN0b3J5KCdoNCcpLFxuICBoNTogY3JlYXRlRE9NRmFjdG9yeSgnaDUnKSxcbiAgaDY6IGNyZWF0ZURPTUZhY3RvcnkoJ2g2JyksXG4gIGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWQnKSxcbiAgaGVhZGVyOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkZXInKSxcbiAgaGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdoZ3JvdXAnKSxcbiAgaHI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hyJyksXG4gIGh0bWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2h0bWwnKSxcbiAgaTogY3JlYXRlRE9NRmFjdG9yeSgnaScpLFxuICBpZnJhbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ2lmcmFtZScpLFxuICBpbWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltZycpLFxuICBpbnB1dDogY3JlYXRlRE9NRmFjdG9yeSgnaW5wdXQnKSxcbiAgaW5zOiBjcmVhdGVET01GYWN0b3J5KCdpbnMnKSxcbiAga2JkOiBjcmVhdGVET01GYWN0b3J5KCdrYmQnKSxcbiAga2V5Z2VuOiBjcmVhdGVET01GYWN0b3J5KCdrZXlnZW4nKSxcbiAgbGFiZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2xhYmVsJyksXG4gIGxlZ2VuZDogY3JlYXRlRE9NRmFjdG9yeSgnbGVnZW5kJyksXG4gIGxpOiBjcmVhdGVET01GYWN0b3J5KCdsaScpLFxuICBsaW5rOiBjcmVhdGVET01GYWN0b3J5KCdsaW5rJyksXG4gIG1haW46IGNyZWF0ZURPTUZhY3RvcnkoJ21haW4nKSxcbiAgbWFwOiBjcmVhdGVET01GYWN0b3J5KCdtYXAnKSxcbiAgbWFyazogY3JlYXRlRE9NRmFjdG9yeSgnbWFyaycpLFxuICBtZW51OiBjcmVhdGVET01GYWN0b3J5KCdtZW51JyksXG4gIG1lbnVpdGVtOiBjcmVhdGVET01GYWN0b3J5KCdtZW51aXRlbScpLFxuICBtZXRhOiBjcmVhdGVET01GYWN0b3J5KCdtZXRhJyksXG4gIG1ldGVyOiBjcmVhdGVET01GYWN0b3J5KCdtZXRlcicpLFxuICBuYXY6IGNyZWF0ZURPTUZhY3RvcnkoJ25hdicpLFxuICBub3NjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnbm9zY3JpcHQnKSxcbiAgb2JqZWN0OiBjcmVhdGVET01GYWN0b3J5KCdvYmplY3QnKSxcbiAgb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ29sJyksXG4gIG9wdGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdvcHRncm91cCcpLFxuICBvcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGlvbicpLFxuICBvdXRwdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ291dHB1dCcpLFxuICBwOiBjcmVhdGVET01GYWN0b3J5KCdwJyksXG4gIHBhcmFtOiBjcmVhdGVET01GYWN0b3J5KCdwYXJhbScpLFxuICBwaWN0dXJlOiBjcmVhdGVET01GYWN0b3J5KCdwaWN0dXJlJyksXG4gIHByZTogY3JlYXRlRE9NRmFjdG9yeSgncHJlJyksXG4gIHByb2dyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdwcm9ncmVzcycpLFxuICBxOiBjcmVhdGVET01GYWN0b3J5KCdxJyksXG4gIHJwOiBjcmVhdGVET01GYWN0b3J5KCdycCcpLFxuICBydDogY3JlYXRlRE9NRmFjdG9yeSgncnQnKSxcbiAgcnVieTogY3JlYXRlRE9NRmFjdG9yeSgncnVieScpLFxuICBzOiBjcmVhdGVET01GYWN0b3J5KCdzJyksXG4gIHNhbXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3NhbXAnKSxcbiAgc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdzY3JpcHQnKSxcbiAgc2VjdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnc2VjdGlvbicpLFxuICBzZWxlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3NlbGVjdCcpLFxuICBzbWFsbDogY3JlYXRlRE9NRmFjdG9yeSgnc21hbGwnKSxcbiAgc291cmNlOiBjcmVhdGVET01GYWN0b3J5KCdzb3VyY2UnKSxcbiAgc3BhbjogY3JlYXRlRE9NRmFjdG9yeSgnc3BhbicpLFxuICBzdHJvbmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0cm9uZycpLFxuICBzdHlsZTogY3JlYXRlRE9NRmFjdG9yeSgnc3R5bGUnKSxcbiAgc3ViOiBjcmVhdGVET01GYWN0b3J5KCdzdWInKSxcbiAgc3VtbWFyeTogY3JlYXRlRE9NRmFjdG9yeSgnc3VtbWFyeScpLFxuICBzdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1cCcpLFxuICB0YWJsZTogY3JlYXRlRE9NRmFjdG9yeSgndGFibGUnKSxcbiAgdGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rib2R5JyksXG4gIHRkOiBjcmVhdGVET01GYWN0b3J5KCd0ZCcpLFxuICB0ZXh0YXJlYTogY3JlYXRlRE9NRmFjdG9yeSgndGV4dGFyZWEnKSxcbiAgdGZvb3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rmb290JyksXG4gIHRoOiBjcmVhdGVET01GYWN0b3J5KCd0aCcpLFxuICB0aGVhZDogY3JlYXRlRE9NRmFjdG9yeSgndGhlYWQnKSxcbiAgdGltZTogY3JlYXRlRE9NRmFjdG9yeSgndGltZScpLFxuICB0aXRsZTogY3JlYXRlRE9NRmFjdG9yeSgndGl0bGUnKSxcbiAgdHI6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyJyksXG4gIHRyYWNrOiBjcmVhdGVET01GYWN0b3J5KCd0cmFjaycpLFxuICB1OiBjcmVhdGVET01GYWN0b3J5KCd1JyksXG4gIHVsOiBjcmVhdGVET01GYWN0b3J5KCd1bCcpLFxuICAndmFyJzogY3JlYXRlRE9NRmFjdG9yeSgndmFyJyksXG4gIHZpZGVvOiBjcmVhdGVET01GYWN0b3J5KCd2aWRlbycpLFxuICB3YnI6IGNyZWF0ZURPTUZhY3RvcnkoJ3dicicpLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpcmNsZScpLFxuICBjbGlwUGF0aDogY3JlYXRlRE9NRmFjdG9yeSgnY2xpcFBhdGgnKSxcbiAgZGVmczogY3JlYXRlRE9NRmFjdG9yeSgnZGVmcycpLFxuICBlbGxpcHNlOiBjcmVhdGVET01GYWN0b3J5KCdlbGxpcHNlJyksXG4gIGc6IGNyZWF0ZURPTUZhY3RvcnkoJ2cnKSxcbiAgaW1hZ2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltYWdlJyksXG4gIGxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmUnKSxcbiAgbGluZWFyR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmVhckdyYWRpZW50JyksXG4gIG1hc2s6IGNyZWF0ZURPTUZhY3RvcnkoJ21hc2snKSxcbiAgcGF0aDogY3JlYXRlRE9NRmFjdG9yeSgncGF0aCcpLFxuICBwYXR0ZXJuOiBjcmVhdGVET01GYWN0b3J5KCdwYXR0ZXJuJyksXG4gIHBvbHlnb246IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlnb24nKSxcbiAgcG9seWxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlsaW5lJyksXG4gIHJhZGlhbEdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdyYWRpYWxHcmFkaWVudCcpLFxuICByZWN0OiBjcmVhdGVET01GYWN0b3J5KCdyZWN0JyksXG4gIHN0b3A6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0b3AnKSxcbiAgc3ZnOiBjcmVhdGVET01GYWN0b3J5KCdzdmcnKSxcbiAgdGV4dDogY3JlYXRlRE9NRmFjdG9yeSgndGV4dCcpLFxuICB0c3BhbjogY3JlYXRlRE9NRmFjdG9yeSgndHNwYW4nKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllcztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qc1xuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50JyksXG4gICAgaXNWYWxpZEVsZW1lbnQgPSBfcmVxdWlyZS5pc1ZhbGlkRWxlbWVudDtcblxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2ZhY3RvcnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGlzVmFsaWRFbGVtZW50KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGlkID0gMjI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMTUuNS40JztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P29iamVjdH0gZWxlbWVudCBUaGUgUmVhY3QgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHs/bnVtYmVyfSBkZWJ1Z0lEIFRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQsIGRlYnVnSUQpIHtcbiAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc4NCcsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogdm9pZCAwO1xuICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKSA6IHZvaWQgMDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBjb21wb25lbnRTdGFja0luZm8gPSAnJztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanNcbi8vIG1vZHVsZSBpZCA9IDIzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuZXh0RGVidWdJRCA9IDE7XG5cbmZ1bmN0aW9uIGdldE5leHREZWJ1Z0lEKCkge1xuICByZXR1cm4gbmV4dERlYnVnSUQrKztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROZXh0RGVidWdJRDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlYWN0L2xpYi9nZXROZXh0RGVidWdJRC5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MycpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QvbGliL29ubHlDaGlsZC5qc1xuLy8gbW9kdWxlIGlkID0gMjM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRoaXMgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudCBzaW5jZSB0aGlzIGZpbGUgaXMgc2hhcmVkIGJldHdlZW5cbiAqIGlzb21vcnBoaWMgYW5kIHJlbmRlcmVycy4gV2UgY291bGQgZXh0cmFjdCB0aGlzIHRvIGFcbiAqXG4gKi9cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cbiAgdHlwZSA9PT0gJ29iamVjdCcgJiYgY2hpbGRyZW4uJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanNcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgbWlkZGxld2FyZSBmcm9tICcuL2ludGVybmFsL21pZGRsZXdhcmUnO1xuZXhwb3J0IGRlZmF1bHQgbWlkZGxld2FyZTtcblxuZXhwb3J0IHsgcnVuU2FnYSB9IGZyb20gJy4vaW50ZXJuYWwvcnVuU2FnYSc7XG5leHBvcnQgeyBFTkQsIGV2ZW50Q2hhbm5lbCwgY2hhbm5lbCB9IGZyb20gJy4vaW50ZXJuYWwvY2hhbm5lbCc7XG5leHBvcnQgeyBidWZmZXJzIH0gZnJvbSAnLi9pbnRlcm5hbC9idWZmZXJzJztcbmV4cG9ydCB7IHRha2VFdmVyeSwgdGFrZUxhdGVzdCwgdGhyb3R0bGUgfSBmcm9tICcuL2ludGVybmFsL3NhZ2FIZWxwZXJzJztcbmV4cG9ydCB7IGRlbGF5LCBDQU5DRUwgfSBmcm9tICcuL2ludGVybmFsL3V0aWxzJztcblxuaW1wb3J0ICogYXMgZWZmZWN0cyBmcm9tICcuL2VmZmVjdHMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCB7IGVmZmVjdHMsIHV0aWxzIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWR1eC1zYWdhL2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgeyBpcywgY2hlY2ssIG9iamVjdCwgY3JlYXRlU2V0Q29udGV4dFdhcm5pbmcgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGVtaXR0ZXIgfSBmcm9tICcuL2NoYW5uZWwnO1xuaW1wb3J0IHsgaWRlbnQgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IHJ1blNhZ2EgfSBmcm9tICcuL3J1blNhZ2EnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYWdhTWlkZGxld2FyZUZhY3RvcnkoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgX3JlZiRjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgY29udGV4dCA9IF9yZWYkY29udGV4dCA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmJGNvbnRleHQsXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY29udGV4dCddKTtcblxuICB2YXIgc2FnYU1vbml0b3IgPSBvcHRpb25zLnNhZ2FNb25pdG9yLFxuICAgICAgbG9nZ2VyID0gb3B0aW9ucy5sb2dnZXIsXG4gICAgICBvbkVycm9yID0gb3B0aW9ucy5vbkVycm9yO1xuXG5cbiAgaWYgKGlzLmZ1bmMob3B0aW9ucykpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYWdhIG1pZGRsZXdhcmUgbm8gbG9uZ2VyIGFjY2VwdCBHZW5lcmF0b3IgZnVuY3Rpb25zLiBVc2Ugc2FnYU1pZGRsZXdhcmUucnVuIGluc3RlYWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgcGFzc2VkIGEgZnVuY3Rpb24gdG8gdGhlIFNhZ2EgbWlkZGxld2FyZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIHN0YXJ0IGEgICAgICAgIFNhZ2EgYnkgZGlyZWN0bHkgcGFzc2luZyBpdCB0byB0aGUgbWlkZGxld2FyZS4gVGhpcyBpcyBubyBsb25nZXIgcG9zc2libGUgc3RhcnRpbmcgZnJvbSAwLjEwLjAuICAgICAgICBUbyBydW4gYSBTYWdhLCB5b3UgbXVzdCBkbyBpdCBkeW5hbWljYWxseSBBRlRFUiBtb3VudGluZyB0aGUgbWlkZGxld2FyZSBpbnRvIHRoZSBzdG9yZS5cXG4gICAgICAgIEV4YW1wbGU6XFxuICAgICAgICAgIGltcG9ydCBjcmVhdGVTYWdhTWlkZGxld2FyZSBmcm9tIFxcJ3JlZHV4LXNhZ2FcXCdcXG4gICAgICAgICAgLi4uIG90aGVyIGltcG9ydHNcXG5cXG4gICAgICAgICAgY29uc3Qgc2FnYU1pZGRsZXdhcmUgPSBjcmVhdGVTYWdhTWlkZGxld2FyZSgpXFxuICAgICAgICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgYXBwbHlNaWRkbGV3YXJlKHNhZ2FNaWRkbGV3YXJlKSlcXG4gICAgICAgICAgc2FnYU1pZGRsZXdhcmUucnVuKHNhZ2EsIC4uLmFyZ3MpXFxuICAgICAgJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvZ2dlciAmJiAhaXMuZnVuYyhsb2dnZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgb3B0aW9ucy5sb2dnZXJgIHBhc3NlZCB0byB0aGUgU2FnYSBtaWRkbGV3YXJlIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIG9wdGlvbnMub25lcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYG9wdGlvbnMub25lcnJvcmAgd2FzIHJlbW92ZWQuIFVzZSBgb3B0aW9ucy5vbkVycm9yYCBpbnN0ZWFkLicpO1xuICB9XG5cbiAgaWYgKG9uRXJyb3IgJiYgIWlzLmZ1bmMob25FcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BvcHRpb25zLm9uRXJyb3JgIHBhc3NlZCB0byB0aGUgU2FnYSBtaWRkbGV3YXJlIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZW1pdHRlciAmJiAhaXMuZnVuYyhvcHRpb25zLmVtaXR0ZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgb3B0aW9ucy5lbWl0dGVyYCBwYXNzZWQgdG8gdGhlIFNhZ2EgbWlkZGxld2FyZSBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZ2FNaWRkbGV3YXJlKF9yZWYyKSB7XG4gICAgdmFyIGdldFN0YXRlID0gX3JlZjIuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoID0gX3JlZjIuZGlzcGF0Y2g7XG5cbiAgICB2YXIgc2FnYUVtaXR0ZXIgPSBlbWl0dGVyKCk7XG4gICAgc2FnYUVtaXR0ZXIuZW1pdCA9IChvcHRpb25zLmVtaXR0ZXIgfHwgaWRlbnQpKHNhZ2FFbWl0dGVyLmVtaXQpO1xuXG4gICAgc2FnYU1pZGRsZXdhcmUucnVuID0gcnVuU2FnYS5iaW5kKG51bGwsIHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBzdWJzY3JpYmU6IHNhZ2FFbWl0dGVyLnN1YnNjcmliZSxcbiAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICAgIHNhZ2FNb25pdG9yOiBzYWdhTW9uaXRvcixcbiAgICAgIGxvZ2dlcjogbG9nZ2VyLFxuICAgICAgb25FcnJvcjogb25FcnJvclxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoc2FnYU1vbml0b3IgJiYgc2FnYU1vbml0b3IuYWN0aW9uRGlzcGF0Y2hlZCkge1xuICAgICAgICAgIHNhZ2FNb25pdG9yLmFjdGlvbkRpc3BhdGNoZWQoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dChhY3Rpb24pOyAvLyBoaXQgcmVkdWNlcnNcbiAgICAgICAgc2FnYUVtaXR0ZXIuZW1pdChhY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgc2FnYU1pZGRsZXdhcmUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmVmb3JlIHJ1bm5pbmcgYSBTYWdhLCB5b3UgbXVzdCBtb3VudCB0aGUgU2FnYSBtaWRkbGV3YXJlIG9uIHRoZSBTdG9yZSB1c2luZyBhcHBseU1pZGRsZXdhcmUnKTtcbiAgfTtcblxuICBzYWdhTWlkZGxld2FyZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgY2hlY2socHJvcHMsIGlzLm9iamVjdCwgY3JlYXRlU2V0Q29udGV4dFdhcm5pbmcoJ3NhZ2FNaWRkbGV3YXJlJywgcHJvcHMpKTtcbiAgICBvYmplY3QuYXNzaWduKGNvbnRleHQsIHByb3BzKTtcbiAgfTtcblxuICByZXR1cm4gc2FnYU1pZGRsZXdhcmU7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWR1eC1zYWdhL2VzL2ludGVybmFsL21pZGRsZXdhcmUuanNcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgeyBUQVNLLCBTQUdBX0FDVElPTiwgbm9vcCwgaXMsIGRlZmVycmVkLCBhcnJheU9mRGVmZmVyZWQsIGNyZWF0ZU1vY2tUYXNrLCBjbG9uZWFibGVHZW5lcmF0b3IgfSBmcm9tICcuL2ludGVybmFsL3V0aWxzJztcbmV4cG9ydCB7IGFzRWZmZWN0IH0gZnJvbSAnLi9pbnRlcm5hbC9pbyc7XG5leHBvcnQgeyBDSEFOTkVMX0VORCB9IGZyb20gJy4vaW50ZXJuYWwvcHJvYyc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9yZWR1eC1zYWdhL2VzL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gX3JlZi5kaXNwYXRjaCxcbiAgICAgICAgZ2V0U3RhdGUgPSBfcmVmLmdldFN0YXRlO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmFBcmd1bWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTtcbnRodW5rLndpdGhFeHRyYUFyZ3VtZW50ID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB0aHVuaztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlZHV4LXRodW5rL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpO1xuICAgICAgdmFyIF9kaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoKGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gY29tcG9zZS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlZHV4L2VzL2FwcGx5TWlkZGxld2FyZS5qc1xuLy8gbW9kdWxlIGlkID0gMjQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVkdXgvZXMvYmluZEFjdGlvbkNyZWF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQWN0aW9uVHlwZXMgfSBmcm9tICcuL2NyZWF0ZVN0b3JlJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vdXRpbHMvd2FybmluZyc7XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICB2YXIgYWN0aW9uTmFtZSA9IGFjdGlvblR5cGUgJiYgJ1wiJyArIGFjdGlvblR5cGUudG9TdHJpbmcoKSArICdcIicgfHwgJ2FuIGFjdGlvbic7XG5cbiAgcmV0dXJuICdHaXZlbiBhY3Rpb24gJyArIGFjdGlvbk5hbWUgKyAnLCByZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQuICcgKyAnVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLic7XG59XG5cbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuSU5JVCA/ICdwcmVsb2FkZWRTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmUnIDogJ3ByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyJztcblxuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdTdG9yZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcmVkdWNlci4gTWFrZSBzdXJlIHRoZSBhcmd1bWVudCBwYXNzZWQgJyArICd0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuJztcbiAgfVxuXG4gIGlmICghaXNQbGFpbk9iamVjdChpbnB1dFN0YXRlKSkge1xuICAgIHJldHVybiAnVGhlICcgKyBhcmd1bWVudE5hbWUgKyAnIGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCInICsge30udG9TdHJpbmcuY2FsbChpbnB1dFN0YXRlKS5tYXRjaCgvXFxzKFthLXp8QS1aXSspLylbMV0gKyAnXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgJyArICgna2V5czogXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCInKTtcbiAgfVxuXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XTtcbiAgfSk7XG5cbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcblxuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnVW5leHBlY3RlZCAnICsgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5JykgKyAnICcgKyAoJ1wiJyArIHVuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiIGZvdW5kIGluICcgKyBhcmd1bWVudE5hbWUgKyAnLiAnKSArICdFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6ICcgKyAoJ1wiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTYW5pdHkocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAnICsgJ0lmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCAnICsgJ2V4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgJyArICdub3QgYmUgdW5kZWZpbmVkLicpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJyArICgnRG9uXFwndCB0cnkgdG8gaGFuZGxlICcgKyBBY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZygnTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB1bmV4cGVjdGVkS2V5Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIHZhciBzYW5pdHlFcnJvcjtcbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2FuaXR5KGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2FuaXR5RXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoc2FuaXR5RXJyb3IpIHtcbiAgICAgIHRocm93IHNhbml0eUVycm9yO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tpXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtrZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vcmVkdXgvZXMvY29tYmluZVJlZHVjZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwucHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWwucHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IGdsb2JhbC5wcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XG5cdFx0dmFyIG1lbW87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbWVtbztcblx0XHR9O1xuXHR9LFxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcblx0XHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHRcdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0XHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyIFxuXHRcdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHRcdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRcdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcblx0fSksXG5cdGdldEVsZW1lbnQgPSAoZnVuY3Rpb24oZm4pIHtcblx0XHR2YXIgbWVtbyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdFx0fTtcblx0fSkoZnVuY3Rpb24gKHN0eWxlVGFyZ2V0KSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3R5bGVUYXJnZXQpXG5cdH0pLFxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW10sXG5cdGZpeFVybHMgPSByZXF1aXJlKFwiLi9maXhVcmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRJbnRvID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZVxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcblx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cdGlmICghc3R5bGVUYXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHN0eWxlVGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIHN0eWxlVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0c3R5bGVUYXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZVRhcmdldC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHN0eWxlVGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YXR0YWNoVGFnQXR0cnMoc3R5bGVFbGVtZW50LCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhdHRhY2hUYWdBdHRycyhsaW5rRWxlbWVudCwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XG5cdHJldHVybiBsaW5rRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoVGFnQXR0cnMoZWxlbWVudCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmUsIHRyYW5zZm9ybVJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHRyYW5zZm9ybVJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXHQgICAgXG5cdCAgICBpZiAodHJhbnNmb3JtUmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gdHJhbnNmb3JtUmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy4gXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKiBJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscyl7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcblxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3N0eWxlLWxvYWRlci9maXhVcmxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wb255ZmlsbCA9IHJlcXVpcmUoJy4vcG9ueWZpbGwnKTtcblxudmFyIF9wb255ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb255ZmlsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHJvb3Q7IC8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSAoMCwgX3BvbnlmaWxsMlsnZGVmYXVsdCddKShyb290KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc3VsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN5bWJvbE9ic2VydmFibGVQb255ZmlsbDtcbmZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBfU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBfU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKF9TeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRfU3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDI0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFXY0FBQUlSQ0FZQUFBQ1dLM3pNQUFBQUFYTlNSMElBcnM0YzZRQUFBVmxwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJbGhOVUNCRGIzSmxJRFV1TkM0d0lqNEtJQ0FnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0S0lDQWdJQ0FnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNmRHbG1aajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5MGFXWm1MekV1TUM4aVBnb2dJQ0FnSUNBZ0lDQThkR2xtWmpwUGNtbGxiblJoZEdsdmJqNHhQQzkwYVdabU9rOXlhV1Z1ZEdGMGFXOXVQZ29nSUNBZ0lDQThMM0prWmpwRVpYTmpjbWx3ZEdsdmJqNEtJQ0FnUEM5eVpHWTZVa1JHUGdvOEwzZzZlRzF3YldWMFlUNEtUTUluV1FBQVFBQkpSRUZVZUFIczNYbU1adGw1SHZaYis3NHZ2VlIxZHkyOURtZW15YUU0UTNLa0VVbFppbUxKZ215RWNaU0FFSWpZZjhRd0VnT1JZUmtSNGhneGtCZ0prUHdUTzBDY09EYWNHTEdBR1BBaXhSWXNpb3hNU2FTNERJZXo5TDVVVlhmWDJyWHZTNTdmK2Fib2lTQUpsTVZsWmxoMzV1dnZxKys3OTl4eno3M25lWi96dk85NVQxMTFzcDIwd0IrekJmN3NwMy91clU5OTR1VXJYL25LbDZzN3QyOVZMNzcwUW5YbHlwV3F1N09wR2h3Y3JKb2FHNnRIajZhcnpmV05hbmg0cUdwcGFhbldWbGFxbGZXVnFxR2hvUm9hR3FwNmVucXE5ZlgxYW5sNXVmemUyOXRiN1I4Y1ZXMXRiVlZ6YzB2WnI2dXJLL3YxVmZ2Nys5WHE2bXExdHI1ZHRiYTJWdDNaMS92VzFsYTFzN2RianVuczdLeGFtcHFyZzRPRDZ2RHdzR3BNSFpxYW1zcG41L0hhV0ZzcDMvbXRycTZ1N0x1M3QxZnQ3dTZXVjN0clcvbGVIYjFzenEzTW82T2pxcW83ck5yYjIwdmRuZDl4NnIrMnRsWSt0elkwVlUydExhVStycm1sclRYWDBsemx5RkxHMnNwNitidXBJWFZyYnFnZVQ4OVVyNy8rV3FsYmZlb3pkS3F2MGc2blQ1K3VYTS9Pems2MXZiMWQ2cUxPZCsvZXJaNDhlVkwrMWs1VFUxUFZ3NGNQSyswME1qSlNkWFVPbHJJNjJsdkxQcXVySzFWZmQwOHBiMjkvcDNwd2Y2cGNoK3ZaMnYwM1pYZjM5cFR6cmk0dFZ0UFQwOVhhNWxwcDM5YWM0L0JvdjlwT0c3dWUvZTE4VG4yODBzU2xMWnViVzc5VlpuWFFYQzBzTEpRMjJkbmUrUzlYMXRZZTNwK2UvdHpyZHg4OUxJMTU4czhmMmdKMWYraXZKeitldE1BZjBnSlhyano3L01kZWV1blZqZ0RRM1B5ajZzcmxpOVhrNUZoQWM2VnFhV3lxVHAycWdZUWluang2VkRweGIzZG5BYVROemMxcWRtRzJBTnZ3OEhEVjBkRlIrVzRsb0EwSXU3dTdBK3J0QmVTQWtzNFBrSnFiV2dzSTFOZlhWNDBCUk1jQnJvWUE3L0YybEtjYTRMUUcxSUVtNEZXR1l3cW9CR0EzTmpZS09BTmo0TzE3WmRsSFBRckE3bXlWM3h3UFZJRzd1dmxzLy9YVnRRSkV5Z2JhanUvcjZ5dlZjUHhXakpFNjIzYjI5OHErN1oyMWZlemJVRmRmcnZmcDA2ZFZWM3RiMlhkbGRiazZPamlzMU92dXJkZktkd0RhL3M1amN3N3RNNy95dElDditqRVdESVBQOWxmWG1ZY0x4V0FCN3RibXh0S1diUzNOQmJ5MXorcmFjczFJcFMzcWMxMUFuVEZoNU5SL1oyc2p4cWV0WFBQaTRtS0FkcTYwYTN0WGU5bjNkUDl3T2E5enV6OEY1RGUzSzlmRGVPNXMxMVg3aHdlbFRSdGpxQTZPWE5mQjUrb2JtaHJiMmxyNzMzcmo3djgxOCtqUmI5NVpYUG50R0lHdGNuRW4vM3lyQldwMDRGdC9ubnc0YVlIZnZ3VSs5YWxQL2RjWExseDQrZjc5KzErd3h5Yys4WWxmYW0ybzc3bDhhZkpuNmh1T3F0MEEyVFBQWEtrdVRZNVhWVHBrWnpyd21UTkRoUlczQnlDN3VqdXE5blQ4dWpwc09BeXlxYkZxNjJndlFBSVFBUUxtQ1ZRQWFtR1k2ZkE2ZmxNWXNHUHE2eHNDQWdjQjdlWUNUb09EUTFWalFHVVh3QVpzMm5JY2RyZWZ2OWZYMXF2REFHWnJRTFFsWUpxQ3lqNE5PUmNtNzNWd1VHUEJnTlVHU0wwQXNIcFVBUlBuQnpvQTNNdmZ4NytmSFRtVDg5Y0g2TmVycGJETWxaWGxHS0N0N0hPWWZlcXIvakRRMWx4elkyTkRBUGVnMmd0QWIyOXRWa3RQRjhONEgxZDd1ZDcrL3I0QWMzdUFjcVhhM3RtdWhnY0hxc0ZUdzZsZlE5cXJCcWkxTWdIZ1FTbWZBWnVmbjZzNnVqb0xlTHB1WmJtbTBURG1nWUgrOHZmYThrcXU0YURhV0YrdE5qZFdxMVFwcjZOYzFuN3FYWmRSekdEVm5uYnRDQUMzdGpaWGdmZ1lnSzBjdTFQMmJjdjUyOE82RHc2MDcwNE1hVmQxL3R6WjZ0VFFZTldjK3RYdGJWY0h1N2x2dWFiZHJmVnFiM3N6ZzRtOXFxMmxvZXBOM1p5anM2MDU5N291WmUrVmU5L2QxVG8rUE5oM1lhQy9lN2kvcisrVHA4OE0vdnpZMmVGTFY4WkhYempWMjlHUnEzZ1lZSy9ka0hKWGZuRC9PUUhuSDl4Ny8yMWYrZGpZV0d0ZXZ4Um05ZUc4Zi96cTFhdWZEWE43b2JXNS9qOVpXbHFveGk2Y3EvNmRuL3hVbU9KcTlZM1h2aHBtMTFXZEcwMG5IaDRvSGY4d0FJRVpBaXJnMXQ0V3dBeURhMnhwcWhxYkdxcXRkR3BEN3IwTWw1dkM4Qm9hNndPNE85WDZ5bHFBdGFucTcrdXArbnI3QXI3TlladDFCVGlBemw1a0R3eHZJd3kxUHNpRElaSUR0akxNQnJnQUc1TThCbE5HQU1ENkRnZ0RmQ0NzVGd3RHh1eWRjY0JPOTFNZit6b0drOFZjajRmeDlzMlgxZmJtVm1Ib1BXR3l6cmN3TjErdGhUWFdCNDdVaFdGb0MvZ3lOZ2Q3KzlWbWpOQjZxZk42akUzZ01NZDBoazEzWjBUaDJ0WURvbHRycXdYMGh3T0MwVTVLL2RXcElmS0hPcmhtc3N6QmZveEdXTFp6eGVhbHJNTVl5ZDFxNWVseXRiU3dHRU93a1gzeTkvSlNXT3htQWVLRzdMaVd0dDdjV010UnVSY3BkekJnM3B4N01UODNHeGxqS3Nmc1ZRTXhHcnNCWGtiQTl3QjgvTno1YWlqZkIzT3JyUmlrelREM0RSSlJESXUvZDhnYk1YaXRUUzJSdERwUy9uNkFPU09jeUQ5MWRRZFZjNjQzd2xBa3JhZlY3T09wcW9xaDZPM3B5TE55NWdOakY4Ny95TGx6NTM1dTlIVC9jMFBkN1IxZGpmV3JqNWRXbjM3YkQrbjdjTWNUY0g0ZjN0VHY5Q1ZsdUx6LzFsdHYvZTl2dlBIRy94elFhb3lPK0V2Mzd0MGJ1WFoxdlByZzlXZXJxMWN2VnNzckM5Vzl1N2ZDWEp1cXMyZE9CU3lQQ29PdEFkcG1HY0szdGJjVXhnd3NnNVBWWm9BRzhBRk5ZRWtxQUxBQTBYRzBVcnJ1VmtCbWNYR3VXb3grYVNpT1NXNEhiR2FmTEFWSTlnUG1tSEJUR1pvckR6dHVKMUVBckVPTU9lZUloSUJaQXN5ajdBUFlHbUlzbWdQT3ZuY2M5ZzZFQVNrWm9hbVJuRUhLcUM5c0dDUE80ZG4zSU9DL1YwMVBQU3hzdHpVZzM5ZlhXMERXNzd0aG5wdWJnREVHSXVYNjdpREhPTDRwNVhWM2R4WEd2QlU1NFkwM3Zsbk56RXdYY0RXNnlJNWg0UXVGMWJlM2Q2Uk5Nb3JJcXk3MTM5M2RDMHVQQVFuSUEyclhGUk5Rak5OcURGbHI5dXZ2R3lqWHVybXhsVHFFemNiWTdJWGhscnFuTHRzN213VnNIejU4VU4yOTg2QmFXbHdLb3orSUVXbXBPbU5nbWdPc3l3SDNPM2Z1NWhwM3F1NUlIV1NTeHB4Zis4OUdudHBKT3htVk1CNnU1VlNZL3Brelo5Tm03VG5uVmlTdTJXcDI3a2xZOVVicXVGTU1jR2RIVzBaVEhXSFZhZTl5djJPSTFwZlRQdEg0Y3kvM1kwUzZ3N1lueHNhdVhMMTIrV2VlZmZhWi83UW5yb2IrOXFicXdlelQrOS9wWi9xOVVONEpPTDhYN3RLN3BJNC85Vk0vOVk4aWEvek42SU8vOU1vcnIxVC8zcC81cVhUOG5XcHdxTDlheWJCK1lYRzJldWJhbFdwazlIUnFmQkNnNkN2RGJpQzVmeEJISGFBSjhCMW1XTjBXSU40SmE4UmNBZkl4S0dPODlHRDY2ZlQwL1pRNVg2MW1HQThNNjhLOHNIRE9yRGlZd25DN0F3cG5xb0U0SFlIZ1JnQVI4d1grMkdwbndBM3dIOHNTemwwZnBsZ2ZwbHdZY0VDZklXakpkMzQ3WnREcTROVWNWbS96dlRLVWhjR3FLME55S281TTlWOWFXcW9lUDM1YzlxT2YwMjRkWHg5WlpxMUlIa3Roc1dIWU9XNmd2NzhZRHNZSSs3Y3Y3Zm5tcmJkaWdCYUxyS0V1REVWNGY0NXBULzNhWXFUcVkzd3lxc2o1V2xJT0oyaDl4UFhscDlybW9EcDdkaVRHcExsNjdiVnZWdmZ2UFlpaDZBb2o3azQ1bThYZ2RIZTJWNmRPRHdmOExzUkpPNUQyU2p2dTFtU2ExWld3OVJpODRWelBzODgvVjQyTmpaV1JRMmZBY2k2c2VlYmhWTGwzdlVZSCs0eGZYVVl4YlFIWEhKZDZhcC9XL0sxdFNGQjhBQnpCRGJrQ3NsSnpuSjFHRldRZjV6cktkWGVtUHYxRGZXVmtGS0dsU2xPVjBROWpxczRiR1IxODRoTS8vS012dmZqaXo0K2M2bnRoYWYzSlAxOWMzTnd0TitRSDVKOFRjUDRCdWRGL2xNc2NIeDgvRlhEY2VPY3hMMzd3eFU5dmIyN1B2SFh6OWQ5NTdybHIxYy8rNlorcURySkxYenJ3dlZ0dlZHM05SOVcxeTJNQnhFUm9oRVhXWTVuZ0pSMVI1elRrWGN0d0hXajA5UFNHQVdkWUgzWWR1QzNnMUJxV2pDWHVCRnpYQTg0aGhkWGh6bjVWbHc5RHZkMVZ3LzUyMVJ2bWZTNDY5a0VZSk1kV1hWMURodWhQcXllSmNxQjVuejExdWhvNU81cHoxbFVMcy9NQnZ0NkE4QzdwT0dBazBpSU1Pci81dTZHZXZod25WYVNSdlYxTXRDbjc5NlIrM1dIOEI5WFRwZVdxc2FPcmFtd09FTGNsVWlMSHJxNEc2RkpRWTRPSWk0Z0pkWTNWNG5LY2NtR0wzZDI5VlYrRy9BYzVkamR5Q0lmZFFzQVdvSE9PTVRoWStuNVk3MWJZTDBEdWlBRWhlL2lObkFQVUhzOCtydVlYRjZxdW51NnFJMjFGb2pHS2FHdnZETnNlS09lY25ubGMzYng1dTBURHRFWWl3anJudzFRWmhOTUJSVVpwTmNadGxUd1N3T2FjSlVVYzdHNW50Qkd0TzIxMWNleDhOWForTWl3NEduaVkrdFBVOWY2RGU5V2pSR2MweGJpZGpkRnJ6YkhEZzZkaVVBWkxXMy90NjY5VnQrL2VqMkVZaUhNdkk1SFV2YTI5SzJCYlZZdExUeU9mWU1JSGhVRVA5SFZYUjduMi9ZRHRha0I4UFVhcU1YSlZUMi9hTkZMSHhzWnk5ZlRSMCtvb2hxVW4xOVlWZzdPZmExMWRYcXl5Vys1bERNaEJSakw3VytTeEt4OSsvb1cvK3NMMUt6ODkwTmZiY2VyV3ZkKzluMXY2enVmei9majVCSnpmajNmMWozbE5HY1lla0RLT2kwbFkzSlV3cHVWSGoyWit4VEQxNHg5L3FmclJWejVlYllVRmtSM3UzNzhWVmpaUVRVeU1wNk1LTDJzTEtCcmFieFpHaWwxdUJwQ3dMSURvYnl5ck93Nm1nNEFlRmt1YTZPam9USGwxWWIrMVUvY0VMUGNES0FCRTJCczJ2YmtGcUtKVG5yOFEwT3dxNExlVGZaWXlGSC95WkRhUklodWxiSm94cHh0dHV6K2FLcWNkOWszZjlkNGNTUU1iOXNMOE1GblJIK29HYlh3blpJdzBnU1ZqdUtRUmtncUhJOURGQnBVdm5LN2hiV2NsWFRtWFVNcnI3K3N2VEI0VFZqNTJ6WmxITW5IOTZ1TDhmc01kNStmbkUrbXdWUDUyenAzb3gwWUVOZlpmWTdta0R2dHJ5d2JVUFBXMGo3QkR3SiszVW1kdHVoeHQxL2s0VFFjSCt3dExaU2ptWnA5RWtwbEszVHVyR09JeXdubWF0dDJJd2R5S1U3S0VHVVpMVnE1MkZNcW5EZ3dPUnF3TUVSbUxpYmFoZHpPcVRYSHdZdTd1LzJiS1lkd1lLOGUwdGJhL3pZMXJVUy9LWWlBWnN0NDRUYlUxZzF3WEN3SzRHL043U3h5SlM5SEs2ZVpHQ2dOREExVlAzMERzNy9CUGRqOTM3VWN1bkR0OXZxV2hmdmJSYkt6SyszUTdBZWYzNlkzOXQ3MHNyTG16cytYQzNGdzBpbXdURXhNOUFaRDluWTJOTy9Oemo2dm5ucmxXZlRSeHpKaFJleWdPNXRyZTNoeDIxWk1PV2lXMk51QVJWc3JwdEk0aEJoZ0FEWCs5emc2MEFaTFk1dVlBV3dHV0FQUlJFRTJZWEdNS3FSMFRxU09nMWhScFlUK0FBV1RtWm1mREpIZXE5Z0JsQ0ZrNmZ0L2I0Si9JaXpBMk1iODNidDRzWUQ4eWNyWU1rN0ZIanJlTzFHc25XckFYeHlRZHVSYjlFZjA1OWZHcUMwalFwQUUwQUgwU1o5aHVXQ3N3RklmZG1lK0NoakVZZTJWL1lFMW5CYjZBOFJpNERkUEpKU05uejVaamFiWkFpckhDa29GUjdYVll6dU44UXVqODNwV1JDTEF2K3dhWVNCWVlkUTNFcW5LTzdzUXFpeVBmakdhN25mcGgrczZucnVzeFRzTFhzUFNkYU0zYWx4SFpLdnJ6VGdIUm5SaVlodzhlUkVaSjJGNVFVdGxkMFk0QnJPaU5sclFQM1Z5N2NRaHkxSEtlaWdJNWUvWk1NVWc3dVNjN2taRTRKeG1LVHFPQTNPZk50WVFveGhDNnBvYU1iUGdDM0VPZm13UGV6V2xMN1dia01ORGZXKzcxOHNwUzd2OVJOWHc2TWZHcHcyWWlQMkxmcWpPanAwcjU4M2tVYTJYV1o1OUlNK01YeGljbnozK3lxYTU1c3IyNWJxdXorWER4MnRPTm5mdnZNelo5QXM1NUNIN1F0N0ZFWXh3elplRnk3ZTJkazJOakk2ODBOYlhjU09mZTJkL2NYTjRLa3pKYy84a2ZmNlVhR3p1YllmU2pxanVNcWF1ck5VRGJFNGFUdU5nNGRqb0RWdGhVOENtaVJtMERSQnhhMkNJMmFHSUN4OXQrSkFzVFRMbzZleUtwTmdTUUFpWTVyaTA2YTlFdkErd2NVdDBCcDFNSis2Sy9Bdkc2dXFacWVpYU9xUjJndWgvdzZxcEd6NDBXRUx0Ny8xNGNYWGNMaU1XelZNQXh6c3RTRVNCSzF3VWNBS3Nob0pIaWlwWU4zQUUzSUFMY3hYRGtSODdGNDBpTnhtaSt3Qml3WUtZWUtYRHplUytBN2FLQkNsQnpqcTJBTGFEMW1VNU5qMWJXL2Z2MzM5YW9FMTBSR1Fld0FyMUVLeFFRd3JBWnFPNnU3ckRndmJEUXhlTDBhNDB4QTNCSHFTc2owdFlhQU43ZUs1bzMwQ2V6T0Y5YmE1eVpISHlkMGFaakZJRDI0MHdDV29wYzR0cjZBc2FuVDUwSzgxMHEzNG1NNlltTTBwV1JqTkZNUCtkbWpNUnE5T3psTU9TWlNCMnVoUnpqK2k1T1RCYkRJMEpGM1dlbXBxdTMzcnBSUFk1alUxdlFuWUg4Nm1vbSt1UVlvNlk4QXZsZXpMY1NvcVV6a042ekg0Tk9nMDZ6NXA3bUdjaVQwOUxDNEdia2tFa3ZlYUNLd2VpS1EvRWd2b3ZWMWNVWWdlWHEycFZuTHIzOEl4LzdzK2ZQWC9qTGQzZFd2M0ozYXZaR0N2L1dOam82MnZaZURzczdBZWR2M2NvZjNBOFp1ZzRjYTh5enM3TjNabVptdmpGMGV1RFV5TkRncXoyZEhiL1VIOWE0bnc1Y0YvM3ZwLy9kbjZpRytqcXErU2ZSSnNOMnpwMDdYVDJhZVJCd1hvOXpicmdNalV2OGJvYkRyUUZORzNhbGd3SU9zZ2FBZkJTdi85cmFabUd2dzhPbjR5VHJMR3h4SnpxejRYRjltQllHS3VKZ2EzMnRBQzlIMUhxaUVFUXR6S1dNNWJCcDBnRGdvODEyWk1nL2VURTZha0QyWC83YXZ5aXM5T3JWS3puZlFvbUlBRURBSEFzRHBLSVVETEV4UHNBTmFPaTJ4MkE4R0EyYnNhSDVjdnB4UXBJeG1uTU5aZDhBYlMweVl6TWdXcE00YWc2d09PMVNKdWVXc29BdHljSjNBd01EUlNJaGt3Z2ZCS3FZcDFBMkRIMlpoaDFEYUY5YWNtOUNDUDErOSs2ZEFGK2lKd0tlMkhTY3N0VndvaVJHeDhlclU1RWF5RDFMYVpPbHlBbWJrWUdBOStubzg5cGNUTG5JRjJHSjJwNWp6aWhnWW53eVpXOVdOMi9jaUN5MFZBQ1hCTFNlOXFZZmF5c09XZTEzNXN6cFlrQm1JNG40RG9zK2xUanp1ZG01d3RhSDhyZVJ5TDA3ZDNMc1N1U1BvUmlGVEx5aHZJUzlrMzIwbWVkZ0xhRE5tTFVGb05XeldWdmxqdXlsN1hzeUlnUFd5eG1SN2NlQWl1RVdTYklmSTdhU3RoRVdhQ1RWa2RGYVMwWmF3aDFIOHR5OTlORVhmeTZhOUgvVzBYcTBzcjVWdlE2VTM4dkFyTitjZ0xOVytBSGZqb0g1bmMzd3d5Ky85TXRMQy9PbnhCcnZoZTN1YmErSHliVlhyN3o4a1lCVEZSQjRVcDBPbTUxOU1oVTVZYnI4Tmp5Y3FJMTA2cVU0aDdDcXpvUjEyYkJEdlE4UVl0Q1lKRENjbm40YzhOMHFmM2RuV25aclM4TG8wb2t4SzJ3YlUyek0zM3ZSbExjeWhBYW1oUmtHeVBjaWhZZ2srSTNmK0Z4MTk5N2RPTXY2b3kwSCtETGtwM2tyNDJ1dmZpMXZSMkhWSTJGb0xRSEtETThEVWlJKzZNNnBUUGFqTjV0MFl2SkpLQnJRem40WVhFUHFTQjRvbW5CUUJzaHdlQUVVek40MU9VWmRVVU9malJvVTYxcUZ0bUdTcnJWbW1Cb0xPR096WkpxMzNucXpnRE5KUmJuMk9aY1JnUEsrK3RXdkptWjZ0c1E3ZDdRbFpqaW5NT1Y5TGZjak5xcXczNDR3eWYzbzg2U2UzbHozcWRObjAxYTdhWmVGSWltMVpoSUo0NkRlTFFGL2JOWjF1ejdoZ3h5RmpJOXlBUEtOV3pjeS9mdEI2cDZwNDVsbWYrYlUyVEtwQmN0K2NQOUJqUENqSWxNOGphSHltVk5WbEFqaklBcERoQVZqd25ld2JGSk9RUGd3QnVvZ0k2UTllbmp1bjZaeUR3WUdZbERpWU4yS3c1WUQwNmhvdFV6aTJTa1NTMStrb1BXd2RTTUlFMzBjQ053NzNtYmFpWElzNVcrRVFUZm1EOWZYMDlYWjl0eXp6LzcwODgrTy81V2gvcmF1VjErLysydTVvZS9aN1FTYzM3TzM3cnRiOFIvNm9lZisyd0J6NjJ5aUIzUzZ3WUhlNnZMa2hXcjA3RkFBS0dGbWliVG82K21zWHYzNlY5TFJ1cXVod2I0TXZkZlNBUk12SEhhRTdiUUZjQUV4SU9QSXdnQzN0aklMTHNON1RxYVZsWTJ3eDdVd3M2VTRCT1hoQ05NTFdJaXEwS21CbEZtRjdabDhna1hTclVVdFFMK0QvRzYySVZZSENJWFUwWFk1RnJGcEVzSFRzS3hidDI2V09Gek9Tb0FMVVFHeHp5SVpiTTVEbTYyQlpLaGVOb0M4R0FZSTJJQXIzUmZZN3FVZW5INnVTN1FGMUhROCtZUEVZZmh2cGg4Z0FlTEhzb1V5ano4cjIrL3FDYnc1T2d0Z0tqUFg3M3pLajRtcTdrY0NtWWtrSWNJRjY2WXBhMGNBdjVyUGdGSzloekw2R0FwSTd1NG1XaVJNWDMwWEY1NlU4ckg1MW9BWGx1bjZNV21mVGQ1eG5uTWpvNG5BNkFuelhpcWpFWFZUaGtnWDkrNzgrZk5wLy8yaTZXUDZBRjhkdDJKWWQzTS9NV1p4M3Z3SXlsK2FYNGgwdFZqQzd4Z3IrNW1ZNDN6MDd0YmszemcxZEtySUx4eUhuSUdOWWZWaXdHa1lqSno3S0Z5dlBhT2l1a1NHTUU1ZGlaNFpTaHVJMURuY3kvM0t2U2t5Yzk1TjVqSExzUy9NTzdNdTY4K2NHbng1Zkh6a3BhWnFiKzdCek1MZDdGaTJUK1RXM24rUGFOTW40Rnk3Wnordy84cVBzYmdZaXZhT2JTd2FkSGQzMjRzTmg5VVY4c04rWklKTEV4UFZoY1F2eHpNWUFHbXFMbCtjU0R6dG5hSXpsN0NyZEF5ZG0yTk1PRnBMSmpNSVJTdE1OeDNzV000d05BY3lBS0IvWURqZ3ZGbzlpSFBLeElxUmtaRk1oT2dwNEVOS29FTnVoekdiQmd3WWRmeVZnRGtuMk9sTWVzQjRvNUVYY0pnUEdBRDBlbkZZQ1pjRFhsZXVYaTNEK0VnMTVXL25WUzZBS1d3WXowMDlnRHR3QmpxQXp0OUFhek1qaGlCdWFSa3lBNUREUEhkekRiYXV5RGJybVdsWDJIRjAxbEsvQUMxWmhkU3ltZk1vQjVnZVI2NEFhQzhHNnV5RjgxVlBRRlNkMXRZenhUckFqc0dxKy9NZitVaDFKaEVLang4L3FkNTg4ODF5clpjdlhTbUF6cURadHo0QUpuWWF1elRwaEk3ZW5RaVhqcFJwVE1BUFFGTHhtZk9OZnEzK3BKbFluVElhTWNwZ3JOb3lTY1JrRWdCSld2RXlzUVdqSjdOd2lJcVBYbGlZei9VbWJESE96c01ZZ3J0Mzc1YklqUXZuejVWN3NaZTJNU29BNnJCVDh6bG5yRmg1TDJDOEZxZG9sT1hlN29FQzh2WWp5NVJabnFtUFl6WTVReE42Z29tN1Z6c2trdnpnL3V6RUlCVGRQZDl6Wmg3UXBmTWJwKzlhMm9hTVpocjc5UTkvNUZML1lQOW5xb09kK3luKzV0alFVUDltVjFmajNNb0tLLzJ1MzA3QStWMS9pNzY3RlJ4TVVISjB5UDlmT05JTHo0ei90YVVuVC81OGtpZGthdTVpcGw0M1ZSZk9EaWFHTmpHdGNmcE5adWk5bjA1NDY5YnIxWlhKaWFvN1E4M2VzTWlEZ0F6dzdZbisyRGMwSEluaUtDRGRHTURvcWphaWJScm1BdTZqRElkbkFwaVhKeTRISE9zampjd1dSbVdvZmZiMFVGalFYbUhMc2oySS9EREJRWnp4VGdCY0NGeExPakNHM2RuWkd4RHNLR0YwWC9uNjEwbzhMWERtUkpKOHlReTNhOWV1aG1IdEIyQVM5cGZ5TUcxMTFPRWI2ak9yTU9jSHN1UVlCb0NNWVFxMHp0NFVCb2VsaFJNbk1vSk9HdEFONkFCY2dDeFdWeFFESXdHa2N6SFZRT1FBb0RrZG8rYnZJSDB0QXNPSUlHeVZqZ3NjV3hQN1RUdWxyL1pHQ3pkSlpUR01remJiR1ZsZ1B3QWtSRzBvN2VoRlo2ZGJNeUlpT2dBcWxxek9aQVFUYzB6Q2FUVUxzN1doV2xxSnNVb1V4L25Sa1lEVmFvbk93SjZISWllSVBlZVU3Y3E5d0hxTlpuYUNYcDBabFl4RUdtbUx2TFFTWjJCVFpKSGxTQTBiMGYzM2MwL2NCMW81S1lyUjJFc2JBR3dBUGowemsvYmVyNTY3ZnIyNitzd3p1ZDliY1NiT1phYmc0N1JSU3lZbW5RM3cxMElHR2FLdmZlMXIxY0xLaytyYzJFaDE3c0xaZ0hSREhJOVRaZXI1NlJpdXBqZzM5K1B3YlFocjdrcTlPanU2STYvdHBjeTFuQ2N5VGVMUEcrcVNwQ2tDczMzVjdkQ0lKb2FxTTgvSVR2d0ttNG5udm5ybGN2VmpuL3prenc3MHRQMFhOMi9jL0h0ZnUzM3Y0WGUzUjMzblNqOEI1KzljVzc0blMvcTl3T3dpTHB3ZWVqbkQxazloV3FiYXRtY0lPeHJXZlBaMGhxSmhWbkpjY0NSdEpwVWtSNUQ4REFBQUM4Wjg2OE1pazNrc1dtWW1IRVN1QURJY2ZvMzV2c1p1aGFiMVYvTnhKc1dqSHQxeE05T0Y3eFRHZWo0TXpKQmNSK2Q0d3dySkJmVUJRQ0JZQnJKaHlHU0pSek56cFZOZXVEQVdGajVZUUZjVWgyaUJpeGN2bGVQbTV1YXJTNWN1RlNiNzhNRlVZZTNZMk5UVVZCaDVjeG1LWSs3T2VSekRpNkZoczhMNmJNZVN4ekdqOW02VEpNaUdWUnNoMkE5cnc1U0J2eGpwNG1CTU8ySzFISnhBMzM0N2NiQWVUeHZITXAxZnVSaXhjenRPZWxWU2pRMGJWUzl5Z25lLzcwUnZaaVN3LzViY0U4ZVRlcHk3VEQ4UDhHTHhqQUlqSXBybVNaaTBxSnZPakdyRU9qdEcvYjJybDdJY1MzYmFTNTF0bUg0Wk9RUUExZFhMNkdNdVJ0Vm5URitkakxKSU5BRGM4WThUdmFHKzZzb1lhQmZTaHhHUzY3cVRDUzMzZzVVNWJZeGl5c21rb1lIK29kUnpML2M5ejAzTzE5allraG93ajNUK0dPU1UzZFFZVmg1V1RkYndmS2lEZTRWVkcvM1lHTkRzV0MzRW9BbnJ2REEybnNSY3oveUZUSHJmZk9QbTNTK1duZDdsLzV5QTg3djhCbjAzcTJmVzM4eVRtVGQrN3psQ1NHNXNyNjMvd3VtQXcwQ2lMa3d6N2hWaWxabDZYWjNwQ09uSUdHQjltREVuazVBeW1kWjBqS0ZFT01UL1V6VmhvV0cxT285TzFwbHdPZUM4bmlHdG1La3pjU1Joc0NZZUFDeWdaS2Fhamp3NmtsamFHSUh0TURyYmJsZ2J3T0EwRWdGQXRwRDBDRklETWgzUmpEcWdnSzBDQ3R0b1dLT3dQRnNpVUZKZUxXMm9jNTJLayt2Sms3bVMvM2h5Y2pKT3czTUpOM3RVQUtvR1JNbExuT01BbHV0U3Btdnhxb0ZnNHJaVEwvVzFQeG5EZnNxMkFTWFJIY2QxQWNTTWl5bm9IR01tenRSa2toaWg3T3Q0K3g1TElNcGhsSUMyMzF5amN4dmtITmRmTzl0L0p3bUtiQTFweStPNjVSYWxmcG1jVXU3SmNORnVwUVhGdU5jemdxSHhtODY5bC90b0FvcG9sN3FNRklDYzZ4WXI3ZjBZdEpzQ2tnelBjblI0MTZzKzVKUDVnSzV5Qi9Pc1NPcTBFZ010TmVoeUFQRmMydC9VK01OY2w1ZG9EQy8zeUxFN1lmNWk0YmR5WDNZeU1qQ3E0Z2ZZQ0RObmJOdkRtRVgwbUlISlo5RVo4RDQ2ck10ekU2ZG1ybzNSRjRwWjN2Tlp2cEh0akhxTUJEZ2hteFBSUWJQbUFEYml1WnpJbllzWEozNjh1N1ZsL0docjQ4MUhpNW1PK0M3ZVRzRDVYWHh6dnB0Vnl5U0dLdzFob0U4VzVoNjg4endmZmZFRGYyNXphK1ViMjhzYnYzanQwa1RpaTlPQkF5UXlpblZteUN3NWpheHhnS0RrbmtoSFBNNUdCa0Fsdzg4T0FmUCs2akFJSWZsNmNvd1ZiVlFIM2RyYUxheTZKMXBoZHdEMTdyMTdoZm1JWTc0ZjU5ZWQyemVyaVF0alZXK2NnMEt5MWlJbkFGVzVKQnJUUVhkei9FSEEyVEFYZ0FObm1xZ2srOEM1Si9zQlREUFlKT1dSa0FmQStzN2tEV0REQVdsWTdmeTl5WGgzNSs3dFhFL05vU2M1RDcyelRJc09jSEhVTVVTeENHV2Y0RW9CVFg4TEJWUHVjZmsrWTNISFFBM3dPTFpNMFRiVldaU0ZmY1JVTzM0M3NnTkdDQ2daTEFtT1JKdmt0aVJjYlNtYWIyYjM1VGZTQTNEcVN0enpTcUlpbm1ZMkpGQVNXcWhNREgwM09qQ25aSGNrR3ZLRjd3QWR4aXdrRGNzazMyQ2ZaQnN6S2VVNnlZbGpYR1htcTRyR3ZMVDR0QUFicWFROWJZR1o1OUNBdHNraG1id1N0ZzB3aDJPRXUzSy9YYnNSRXlZTnRJMGdHQXhNdVM5dEM0UzdvMWM3SGpEdmE5T01KSVQ3RFErTmxPY2xPWjRMUUFzRDVJUVVXdGtTYVdYSDl6RncrL3Z4SmFTT1Jqcml0d0YrUis0LzBIVS9iY0x4bk52b2hKRzA5ZlozRjBQZ3VaQ3FsYlAycFJkL3FQcll5eC85WUVQVDBYOGNFUC9pZzZuSDkrMzdidHhPd1BuZGVGZStCM1VpWjdSMWRXeS9NNHdPWUNjaTQ3OC8zTno5SHdEdStURFlvWUcrNUtPUVE3bXVGcjdWSVg0M1lCY2R0eVBnS0tKQWxBWWR0RGNlKytaMHFxWUFzdEM0ZzJpQlpZZ2RVQURRY21FQUEwQ0U0YlJHT3k2NW1LTVJBeTFUdE9jelZBNU9WbWZEeEt3Y3NqQy9XRDJON3RrQjRCT3hJSW1TMFhhWnFNS3hsZkpvb0Nhd1lFNEFEcnN1SVh2Uk1iRW9aWnVHTEg1YWZjUUp2L3JxcXdYb1JDTFlmdjNYZjcxRUpSeFBGTUZPQVpvaHZlR3k0ZjR4YXo1bXc0d0RjUEk2M2cvVEJkRCs5aXJna1VzbWE1QXl6QzYwY1g2SlBqa0dGK1VEbDk2RUJBSnpkZWIwY201Z1p6L3lBVGtBWU42NmRhdklNR1ZFRVVsRG5kUWpnLzFTVjlmWkhLMFhPTTlIMmdIbW1WUlV5dXJ2VDFLaXRNWHkwbndwSDNNSHJJNW43SlRsV25QU1loQ1VSV08yejZuaE0wVmlLVTYvSE1jaEM1elZSLzNWRVRnS2JkeE5aTXR1Z05oOTdzcjNtTG0vanhsMFcxdHlwcVJzR1FReDlpVGVMd3krTi9mcUVma2xzZzJqeE05Z3hNVnZnVTB6c2czYVBpTVhkZE4yK2FlMEViYnZlclNUMGNuR2V2S2g1SnJFd0RNU0RCaS93c1hKaWFZUFh2K2huMjg0M0J2ODJtdHYvbXE1S2UreWYwN0ErVjEyUTc2WDFjblFmdlNkbXZOd2tncjM5WGI5Tit2cGJMenVISDl5L1dKbk1zbWRUYkEvNEpUbUVXRnB6ajg2UDRkUVo0YVBnQUt6T1F6NEF1TGQ5QlREVUhxekpEN0FzejVPT0d4b0xscGczMUJmWW1sUEZhMXlldXBCTlpnT2phVy8vdnJyQ2RQcnJjWXZYaXdKa2t3QXdSNEhrbkNuc2FtdGdHYndOU0JXWDhBRUNHSk9PaVZXQ2h3S0dBZWNoWFFkQTVlT1d2Wk5IZW5RdDIvZktkRUcwU0xMa0YxSHI0RmRMVDRaTUJhbW0zY0FBQ0NQQWRyZkhJVEtQcFljN0EvZy9LYXNMUGdSc016a2l0UVBJQUZialFtUU9LNHdadnF2T2hld3ptK2tqRHJ0R2tDemZCVVpnVEhoOE5KK1prUDZiT2FkU0FzWjNweXpnR255bk5COCtRTUFLVVBsL01MY0pIY1MwZUsrZEFUZ01QVDY1RmhXTDR4WW5RQ29iSDYrTThGbkk1cTZoUDdxNmUrQndlRklJYWVUOHlLUkhBSExudVNnRmpsajZ2ZjR4SGlKalZhVzQyVUszTTd4Wkk3RFhGTmY3aTBucm12MXR5Z1RZWmRrRmc1U1Rsc09RMng0WVlIUnlJaEU3ZlBzbFlrL2VjNk1OclJsU3NpOVRwN3YzdjVhZStRNkdkSmFPdFU0a3dQRTd2OXlqSDBEeDJJWXVPdnFDMkZZbUZ1b25tUWlqZFNxVnk1ZmpuRTUvK0p3WDlkUHppN04vdXJpWWtJOTNrWGJDVGkvaTI3Rzk3SXF6ejMzM0N0SFcwZUxDOHNMV1M2anRnMmxGeDhlN3Y0bDJjRjYwbmt2ajU4dlNYSEU5cTRuLzhIRTVIZzZoeW5XQWVOMDJzYU12MDJ0dHBJSGdFN1BMNEN3a0dIM2R0Z3JjTVp3TWFFQzJ2RzhBMW1kVitUR1VHYXdBVEc1bVNYZFdRdERiazlIZTVnSkQwM1o3MVNNQXlDaVNXNkVBV1BEemZIU201NWN5KzRXSXhJUHZlZ0dZQUJJeGN6NlR1Y1V3WUF4Q3FFRG9pUUJqQmpZR2VxT0pYM200OGVQcWwvN3RYOVpmZXhqSHkzQWFQWWdiZGhJSUp3NDF5Ujh5NG9wdFlSR1phSkpKSjFjYXBFSEFLTnJBSVkyTEpkeEFOaUc4czRMa0xCazA4WHA4OTlpMDFGTDFFV2JBRjcxcmpGOXhrQUNvTnFNeFFMME9hNG1NUnltVGR0S2FOdFdITEtTM1dPeE1abGhoTTBGdkdqTllyQTdJdHRvYXhFdGh2VHpjL0VMaExtVFVzaENPMXZMcFo2WXZqb3hYT3J1Zkl6VVpwNERLOHI0N3R5NUM2VWRHVXFNVnZ2T1REMnM3a2VLd3BnNStiRHVNcE15NzQ1cFQzaWVFRHpHaXRIUUZ0cmR1VWhSSnRDWThPTFpFVzVIaHRMMlF2WE1RSlI3Mm40TUZ2bEpuUTVpZ0dqTW1MbGx5TlRWSzBwWDJlUUZVUi9uRU5HUlZvK1RVYzZPNWtTRFBNNno2NW50S1hsYTFEVXIrVlF2ZnVURjBaQ0UvenhaKzJadjNMbi91N1dTdnYvL25vRHo5LzhlZkY5cWNHYm96S21OdlkzRmQ4b2E1ODZkdWI2OXVmNVpFUnJuUmhPM21yaFhVNTd6WFZKQ3psY2YrTUMxeE5OaVFrbnptTzlwMWxiSUVBb0cxRGlYV2dMR1UxTko0WW5heHF0dWNzaVp4TVNTTW1pc3dGSmVZanBvU0UxaFpCTmpZMldTd2EvOWkzOVJtSFJQd0hZandOTVVCalNhZWtnN1NXZmQzTWowNlFCSmQ5SllaZzVNbUZlY1lRRUNRTmlaamwyWWF6b2Z4NVhYNk9pWjFMTzM2SitBUVpRR01KbWJteXVUVklBY3dQTzNpQTNzVTFuSGsyUUtxQVpZZ0Q2d1VjWXhTL1k1WDlUT0dZRDJQVUJRSHk4Yi9WT2RmS3FCY2hBa3h3QjBnTlFlMER3K0RxZ3pIT3B3RFBRY3I3V0pIVlVKbzFNSFFPcDQ1MmpHTlBONUkyRjh6dU80WWp4eW5ISmJNZFY4TDcvejJQaDQ3bE52ZFMrZnp5UmNqamEvdTdWUzZxd00xMmc3SGhuNERqaVRhVndyRGRwdmZBaWlXamdtbTJLa3huTHYvUDdXVzIrVjk0bUppWEtNOGpCaG93RDZ2NWZSRFlEMVRtSlFCdTFaZmcwK2lKVTRFWU9tWWVlblltUnJvS3lkeUNOWWVBWmhLYnVqbEpFQWpoSkdSK3RXVnhJWWcyRktPM0RXUG8zMXlTOFNuZDR6UitxaWJUUHFORy9YNHRtMUR1UkI2bi9seWpQVnhNV0xQNTJacUp0dnZIWHpYUkhOY1FMTzVaRjhmLy96d2d2UC82bkhqMmR2dnZNcVorZG5aL3FHTDN4Z2VYRjJ4dmN2di96eVg4eWd1blZwWWVGUG0rN2NGNjM1UXB4MEhtQXJrVWpHZm5hRWM2MEtRQ1F4VVVBWTYydExaeE1lTjdkZzlZNkFVWlZvZ0syOUlsMTBodUVNRFEwbUdmK1pxcTE3TUNzOFo2bW5BTGdPdWhzR1BqUDlvQnFKWTZralh2cURkTDdsREx1bkltOUlZaVRLWU9IcFJtU1ZMTlVVV3ZUMHFaVzVFd21RYzBnS1R6T05PSkJPbGhDeGREcXN1SzJqbG9aemRTMDVuclBnYk9ZVGhxbjFsb2dDVTQyQko2VjNQQ09DNDltTUlpZEtoMDNkSkV3eTdmeks1U3VGYWRxWFJreGVNQ3R3TGVmd1hVZXUzWkpROVVsdm1UOUxad2ZFbUxMWmdjTFhKRTZ5YjVrNW1FWURJRmloL1NRYU1ndy95a2dDc3lVcFlIVDBkdzVRT2EySDRvaHRiUTFnaGJubVRNV2dMUWRJcE0vc0NRZzl5YnloMGFRQkZTZU5ZY3ZzSmtOZ1MxdGlmanVhVTQ4c0g3Vmg4VnFKOElHVmxVWWtOdW9wTWhKblpWOWZNc21sUEZJTG1ZQ3pUdWpaZnRMQ21nQjBjQ2grT0FtSklvV1VFTWd3ZkFCSVYyYjhZbkdnZWZVMDBzVndqUEJxZ0RMV3ZocUs5TkVZQUo1OThxQ01KQUFzTnJ5Uys0ZEZ5NXNOTUEvcXhLMW5oQkg1NlNpTXVDMkptaVE5V2tvUVJXdnVaVWZhdDM4Z2sweVNBTW1LVlhzSFlmSmgwMXZKODl6YWs1QytwbzdDbUQwTHB2WkwvR1JVaGRtek5kdDd5UXNlNDBRNmFjLzFxTHM0ZUcyQmVSOGQ1WG5jZlZ2cXlycUhaK0xuK01pSFAvamprMk1qZitHTm0vZi9wMmpwTll2MXpvN3pQZng4QXM3Znc4YitYcC9xbFZkZStvVVBmdkQ2WDB2STF1a0E3b3Y5L2IyZHZiM3RPeGRHTHJ4MDl2VHBTY1BGb2FHQmF2ejgrVmV1WHA3OFg3cmJXejV0Y29UbGh3NENJQTNwckFBWjBFalNJemtQamZsYnc4OTBSakcwbGx1aVU5dXZOWG9tUFJMSWlEUm96L0M1TGV4TFV2Ym1zRDd4cTQ2cGxTZEZaYno3aVJ3bzY5WWwvL0h0V3pjRGpFbEJHUUFuZmRBSW43OSt2VENkMjNmdUZOQWZHZzV6anZndE44UjIwbUs2anBJUEk2QW94NExFL1NRQ0tURUJzbm9EeWRwUVY1S2RHbGd5TkZnZkJ1M2RiRHBEWFFCaVg4Tmx2OUd5YmNjTUdpdkRLR25LR0twamF5QlF5eG1DbFhtNU52VXc2NDlrQUp5VmF3aHYvOTBrZWZLMzgvbGRPZjUyYkhFcUJrU0F1dk83UnV5YU5hREJHdHB2QkpBZGF5MUcwb2p3Tit6YU9uN2g5UUhvYUxzQlFjRExhV29LOUtrWVF4TmRwcWFtcXBGelp4TEZRTXFJekJQUTVqQVVBb2RsaXZSWWpVWXYyZ0xEMVM0NVdURWk2all5T2xxdVI1dGhyMFpJTm1sYnRjOW9mcmVZclBvQjhyMkV6V2tyMFJnRjJMUHYxV3ZYeXNnRzhET3VBRnY5dkpOM0dCMVJHejBCVWd5Y1ptNXlTME9pTmpaVHQ3N01NSFFmM0Y4UlBVWnZkR2R0NEpxTnNyUXBSNlQ3YU9Ua081SVJkaTBsQU9jb21XZHVmcUU0dWk5ZHZocjVickpqc0xmanI5eDU4UGgvekxWblJ0TDNaenNCNSs5UHUzL1h6NXJoWmMrMVo2NyszY3dnKzNDbUw3K1FwL1NWNTU5Nzd1Yys4c0pIL3RLbFM1T2Z5Y3JMbjhuS3laL3Q2Kzc2UytmT0R2L2NNMWN1Tmw2K09GWmR1VFNSUlR4N005Ui9uSmxXYmRYWlVaS0VxY0NpRjJpTmljalEyWUZ2cnVJd0hZRWVLMmNDNW9pNWlGblZpUUp4Q1lIcmoxTXBtblBLYXFGOTVuc3BNR21KWjg2ZUtsRU1GandGS0pMM3lEejIyNy8xVzBVelBUc3ltbVdYWHF1ZWYrNzVNbHdWRmZBNDBSenlMc3Nqd1lsR2x0RHhPdU9jNHAyWExONFFuQkZaV2xvcG5aRHNBbGhib2pzQ3UzdjM3cGFjRUNZMERBNE9GREEweGR2USt5dGYrVXJKQURjNU9abXk0K3pLUGpweUFkTUFxTTA1c1VkNk9KMFgrNmJsU2lrcXB3aDlXVVk2WUFRb2pvR1hzUW91NUR2TUxtNnRqQUtBc2JMVnoyZjE4MklZWWtNSzBKRXI1QjF4VFRXSDMzYWlKazRsMmlLamxaeEhEZzhBZEt6ZEFyZmVnTzFCUXRDYVlnekYrRnIzejNsUFJ6TGcrT080YzUrRUpSNXhFc2JSMkJtSFdXTmtpN1ZFdmp5WWZsVDBac0RwVlpodVJndnEzUmNqYXRhaWRyRTZpeWdZSVhqdU44bUVvMCs0NHJua1l3YmtuTUxhd3Y1eWd3QjcxMngwcG4xZG56WjF6V1FjZ0d2L1BIWVpGZkVwNUQ1bEpGRWY0K0Y2dFlzUlI0STF5cWpENXpSZWNUSnlOdkp2OUNiUlA3OEJ1VXU1eFFqbEdUTUtrSGEyT0VDbEtjME5rYnFXMDlObjBweklrYVJ3clUvcysxOTk4UERXMzU2ZHpSRHUrN0NkZ1BQM29kRy8yNmNFekdFTXJZZDFCenRuVDUvNWljbkppYkw4ME9jVEx2YVZyL3h1Vm1iT2tEajVnLy9rai85WTBpME9WbDF4b3JSbHFtNUhRckw2c3Nob1dWZzFBSEh0NnRWTUpta0tFMTRwbXFBaE5EQ1RaRVlzY0hzWVhBbjNDZ0FadG1Lbm5SbXkwcHRweE4ySmRiNHducHdjU1UzWkd1YmNsRTVIcmdBUzJQZGVoczlZc2dRM3dGbkNuS3pDWEgzaDg1OHZlWVNmZmU2NWRHSmhjU1o3SmFGL3pnMWtKSUFIZE1LbE1PaW01UDRGMEExaHBwSWRzU1lTOG5ka1NJNDUwU25GOU9yd3djWk1FWDVhd0FDOUZGWkZKdUV3QTNJWXU0eG9NckhOWlpJS1FDY0h0S2VPTXVTUlBZUVNpaU51UzduS0I2ekFCa3NFcklXOXZ2M3VYZ09mV29ML3NGdTZaNWl6L1ZvQ2hJNXhMTFpjUUNRZ2hYa1dCaDFqWjlJS1prZDZBQ0NXOTVwZmVGcjArOG1KOHdWb0hHL29qaEhYakVIYU9LeWIwOC85NFF5amVkTmFDeU5OTzVtSnVSYjVLVGlYU1I2WnRCRUF4WjdOM0FSMmMvT0x5ZnRSUzhlS3VSZG5YTTdEZ05IR0dWa3pHRGtDQWF6emVtSEZESysyM3RwTWpvMldPSVRUbmtWcnp2V1c2NG9SOC83VnIzODk5NjI5bXBpWUxHQ1BQVDk0OExDQXBVbEtzVGg1UllaSXVhUUxFUitkN2NsUG5lZEhFaVVUVGJTbEJXbU5Kb1pqc0d5aVZZcWpOUktHdW5YazJSUDVZZG8zWUNiVmlCbFA0NVM2QXZ6ZUdCelBqMGlPMVV6OTU4aWN1SFF4YTJKZSs4c2I2NnZUTjIvZFM0ckQ3KzEyQXM3ZjIvYitucHd0SFdpSG8yL3F3Y3dYNnc3MmZ5c1p2MTVzcXEvTEtxaHhUZ1hzeUFncjBmV1d3bzZQQW9vWExveFd6MTY3R3RZelhGaXhqaldRTEhPV2dscE1ubCt6LzBZamIvQytONmVUVzFuYWd4Mmt5ZVNIN2ZLM3BhUXdEcE5RcElGOE9EMmQ3NU43SVJNS1RwMDlGL2toekRDYW9OQXJFZ1RBbkpwNWtDcEZXZ2tMTnFGaUlmRzRFdG5JRjNIcjVzMnNBL2lrUkZHWTVtMDE1NTZzMHdjY1JTZmN2WDI3T2orUnlTcGg4c0NNVG9uTk1ndzZyM3pRWmpkaTJ3ZnAzQURTUkExZ0NDaWRpNU9KSmk1am5VUS9ESXlzY01EL2QzN250NnNQZi9nakJjU0JrODRLVUx3d1lYVXdHaWpEaW9Cbk1Mb3dUQ3dUYUhobmhFUmhZTHdZcEEyNzladjlNVzJnckU3RmNLUnNRQSs0YTRCL1dHWXlralFzd2FYOWhnWXRHVlVMRWV6cmszZ3B3L2lVYVlKSnNySGxPaE1HbUhaWHY0Z29wYjRsdGpmWHJ3MFdGdWFqNVQrTmxqdFE5UTRrOFZRa3FDZHBYK2NUbys3NG5veDJwQi9kM013YWhMbW5qeU5WckFaME1XNTYrRktPeDlUYkEzTDJsL2ZETzRQNTZGSFdLTXgxRzFXMHhXZ3lPTTU3RklhT0hRdHp3NkNCZTJQYVZiNFFVK3lCSlVuRHRaRlFwdlA4QUcwTzRaNUlEKzVwUzNON2pNcUZqQXI2VXJlZEVndk5zVXpuRnl0ZG5JRjVONkxpdE1hV2diUzYwcm5wNndBYU82YnhNOVNNZzJ0VWhuc2kzRS9FQjNyT0lheHZmUEpIUC9FelE4TTluLzZOMy9pdHYrVWVmcSsyRTNEK1hyWDA5K2s4ajJmbjduUzJ0YXdreisyZmZ1SDY4d1dBaCtOSU9vemV0cDZsa1V5a21CZ2ZyODZlczZ4VEV2aUVGWmx0WjUwK3VUSG9wZGh1ZjBDVFZpemNqY1FSUE1sS0dVc0Ixeno4QVJNQVVsSlRSblBlVG1mRlpyYWlxUTZFbFY2WXVKanhaNmJTQmtCb2gwY1p6Z084eldSTkl3dGdyMDFoTFp4dk4yL2VxRDcrc1krWFJEMWYrcTEvWFYxLzd0bkM5cVN3NUVpamk3Ym1XSTdEWnFGYW1WSnVpU05nMUIyZ3hpSkxCck1BcGtSTVhXSHJraDJ0aDVWaFJnWDBjajBBM2VRTXl5aFpjWVNSTUhPT3hQSTArYWl4NnNuVWV6R09Ua21Kc0dkbCtWMjJPU3l4cklZZE1NRll0WU15aXJaTnUwaFBkNjAyZ0NOa3JQWVpZRWFHU0FPU1FyUURBTE1CWlg4RHM2SXZaeitBQ0Vpd1o3bzlrQUY4OG1wd2tEbkdlV1NUaytPRTh4SnpYSXZ6alMvQUxEN0FiNFRSRnduQzlpU0c3bW5pcDRlVHI1bXhxWXV4NEF5c1pkdXJhZkNXazdJUUxLWXQyeURwQnJDNlJneFgvTFdSbE9NWlFKc3A4Y2NzR2NQZWpWTVNHSktaR0NkQTZiMi9MMU96STNFQlM4Qk9BaWtPeThoYThrT1RUZXg3UHdDOUgwWS9HQW5GSkJMRzNpZ0FFOVoyZFFuWmNmODVlK25ldFdnWGVyTFYzTE5pVGU0dFk3SVdBeVFpUTZTSmtEdkdWY2E5N3E3YXlBQ3drME1ZVHVrRVRMQkNJQ3dhekNIdTNrOU9YaHArL3Rsci8xVytlL1BPM1Fldmx3ditMdjl6QXM3ZjVRYitmaFIvSmR2bzZPaGtmMzk3NDdrelo2N251ZHlKbis4emZjbVBNUnhHZkRtTTg3bG5ucW5PWjNaWGV3REhjTkVEYnBGVW5lUWd3SEVVZ09GY0F4eVlKdkNWT25RclRoYzQwNWg5QUxYaHN1eHR3cjR3a0R6ZEpmUU5vRmloT1l0eVZoZXZYQzE2YzN1QUpWK1g2ZDUwNnI1TXJ5VnJpTlVGemxaaUJzNTJBbkk1WVJMMVBDb3MyNUJWcmcySi9IbmQ2ZDVUVDVMd1BiSEQ0bGhMUGRQWk9aeXdLYUMxSEdBRkdGWXJBYkN1STcwd0hieXhoSU5oY2h4amdOSitXQnhRSVpGZzRmZnUzUyszRDFBQ29mRVlNZUN2YlBzRW5WUFZXbWpjOFgzMm04MytKdHpRWDdFNDE2ME5NZVZqc0FSMDZxME1ZTzg4eWdWd2pBZ0xXSXZMamxaOGFpUi94aWtXZzBJM1phVHFHeE0rRjFaK21IWURvSTduQUd6SmZTaHlTd3hRYWNmVUJ6aGhoUmdxeCtGeURMUHAwTFRwL3JTbmtaQjd5eEJiOVdZdWJMa2gwUkpBbXhQTkpJNmFrY2l1K1k5bWJkMUE5U1JaTUNoZU5nYkdOU3d0enBYckVXY3VwTkcyRmNhcmpZRDBRZHFQMXMzSTBiK3hZNkZ2SkkyQmFPeDMwdjVTaVpKL09QTm8ycDRCRVR0dCthNGxzMVdkaXkwMDNYMXFlcXJVeTNQWVdHTEthODYvM2RSUm0wbWVaWDhMenJybiszRjhTci9LVjhJSVdoMThQV0dqc3VibE5pVlNxSzhRa3JkdTNDaUc3NU0vK3NrdzZmRlB6ejE2ZFB2MnZmdXZsUXY2THY1ekFzN2Z4Y2I5ZmhRZEFEbVZYTHVmVHFqUW44clE5VS9HY2ZUcGc4UHRqVysrK28xUHpRYk0ydE9CaGdMR0gvN3doNnJKeTVjTFdIQ2EwQ09mSkRMQ2N2Wm1qMkVvSmpsZ1pIWHB1RmJoSUlHUUNDUnJweEVmaGwxUVJDMGhwSFByRkhVQitmVDlvbVVHaWdwYnZuVDFBMG56R1FaWG9oY1MzUkYyWGlheWRMZVY5ZWtzWFZTV2d3cFFZeSsvOHMvL2VYVWgwNnBmZVA2WjZsZCs5ZitKOCt0MGlUMFdMb1hKR3BMTFczemp3YjBDZ3VmT0p6SWduUzZRV0lDNUpNOUptUWNCWlZ0Zk9wNU9PUnZBQVlKMGMreTdoSENsM2hpNTVaOWtkaFBTWU5WcXEyQXZMNi9KWkZhWTFrTE9lL0hpeFhJK0FBdThZMElLczZRamF5L2d3Ymh4OVBrYmlBRnpjR1o3SnpoanoxaTczekU1aGdJUUF5MWdCanlXVjVmQzFNWHhIc1Y0bkNsbHI2Uk9jay9JWFZMZkZHQk11OUo1cHg4K0RLTmZqMU8xTzlKUG5HQU1SMEJKVWlQc1VYa0FXdTRRMFRQK2ZycTRranFIa2NjSWN4b2U1SDZhOVdqOVBzRDdORktQdWdCZDliTUJWb1pIUHVmbEdFcWFycy9rREliVDM5cWFNWHIrdVd2RitHZzdPclRqdEEvWlFwMDdZeGhJSENRalRrRGZpLzVnc0lTNmpZeU5GUitBUENCQTJVSUwybmcvWlRCd0t4dUpMTW0xMmRmTVNhTWhURnc3TXJJTjliVlJpWWdUNEo2RDAwYTFKRkYxQWVwZHhDQ00yL2ZIU2FGYWtpd0ppMlowY3ZkeS9zeHVUUnV2SnpXcGF6eDFPaWxPejEvNE01MXRIWU5wejYvRWtmeGRjeGFlZ0hONTVONC8vOUNhTTZIaWk3ZHYzLzdIdDI3ZCtlVTMzcnp4ZDY1ZXZ2cm5mdUpQL05qMWE5ZWVxY1luSnNJd0hsVy84WVV2Vkd1WnZDQ2UxcVFMU1dxQ3ZobktiVWFyVGFmSjB2U1pmMVV0eENuR3VTU25CUWtFTU9tZysza2RaZnJ2WEhUaDlXaVQ0WWNsdGxWMFJzVEx5QmoxQWE1RVlHUW9QWG41YXRZVFRQblpEUDhodHdROUlpdW1IczRVUU9wUDV6RU1QNTFKQkYvNHd1ZnovY1BxbWF2UFJSTStYYjN4NWx0aFlNa3VsM051cGM0WkJVUTNONnlPUmhyVzFKeU8xcFVPUkVTUUxJaEJPUWhnV2gxYWgrOUoyZUpiVndJSWhyVnJBZTdsT05Za2JnSlNJa0k0QlF0UUFvRUFGUWxqY215aSt2S1h2bFJ5TXl3bGpPdC8vYnYvVy9XaEQzNjR1dnloRjBwTXRtV1ZSSmRZVHN2d2w0RXlBckNzRXBEVHlUbmthTXRDQlJrbHY1TnhaS3hMbGNxK0FETFZLcEVWVnBGWlg4MkNCaG4yMDFYWDF6TVJwS00zMmZQQzhBTzRGOGJHQWhtNS9rU203SWJsbVlwZEh5UTBkQStHeHptYWRtcUlnemVnc2h6dzJzNTVNNzdQOVRjbERqcjZkRUxhQm5vSHEvNkF1MWhwc2hWWmhCT1VZd3h6bGVmYVdvMzBkL3E1ZHhOUGdCNXRucEhScmlZUjlTYXlaeS9UK2NrbUIwWUl1ZDZPeUUyTTdGSnlRbE4yTnlKSCtFeUs2UTZEUHA5ck9CMUFYMTFKRXY4WTJldlBYUTg1SUN0bGtrM3U4M0prRTRtVkdzTjIyVFYrQnNEdUhCeWtIWW5NOGJ5Ums3UWNpV05pZkx3Nm44eUM3cjhwM21VRmxkemJZa3pTdUp5NDlSbkpjUXhiaWFVbERzYm1QT041QUFxZ1N5bkF1UGYzcHkvMERFVGlrZXRsdCtTUFJnVGttUGI4YjZ3dEpWVkJjL1dKVno3Nll0M1Izczhzek56OVJ3bm0rSzRBOUFrNDU1YTgzN2ZiZCsvOTQ2TzluY1h6NTBiL0pPLzI2TWhJY1I3TnBuTWFDbU12MktUaHFSQXcveFduVFdKSmRRYUplRXphTUhHazVseHF6cnZWU1RJY0xVUHhsblNnc08wOHZDYVV0QVlZZVB5dGpnMGthTTYxTUszYWdwNkc4M1RSOXFRZmxWK1lJdzZUYmMzeFdOL050MjZXWE1PaVFzckVsNENCaFVWcjhiM05jUVE5Q3JzS0NJYnBDdkV5N04wT0dJN0VlU1Q4alhZTVpPb0NFSmlWZW1OL282TWo1WG9mQnZoUEowK0lESHNZbkNXdHlCNzJGYkhoWGNqYUc2Ky9XVmpkaDE1NElVeTVwN3AxNTNiMXBTLy9UaldZenZyc1N5OVdqUUZGckxCRWlzUm9BUkJ0cUUyQmd0U1p0WTBtSDVoS205bW5iSmwwUVI4dThrVUFSaG1BUm4wQUlpWnA2YWFhQTYzR2prMWNvVGZUVWpISDlUQnI1MHVodWVhQWRVWUZKQnpua3FaMU1CTTRPT0t3U0p0MjhwczJjN3dvQ0d4VEdZeVJ6K3FOMGR0TWY2Y251L1l5blRyc1dmbjJVU2FIMlRHakxyUC84aHkxUjRkMlhhN1ROV2hMekowczRwa3l2ZDZNVE9GMEhJRE9PZk0yVzVZZ1NiMUtYdTA4YnlVY01NK0FmWTBvRUFQUklkcE11WjVaaWF1VW9SN09TWjV5UDJlU0luWjJkajRHSll2bjV0a1M4a2Y3Wm9DMXIvT0lSTUtjeXpYa3Z0dFBpQjJEN1dWRXlNaVhaejc3Nnhza09DTTlCcUE3NHZuNHhNVy9PSmlnNkc5ODg2MS9WUnJ0Ty9qUENUaC9CeHZ6M1Z4VWYySTZrMHZpejMvdWM3OGU1MTV2RXY5a2lKNU9KR2cvejJIcDlDSW9QSlFXNjhSU3RzTEdKT0RCUXBZenpMY1NkdkZ5WjM5U0FPWUhhb1NmNmR5RktlYWIvUUNDR09QNSthWGlrUjg1TjVhaGRNMnhwVk5oT2hqWTRLbUI0ampFM25RQ25ScHJCWlIzNzl4SnN2YVowbEYxUUIxYUI2VTNZN3BraGJwMFZnQkJZd1pDT2h4d1lCaFN4U1JxT3Awb2gyUTZTM21BUXR5ckRyeVMyV2JpbWhrRTJpaEc2THAxVW12eTJRQ0UxYXdCQU1lWFJEMGNuci95cTc5YXd2V3VKTUpqZEhJaTBvRXNjekZuQVdKdFJnc0hZRjdhMXhScjUxUStnd0ljdHJZemVTZDExT245eldFSUdLektBdmhveTQ0eHlVWHlJb0JzUHpxdkVFWE9RWEtEY3dOYzZVM0ZNN3VYUU5PTVIvdTdKeUlvMWpKS2tBVVE4R2d2a3BLRVMrcG5QM1hSNWpZQWlLa3FINk8yUDBDbEIvZUZKY3VUNGo3VGFaM1BVSDgzT3Ivem1IVGozUWpGZDZRZGZ4OUhjdmhiOUFwbkg0QUUvRUxidEwrMlg4MkNEZHBoT0xIWTVBMWdTQ1pSUHdCdGhPZDMwaFRwZzdIMlREQnNydHYzZ0pteHFRRTRnbUN4WHF3WTRFb0x5MGpXZFA4eUpUenRyU3lTblAzSVFFWHF5Qkg4S2NpSlNBNTFkcC9WbTVGMUw4MjJURTZYcUhWdFAxSmZmekI3NCthOTcyaGVqaE53VHBPLzM3ZnJIN2o4NG5QUFBmdFBFa1BjK2NZYnJ4Zm5IU1lrNTRYT1NhZXpzb2hPSk96cm1GMFpoaHZTMG1NNWhxeXlBZlFNWFRId2pYUXVxNVhJakNiRnFPSHJUaUkwMXVQRUVSNEZvUHZTeVM5ZGZhYUVROUgxbk04dzM0UGVFSDBDaS9ZU0FiS0gvUVhVK2hOMU1SZnduRTBIMWRGTVRBREt3QmU0RzFJREVRNHUwOG9CR29maHpaczNxN0h4OFFCYVRWOCtmV3FvZERTZEZuanF3QzJaTHF3OG5YOG42eUhLLzdDVVNUR0FsNlBRU01DUVhBY2NqV05LSnhUR2xvdk84a3RYRXlPK1ZOMS9jTDh3NjJ1WHJ4U21wak16QUFCWVhkVFp1MkcramwvN25nRUpNS1RIcWJ0ckNXUVhSZyt3dElzSkxLNFRHS3N6ZzJDQ1JNMkExaFdubXQvSUczNG5SVEZFN29Ib0dwcHpXY0FndnpOKzdnblc2MVhUWWpjSzZLdVR1cEFRZ0I5UU1tMWJ2VzFpdUF2b1phWWxJR004TVhxcm94ZHRQczhKblhoaFliNUV5VERnREF1RzdEcUFMYVpNdm5LdFFORTV0QW13eHR5ZGF5WEdYelFJeWNvWXcyZFBHQUEwWXBEUG0xWThNREJZMmtDSUhnZGVHUzJsRHRwZDFJZ3lzV0xnN3pxMWdlZkJ4QjBPVU5lcTdPTm9FZTBCMERsRjNSdWJkbFIzNzREZDUrNlV5ZUF3WE1KSEdRditGbEpNbWRoemtFVnlHYjYwYzU3RlMyZmliWC90OVJ0ZktBVitCLzQ1QWVmdlFDTysyNG9ZajFOUXRNWUxIN3IrTnk1ZW12eDBmMC92SzFuSjVFVzY0dlhubytPR0ZVb1VMMXVaVHNDenJRTUJKNTBmKzlPQnJicE40cUNwZW9ZbGNTK3JNa2NtQUZhaU5RNEQwcGcyeHJtUlRpa3BlZ0tTQXM2TFphcjF5TG56MWRVUFBGZDFSWXVXY041bVZSRG5XaE5IRzJEeWR4bVdwMU90cHJPTnhHaFlyV1A1Nlh5SlEzN3k1SEdKUmNaaTc5eTVYUXdEc0IwTytBTDF5SkxaYjdnNEZ5WFFZV1FNUHdISzZHaHREVDJBYnBnT1JET04zUXl3TWhyQXlLOW1zczN4WXF3NkhlZVZSRDVXZWhiaFFTZlhEcHhEWmlJYVJaQjVFdVZWWGJwOEtXM1ZVRmdmbHVYbEdCSFpRS2dBQUVBQVNVUkJWQklQK2NGdjJxNDJ2SzlGZldEVHZtdUlwbG9EN3ByajBEMm9SVHpVRlRDcjVkOUljcWkwQ1FBQTFzTE1naEdGU2ZZSElJRVJoaXMyM0FpQ0RndWtYSVA0Y05FaUZoeHd2dG44Yllvell5cWVuUE8yR0lrY241OExZQUltWUtUdE9BOEJxa2lMbXBGNmt0K3lSbVJtWEdLd3kyRzYycDc4QUpobHNGTi93RHdRSjUwTWd1S3dUWnl4Q2c2cHhTb25aU0dCZkRjNU9ablJUeTA5YW9ySitXcXpNWlVyaDNObm5rMEdGWkNhSG03MnBwREo4bXdHbU5YSkNJTXh5RE9mKzlvZkpwOEZpZDhHV0tNTzdlVjdSb2FtRGFpMU0vRHRDdWxRbG1kaUxmZXpqQnJTUjd4cnY3WThvM1Jtb1o5eXFaais3bG5JTFM0RVpUMkFiUW80UWhHRGxwd0hSNm5uWUY5ajByVE1QdjNqenlvOEFXZFB4WHQwZSttbGx6NXo2ZEtsVDErL2Z2MFhMMSsrL085bjNiYVJERWNIMHFFMjNuenp6VGR1MzduN1QyL2Z2dnVQYjk2Kys4dGYvY2JyZjMzcDBhUFBuYjh3K2xuRGFlQk1sOFZnZEdhQUFwZzk4UDdHVWt6WFBzeURMdmF6RE51alkramNHSnJoYmwwNi9sWjBhWnF1NkkwOHQyRVFtUVVZeDR1MS9JQUl4OC9rcGF0bHlTcERSMXR0bG1CeVNlUXowTUNjU1IwbXRBQjVPYVIxQm5IWXdPdmV2WHRGWnJoeTVVcVJJMlNRMDFubFhpaXJOQmRtSE1jUnhoMmprUDZYMk5paHdvanRwNE9UTW5SeVNad3dyc0xDNC94MFhVWUI2bVRVb0RNYTlydk92WFRhb3FPbmpkVFQ1QXRUd1MzbWFqaWY3bHFOalkxbE1zeEVrWGQwNnVOaE4zMjF0RkVPQkFBV3V3VUlPalBXQ3hCRUFmaHN5TzA0VVJtK3h4elZEeGhqaE82THNtZGpTS2FtcGpQMHJnR1VlMVZ5TmdkQWpVcEtHYmwyaHNUL3BCdEFhSnEwa0RVTHdDNWxCdVZxUXNYNjBzWW10UUFoZ0NxV0Z4QnJiNk1JOWVnZGtKUS94amJ0Z2RuS0lNZUo2eDVMR1F2dzNEY0FMSzVkSFU1ejVPVVlvdzBUWXpCbWhoRW9rcUk4YjlvRG9NNW5GQ0xlR1hPMjBnMldURHpRRHRwZ1BRNUQ0T296QnZ4c2pQeDhJb3ErOUtVdnA4WHFxMmMrOEV3NVJ2dVJia1NMMURUbTJyTXNCN1VvRGhLTmRsU3U4NHJUSnBNd3ROcFoyNW9jcGE2dVFSdjR2SjVyUWtiNFY1QVlveWs1UFlSL3V1NDhPWVZOMjk5enNyYXhNWjVvcHArc211dGVyMjg0blAvajVvYytBZWM4RE8rbDdaVlhYdm1GVDN6aUUvL3F4MzdzeC81R090WmlZblAvNGVjLy8vbS9tU0g5UHhTbGtlSDZ6VHg0disvYWFPMjlkY3VOUncyL2lCME9aRGFaNGQyeEhscFdDUW1EcmcwWmF6a29hSG9tYm1ET0dFTkxHSjkzQWZxbDl3ZkFqeDJDQUFTQ2llMWREOGpxQVBWaFpuSWlYSHYyK2FJNTB6aDFUSnBvMFdRRDlrWExDMERxQU5zQkR3NUNkUkJhMTFoUGlsZ0tFTTdrdU9SM1RpUUh4cjBTeG01bTMvcEd6dUcvZENnZ3h5RTROVFVWd0VuVVIzUkxJQUprbXVPNHhGeE5CVGRjQnhaUFpoOGxYTzljT245ZjljMXZmck00d2VqU0RCZnd0azliQUJPTExFN1J0SUdrUUpJbTBYZG5VcWMzd3E0NU5nZGlGTEJKSU8rNnRBMWpKMUVQRmhmUFpBRUJjYlE2UFJiYzBCalFUbHNCYkV4ZnZUQTZXMjNvTHhRdkplVWY0RVZHd0U0eFpVTi9jZ1FqeVFqd0E0Z0NVUTVIbFdNd1ZaTjY3RTl5Y0IvVjBRUU5ob2ZtMEoyY0o4NFBuSTZ2RzFoeEFBUHFwb0MwZWkwR1JHdDVWV0kwM2F2czd4NjFpY29JY0dMWndJMXZRcGdqT2VYVlYxK05BUjB0a2tRYXNHalc5RjlBS21MRE5YTGFhZXZOU0ZPMC85MFkrSVdGaEVxRzZaNk9VVDBWV1VKN3FWTnBzN2VCa3c5Q3ZlWVg1c3J6T3hZRDZibGlBTnhEQnNkeDl0RjJqTExuVS9zd0tHUVArekJVcnBQQk1LdFFYYlJ4YVkrY2F5MjVTNHlRekFFUVlaTkxMNUtQTnFOSEoyZHVvb2N5V3N3elF5b3pxbURBODZ6OWJHZGI2MnYxamUwQjZNVi82d1QrSitDY3grVzlzb1VoLzBUQTVKVjArT1hjOUs4R2lQL08xNy8rOVM5K3UvVy9mdkhLWDQ3VDcxT1Q0K09sbzhxRDRhR3VBVU5Da3NMcVBHaUEwSU1PYkxBRkhSK0RhQ0ovNUdUQVdXaFlGb0dOSXk5SjFmUHdjNFlCU09GU20zbkEyOXFTblM3Nm9GQzY1eE4rZHV3UTlPQURaeHIzVm1aZzZSeU1oVkMwelhTRUIwbTBEd0FHK3dkalFCSnVGM0M4ZGV0V3FhZE9BYVF5V2lpc1VHOHhOQlhIU2s3aERGd2xoOFF3eU5jeEV1ZlEzUHlUNHVGWERtM1o4Unh5aGVFR1NEbWxBTjF5T3BWT1N2TFJTZS9ldlZzTkJyaGx6eU83Y1A1Z2h6cmYrUGhZZE43bXlES2I1ZGp4dE9mbEQzNHdmZld3VEdSUkRuQVFsdzJZQWJSMjFaYUc1YzRQUk9abkUxZWVkZ1lZcnMwc1BDeVdCcTBPOUUrL0FiSWFPMnN1TStnNDkrN2Z2NTk3Z1hIWEpnaGg0ZVFvNTdKL3VZY0JUdmZGZFM4c3pCZUROVHBLNWxrdUlHalJYZlZ3RENQa1hnQjcycXJuWWlISEFVYWJtWGl1b1dTM3kwTlE1SWJjTXpJU2g3RDdTcXUyRHlQTlp6QTN0eFNnSFhoYldoaklOZFVjaUlBU1MxYTM0NGdXOTRNczQvcU5zRXpmTm5OUmVlcWdia1lDVnpKNkdoa1pLZTFvNW1kcGwvenVPc3F4cWJkcktPMmRPbW5MMnBhMnlzU2RXbnQ1aG1PNDhyelgycXZtRVBUNWVBS1QrOWVjNi9UdUhqai84WWhHMjJqcnBVVExNTTcyUVFRQS9IRnlyVGhGZi9iODZMbVYxMTUvODk5YWd6NEI1N2R2M2J2OUxleWc5VWEyTzNmdS9OTzgvWU13NVY5T2VzWUhmNVI2VDV3Zi9mRUE3Q3VYTGw0c0NZWmE0dkNSNkp6blh0d283ZEtMTnNqcGRKQ0hGMmdZdHBhcHJXR3AyTjFlbkg2YmNiQWNoQ0h4ZUhla2pQcUFrRmwvbUJwbTFwWk9sdURhc0t1dTZ1TGxhOVZBMXA2ckQ2QWRIQVg0VTJrenY3b0NMUFVSYmozUSsyRXpjOUZFWlphampacjVOakppU2FRa3p3bjdXVW55SmRPTHU1S1lDV3VXbVc0dkJla1VXTmRLdk94ekNiRmJ6L3RJOGxDTGY5NWN6MFNFRE1uN0U1N1hrZGhVRE5JSzM2ZWpOMjl1YkpmY0hVSEhFbHFJc3o2TVhLSXNNZGdZZkdObXlDMmx2S2F3WmxhcHNGVHRFVWNXNmVVRFY2K1ZkUlh2M2JsZEhXU29pOUZKTmpRMVBaUDJPa284Y2FaYTU5cTI4MXRqcENGNnVod2tWbm5CYXBkbHpZdGhvN2NEUktNU2hndnI1blE5QUE1cEQ2dHJtOVhYbXREQnB2eG0xWFA2dVgwd1lBWkVwQU9wb1RhaGlCUVZRd3FYOGxyTC9URHp6ZWloelBKTHU4bXQzSnUyYkV1Wm01RnBHSTB6aVc1eGY3SEhNbU11WmJ6MTVwdlYrZEVMTVU0eFZDdUoza25Xd2JWMUVSQzF1UGJldnVUcnpyMlY0R2dqdVN3ZVA1NVAvWnFySC9ySVI2c2JiNzVSbm9tYXNlZTBUUjd1QU5qdDI0eHRraTlOam1jUmg2WHEwcFhMeGVneG9DSXlHQ1lqRjdIUnB2eExBV0ExOXhSYzBndElEOUNjWjlRSzdJeXlYQmxKVTFCR052WWwyWmlDdlo2NGJqTXBBVFRncGI4RGNPMnJIcTBoRU5wQjI1RmdyT0JPOXJEUWd4am9yc1NReTNDbkQ1UzFMdk1ldTVObjJ5ekRsdXdiUTV1K1lmS08rK1k3ZmhIQXZSNEQrSGhtK3U5ZG5oajk0SzE3MDYvbVR2eVJ0eE53L2lNMzJmZm5nTVRkWm56OHg5djZzc1JJSEdnL041WnAyMW5nTW1CWnUvM1lSMjBJV0ZzSGtEYUlIWmlVZ2pGZ2ZMUllNY0FtVjlTR3p0R0pBOHhpUVkrak9EQTJVMlZGYlRRSGRQYVNzcklobmVQaWxXc0ptenNiZ0RPREwyUERNRjdNcFNYRGZPY2xCVWdqV2h3cjZXaEMyQUM5ZkI0ZWRNTnNRMUdUUG5qZGhmenBKY0s1U0JpWWxjNHV6QXhRbVpnaEZPNXVvaW9Nc1FFT2htZm1vM0MwOUsrU1gwSklJY1puV0Y3Q3BsS202eldkMlZENE4zL3pDOFVRR0JwalI5SjBldWVnMU9FbDVWbVlYNmord2YveEQ2cmYvZDJ2VkpNeGVyNWJDeHNuaFlqWnhnZ3hhVktNVGc0QUFZVnptdldubllFU25kODV5NmdrYmVSelEyUWsyait3d3RBQXZ2c2dSNGFRTVpFQ2ZzTXlLVm5Ld2lDZHM3YlY3aDA5V2JrbTlwQ0YxQUZRbSthdEx1NEZUVlpadEZWdDRuZGdpRW1hV2NnNDVDMHpTTk42K2Q2ems5M0s4ZVg1Q1lnNXppaEQzWUZnUjk3SkIrckg4V28vejVaMklGODBaeHAxWHh6RjgybERpYXFzOFdnaFdRejF3eC8rb1hJdnhKdVRORnlYVVlaMmM0K01kaGhTOTZNallhSytkKytkMTNrNGlCbGo4cHIyZHp4NXhrYUNVTmRIT1plMkl2VllmR0E5SUcyRWRQck1xU0pqYktWOXRjTmFSb0RxVVh1V2N2MnBoL00yTkdYc2tuTllrbTA3UmhTeFFUeElSRElvM3I1NSsyY3ppdnRiWTZQRGt3ZDF6WTh6U3ZzajllRVRjQzYzNi8zL3ovWEw0eStHY2Y2WmFMc3ZXa2dWY0p6SjhOREQ2ZVdoOXNEV0hsYnhxdlRsbW5kYlp4UHJLL0dSNklqaXNVNG50U3EzNytSaXFER1JtamYrYVpMS0FFS3p2ampOSmk5ZFNXS2xDK25VR1I3bTZhVXY2NkI3S1lzT2E0Z01lSUV1TUg0YWRsc0FJL0c3aHNXRGVkRHRZOUpNelVGampidmtkVWdacEJjQXBnUFNGTWtVdDI3ZExCMzkrZ3NmS25veU5LYUZXb2gwcTh4V1MveDFybFVuMHZGMWRqUElYTC9yQnQ0bU04ek1UQVdJbnhUalZNc05FY1lhMXVaY3pvdWxuajB6VW9id000K21FMlV5VWozNzNMTmxHRStMTFpKSUFKQUJxdW04dFdXV1BHMkFSaWhnUGhWR1oyUUNsTlRIZDBDc09LZnlHZEFEYnhWanBMUzVuQ0pwM0FKUWRITXZ4ekJVZ0VNNXBDSnRJdXFDNURBMVBaWDN2YUlETzU5Y0drQU5BQUZuSU9wZE96QVlIV2FOaG1IT1JUdGZpeitBQmsxeXdGcE5PaUZwbVE0dENnSVFraXY2ek1iTWZiYXdMdWVydEFDQXl2dU5temRMbU9QRnlGSmlwYi81K2h1bGJVZ1FrNU9UeGVDb0MvbEN2WHJOTnMxRjF3d1ViVGNPeDlPMXBjZElKR1FOMTJ6eDJyYU1BbDJyN3hnYzlWY1hmaFZHUjNtdVRmbU1PTEFtTzNuZWtRL3RoUkNJUEtHbGUvNk01dlFMOTdMMmpLNlVaNFVCWWdEMitERFNOd2JpT00wWDVabVRDbGVjdVBOWnd6QWpzTS9ra2Y5TVowdkRQNXQ2dkRDZEMvcTJ0eE53L3JhYjZyMjk0N1ZMNDU4TmcvcEZrc0NWZEk3eDhiRU1HVTNNa09tc0ZsSUVNR3c2aTRlUHJPSGRnMnpJSnU1WlV2MFNVcFRPTFZyaktNTkhjZ1AyRE1RM0loZEl0RDh3Y0NydkdhNm4wNDVOWHFyT2pVMFd6eituSUEzYnc3KzJYTk5jMXpJVk8wOTlBRlJ5bkdROXkvRC84RWdLeTJpSnFWdDNKckJJNDZtVHRnU3dEU1d4V1owZndNcnZZV1ZsVXNmVEpIMy8ybGUvbWp3YWo2dWYvdW1mcXU0L3ZGLzJQWFp5RlYwd1lLblRQWXBEeWdZOGoxbVI3MTJuYlNMNWt0OTg4NjNTY1hYZytmbUZkUEQyNko1WEN3RGN1M3UvMUFkemsrWHNRYzRGRUlUWFlibzI1V0dQNHFrQnYrdlF2a1huZHAyNWJxR01RSGN0ekEwWUZVREk5MEc4QWh4R0xBRGFkUUplaHNIcTNaeXA2bU9ZYnRRQm1CNUgybEdPaUEwUks4WFJGUmttZDZxd1FTTUhqa1FzdkQzSDJkVEJlYkZEVEZEOVNEaE5RQ3JuTXJXWmRDQVVVZzRUZXpPTXV5bXJwcGxIRkVyYk80N1dEL0NVMlo1N0JmUzBMMk1ITU9QQVRwMDdBcktuRTBHelZsWmF2NWdSaDdZUkJvY05UMHhNRktZTjROWERkODREV0cyTWg1ZkgxVWhLRzFoTjI2aUFyR2JHcVRZVXF1ZzYxY3RMaEVkdDFMSmV5aDhPdStidkVGVlQ3bjlwYjdKZFFpNGpOWFhsR1hNZVUrMkJyWGNiUSs1YW1rWDN4Q0F3aUo2WmpUeVBuT2p5bWpCOElrMUlUeHlmK3dkSGY3K3Z2WDc3anpMVit3U2NTM1AvQVB6VDJQcWxyWTJWLy9mQ3VkSFBrRFhrL2pWYzFWRzhkSTZhUEZEemVwY0gycVNUQUFOV2pLMTVnSDBHRmlXRUxZQWdZeGsyQmh5RVhXSEhSOUdhTVdlZER6aVBuaDhMT0U4RWhQTGc1cFhEUzZkOVBQMGdvTVB4R0NkV09vL0VROG9SYm9aWnk3QUdoT1VBQVUzZDBRU3h5eklETGZ2UWNVME93R3JQanB3cDRWdW1lUU5HTEU0TXJhVDVqYUpNMHBGMVFwcnJZRmowWW1RVThveE9qRzBEYjIxQWN4UXJyRFAyOTllbUxXTzliNzExSS9VS1c0NDJDUXpKS0xiYVlnRlp1aXVPeWVWb3BFS3FyZ2E4R1EyNkxVQUJlZ0RjdVFDbmEyUHdUTzV3dlp4VXdCK3IxNzdrSVhYU0RrWVpXTEk2aWJoUVo2RjhGa0JvamY1cll4UUJJdDNZY2NjYllLa051NjB5a3Z3allYWHVvVkE4enJCejBkNlBEVE9nQjRSa0lvWlQrTmxXOXRFZWd3UFJmRk0rb05WK1dLdlBjbnU3UDQ2cnl3eE5jYzdhRFNCaXRMbVVBc3drRGVBcVFSSkRSZEx3elBYMUQrVWFreUV2OWJsNzkxNHB5NVR1TWtySS9XWU1PU0F4WnV3MFJTVE8vVTVoNWVwbndRQmxDNk1Eekl3M1EyZnlpZXRtZkl0VE91RE9FWXpsZTU2VnowZ29UejBRRHpINll1TmRuM3RocENGdHFzMUlTbjl3VHhrZFlaZnU2M1p5aWloRXUvdjlUQXpPVnJUOXVkbkhtYWlTdFF6M0Rvc1QxamtUNi8zWkxCdjJmejZhWDNwU0N2MDIvamtCNTIramtkNFB1d1FnOXRzNmUyZjZPbHQraVpXbnIzWEVnZVFoS3c5ZU90b3hPTHRlbjNVdUxBRVRFVktFQmJTSExYaFlBVlo5T21RdkwzNyt4c1pzTGRFUkpWRzNzZ1pXVXhlSHpXQzAxZEVMRS9rdE04bkNuTVZFNjl3TGM5T2wwd0FrRDdWNDZWS2ZuRUFuTnROUHJtVXh4UkxzRElRZHpZVjVHcVlDa2Q3VVg1UUJZQjBkR1MyZHpBdytzc3VaaE5MTkxjd1ZVQ2FGcUxUbGpsekxTZ0RNekMvc0RaaGhRY3JRaVRCVHcxalh2N0d4bktIMitkSStHQytkV2VRREhkUHZQYWtiSjF3SlNRd1lQRTAydTUwNE9rZlBqZVM2a2c0MVRNdDFZSTVpcUJraHdGNzB5NXdIZU9yc2dBWElpYThXamlWYWhleXdueGxvMmdaSXlMTUJZSUdPNnpGcGhxR2JpOVJqWDVLUXNyMERGN3I0azh6U0ZMTnN3bzBaaElEWlRFL3Q0eno3aWZOMnpjVVFCd0F4VkxIQ3dBYVl5dHpHR0p3YU9sWDJXUXlUM1FUZVlhZllvZnpSam5VTndLd2NrL0lZSC9kWFFxeit3VXd6VDlzTHRUT3h4QVFWazJ2bUZ1WmpyTnFxRHliS1JXUU1VQWU0TmhJQzBCVGJySjM5Vmd4b3JzVSt6Z21VZ2ZHRkVBMUFLNjZhTElFZDkwYU9jWDVPWXNEdW5qSTRXSzQyWitDVjcxa3BCanFrQUlPV24wWDJPODhuQjJCdHRxZ1ZhNUNFK0FCU2xudDRISld5bm4ybE9rMXpGeVBYRlFOY0gwSkQ3bEZHZlYzNlVOcUR2ME5mU0xiRGY5TFIybkkwWjdYYWIyTTdBZWR2bzVIZUQ3dlFuSnZyNnk0ME5kWi9kajZhbmdkNUt3L3QxTlJVZWRneEhadU81ZUhIOGdCbW5yczhrR0VLR2VaaENTUUpFMFI4eHpsVlFvZWl2Y2twckNQUUpSdVNGVzIzbEpQSEt5eTZOOHhyL09MbDRua1hvNHVGQTRXdDllWGluWGZPaFlBZnhpc1dHUXRjQ3pPVXQ5ZnFLOWdwWUFSUWNqWUFTSjI5SmJGT3dNcng4bWJRSTRIb1R2YkJDQTNGWC8vbWF3RjVVU25SWDlNSnNkU2xEUC9Qakp3dG5SVjRZbjQ2S1pER25ubmVYZi8rUHFhWTVFMHhPR0p2SVR3TjJyV25LWXE4dzluR01ZbjlQVElsUE9jZUh4c1BDQ1czdEh3V0FRUEh1ZzdIR3ZZQ0RnQmtBeExPZTh5Z2p4MkNRS20rVVZSR0xiWlpoOWQyZE9UK1RDcVJ3MW9hUzFFTndNczlLL0hCTVRqYWxnRllpNFBORFJ3S2t3VDQ2ekd3emsveU1LRmsvdkZNTVI3QUZSQUNNY0RsWFpsZDBXaEpXSEtlME9pM3d6d3QzSXNsTjZUZHRRRTV4ajJvQVZnbWt5UTgwNzNDV0FlSGtyRXU5WFkvTVZmdlJnemFKR0dnSVFqUmhhT1ZBMWdPUE93WmlQbXNUSkVoeXZOY01ScFFmbnhzb2x6NzA2VTRmL09NT0piaHE3Vm5iYklVdzgxZ0duV29IMk1PVk5NRTVWbkI3RzJja05xK3NHVHRrdWVJbk1HQU0vcU1tWHZGR0JYRGs4YjBibi9YZFJoL2llV3lTRzM4TTFMeTh1V2NNMEpJdE1aaEptTnBCM3E4ZGsyRTBIK1U0LzdaK0tPNUNHQkZIU3IxK0lQK09RSG5QNmhsM21mZmQvVFVyWGUzZGQ2UVUwTmVZOUVSandQU1p0dUpiQmdmSHkrZHhrT25vK3RJaTJHZWd1OTFKcXdaaS9hT2VlVjVLNnlBckdENUo4TjU0TW1KMVdDWVhqcDBja2FrSDBnamV2SEtNMVY3NUFjZG1nd0NmR1lmUFN5Z2loVUJaeXlSNTF5U2MzVVFVZ2RNU1FKbGRaS0FpdFNpMXBrRE5udGhmdldSTnNTdkFpUWRrRzRKcUExZGRUU3NhbnhpTEdWWTBtbTlyS29CZU0yMk0yUStUcWFEaWFxSGNnQ3V6dDZackhuK2RnNFJJSmlwWTJ6WUtoVlQ1OU5HZzlIeVRlU1JtdFF5U3ZjQ05HY1R1ZUZjTmd4YnRBUjl0RXhZU0tkZlhKd3Z3M1ZBWmFoUG8yUW9oSHd4T0RxOHNMWlVJVzBUb3hGOUgxdGttTWdqZzFteUN1aTVidEVhZ01TbWpOSFIwUUxtSllJbFFMdVYrd1NZKzhMaWdKWDdWcC95Z0pQTnVkVkQvREdtVDg1d1hVRFphT0I0YXJVSUVmbXFoUWRpd09ySktIQ2tNWFRpeGRYRGk4cmwrb3ZCU3gyVmkvbjYyM08ydTF2TFBhSTlISHZseXBYeSs3MTc5OTZXUGpxL3hhS05jaGdOeGtnNVFObUl3M1dUUDY1ZHUxWU0zZlQwVkhtMml0U1FkZ1BFakUrNWp3Rmo5UUxlM2kxN3BpeGdQSi8yTHdZeTlmVnN1ZjVqSnpIR2JQUGNBMmR0NHJydWh0aGc1M3dqSWw5bzFVWVRGcW13WXM1RzFtZzBndkxNQzAxbEtGT1R6NngzZFAzMnZVZFBicGRDLzVCL1RzRDVEMm1jOS9wUEgvdll5Mzl4Wk9Uc2xXaDlGeTZjdS9nTEgvdjR5OWN2akU4V1hYaHM4bkoxK253bUpFUS9ISnVjcU02Tm44L0RFNi8wYXFZL1p4THQ0VkdHcnY0TFUyNUt2Ry82UWI2bnQ2VkRoaEUwTmllOTZJRkVRZllWYWxmTFFGYVhoMVFxeHFhd21iMzgzcDNjd2IwOXc5WFl4TVdzWE5GVnlqN0s3TGo5elA2Ym5idWZITkNSTkhiTnpKS0djU3Q1aSs5bS84NUlCaVpESkxRdEhVTGVDSjFRSjZGbFF5dlRrdXNLeTA0MFFvQlg1TVI2bU9KczlyTmdxVVR1Z0hBNk0vazRvOW95aERaVTdReklBaVNNOENqRHpvMndRY3NYaVplVmE4SnJPUk5adGhLQjRLSTcwb0U3dStLb0JJNmlUM0tjb2F4T2p6MlNZY1FlYzBSMVJHZWtkOTYrZTd1Nms5ZXp5Vk1NakthbnA4c3E1VUNmazBwY3JEVU1EM1BNZWlRRWl3RTBwRUtMODdQSkZad0lsZDVveVllWjVsMkpoSWptbXZZUzd3eVVHVXFNanlUUW5DUk9lNG1VS2N3d0NLRHVxN21mdXdrQUYzOHN4bm1kMHpUSHRNZkFtZFRTa1B2VEV5Qm1BR1ptNDZqS2NaeVZqSXAxSTV0enI0L1Nyb2M1UDQwV0kyNU5KSVFabTBaSEhJdWtFdUJlbCtmRlROT2RiWG1lNWMzdVRxeHdKclhrZUtNVUVwZHNnWG5nU24wdE03VVV4bXVkeVd2WFBwQXl0a29FaC9vL2YvMTZqT2RHTWFhWDRyQVdYVE05TTUyejFlcm4ra1dkYk9WY1Zpb3hPMURJSXlOT2pxbXhZYWxYSTFlRVpTL0dNWHlZVUU0akFvYVZFUVhzMmdKQmtWdGtKZWtCbXZMOHRYVzA1aG13bm1OdU05SVJQd2gveG5xWXVmWnZhemQ1SlliZzZVTE9IU2R1K3NkV2lNSEV1Y3lBaklTeUZBTHdPT2tLeUNiUjhTSmZaRkpnZ3N6ck00TEUrbW5Vbk5VV3AyakllOVpXM0c0NFdIODBzN2orNkEvRG1CTncvc05hNXozK201V1VrK2J6YmxocTUvYk81b1A1MlNjMzRzeDdSWWN5WVdJa1RqUlNBajN0YkFCTS9DdU5EQ3ZFdmhyemdEV2swK2IvZE1RNFN0NW1rWkt4bDZROVlWQ0gwVVhsdUpEYkdaQ2J1RUZHRUdyVjJtcjJubWlRdm1qT1kxVlR5bFJPQ2dySUhWYVBwKy9tdUVnTkFRd2FuVld4VGRjMk5DeXpEa085c0JpUkNxWndNdzk5bVNxTlNmcXV2aVI1cjhYVjlxU0RjaTVOcFVOalJoaWxLZHdjZnlaSXVFWmhZT2tiQlZBTnA3Y1Rnb1VoRi9CSzNVZ01HSjBoUFViWWF1TEsyMFBaMnJDMkZ0ZDdFUGFLaVZtZno2Z0Q2RHUzaW1HMlltYU5TRVpHejFkalk3bnVuRmYwQ0laSnJqRmNOcncvWnBtWXBNbEF6c3R3R0QybzAwWm1FZ0pSRVJDNTRDTHBTTjFwR2pUZ3RJK1JTakZPa1NEc1F5OEhaSnlUN1ZtTXdNaUFSU0gzdUNadGVNQ1FwTzRBZUQ1R2d2WUtUREYrQ3dVWXFtT3k2MnUxOERWcjdLa2pXVUY4czJzdE1rSEt3a3FCcTQwMEJpeTFZZGsvM3pGZW5pWFhxMHlNMWIxd25Cemd2blBkTnZ0aHJMN3pmS3F2c3N1K3VaOGtPTjhweS8wVEJZSDV1Z2YyY1p3MndXcU4vRWhWeWxOWGRYT00zN1d4NysxSDlpQmQrZXhaTTNyeW5aQk96NUI3WnpTR2lYTm9rc3NjcjN3aGRjN3JlajBQbmhIWGd1SDd2UzhHMG5rY0M3aGRIMzlBMnVpRkREdW1YN3N6OVlWeTRYL0FQeWZnL0FjMHpQdmg2L241Mlprd3pzVU1WKy9NekR4KzQ5NkRxYzk5OWRYWC9uclkyV0NHdUM4K2VUeGRjdjVhZFp0Y1lBYVhoekpZWE5oUklEaWZnMlpoQ25tbThnQmlpNXhTMkZBWWh2K3ljMHZZUjBlSk01Vi9PS0FjNTVaWGQzY1N6aVFNcnIwOWF4Y21NMXBEcElaQ1dYTU14OVQ2aXNrSHRYT0oxbGdPc3pHdEd6UHo0SnVKeVBsbEdHbkdYcGtobUk1SjU2YUhIb1JwcTRzT1JEYklZMStHcHpxWHpzall5Q210TXdOR3M4eUFCZWFyUTI4RjVNcndOK2ZXc1FBV2NOR1pTMmZMc0YvbjhqS1ZXQWQyN2dLbUFRWGFPN0F4dk1lWUY2SmxNd3hTc1dMNmo3T0t6TVdMRjZzTGx5ZXJtWUIxVzFneCtjSTVHRVlnVFVyUTJiRjhkZk1pUDZqRHprR216RWNxb1o4eWVKaTd2TmUwYk5xc084TmdIaWZsNGRBUzFVSXpmNXlJQVVOdHN4MEJpUGgwNXoxSStjQ2tCbFpkQ1FGY2lWRmNUa2xDN1JpanRFV01zODJvQXJzVnFhR05TVXh5VEl2V1VKWXdQV0NrTE1CRFF2SzlrWXB6SElPVlkrM2ptdnp1Yi9zeUtwY3ZYeTUvaThMUS91NkxOZ0p3eXJFNURxZ2VBN1BqL2ExTTc5ck1mZlM3N3dDb2R3NDk5ZkE5RVBleUx6MmVVYmFQK3ZBVFlPTjVPQXVqZHA5TCs2WWRzRzFsdU9mSDUvY3N1VFpwVnYybURzY0dCN2o3enJsSVJKNW56dlBTZnJtdnlJSHVrOGlieHFQTjdUZW5GcGFteTBYK1B2K2NnUFB2MHlqdjk2L3VQcGorMWJxajNabSszdTZmbVJ5UHBER2E2SUxlcktHWGpsYzgrbm1BeFM4M1JyN1FhZk5IL2s5bkMwQWRCU0NrVUFRQ2pSbEdDNmV5NWx4YmNqTUQ5cElnUHU4Y2crM3R2UVZVR2h1elVrb21rMGoyZmhpQWwwOWhKMENTK2Q5bDhvbUhHU0Jnem5SbkRrTmhUZkprNkpnNkF3RHowcGxxcktRdk0rU0FTbTFXWHdtQml1RXdkQ2N4NkV4QzdHN2R1bFZZMk1CQWRNMndNQjJSOXF3elllZUdtMEd2NUxtbzVXdzJmSmVFM3pYTC9RRjhyTndONEN4eDVEZ3YrU1RNWkxTcWl0WEt4Y3lxQTIyWWxLSER2dnJhTjJLa1dxckxrNU01YnkwSFF3R25ERVdBdnhTdTJDQjJTRDhGQ2tDT3M5WjE3KzVsdGVtTUhtcXg0WWtvU01SRkNUT0R5bUhKMmhEYjQ2QmlGQUEzMlVmOXJBYnpPR3dkYUFsSk5KUm5ZRGdGQVV2TnFFV3lDdmdEY1dCazBneXoyeEhEeDhsR1ZpSUhpR2xXSnVjY2xRSmdNVmhDKzVURitIa0hUSzZCektCODl3a1lsdnViMzIzMi9UY2psUFVZMENRNENnZ3pabDVtUG1Lb0FGUVptTC85c2VLeHNiRnlIOGhFN3V2SXlFZ0JQVzBOek5YQlo1djdmeXBhTnFEMnZYYncvS2lmNzdRem4wWjV2dk92RVFwNWh5RmtITjN2R3pmZUtNKzB1UUdjMEhLaCsyMDAvWVUrTFlMSnZTcitoN0FNejY3eU9JekpQcDRGUnJkRTR1VDVOa3JWRmtaOWFlZ0xpWEIvMm5pMDhmRFI0dHJ2bTZqc0JKelRuRDlvMi9WbkwvN0VzOWMrOFBkUER3ODJBbVM2cmxTWXJlbWtvZ1dzeVNmVTdDRERmcDAxcXp3RXdDVG1DUXZKdzVXblBkOEhqS1BUTm1VS2EzT2VTVFA5R3FMVEdiYmxud0lxRFUwWnhtVWY0aWR3cmsrSENURkxCeGVGRUtkZ3loVTVvZk1ZVHErbmN3TjRVOFFaQ2NiQUE0L1JwNThXRnFKK0hITTB3L1dFcnVtRU9wS2srL1E5QUFtb2xLa0RmdkdMWDZ5ZWZmYjVBcGd6MG54bTM2ZkpweUNXMkRBWEFHQy94d3dhNDhGeTdDY3N5dEJZeDgvSDFDWFhuTitFWGVua1JVUE9kMHRKYlA4b21pT0pnV0ZnQkY1NDRZV1NObFc1MnNYSXhMbUdoZ2NpRjZ5WDh3RjBMQkVqczlwR0tUTnNUaWRXZDdLRURyNFdEUlBiNzhvb1JMM0pHcElrT1ZjSjc4cnh3RmpVaU5scGpJNFJETWV2L1d4V1NOY213QVNZMDBIWG81OXk1UFhIWWV1Y25LNG11cmkrRW5rakYwcEdCMUtOQWhYcFBjVzFBM0xNVjZnamdOUStBQnNvdXhhakFkZXFEVjJIZG5OdTdlb2F0VEd3Qi95TWszMDQrSUF1cVFJWUEycHQ0LzRDZEViTjl3RGZzYlkzMzZqTk1Cd2JHeXZuWmdpT2piaDNjY25PNTJWVEorVWNNMjJHZ0JGMFBaeUNVdytuTTZQMHRaeDdLUURlWFgzaVIzKzRHQVdzM25rWkVoTEh6WnMzUzUxN1kveHRydDh6cEh4MVU2WlFQdzVwOHdrOFo0eW9FVjEyU1R0WUhVZENzWmFYdDdmM2JyeDVkK3BMcGFEZjg4OEpPUCtlQm5rLy96bWVKUHdmLzhpSC92YjFaNS85Ny9Md05zNU0zU3U2Mm1CaWlETTVwVGg5clBRZ3lYeDNuQzhieTFiT2lOWmMyTFBvZ2JEbWRESmlCMmVZQjczUkF4L2tpaEpaT2tQeC82UVI1WUJ1YUpRREE1dG9yUG95WEszSFNQMlpCNU9zVVgrMFcxYlRyZ0ZlWnRJRm5MR1FtaE13blNxTXo3QmRad1ltWllaaU9rTFJvNTA3WmVrTU9qQjJKMnJEdXpoa0hTV3pZYXJmL05mQStka1NyeXp5Z2NOSU9Kak8xaEI5WE5URFlxYUxDM1hyU241ZktFeURGS0ZCUXdjc1FzbHM2dUQ2blUveUlyOWg5WU14SGlhOW1JNHQzdmFOTjk4c2dHQVZHS0dCQU90TUpsZFloY1V4cHFwamI5b1RpR0NoUzlIYS9hWk5BU1ZBT3BNY0Q1cGU2bEVoaEZhZkJ0YWlKYlFycDVTL2M2V0ZqVm00NEZpVDFtNGlMQUJEOHNvRzlLWkxXeGtaT0NjdzBRYWNaU1poMEpHeHdTSmI1U1laanBkVW1ia0hraE1CSmVjVnQ0eGRGbmtnMTBHWGRTMEFpVlNBNFFKeW93SDdBRjd0WlhOOTJzSytnTnM1N1d1L3lZd3V4c2ZIQy92R3dOVk4zVEZveDRub3VIL2ZiTTlrRzR4QmNGNkdENEE3bmtTaHpaekxPZHdua3BqZmZQWU1xWXR5ZmJhL2tkbXhmOFZvQjVBYU5RQlA5VnRjbkMyc251OENBSk1ueW5PVmF6R2lBcmg4SjJYL3ZIdW1qU2E4VEhoaVlEeUdqSkp1NEZqUGxKZFFRVi9tbU8zV280UDVCN09MOTdYUk83Y1RjSDVuYTd5UFArZkJQelhVMy9OS0dPbmZJQnVJdWMzZjFjYysrbUtaTG11OVBVTlpRR3lsREIxNGZ4c1lrVFJNTUJBNmx2d1RBWSs2eUFkaU4wdThhNTZndXZ3V3ZTTVBKWmdJeVE1Y1lGNTFEZkhXNDJMSlJDZHh1MGlPQW43NTFzTzd1N1ZTUFVpSDA1bkswRG9kMnRBYWE2WTdJK0dHaUY0bHhXaEFDM00yVkRSc2xCMk1vMFdISkdjQVNNWUI4MUdtT3R5NGVhUEVQeHNxOS9VUGxnNXNuVGliYXhIeVpDWlpmeUlZcE4wOFpwV0FXTFkrR3JOT3JUejdBcFBtZ0NBUUJVcmV6VVEwMHRBcHlRNGNqeGloZEthT0JRYkJsd0lNSm8wQVVVTjVLOGdBRzUzWTlRRUVERlJueHhJTnN6a1l4ZG5xekpwWmg2WmxxcSsya0FoL1AzSUdCaTFYeEZLaUZPaW45amQ5MndRV3dBTHdhK3cvZHpINzBhVVpJQUNHWFFPTWxoZzNJeGhHUTc0TTlhRXptL0t0WHI2VExSQ3dlVDJ4OG5yQW1FNnN2aVFld0l0aE90Wjk4YTdOZk8rWkFwYStCNWhZdWZzQzZMU0J6OG9GdXRwTW1jZk9SdTNrKzJNd2R6OG1BdWJPajIwRGRNY0NkR0RvZUUrajh6SkV6dTJsTFlCaytUM1BzZXN6bXJDUDU1K01ZbDFHTWRRTFNUZnIvTzZ6OHpNKzltTXNmSmJnU2ozVUV6dFh0citWN2I0Ynpha3pVRGNDTkxKeGJ6MmtwVi9sUGJMVnRiM0RvN205blkwYjgwOXowbmRzSitEOGpzWjR2MzY4ZnYzNmkxM3Q3VmVTR3ZML2Z1dXROd05DYmNuNjllSHE0eC85U0hVcGpFV3NwczdabTRkUXFOSnEvalpUU2loZDBUK2pEUU50RDFnQjNUQlNvVXRDdXZKVjBKalVFWUNvaFhYVXdEa1BjRjJETmZCNDlBTW9ZU1oxNlpTU3R0T2NnVFBOK2M3dDIrV2g3ZzdyeVk1Rnh5TWxZTk9HNmpyeDhVdEg4MWtuMUNscmRhcXhNVG95b0NZdDBCSjFlTEc3WmhSaWw1aldVTExLQVFZSmxLUU1IVTVxVVdVQ0ZSMVFwMU0rQU5EWjZkNDZuWTRHckhXMG93Q1pqZ29BZEViSHpJUlZGaWRrcEtHclY2OFZGbmpqeG8xTU0xOHRIVlVZbHNnTTV4QTFNUkNKcDJ3aHdNQUE4R2wvd0FWb3lEZ1lPYzJaakVHemRBM0MwQ3p6NUxxd1YzcTJPa3JmNnI1Z3pZeGJpZkNJZ3phM3JMUVRzQndjSEtnZWw2aURzUGEwTllDYW1uNVlISUpBVEd3NEE4TWdhbjkxcVFGc1lwMERLSXdRcHJzQjVBUDhRTENqczZZRjJ4ZHJQVzRUYlhoc3VQeW1qUUFXY0FSZWZpc3NNdGZrZTJ5V0ZPS2V1bTdsMkl3bzNEZjdZdEN1QXlocXIzSlBjdThtOC95NnA2UUc5K05ZNzFkZk1jZnVsVTNaZ0ZiZGF0Y2lncU9uUENkR1dnd2RtYWdXSWhnWktyTlJPenFhQ3pOM3ptTWp5NGlvRnlhdm5WeVA4NnV6YS9Yc3VGNHZJeGY3TzdmZlBaL2Vjem1sTFlzMG1PLzJqdzVmVGxyZTM3N3o0TkhycGJKdi8zTUN6dTlzamZmaDV3VDJYd25BWExqeHhtdi9aRHNQeVovNDVDdlZ6LytILzBIMXlzYytGaWxpcTNxVURqby85N2hNNkpDb3BxdkxTcy9TZnE1WFBZYmhKSXYwMk1LVTlYWk0ybUpDZFFHcEtnOWFBSldzRVJ3dmVpOFJSS2hkZUVMeUVXZm1WSnhLZGZUZGdMT25VbXdzdlUzOGFKTlk1OGZKTkJlRzBSWFcwcFR2dHpjeU15M0Q3SlVNODBrSEkySDBabTZ0UHMyVWE5SkJabzF0ck1YWkVzTkFjd2JxT29TT242OHlSTS9rbWFmejBYM2puTXIrUUV1c3IyZ0hkYkN1M2EwNzkwbzB5Zmo0Uk5GUW53VE1NWm5qZXRXWEZWaHEyYzNFN0FJbElHNzY4UWJtbFBlV3NQZlYxWTJVZGJjNDRheG5xQjVXS04rT2diTk9ZVjBNRUtmUldrQzlPRnJUcm1Oall4WTNxaDdIUUl5Y1BodmdheWdnQjZBZVByUnc3Tk5pTk1yb1FNN21HTDl6MFdOcDZVOXlET1lkcTVaY0hwRWpPdnZLdWJGMXdDVFdYT3l2eVNzUDc5OExNQ1F2ZGtZWE5XbEZ4clcrY2kwTEMwL3pmVnQxT29iaDl1MDdHVjNjQ3NPMkxGWjA3Z3pyUmJHc0pWSmpQWk1vVmhJN3ppSFpHamxJWGVZaWtTeXZMSlgxR3psY2dkM2R1M2NMZVAzd2oveElBYnN2Zi9uTEJYUUI3ekZ3NlZvQWk3RURhSURTcUFCWTJZZVJVaFptQ3Zqc284MEJtODF4am1FRUFMRDk1TU53MzYyYUFqeHZ4ZERmejBnc1QyTUJkVG5GbFFPZ1NTSGFHTkM2VHd6UFprSU84NkJtdHVpWjVCc2ZyTFlUTTc0ZGcrZzZOM0lQY3dPTGxrMHFzOFlnNSt6Z1VIL2F1YWxNbWlJRGtVVzhHOTB4c0o0am94UWpvYmEwSlNjNGtzSFk4OWY4Zit6ZFNaQmUyWFVuOWkrQlJHTEl4SnhBQVVnTW1SZ0xRd0Znc2FwSXNVb2lKWkxGb1lvc2tTd09hbEV0VWQxMnVNTnloQmVPc0hkMlJHOGNJZSs4OE1JN0w5d1I3QWhIZUdFdEhHNHIxTjJ5UkRWWnhab0xZeWFRaVRreHowZ0E2Zi92M0h4VmNMZnRsU2hXTWZJQlgzN2Y5NzczN3J2RHVmL3p2K2VlZXk3U1FjNlJHZFlwN1VYSnh1NTlKOTRsSDF5NGZPMmp5Y0Y1Y0s2bS84MzhFOGI4OG52dnZmZDNjVU03TWhKM3VmLzRuLzVwYjAvY3VxNkhlWER3MzU1RktLdmlwYkVoMno4WlppK1BuZG1xS05IbzJKNVpNM1VZQXRjT1loKzVxbk14RzJTUlNiNFY0TWFBbkhjK0hOM3Z1Uy9NV2REUVhKN25aUGx6ZmpjWktBaThZUEdMY3MvbDJBeUJ2OWpOZ1A5NlpOTktLeDJ4T2tPR3pFSklBaUFkME1RTnV5QVd5OHlDQmZGeHh1NmtyN1B6eFFWV3AwNU5oZmxjRG1OZVg2NXVxOFBLc05DcHNOT25uMzQ2bmRWV1NWUGxxbWNMTEl4U3h6SU0xYkZYaGFHS1JIWWxybVk2dEZXUU9yc09wNnlyd3J3QVJXZC83TmdoRUpEWGJoZ3RqNjdIN29HQ2ZCUUF4VXpBNXQyQmxrNXVvazNzWit6U3lyT1pkR3htQjVOMjZnUElNOGZZS3FzLy90dkF5clBrQzJCaGJ3RE5xelpSQ0hpTWowOFUwTzFPNkZaNU11bGxkL1N0VzBaNmtaRmlwVy85OHMycU82eWVaNEwwaG9mamdaTDhUazlmcXZ6d3Y1YnVVQmh6SzFOVWNPb0MyeVVUZ005bnJQcDRnRko5R1BLekMyUEd6bmVqSHZXSnVYcU90cEpPQVc3YVhkb085ZGlCdTNlSC9IaXBUMlhIVE5VWms0aG5tWWdENnVURDd1MCtkM1VqaitURDg3QnZzY2JKZ1BhN2RDa1Qwd1hyNHFzRW9BbHRUSFVVbmpUa2wzU1hSMForODkzNUxqOCtleFZqVHI3a1JlQXY3Y0ZNNU1DMHliVTJsS2MxcTBVTnpNUnBVRHFoQmc0SG5ZOThlUHowUjVPRDgrQmMxZmFiK1NlZDl0YncycFczOXV3WTZ6My8yVU5aSGJlazk3Ty8vdXRhcWJSLzcrNXNCV1d4aDEyT3c1alNrVUpzTW53SEJyd0F3cFpqdW9Dc3ZDWUFaMEV2b1Ewb09yOWd4c1FHRnMzRWtmTzVwd0UzUU05bC9RR05mRWhmeWtyQnpGZ0hqRjFqTlpxWUVjRDVSbUxBTUkwSXpHNkZvR1hsd0psUW05UXkzQVlJT2xGL0FJbFE4OWF3TEhrd2VRY0FGa213T1FOUERPVkdPcHVPYmhHTVRyMXg0MGc2dktHbkFEYUQ1V0kybWtCTWoyTmlVVjZlQXJmQ2pBeHBNVmJoSGljbjQwVVFKYUF6OFNxUWppQk1ZblN3aC9POXRuSlJaNndPR0JDVVR4MGZzRHJXWlBXWWZDc3ZrMCtLSHFZckJ2U0dLSUxCM3ZtekNWcVVlbFVHSFR2RkxYQTVmZnBVTWNrTm16WlU1NSthT2hPM3U2WllsQXZBOGpDNG1na3ROa3d4aEQybnM4OTdkdFZYZ0toYzNsTEJUQkYySU9ISndoUmdXZkZFUXA3ZWpPY0lWN0hCMUl2blBoVkZSbEZ6RzZPVWdJd2hQN0F6NFlYaG1qZ3pRY2prMGdHejUxQVM2a2tkK0R3MU5WVWd4b3NES0FKUllNWkc3WGZiZmdGZ1lLd08xWUh6bnRtbDRmY093TjFMdnB3RDlLNmhFS1R0SE1EMmZIbkw5bTJSNzdXOXNiR3hZdDJXL0VkUXk2MVMvY2hMTm1TdGM4cHZlWGhONUVXKzFKVzZqSkRYNUszbmpvd0lyTFVrU3VaODFZZEZNak94OWFzREwvTE90T1VaVEZCR0JhSW5LZ3V2SERMQnZrOUd5QTV6RGZtNmwxV1Q5d1AwQzVMRzNic3pWMi9jdWY2MzNjYXc4K0NjNnZ4TlBBN3QzdjNDbmoxai8zMU1CanZXWjRnOW1NNDdlZUo0eFZCKzdadGY3NzM0VzUvdkxWdWNtQkV4SjFnQVlwdXBXbUlhMExUak5uc3VQMmVZYXhpTkVRTkxJT3l6ODMweFdSQmdaZ0FubUN6OFdzQnMwbU9SaFJxZ25FK3ZwYmF4eFdVWUQ0MjV5L1ZtK1lxMmZRaE5Lb3BzSjFvZWNIYlhiSmJmZWdLZllneTJZODNzdnhaVlVDQ0VIRER6d0JqWjNQYVdNK0VIRUV4RXJvK2QyYkRVWWdwUjNMQnVvVFl4MXl2VDhXSklrSHlkaituQkVIVXdIZER3Vk1mbnZxYkR1NWZIQXBhR0JWbDhvYlB4WnZBN2dNSzJNRVJwZEF3UUd3Y1dWdHpKZzd3YXhqcUh1VjA0ZDdIM2xJMW9BMGhObWZDYWVKaVJRcHRvV3pQTXRyeWltSys2cTZYSXliLzdUUUphSm94RlkvenFTTVVEQUtNZmkzaWtaZUxQeENPMnhxZVpZakR4OStZYmJ4Ym9BZnFuMW0rb2JiZE9uaHpQUlBHNUFqT2hPOGV6bnlQUXBDQXBQWXdlQ0NxakVZTmwwcDZCdFhZUi9yQlFlVlpXUjRzZU56UFhIbTEzY1dCTXFTa1Q0SFZRVUMzdGp3Rlkyc0ROOVVCWnViV1ZQS2wzNzFVWHVVNDU1RU83czl0clAzTUJKak10b3JGMTFhYkloMUhQZE5wUmUvVGwrZklMakNtNEZxQ29MWlFCc0Z3TkxmY256eFhxTlNNWTdZN3hBMS81OVh3bUYvbnhUTzllcGFnanA5cFcyOGcvYnlONXhzYVY5MzRVckhZeG9UeVE3NW5RUFhqenlyWC82L2lwc3grb2szbHdWZ3UvWWNmZXNiRnRmUU1MaGxjdVcveTU2UXRuZnJCa1lPRS9lMnA0ZGR5NTF2WmVlUFp3NzVXdnY1d1lEaG5leFJaYk1URU1yU0xnajJKcThHN0dmbW5zemNIYUhBQVNLSHMxZ0xaU01OQ2JZUHM2V0M0QjdEa1hqbHpuOHlYbmNqNW1EWUx0eTZwTXNOUzJXTXdQQWZQN2NRTjdrT1hKRm1lSWVBZVFCZkszcThxOTJHMTFUTStRSnY5YXd1NmxFK2xNd0FMQXN5Y0NaNTBRZzhiZ2JCZGtNdWIycmZzRkdoOThlRFRwSlE3RVdpc2dzMHc1NWdvTVNPd0V5OVd2eEx2RFJOM2RwRy9HZm1YdXZaVGhNVkRqQjJ4VEFxQm4wWWxPNlR6MlU4dW04NXMwMmVsMVV1QUJLSFMrMUh2bFVRUTQxV0gwd1dlWVlzSFNUVXBpb2U3M2F2N2JJcms5NlAzbFgvNWxmZCs5YTNlZUhjK1JtRGVFUE1YQ3VCaWF2THFmY21zZnRuSUt4WHQ1QmVTekp1Qzk0VHNtYWFTaGJNeERYQWZGL2hnYXRHREZaQ09BNTNsaVk5Wkw1YW1BWFd0bGRjNk1JWC8yMnBNV3MwK21Nc0plTStHYWVzSmNPenV4T3NCcURmdVpqclRUTysrOFU5OTM3ZHBWU21oOGZMekEyZjBPUUEyODFKMzdqRmE4U3d2WWFtTUFEUWlkeCtKTkVBSks0TjBCdkdjQlAza0gxQlBqcCtNTnhJT0VpV1pkNnMwSUJkRWczMWtjRXU4Y2JQZmt5Uk5SdkZlUzc4UlJTVDFReHBpeitpTHo2a0NzYmVlMHY3NGd6OERZcytVTklDdURkdThtSVNrQzV3VFZvZ1M0aUtvcnNpQk5jazl4Q0NsS3huV1YrL2V6dWR2ak8rK2R2WER0OGp3NGs0N2ZvQ05zZVU4SVkvLzdINTU0NCtqNDVML1lNang0NlBsbkQvL1JOMTcrYXUrMVY3N2VlL2JnQVlGWGVwY3pzWFEvQU1GdWE4TE5aQVgyQ21zWEJheTVZUFZsaDFHQ0ZOR0w4SVV4UmdETGZCR0JjNzR2WGhoQW9ERm53SXhCNTRTMy9IdTBNSDdOWWRjQzd1dXc2VjBTeTQraW1tVmZ2SHZ4Zm9qSmhKRGFWWU9ORCtqZERFT3p5U2E3S21HdkFEVmhmZGdwOXl0K3AxTlRrOFdjZFJJTEl3aTJGWEU2Q1p1dURqNzdPUDZ4dzAvMTNuanpUUS9OeE5HbTVGVkFtdjdlTDM3eGk2d2dXOXZidDI5dm1UQVNkNlNZc1ZnZmJLdHNwcXc1R09EdzJ1R2FES1F3bURJcUlFL3FZT3ZXYlFVb3dJS1pBRXVTUjZCUmJDOW1FeDM0bzBVaHNaMVB4VnpDbEFGMFRKeXlNN3NHRVBrTTVLem0rN3UvKzd2eWFObTVjMmNCQnZEZ2dtV3BOcERLNDZNRTRoMFFrUGJDa05XZEVRcUZnamtiYVFEMWNuOU1EVTJkbnFvbDhzcXplZE5JTWU4YU5jUzBJUlFzdHJ3MmRjZmI1YjEzM3k5V2o5RURKZmt5dWNnRkV6Z0R5VTFKUTd1YUV6QnFHQnV6cTN2elArNkFFMWdDTU84QXl1RTNJTVZjcEo2MG9mWnlxQWVmdlZ6VC9hN01GSVJydFlQbisxenRUYlp5QUgzS0FqaGk5cVBKRDRCa2lyTG82ZlJrZ0RwS2RHUGlXd3VzWkRHUE5BRTBPM3RibHQ1TUk4MU9iRUtYaDhmaktqOTNSYVlmTy9WdzIyUWljcDI1Z09hSklkNEdiNHdXSW5SSjVFZ2VDYWR5TUl1UTU3YWlNNkZxVTFhaFpTbGJlMnZhZnpQbE9aZ2RoRTU4Y0d6aWIrZkJ1WnIxTitQUDZPam9rdG5aNi9lT0gwK2czcm5qNVpjKysrNnIzL2g2LzhGOW1RQ0xqZmRCUVBGV29uRXRETmhhZkxBNGJsNFluZVhUR0xQdGo0Q3M3L25XVWdsb0Exdm5nWEtaSEhKUDMyeGI2V1NoQ2hORFpMTFN5dDI1UHdCZUU0THQ4L0xNN0dPMGhuQ3hiS2NqQ0s3UE5DRzJnZGk1OGFnSXExNmVWWEUzRXVGTVIxNmFaZDlEQWFPTFdkaGgwbEpjNTJ2eDR0aVRpUzNoTjYxUTA3bWtpNEh3dXpXa0ZxRk84S0dyVjI2R2FUNFYyMTlqNG1zRFNueUVlVDV3bjlzK2xsMmxjKzNmWnFHS29Uc1czVEdtalRHSDhPSUFLaVoyenNidXkzU3lLUURQdjNWdDdLWWpJNXNMSkFDRmRIUkVRSXN0TVZ2Y2psZURTYURGcVdlakFOc1lNUW13RTVjWEJiTm1LdFQ5WHVvRUNGbjlDS1I0V1FBb29TMzVMN3ZZMEp2Tm0vMDdWcDlTRHNES0M5QzZUeHJ5TFpoU0M2STBGeHdxdzNFamkvSHhrelZ5Mkx2dlFDOHlVMHovOHFYTHhaQzNabk9CVkVPbFo1V2hVWUJnVkJpcU1nSk43bm9ZdE5FSGU3MDZWMTRnN1BrQTAwc2V0QTlnbHc0Yk5BWEdKVTQ5M1VtTURneFN2bDN2R2Q3bEVjaVRBUy9wQWx4cGVYV2dMWDNwK2gzb1NSZWpmdXV0dCtvNlppRDU2ZTcxVERacWRWWDFsS2h4UENVOEZ6Q2ZPalZSQ3FQbUNTSlRGK1BGeEc1TklWSjBtSzg1Q1RKcmdsTStIT3JiWisvYVhsdDZSaHFyUUptSFJ1Vjc3dmN1Rk9tS0FMUHJiY3JBODRUeVpkNUlIU3dlR2x4MGR4NmNxM28vL1g5R0E4d1RFeFAzcmw1TlMrZllNN1pwejUrKy9yWHByNy84MWY0WG5uczJLL2w2dlZQcGxFc0FZRmJEaWF3R0p3a2FFQUJLV0RHQWRnN3ptZzB6TGhyOFVmVUVhQ05NbUlUMy90a0laNEE1aENMQTFNRForVWNCWm43UWZWbSt6VEtTdnBjRkdWbnFTbGlUUGxjOHcvdEg4WFBHMk9KL25VazRpMHFBVGp3eDBvR0F3RUFTeGtoMHVNMmJOMWZITVpGakd5aHN6WEJjWjc4VzVocUpMbThJbmZSVzBtWlRYTkRYNHY1eUVidDU0M2JGY3Jaa2x6dlk4ZU1uZTd0Mmp2WTJwME5qcWN3Q0dNM3EyT2VGOE1RSWIySkd5YnozMUcyQjg4YUE4OG1USnl1dUJhYXBZK3VZVEJIdVlSb1FrUTVnbkQ4eldiOWhienFybFlUQURJdFN2b3ZuTGJ6SUxpVUJuZ2JxTGNJYkV3bkdEQWl3Y3B2Y05wWVhocFYyOHp5MjgvNjREVDZJR1FqZ0c0MllaSzJoZDk1dEk4YUVnYUduYWdKeUZKUWwyN2NyVGNyaDNQbTJ1azYrQlpmL3hScy9yNUhCZ1FQN3k0NU93UUZlOWxabGxpOFRnb0RLeUNKTlhlQUtsSlJCR1pWTm13QW95c3JFbWZZRFppWUNYYU4rWEtjTTduTy9hd0J6WjZ2V2pxNXhIZ2hMcXdOeHY2a0QzNEc3WjNYM2FRL0tBSXQrR08zRjNZOFNPWlBsOWN3b3pCWVl1NVdjNitLTndweGdzbFkrS2lSQTBuT3RDZUtSbUVhTTZpaUxNditrYmZsRUl5Sk5IbHZNbFFMaXlMbjhQNWxISk1WdnZHMzhscTkxTUNVYVBjem1OejdxZ0hrMmZxRExZcllheWhMOWpEVEhZajc1L2p3NHQvcjYxUCtORUgrMDdmcUJ6WnNQL3VBN3I3LzNreCsvbGtVbVk3MzdBYi9iWVRzYmhtUDNEVnplaWVBSkc5by9JQll6K21iV09jTzVSWWFZUUJhNEdtSUZuTlBwaXhIbnZXaHpaSXlnZWMwOHpHUkw3dEdKOGlmM3hwc2lRR3dSaE03MEtNTjJIVHp3blZqSG1TQ0tTY0dNdUVCQjNNb0drcFpnUFd4eXRqOHllNGl4QTZwclY3UDBOWjFQTEFyUjNIUkFTc1JoYnowTE8vb1NXL3BtT29zT2dEbnJ0SmZqK3l5RTUydzYwTzM0c2E0YVhsVWQ3VmJzMkpRT1c2UUZJb2FZaHc0L1U4UGRpNG1qYlB1dCsvY0ZEMHArVS9hbHl6THN6azRqNGxjTFVLU0RpVFZ5TmVZRkt5TlBuWnlJL2Fldk56bzZsdlR2cFdPdHFCaks2b1Y3RlAvbzlQa3lZU3hZQ0VTdVIvR2x6bUkvWGo2VWhSVlJmRmZUSm9PeFdhY3lxNzZBbFVuSXV3bHV2enhzMllwTHNiSXQ3UjRaMmRhYmlNY0JENG9sUzFwNDBOdFp3Y201RzdocHBGbytIclozTFdhaFZiR2YzcjB0Sk9oMExYb1JzN3BzNjVuRU96VTVHZnZ4clFRUE9wbDZiUk5iUmhQM1V6NDdiZHRhakp2Wm1hblRCYWdqSTV1TGJmL3NaMzhucTJYT0FISlhZcnZ1dHNteXVhemZMS0JoTytlU3VDVFBaSEpweWo1cHB2NTlwd2dBbGVzb002RGZUQUZabVpyZktWUDJZRjVFekNya0M5TUZrcFFWMlFMRzNYbm5BTGp2RkEyRjFHemp3cStLS2QzYy9LVGhkOWVTSno3cmdKSE5sN3VscmRDMFJ4dUp4UU1qY25pVDZhVkdLOHdSQWR2SXc4S1k2d2JpeG5nL1VSTVhaZExicGdIMzgxcVE4N01tMFNQM1EybmpOV2tEOFZDVVVRUkRDa1hjR29WMzdrSG1YZXhxYnBUSkhHVkZhY2w1ekZzclYwUnBFUGI1NHplbkJuN244TlAveFk5KzhMMy81YVdYUHQ5YnR5SmdHU0Ewd1JaK0hFK0VEQWtqMkpHR0FpR0xObWg2cis0QUxvNzIzbXg2M1cvL3dYczZHR0NvYTl0dEFlZVAvVkFmQll5RHQyVU1HUW9ESzV0MWhQTmhUcGIzUUo2UFlmTFNvREFvaE1oczdIdzN5M3l4T1BZN2pFYm5TbzZxVTJIa09xY09hY2R0djFFQUR6MDM1U3JoemptNjVGNkFjSDJ4cUltNmZtVFRsdHpiSDZDWjZHM2Z2aU8yeDZkNjB3R1kwMkZ5Yk0wM0F1d21HY3RuT3FCNElVTjlLeG85VXlmSGRnMkxzVjJlQnBlaVFIYnUzSlhQQWNjY092N1FVR0pXQjVTTkxoNkYxVTVQeDJVcndHeFk2OERnVFU2YW5PcVByWkZDb1l5MGdjNnJQaWdib0pUaWwxa0U0elg4bGhaRlZqRzJJWDhhVUg2WlRreklTZ3Z3c1QzWFlvZlk2VTBjcWhPMlZsNEdSaTRUOGNMQVhvRU04NDcyZStHRkY2b3VNV1RBcHJ4R1VzcUxMUVBTRHo3NG9OemYyTmUxQzY4Uzk4b3pUeFlzRjBDNlYxbW1MMDFYdVRGWjU0QXI5and5TWxLMlllQ3VQZVNiQ1lidDFjcFI4d3FBdEF0enFtN1VoK2Y0ckg2ODVLdmFlNjdPT3JNSDhNV2d0UmR4TmdJeDJXZTBVT2FKUE1QMzg1bjhGSmFBREpsTUJKZ1ljUzBneW8zblk0WlJIaTlwZWFaOCtlNGVuN3QyVlEvT3UwWjd5cXZBVlMyL2JXUkRPVVZLQS9KdHBldjlLREMyWnVXZGlUSi9FT1ZZNmFZK2hIcWRCK2ZxTXI4WmY3NzF1OC8vOVBYdnZQcWZIejY4djNkZzM4N2VyZW1wTUxTNEkyVXh3MUorc0JtaTJZMmhQNTJPb0dUQVZjSkFJTHk2ZzZEVnk3Sy8vNThqVnhWUXVpUXBWQnJBdVV2cmNYWWFLZnR6WmlnRjdRbGtaZ0dLb1Y4bWRNSitrUWh4SHZnVnM3YzZ6L3d5VTBQSmRJWXdTS3lsODA0d2hCMEk0REM1Y0sxYktZUmxPbFNidElwZ3V6ZUN6MlREckdFNTh2cTE2MnR2UHdIcmQrellWY3pVNU5xT0hkdlRzZThIbUNjcnRnWjd1bVhzR0dSQ3FkWkV6YnZ2ZlZDZDBxdzkwd0xUaGM2NGI5KytLS1dGdllsTURvMk9qbVU1ZlB5TVkwTEFzSUVrZDBCQjlTL0hBMlFpNWhEUEFTVHNwL2NTd0lpaUNYYUgzVFkvNkZwaGxyUnJ3ak5BWFBib2dPbkRHVjRER1dXRTVTNktDeUxGdFNSZU5CU0p1WUlGWWJlQ05ERnRVRmdBRWZoUW1FQnJRMVlneW5zRjV3OFFpS0sySW95VDRoQlRJaEhSeXQ4WHFEQ2pzTjh5RzdFZkczYVBqWTRHcU0vMWZ2YXp2KzJOalczdnZmVFNpL1g3aHg5OFdQWlp3QXJ3K2ZreVB6R2RXTnhDbVJrRlVCQkFYTjZBSlpseU1KVTRMQURDbXFWalVyZUxzS2VlNWJtVk41TzlhUk9BSngxQUxyL0FqMUwwYko0WVBDeVliSWd4SDNCekN4YXBVRFR1TlVHb1hpaDE5MkxYcTZKTXA2ZmJBcG5yOGJjSHBMYVlBdTdxb0NJMkprRWpNUzlJWC9LZHZLL0xDSUYza0hBQlpBNHhTTE5XZEVHckNYbm9xRStqSHUxT1NaWUxhT1QyZnRvck4wU0p0LzdEcTRaeTRKK3ZyRUMvZk9pcmx1Yi9mT3ByNEV2UDcvM25mL3BIZi9EUGZ1OUx2eFZ6QVEwYzVqVWoySTJKdnBnc0FISEFMeDh6M0E0VXBWTmtoQlpVMVdIeThqNzNPUndnY2hobVZ1OEJFaEkvZHp6NUdSUHVPcHdyQ0xkWGR6eE81eUdBcGhFWFovSkRiek5VOXhnTXFTL2VHV3lvbG5JRGxka0FrOUNqdWF3OFNPNWxrZ2JndE1taFcyVm5saS9uZEZCUEFwWmlkY2lYVGw2c0toMEpRTWZRVXVCMUlUWkh0a1VUWE5oYkswTzhPdUlWa1M5bGd0Q0JJU2FHeUdNQmd4clAwbXpoT20xNTd6Y3VkSU5oZ0lhbzJQYkNnQ1NQRFl0Y2xGdW5INHc5MzRRZlU4blM1Qk1lQVhzZUVoZGk1OFNZbDJaSXpLVnJjWUFMb3dRaXlvR2w2c2c2cDZOdlljcVFCcE5uYVM3TElpSWdQUlBUUzdSdTZpMHIzcUlrdXBqVVdQU3RMRzIzSlplaE10dC9HLzRuTG5PQWsvc2VwUVY0dHlRSzRSdS9mRHVqRG5zQlpnRk5sQ096Q0ZHd2FRQ1BsTTk4NWpPOXNlM2JLNTN6RjgrWHpYNXo3ck56OW52dnY1OUxtMDFWdmdGdTJWRlRuK1lETEFJWjNid2xFN2xQdFdpQ1liNVdWUEx0TmFGcXN3UW1MbVhUOXZMS284S1NlK1ZuNXdaODNDOEZrdW9ta3hlY1Y4MjhBQUJBQUVsRVFWU2x6cG13VEN3TEFhczhUQktVVHUxMGszb3pjVnU3ZlFlNHU3cVZweHB0MWVnbWl6K1NIM1ZrQkxkdWVFM1psKy9GVGkvTWFxb2dJNjdock1wY1ZYSldJNDhBTUVWRDNyRm9Na1RXdEx0emdKOWNOamxzd2ZkTkxKSlg1WFF2UDN1c21ZbE1mNm1ORzNMTy9aN0I1S1ZmUnIrWFRNNHo1MVRTcC8zNHl2TUgvL3pIUC96ZWYzWDR3TzdlME9LNFU2M01yaFRucDNwcnN2ZFpaRGdOSGh0c29BenJ4RDVvZjBMOUdITGsrQWhnSTNBT3dPY0ZuQnVRMWVtUFBuZm5zRytmM1k5eEZqalBmYTg3QXM2ZXgyNjZKSUNSQzdQNUsyRE50UUc3eHVRQmRJTE9oQzBEYVh1czhab29PMlRzMFR3VHhDakdIblVjSGNweksrY1JmUEV1ZEJLSGErV2FIWlVMbVFuR3h6RWgyQm5iekQwL1lSM2txZXpTRGNnRmVkTFI3YkJ5TGc0dTByeVZpRzVNQU5zeWtYWDA2TEZhbE1IUEZ4dkU3cUZYVGNDbFJzMnNXN20zZGZPMjdOUnlQbTV5VTdVNTdhYXM3TE10bGYzbGpDaW1wazdYc0Y4K2w4Uy85bExNSlphVmk4R2g3R0pwRDBkUnNMY3o4VkJPSnAyMG5kRUpIK3VCZ0xKekZhc2p0dXJtSGNOVVlqUFNoT2RNL1hVN21iQ24zdzhyUGpGeG9rd2dKc1hzRklPOVlYVkFBK05kdDI1RGpRSjI3OTVkWU1WM0dUQmltWmorLy9tdi9ySjNJZ3JxNE1Gbm9wejZlbS8rOG8wcVB6TkJUZTRsUFNNWTVvc2E0WVE5Yng3WlhLelZoTnY0aVJObDZxR0FBSnEwZ2JoNm9BdzNibjZxZ0JuakxmL3ZwRVZCWUxXQURvTjFrSzlPSVR1SGtib2ZPd1pxV0tmZnNYTWc2UjNEWGxheTBXSmU4TVl4WXVBS0IvZzNieDZwTWpnblBURlJ2T3NuTmpFd2djbm5YejFZWU9OUUJzK2lRRDBYdXliekZLdm5PUnFqYjZhZDlMQWlJaGI5bE5kTTVCWUR2eGM1cjhVbjJqbjlnemNJOEc2eWE0VnV5cDEwNThHNXF2VFQrK2Y3TC8vMlczL3dnKzkrNS9QUGY2YTN1RC9zSXgwKzhKdXdsdEhZWWMwRWh3QVE4T0JldGo0S0tLYmg3VlR5S0d2NjJVNGJTd1pObUhCanpSK2ZhM1VEaEx0WFYxdVljd2ZVdWJFRUU3eTNaK1ZUR0VPQmM1N2plWGxZM2dNb29RWnN1Y3daV0doUUtSMHg3a1FCSFl0UWdOL0RkTUtaZEZicDYzZ0FGOHVTMzQ1Wkxra25sSDdYaVozdnorOU1KZmR5N2NPQUJ4OXVRM1VUVEVEblFkaVpXWEZNOUVwWWNYbW5oSzJ6bVM0Tk03VmlVVVZ0RzkwV0JYYytMTTlFWWlhZ0FpcDJVVGx4L0hpQWFHRjJqOW5jVzVGSlZjQ3liV3NtWFFNV1ZxWUJYRU5qN21lckF3Z1V5ZVRwaVdLUGV3S0NpMkxuUFpHSk9QNnpBdTE0cmc2TmRRS3hic2l1WE1vNkV6c2tBRFRaQ25nNnYyaS9WN3lTNU5Yb1F4NU5QbUZsZk11NWZUMk9FbFIvZ0lsbmlUS2JjUFE4eWsvd282MWJ0NlJlMXRSQ0RIbWVtdUpoZ2dYMjkzNzUxdHMxZEhjUG0vRGxUQ1plaVp2alo1NTl0cmR6MSs3eXFtRVdVUC95cG4yMGdSV1R2cjhUbHpaKzBWM1pPb0RHNWwxbnprTmVUSjR5UlpoRVpJTUZWQUFhYTZiY2JFUmdCTVpmR2FtNFlvVEJ4RFd3ckx3eDJHeU5SSEpSS1YrVGxkSXh0bXIxbUluSWdDSWcxVTVZOU5SVWxwYUhxYTRiSG82U2FpTW9Jdzl1YmhTTkVBYk1GUmk3RWRkeVNpWFA1dW5qbkszSXlneWhNMFQyc2ZZeXphVGMra0FSb0pDTGlIYVUrRUNJZ2RGUmdoN2xkKzJhcmhhZ3Q4S3pzV3BCdmNnOS8zL0FuUXpNZzdPNi9iUWVYM3Qrei8vNG5kZGUrY2J2ZnZIRjNsQnNrY3RpaDh3QzEwUnJ1eFozc094SW5EM29MQURCYW5sTXpCSUtJcHNaWmQ4alV3V2t5ZzlRdXhlQTZNQzhBK1FuMzd2NkF1Y0V2cTVQNTlIUmNtTjlyK3VML1lVQlJjajdveVFJcFdBK01RQVVtNzhkY0hRd1pUeE1wN2tSLzJzTWtFVHJIQThEU2c1cHNTMWlYR1VPMExIem5DVXhCMUFRenN0REZ4VGZCcWE4UCt3aHAreThGSFRzVmJFYjM4Z3p4U1JlR21BM2xNYVNiU2g3ZVRxMjBuUnd6RFZWVm5idVdyV1kvSGkyeVQ3cytiMzMzaXNHemFWdVV3RGF3bzV0VzBjTHZBSGlqVVNWSzVmRTVPZHhHQkJnc251ei9KWmJXaVlFN1JJdXphVkRtY0RMa0I3ekJVellGWmFPb1R1L05MRkJCdUlOQUF6WW80MGFnS1NlemRXTCtVTDVCM2szcEhPbllxTUlKc3NmZk8zcTRkNzZrWFZKcDhVcEFjYnlMLzZ6eldFTjhjZHpMWlpvUXJWQ3JXWUJCMUJoNmhpUHJYeGpiTlk3ZCs2c0ZYNmVhVS9HcXdsYkNzeE44cTJZMjVtbFZoMm1qaWtxbjFQbEJiWkR5U3VGWmNJU216Y0NZRTdRVnVyenpuM0I2NXNiRzNPU3ZGN05wQ3g3TTNDM3l0TzEybDhia3pYMWlIQjQyWURXOTQ1VkExNGc3QjdId3F4RXhZd0JvZm9GZmlzeVNsSG1FeWVPWndmMHkzR2R0RXQ3WTlwSmFzNG1QVk1LaGpKbnNqRnA2aG1Vam1zcEY2QlBpY2dUNWVTWm5ZbktlZGN6dDBGcWNtL3pDZTBqTC9tZnZoSkZrYm9BNUNvc1hhVkdqT2tZK1IrelpHUnBuam1ybkUvaDhmeXorNy8xbi82VEgvLzVTMS80WEJvM3cvall5L2hOM3Mzd2JKQVd6dWZaMkNVTEpOTUJCTWd2b003bjJVZ2hvbEVUL3ZsTXdQLzlWNnNTWXRUQThmL3RQWGRWK2dTMWJNc1IxQ1JVZ2twb2lTSDJNeFBUZ3FCRHRxbkNuS2tLelBsV3VTbWxzNFdsWWNyWDB6RWZwdU13YStoVXk5TFJEUmV4VDBORGJGT3duTVpzc2pBaG5SZHcrUjFqVmxiQXJJUHlhZ0FLV0tjNHlNd1ozTWx1SkkzMU1XdXdVV0pYRmgrWXlEdDdaaklzV1N4a2l6ZDRDbVF5THZlYmhNUTh5eXdTNExRTUdrUEVPR2RTUmhPS2JNNmVyUjY0K0syS2pSbllNTk1BR2VFOU1XUkQ0djR3NTYxYnR1WGFUTm9adnVZK25WUzhaeXY3Tm9UaFdwd2gvMzYyUXpWZ3V4d3ppTmdNUUUzSVNydHJ6OGJVQU5nZDBsWGxBdnlZbU9QVDJ4ZGZSV3lZYjY2dHN3RGhZTXFTaDZaOHNVOW5TVEx3TVp3WDN4dXo1VWxCb2FqMy9nVURjZCtiS0dBRVFCYWgrTzJERDkrdmliUlZNUlVkT25TbzdQTS8vL25QaXlVREp2V0RuZTdkdmF1QmFPcFFQVkpPUUt4YnNMSjJIWVZuY2k2YkJ3VDRzR2YyYkQ3YVJpbkFHUWl6RzhzalU0TTZOaDlnd1lueXZ2dnV1NVZ2NWdkMTdUbmF3dmQwZ2dKYnoyV0drUVlBQjY3ODNZMlMzTVBMeEFRdnRvNGdkRjRuMG5FZmVUTDY4cTUrbkFQWUZCU2wwYVhyZDNMZjVDQWoxcVROZkllTkd4M2tTNTVqUVVyYkVjY29oeWNPT1NYRFluRFlxV2FSanBrMm1nZG5rdjBwUFA3ci8vTFBqbnpsdDE5S2c4Zm1SUnMvRGhEZHprVExzakNPcFJtKzNvMS9acitBNjRaWnpWUlJzOXNCTVVNcG1oeDhpaHJYWHJtMGdCdDROd0JuRzJhQ0FBSUVOZi9yQlhTajU0c0ZZMW9tUEFoa01kZ0FLNEVucUgyTGVHaXdPZWVPUExOWWxiemszTXk5dU5QZHllS1JKR3BEMWZEdXVXWGJZVU9oRVJoaGZpd1RETWE0TkVOK3dGOUJoTkloSElhTHlWa0plNFZlVEVmQURPL0Z2NW5KNEU0WXFxa1hFMXdWNEQ5Z2JGKzNmWHYzOWk3R1JzeUw0c0QrUGVYRzk5Njc3NlV2endRSVZrUlp4RVVxcXhQUGhVbmVpMW5oYWxnbWtOZ1ExenMrMTJmT1RtWllyb3k5WW5yUFBmZVpETDJqSE1QVW52MXNGdnhFQVUxbUljTzY5WW1iRVpBN201alYzUHBzUE1CRmlsMzc5T254R2pZREU2T1poV0ZhdzhNYllnL1BDc1FzeXo2Ym5idHRvNldNV1A1QUZPNzlESk92WlAvRHZNWFRJREdQL2FQRTRnbXpJQk90dHIvaXEzMHBPM2dNRFM3dWJkMjBwWlRkcXZqTXNuL3paV2VMdDdKelpPUG1LdWN2MzNpemQvVERZMm03UjczalIwOW1JdkJzblRlRi9PQytrYzNqM21jT0g0eGQrVUpHRGU4V2E5WXlGd08rRHhLTHhhckhHeW5QZ1gzNzByNjhhTmhUMit2OWpESjI3dHJWMi9QMDAyV25wWnkyYjk5ZWJZbEJQMGg5UElvSlp2V2E0ZVNOL1R5amk5VC85TVhwQXJUTFVSeGtpbXdCVkM5cEFHbjNNeTF3SzJ6ZUViRnBwNjc0ZHhzTnZmM08yMUZndDNyYnhzYXlWSHM0QzM0dWxYSmJGODhPWUhuczZMRXczaGFRYVhnNHNjWnpCQitML1pMZGg0K2lHU1A3QW1OdDN6NldvRnFicXZ4SGp4MkpQR1BnV1RDU0VMdVVJeHMyUmR0Y0hGdU1FL2N1eWdwRU1UeVlqOGo4NDhmODBUUG5zakJCbmhaSHppSlQ5eDlrb2puS1dBeHRNME1QMDlkaVRFbTN6WHhONVdyK3o2ZXFCdjdrOWEvZi9lYlhYKzUvS3M3ek0yRm5qeUpJbEcwZ05ZTEg2VC9lRVduNHg0QVpjQWZVMnF0TjlKa0k5QjNZL2o5L2F5RGIyWjFyZTZxS1BOZXFCK3RwTDNhelBEQnBOM0RtNjh5OUtYQ2ZkQTJSRGFGbjQ0eVAyWGJnbkMrVm40VmhENEQzUVlERTg3RUdqSlZKb2RtUERmTVM1U3REVVIxRldkZ1JnYjRkV25STXc4YUJESnNwamNwTFV0U1JXN21TZHRpSXlUWTdoWXRDZGplTWlaR3pZaVlrSDRidUcwYmFDajh1VHBpdG9TWDJoQmw1cG82SENURWg2TkQyR0pSWHpJck5kT1dxYkhzVmRyZC8vLzdLbThsRkxNL0NCcmJZVldITVpRdE5SV0g3dFFna3JtWXFyc3dreVR2end1am9XTmswc1dIZ1EybTJpYk9BUk1yVTJYRjFadXlXK2NoemdJTnpsSzN6R0xlRGVVSDlVWWlhaVZzWE5pczRsQTEzN1FqRGhqMllPblV3ZVdneklLZmRNTUh4OFpPMUNLWHV5NzBtRFprNGZQZE0rVkkvdml1TFVLUHFuTEpSQnN6NVJzcld5WXgyOHB2Mndjb3hiTExwZDlkTFU1blV2WmN5VW9wWXRtZG9GMllHOHNDT0RhREoyNDRkTytwNjllamxQblZuWmVMOWpBNm13OFMxaGZnbWdrenhBWmNIejhEWU1XbnQ2ejdLaFl6Skt5YXRuZG1tUFUvYThpZGQ1U1YvOHUzZDg1ZzczT3NnTXlXTGdWZUtCVnV1ZW9qOGRmVkJCZ2FpZlAyT1dOUmtjQlFkVzNwRkZvelNuUWZucXM1UHo1L3Zmdm5Gdi9vblAvbnhqdTJqbzcyRllYNEFLUDJ2L0pqNVpUSUhBRlVURDQ4VDFaNGcxb3RiV3o1SEdqNDZGMnd1TU0ySkpqUWxLRXdVZ0RkY05rTG0zWGNkdmQ2bE9mYzcxdW9vQWN1NURoeDlKK0NQSTR5Rzd6VzB5Nk1kVENwTURKV1hyRTdVS1FpajFYL0EwWGREUGNKcU5aWHZPaGJ3MTVHNHMra29PbXQ1aUtTRENqWURvQXdUN2M4SENKa0FjaUxlR0l0cVNHOElhMUp5UlJRYWtGcTdOcDB6bmJXZWx3NXZ0dDQxZkd4cjVqMzV2eDhHRGhnTnZibm0yZE1QT0FNSTErdzdjTGo4WFpYYnNOeUVrY1VkSm8rQXpVeFdnUGxOeDFVRytSNC9lYkk2cjVqSi9HeDEvbldKTkdjSVBEVjVwb2JQRnV3MGNMYnNWd2NXOUNkeFJnS21BdTZZSE9XcnZYaEpBeFBOWU5nTi9OVXIyeTF3WGhxM1ByR0thNGw5dERmYnB4R0lJTzlHRTJuMXlpdlFFZjRVTVBDSU1jSVpHeHVMSXVTM2ZMR0FzT1huWVFHZG9UMmd4QmdCSDRBU3RwVEpnNWtFb0JiQTVYbE1GYzFNd0FYUTVnSVVnS0UvRTFkczhmbW5MSURXT1o0bGJZZVZLRnNBRlZseUQyQm4wd1dxMHFaTU1WOEtRZDJTQjM3cTZsTWQxSzdpaVlSb2lUOWxmbTh1MGh3VGd1ZHIxeXAzMHUrQWxRbUlJdkJNTzlSSWs4eDVsalRVUWZkczdhbzlBWEpuWTY3Nzh0MjdvL2Jhakx5b2QwZUswOTZUL3lwdlZwaFM2R0xjcEJyU0R4S2RNWFZrWGtaOXpvTnpxNjlQeGQ4RG05Y2YvTk0vK2NQLzl0bkRCeEl4TGt3d2pXbGoxREpSaFRIelp5YU1HVkZwNnl6NGFJSE0rK1pjMnZKakV3NnorWDdQUlFUWnE5UG8zWGNYNnVEdC9KekdEekIvZkxEMXR2c0pvL3NJZlhkL0ErY0FlZklFNUdzQlNvQ21MeDJRNEVjK0E2cHRXM21NMlFJVVF1bytLOE4wSXVhT0RweE5FbUVxSnFTOHN6bmVDZk0yeE9SbGdmV3dZMk04S2dBYjZzL3pCRWNDeGxmalRzZE5heVIrdXRNQkE3R1dCOVBaNU5rRUhqQzlHeWFJOFZFVVZzSHBnTXJHUTZJcGtPYWk1enk3NGRxNG9rbnp3dzgvN08zZCszVEFabEV0emhnYkd5dlE0c2NOVUlBV3BhRnVzaXROTVZNZDJnNHV3RTNudFNwUldFcEFNQnl3VnU4bTdnQ1dGeERqS2pjNG1MMzZvb3hxWkJKL2RzQm9Fd0xNK1VaTUhzb0RFQUgyaWp6WE0xYXNhQUhzMVVYYklHQ2dBSStIZ1dYcnZEMjRzc21qUlJQS05ycHROR2t2NkwzeHhodFZCK3FoTXljQU5uWmZpMlcwaFJmL1pYRkRnQ1VnVXdlOEhKaVJMcVdNbm1YbmJncnNlcTR2cjVuVURRQ1VudndyT3hDV2h2U2ZpZ3Nia29HQkd4VlF1dXFCeXlUZjgzdVJpUk1uaFB1OFhEWm05WXoxZXo3Z1pKNHllZWs4dXo2WjBJNG1YUDJ1SFlFaDEwRDFXTC9uMlQ3clI3YVRzZ21FT1pDUzBTaDdrM1VmeFJ3UDJqTGgzSTd5QUt4VzN5NlBJbVkzcmgzTlkzNGl2NlVjOG54dDF2VVY4bStpbUpKSElJeDJrUUR5bjhmVk1RL09INlBOSi83VDExLzgzSkVmZnZjMWk4U3kwaS94SEdqdGZKbU5TZUIrekJzWTlFQUVoR0FaU2xtaFZ4MC8xK1ZrbFkvUGNlZVQ3QndtNjVVTGl4MzdETGhMeVplZ09KOVhXREJiTUFaTmVwd3IwTWgzSVRpQkwvT0Y5KzZ6TkhOaExVMTFEM1pvVXBCWkF6c1c0Ri9uS05laFBOR0NDdCtCSkpwaDZUbm13c1NBYWVoTXpCbzZJT2JHOVFtVDVZYTBNTS9oT21mWVNxbmNUV2UrbFFrK2ZxczYvSVVzMWVXbEFkVEZnUkMvWVRBVFhFRGQ5U3N6aWFjQUV4TW5DeHkyajQzVmN6emZUTDlKT1JOaUpncWxaMGgvNGRLVm1sakVGUGZHanMzMUNzdGpDd1ZrUS9HK3NIb05FeFZSVC9DY3V3SGN5OU5Ya21ZQzZuQjdUSDU5dGxrcU1ESFIxSUh6OHVXSmoxSGx0ZU56WTg4NnVEWTFRVG56S1BzbUp1OUFXeWRud3ZHOXJhN0xrdU9FWFZXWGJMSDlpUzBOdUxXTjJDZThWeFpuUDBYTVRSQjkrYk5aZ1IzSUxRWlJ2cFd4cTU0ODJmWUg3SWJ1Mm9BeVl2OFZSME9hMkNZQU5ScWdFSUNoa2NUU2JHb2cvNWk4clpnb2tWSXFFUzdnWkVQYUhUdDJSb0cxNjI3ZWJDc011WmhoejRNeDIzZ09SYWFlS0N4QVIwYWNHOW04cGQ2TkdvQTdrNE1YY0orYW1ncVR2aEVBYjVPeUsxTmY1UkdTOWlON3lxT1BhRHVNV2RwV1UxSVVQaHRCMllDaGMyL2tkVUlKWU5zVUNzYnNWV1dQc3BFdndDcWY4dVk2KzdHcEw5ZVFJNk9UQXVPQWY0Mkl3cHpaeHhFUnk3Y0J0R2Z6VkNKejgrRDhpWWZrbHNIbng3Wis2L1hYdnZXVHp4emMwNXZOZGs0REM3UENMQ0NjOWl5Tm0xNVhab0NpVFBsQ1NKZ1ZOSGErVkNJbUJnbVFGeTlRdHE2TzZkWjFUOVJGWFJkTjNnNndENU5iZXRJV2l4aFQ3KzV2MXpVYll2YzVEOGhOVmpzbG5ZQW5FTWVjeFhjb3NJM1pvSHNPVTB3VFNzR0cydXgxZW5SMXhCb0p1TDhFbDQ5dUMwMlo2Wk5pZVJnYzFvSGhZczVpSk9oY1ltVUFKa3pJcnRXT1Jma09SREd5VlFGT25kK1NhME5iTm01Z3BLTnQzYnE1ekFqdVlTb1NvMk5qRnBld1R3TWs1YjU5SjBQcTNDYy9odnFpNCtuQXdFR0FwYk5UcCtzNnZ3djRvOU5TSGgzYlhKWTRISUJNRkRSMXdtemgyb09IRHRmQ0J6N09GQkd6Z0h2VUZmRHdmTi83SWdNNnZ3VSswZ0hPN2dlSTNQcWVpZ25BS0lLcklCYzlibmdVaGUyVktEVVIwUUFWNEJkcmdxY0lON08yb0NVZ2xlWmpYMldxWWQ0QWZNd0s2c2hSbzdUVWc3cmdodWlRRHdEa25zRjhCajVNS2ZZenZEUXRrSC9NR2ltSHV1SlJvVTZBdmZmRGh3OVhQYW8vY1R3dVpSU2puYXpLOUU0Qkt4ZkZleU1qSWNwdWVPMXdzV2pLazRjTGN4Wm16YS9Za200YkZVdHZhUmJJR0JHNG4wSUd6dTRuVThDK3RXbmtJN0tpanZXajFhdWphRExQWUpTMUxDWWlDb3RMbzg5aWlnTjdhWmtJNUkwaGxLb05laTF1VXEvbUpKNDhLRlhQOHl6eWJ4OU5zbWIrZ3huUHlFcytiV3VtMzh5RDg1TzE5d24rL0pNZmZQZkkxNzc4TzcwMUdhTDJQYzVxc0xUY3dyRGdjcHBQU3c3a0JOQUVKTmhKYTkyd2F1aWRZNVlwWXc2WTAvb2xKRFE1dTZORkZUUzVsL3M2ZHNOV1daNGI3cGVNMzNYRzNPZWRvSDNFa24wSHZnWEl1VGpYeW9XSkp2N0UvcUgyOHJNbzl0TmNIcUJyaTB4MEdKNFRRQm00MVBBdXdocnNMMEhXOGJFY0J4Y3dCd0ZuMGdBRXhScFROdmVxQTRjT0NmQU40d3YwOG55Z0RKaTRtVm15dkNGRFp5NVZnQ0VwWnR1bzh4VjQzeEp6TzQ2WXpNTjY3SkppT0N6UFhOcUFwTEt2Q1dBekZadzlleWJEOExET01MM3BBSkFaZnF2cUhpU3ZBQUw0eVlONjdVL2RjVzBUczhLTVA2WGdPN1pxeHhOZ3kzTURPRjI3ZHF0czQwd1pseTVOcC9NM1JvazFZOGVMbHpZN1AzczdRR0dlVUFlMmo3Sng3cTJiMTZvT1VsUFZGczNlbjZGMHlxc2VSS0ZUUHNwdGRYekFsWS81QjFqeHViNlIrQ0NqbzZNVm4rTG8wYVBGSWp1WE8zVWd4S2FES1FqN281aUFqWU81aG0yOFk0cGQyL2pkeTdYU01KSUIrcDZEL1pwOFU3ZVVKdkFyNVpNMnRrcFBYVlc3NWo1dFJzeXhabWxqNnRyZTllNTNuVzI1bWdrdDh3ZFJSQ1krQVQzR2E0UkQ4VFg1YVg3b0FCVTRZOHZBOWxwR1dFWVU3TCtVZ0VxOGxBbmRxMkhicWFyNnJaWmlKeU10REVIbVR2SjgxNVZNNTZPOFNFKzZSaXpLTG05a3EyOWhHK2tnRTVRelltRlplbzA5ODRCNWNDNVIrbVQvK2RhTEwvejBSOTkvZmYrdTdkdGl3c2pDaW9mWnZEVEx0QmNCd29BeGFRRFNBTWRuUWxwc1pnN1FsSzV0dEtxYk5nWktRSXQyOXdIYlNBSnB5MmZ2YzFCYWdpV2RPaXhjU2Fjb2hNM2ZBaWpYNXB5WDZ6eTNBMGYzSkVjRjJIaTZqbFRLSWFBdGZvTG44OURRbVpnMStBUmpENFFaT0RNZlBNaDVJS3hzSnNKMFFyWkh6d0lnRDhNOGRGZ1RRa3dUWFI1MERNTkl3WWVhbTFPWWthcEpmVEhIakczUFpGZUcya09acldjbnhicllHNDhkT2RxN2tKQ2JPcE1RampxUVo3SlJZbTdZcFU0b2o1Ni9PUEU2RE9VeFB6YlNUU01qTlV5MjN5QVBqbVZSREliRHltb2xtbnU0MHJrZk9NekV5NmFHLzJGd1BEd3NlZGFKVFpRZE8zWXNMVFdRN2FDZXpwTG9MYlZTa1RjSHRrZTVlSi90VThZRVU0b1NLTVlYcGRlQi9kazg5M3lXcEErdlM4Q2ZNRVkrNzVneUJieHh3MGkxOWV5anBrRGRpM1ZiV3N5c0FieUJpS1puUHNJeWdTWWdQSGp3WUUzNnVRY2JWejlZc3FEMERtWUNlZEt1ZlJuV0N4aGxaeFdLWlVzQytWTlVoRXg3bXRDempOMWtwL0pRWk01ajk1UVpsME1tSk05d3FEL21BdXpkSElITkVIeVhGMjFQVm93b2dMdzZieVFsU2puM1daUUVuR3Zic2JTdmMvSktUdHdIN0NrcDl5bjc2Y2xUdGNla2NuaStsMUdCRjFBMzhVbnVpeVRrZnRmNXJHMWRLOS9uTDE2cHZGRTA4a3VoVW9hdVV3OTNNd0kya3ZKY281QkdyTmg4OU9sNWNLNUsrS1QvK2Q0clgvN3BxNjk4S2ZZOCsvNWx5V2M2RGJQQzQvZzJBMUtpeS9PWGo2U2czYlB4cnhUb1BydE01WHVFTnI4OVltdUd2QkVHZHQ4K1FKck93L2ZaQzR0bUUvVGV2VnhiQzFmcTNpUVN3Yk9vaEhadndCNkIwb01EZXYxV0owWUE4L2c4aDM5eUpqZXlNS0tlSDJBV3c1a0FHd0l1RHNzWFZjMmlHV3ladlJ4cjRkVlJBWmtDaWdYa2dhZUhVRDN2SnZ0NFV6ek94T2RBZkl5eGJxWUNrZGJzZjJlVkcxQVY4SWJYZ2M0QVhObHdiOTVPUEluc21ZaEo2OFNpc1MzUEV1NlVwTGNrZGVGbDJINDdLODZHRXVsdUlMWllQc21LaGxsaE5JYWJnekZEWU9JNitxMEEwTklzYWttTmxCdlorZ1J1RisvMzVuV0IyVmRrQzZ4TjhiTnR0dVh5UUVpNmdpR05KbERTMnJXaW9jVzc0dUxWOHFmZXRubHI3czB5ODRDTnliTVVzdll4TkRRUGF2WnNkMFF4V0QxbjE0eUZxVHVUYXpOaUNBZkFyd2EwTVhJeE9oNUhlZlFGaEI1UjRxazY5Ym9tOW5TaFRDMU1rbjgyZXJ1dEs2UGdPOHdBZHpKY3Z4SlR3K0xVNFVDQWFqcW1sRWhOZ2JnZHcwM3FDbzZrbm4wWEE1bWl1eDhXdUNKdEFIelo4UzBTdWhUQTNmUDAzdDd5RE9zdnhHZjV4TW1KaE05TXNLVnRveFV2bWh3dVlkdE9Ya1ZrTzU3NEhXZW1Kb3N0ajIzYldoTnFBa3ZkaVhJMXlXYkNqWW5EdU02RW0zTTJKU1lQSzZJZ2xJVkNmcGlSQURrVFYwVGIzNzU1TlZhZGtKVTBKSE1FNEFhT1JuUE1VVUNkdlozWkNLbG84VGZpM3RoRnFETkpHeUNlbk15cXk3d0RjT0JNWVFGeE83bUx4bWRrazhkRUtYQmxOS0prdW9xQ1N0dFZiOGpFOEd4ZWFaZzhPeGRtSXZkaDVndXNhRFhpY0kzbkl5VW14c2srVStBOGMwN1ZmSktQRjU5NStzOWUrY1pYdmptNmRTUk1VaXlLdU02bGZURzUyakU3Z3NlMDRFVXdtQ3o0c0FMUVlzQ2tKcXkzZm5ZRmdPMWVFWGRnMVRITzdyenZQczh5OXM0ZDNUbm5mWGFZUFhlMDM5bzlIa1RJc0llWmNvK2FzN09WdVNYTUlrQm5DSzVqRkdPT2NMSVZBK1VTVHAyc1dFalNBT1k2WWw1WUJUYU4vWGllenhnT215aG14MWFLeWJRaFkyTXhpWEZmNE1ST2JGaUxMZDNPaEJ3dmlQNG90OFh4OGxBOXhiNkFPVnNzSUM0VzFZTFZ5S2RKdFRPVFV4bnlod2xsTkdKU2trM2Jxa2VneVc4WTY2TVlBUEgxZ0lvT2V6T3J6VHI3cGtrN1pnSU0wekFXVUxBcEF3dnMyNHk5U2NSckpqR1RLZXh2Y3RMR3JJbjRWdURLTEpLd3BqR0JUQVM0S0IrZG05MmF4d0JGQmFDeExtVVlESENvaytuTGx3cDBMR2JCU0FjQ0pyZXppUUNtK21odUQwZ01FM08vRWJERFpzWFNBTHFYRW9sT0hWTjYydE5uZWRpeFkwZXI4NVNYU2NMeHp0dHZGMk1HOU9wTS9teEE0RDdNc1dzWGJRY014OGZIVTBmTHluOGF5enlkbFlnQXp5U3ZlenhqZVlBWHM4VndIZkxoV2lZVDZWbnRhQ1NnWGVYWHhLSzlBWldITjhaUzh3djVqUXdaVVhSc1dkMnE0NjF6SmkzZnA2YW1Dc0N4Y2lNQ1lIdzNTdDI5cnBWdlpaYzNhYkdYMjluZE9mS3FYL2lzUFYxRHB1dzBiMkxQcUN3Tmsvd3RqYkp2SmoyeXpwVEZmTkxTYUJzQWtIUFBLeUpUcFo3Lzg0bXNnZTJyVjY5OC9idmYvdGV2Zk9PcllRZlpRU1RNcGR6bEFvQUFpem1pUURtYU9sOENwc3dLOGRCSTU3U2JCWTFjd0t4MEVhNzZMZmQ5WkdPdTB3MVVDUmRCOUdwZzI4RGRyUTdudWxjN2c4OEduT0UzblpBODVKSVNMSk1kRGFBQkJXWFJGbjlneGlaMWVBaFVSOHd3VHljRHprd2FCQk9RRWt5Znk3YzRIYjJDR1JIbVhPOFpPaittK1NBVGloWVdjSHU3bFk2RUhWbXBoV1Y3WDVMbHh6eEFlQkw0SFRDdUhNcXVKb21WYXN2N2dZQkRONm5ETGN1dTFKWS9zekZqekx3elBFc2hyWWd6NFlPbFY5akhkRUFqRHRkaE9aWjFXeEsrZG5oTjRsS2NxblFGVmRMeGltV0ZyZklTUVdleFdSM1lSSjdPckRNcW1HdHZwQ01EUVFvSFc4WEFiTHNGMEpkbktiY2g4TldBRzRCaktqRlpwVDI3U1ZTR3EzTHBjbitlSVNDK2ZQTU1ZYmUzaEYxUWQ0eHY2ZExsc1RXdktjQzJTQWVqcFZRdzQ3V3BLeUUwQVJGRllvSlRXWThjT2RMYnZuMTdnU3NBY3M1ejJMamxuMWVFOGpDRExGL1JsbVd6Njh2dnYveVgvMnNXc296MW5uMzIyUklob0NWdFpoQkwwcVhIN0NCTkFNd2REVk1GbUE2akcrRHNkMEF0MEpCbmVoa3RrVGwxVlA3b0p1a2lXOXBQR1JDQ1RzYWxwZDdKbVhyMkRITEkxR1dVeEd2RzZQRmhQS0swbmFQckY4cnFNK1ZENXFXanZYeVhMOHJFeTMzODZBRy84bm0yZk1pUCt2Rml5dkFpWDlKVkR1WU9NajRQemxYdG45dy96KzNiOGQ5OS8zdmZlZUdaaEFLZHlZSUFab3dhMGdYZ0NFaVpGSUJ5T3RXVHdMeGd6cjlaeVRwQTViN21uZ0xvanYzbTNwS0V2R1BVWHBXVzlMd2lMSVc4c0NQLzZyUHorZDZGN3ZTTSt0WFA5VnRqRjlpTE5DZ1JONWlNcTNzaXRBUEpDOEFsa05nTXNNcVAxYm1BRE1Fa3NPNGp4QUM3QTI0ZGtLQzN2RFV2QzUxQzUzU2Y1M1Rwcmd6NFlTdTNZN3ZFcEpoQWRPanIxek04enhCMFlid1gySW83bG9ONW5UeDVvblpLQVVZWUZCWnRYME41eG9JYk9MZUpRZ0FCOEtiT1RGVW4zYkZ6VjlYaDBXUEhLMTFCOFRGZm5WZFVPOHc1dFp5T0xDMExEZXpQZDdNbTFHd0NDeVR1aEFYN3pkQjVaR1JMeXZLd056bDFwc0JvL1liMURWU1ZpUjA4NlF4R3lmQzYwYmJ5MTJJQ2YreVJnSmx4RHhSTmpqMTNaV3pwSytLaVp4VWhoVzRyS1hWNk8weVJhY0FxUVhaZ1hnNWN5d3pwQWFqMEFaeTZWYy9xeFRuZ2hCbXJGNEJzc3N4MWRYM1l1L3VWSDZEdjI3ZW45eGQvOFJkMS83ZS8vZTBhZFpoTVZBZGRYUUY1OTNOWFc1dHRveHp1MSthQTFEdFdDOGpFYVFHRURzdkliOTZNZlRwbDBTYUFrT21EYkFCS2N1UmRHdElIeHA3bHZidGVPc0xMWXJ2YWdMOHlPZllDeEV3bFRERytlMWQyTDNtUXByVDFONEFzM2RwUkpYSk1TWXNmZzREVXlDRHlicHBIbVNzZWQ2N2hxY1NWVGxoZkk2RHFLekkwZjN6eWFtQXNZNmF2ZmZIRm4zN3BkNzVRMGVidTNMbVJrS0RwaE9uY3phVEJodXo0RDRHWngwUmpzb0hIQ0V2WmxNTUl5cGFjOS9KWkJ1b1JXTDgvZVRoSDhIVkNBT2w3ZDNUWGR1Y3d0dll6SUsyclMzQUJpdnZObG9Ob25ia0FOZ2t4QzFodzBhWGhXY0NobUxMN2NxMXpVdVB1UmZDdDdxSXVBSEt4YkEvTmYzc2RZaDVZcGJDU09sUXViUGZvMExFQis0YzFjOTNDT29VTHhaTHZaTUhINC9pWldrRUg0SmFtSXdMbjB3R1RjK2ZPRmlQRjBtcDRIakMwcXdmdkVPNWFhc3h2T3FrRk1DYTBkT3FObStLeEVmWjNjdnhrSmhwSEM5U0JxR3VCTTEzSVc2Q3g5YmhOSmU0Q1J1bTFQcVlONWNhS2dUN0FvdHgwOHF0eHoyS1M0SkxHTXdTYk5wR29ERXdYOWpSMGo4NWRwcUtNR3NTeGZ0SUY3SHJZTTFZR25PM2N3dDF1U1d6ckJqL0FDVk8yTXZGS25uLzIvTm1xSTZZYlFBTW9nWkJkUmVTSENlQ2xsMTRxcGVZOHhXZEN0dVJtcnYwQXFMZ1oybDVaZ05mT25UdUwvUUpzNTNidTNGSG1BZUFyS2lEbEJNaUFmQ2tFOVJXUUpVdGtqOElrTis2bjlNUVRFYjNQS0FDeFVDL0NpWkkvaWxVZ0lmZDFjaXZ2bmlXZlpHVnc2VkJOVnFwVG96M1BvbFRLdEJNWnNZYkFQV1RBYzdVVGVhU1l2Q2dLZVhPTlo3ak9nWEE0TDRCVHA5VEl1TW5wSmpjWU1vS2xiMGFVSTh2eTVGcHQ0UkRQWnQ3bVhGWHh5ZnZ6K1VNSC9vZWYvTUgzRHUzZXRUM2FOalBONlhETFlrT2pmU3R3VVlRQlNtRE13SmVObVNrRE1QTWxoZ1FtUTlqa0NKRnJ2UHU5TzNodUFBRFhldmtjdlBub1JXb0lqZ2RKcDN2NTd0VjVTTFRmYzZydUJld0F0ekdWQXRRSUs0RjFsNVZpUU5lMVNURHBlNFo3aEFOdHk3YTdjeDZ1a3pObkdQWUNTTmZxV0R3c21EVzZRMmNvNWhLQUFpZzZnVWs3cG9FRkF3RzVNRWlUVDdWY051QmsrUDRvblVPSDRoSm1aSEUrQWZKUFQ3STkzaS9HZGZ6NDhYcTNpbzdTd0h4UHgreFJRQllRTnZUR3hKOTcvck1GR0FDZXg4WXYzbmd6UUhFOXU0VHZxVElCRXRIbFJMdFRCOHd2eW1BQ3RtTnhtTE95bnI5NG9ZREhQWHlDTVQrdWlPUGpKNnQ5Z01zNWdmelhEa2VoWkNJcXY3bVhrbENIQUpYTDF0MU1zbEpvMkRUVER6djRwVXNKQUpWSlFLT25EWW5NWnhqUFBLVDVoMkxLQVA0bXFPNmxyWUFIcGtsbUdtQzFJUGZ5cTE2YzM3RmpSK1hmZDlIL21DOGlKVlVYUUR0Smx3dWMrd0ViRHhTZ3JuNVBuRGhSN2FsOHdKL2RITWhqa3RyRS9WYUsrc3krcTc3OExpMktTZDVPeGFOQ2ZWQzZsSnNKUFlwWFBaSUI4eEpBVlBwa2lreFFGZzZBbXM1VDN5TlNhZjltZHFBZ2xOM3Zkb1FueTF3WEtXQnNHU0hSYnNnUFV0QUJ2MmNxbDN4NnVYOXlhaUw5Z0dKcGJjNVBHcm53M2IyTE1qSE9CRlBoQjFJdWRXcXhqajBtQzZ3cnAvTi9QbEUxY0dqbjJNdmYrZmEzLy96bEwzNGgydDFRTW9zeTRnb2xsQ0RoQjJ6QWRqYU5pUVViSXowSnpPV1prV3RzVWFYQkc0c0dDMm44QWtQSW1OOUx3S1RSN003ZGUvM29ENm5OMFoxdmFiWHI2MXdCZGhOUXdDMWpTZDdmNmd5dTBTa01sdzAzZmU0bUpQMEdPTDBUWUVJTG5GT1VPcHl6NG8rUUFuamdETlJyK0lkaDVQVW9aaDRtQWsrMEVzeUNnU1NYVG16UlJvTGdHSUtHWGZNc1dCaVFFdVhzV29hKzZtMXhXUEtDVE5qb1NKczNiNmtWZXNCTFJMdHlVMHRlVFVRQmg4RXdaNU52T3UxVVdOdW1qWnNDam1zS25HK0VEVDMzL1BPeEoxK0pwMGU4SXZMNitSdS9xTytmeTZhcHdBUlFsRGtrdG5DN2hjdWZjdG5qa0VsRnZXTCtGQXo3OHZqNGVKMmpNQ2djRTB1blQwL1dpTU1rRk5PTnhRNFdPZkNQbFRhRkxVMURaZWZ1aFZWZnVad05URE8rWWp0WC84d1YxeFBQZWxFaTdvbm5vWGt0RXNuRGNuL2tLWlhYUUVmZFBpNDN3MjRQUHVDS25XL2Z2cjBZOUR2dnZGTy9BMlJLeWlRcDg4YWwySVhkSTV6bXhheWc3TXhHZ0ZrNWxVZWRqbzJOeFpmNy9TcXIrNWlPMkxNdlJUbDVCcnUwSFh3bUVsY2E4TGxQK1NnSHZ0RUErdHJOSzhXY2xZdWRmUHYySGFrVDhUQWVsSmVPdVFiWEEyaDE2eWgySG1CdjRDME1hdVlKMHBaR2VWZzRzSGVRaTRkUEtIOXk2bDd0aFdnQVgzczNPandETUtzam4xMURDVnk4ZUNZeVQzN2J5TkJuc2txT3lDbFhVSExzV1RXSGxJbDdySjIvTzk3OE1ZMnF4OHovK1NUVXdPOTkvblAvMjA5KzhzZkRRNHM0ejlzNUc1Z0d1UEttczJOTGhqL0ZrSU5talQybndTUDhhRkIrTGtHMnVTdWgwaWxJQStDc0lFVDVZRkdLeWJydTl5ZmZmZllDaEk3dU4rbjQzQjBMNG9wSDJENCtKNThObkwzWHFyRU9iQXVnTTNSTEdseVpwQVVZM0Z2Z0hIQnE0Tnh1S0JhWURsQjVCK3A1RGdiTlRLQWpHTDRQTFdlS2FKNEVXS1pocVJ6b0pJYk53STM3MldPS0xRek5kOTRLL2JHenB2SktxV0ZnUEQ3VUhUc3N4U0lmMTNJZmN3Y0dCOFVNa1d1eTcrUjRGQVV2Z0xibzR0anhZNzNSQUExUVc1K0ZFbGd1UDJlQWo3bFRTRG84THdabDR1ZmNKakd6Z0NQTVRmcWVUMm42ekNjWnVBRWliUWtFYW9LMzJyWHIyQXNxam5GL0F2SDNoMm5LbThabEVsZ1Q3eEZzbFBjR2NNWUl4UXBabmdVdlJqUGM3Z1R3NTEyeU1oc3lBRDZCcUxERENrU1U1NmdEb3d6ZUk2MTkyZzRpOGdYVUxFUUJkdktObGI3Ly92dmxmdzVVdVJ5NmptSVQzaFJZQWJYT05LSTh2bnRuNHZGOFpncTJXTDdoVDJWSitIdnZ2ZGY3bTcvNW0ycHpRQTVjdGEzbkFUMG1EMlU4Y0hCLzFlM2JiNzJUOXNvR0UvSC9Ga3pLUElQMjRhR0RMYXRYNlFCTithbTZqWnlzcWNCSUxYYUs2M2kyVURSK0oxZXJLTFdVa3p4NXBueFRFczVKejhTei9IUW1EcU1kaDJzODUvcjF5L1ZkSFJZQVI5YklnNE5jWDRwcnBkN1M1b0gwYTR3K0pwRXdaMmFzZVhDdXF2cmsvUG5LODRmLy9OVnZmZVhiQjUvWjBSdEs2enpLZ3BNRldSRTRLQUpaZkNURkRYNFlmOG0rQktWNU1CczdhRHBUb0xUQUFmQUJzYUJpYnlFd2pDQVFBb0JlVER2ZkRXdUJRb0ZqM01rV1ptWWFXR0hlUUQ1SVVPOU1IcUdkQVlqR3FMaHN1aGZnVWc3MUdQR0V3d3E4c0J4Q1hTeWgzc09LWS9QTlRjVmdDYlJsMGhYN09Wcm1VZncrbC9URlJwZjBIZ2E4TElMQVR1VlRpRXN1WXcveVc1bFNBakNBcWtBano3RWp0U1d1aTFPdTFabmtNM3pGWnRpeURjdDFKSjFOTm0xc3VqQnhyZGxaVjYyT2ZUbW1nQXBObXM1N0p5NWxBSjl0ZGlSc1dJZWVUZ3dPdnNJOEJBSnJZZkl4cllUTjJpa2JRSERWbXI1eU9mVVZkaG12RC9FYkp1TEgrK0tMdjEzZUlIYW1wa1F2aDBGeWtWc0RVSmgwQXB6QWYrdm9XTzlLOG5RcHEvZ0dNMVFXQUFqcjB4NWlmVGk0dFZWMHV6WHhGb25KNG14czRNREFBcGhyMDdGNzNybmYyN056ZCsvcXpkdTF4OS91Zk42U0FQNFk1S093cjRWaGdRL2lGcmdvbzY1cjhkMittV1htWWpodjM3NDc4dEhydmYvZXU2bVBlR3NzNlF1d0I2d3lNbnNZbWVFSnhGVEZpMlJaN09FQUZFc0hMQlRxWGMrUHdsazNzcW0zTEFDMElESmhVdFBtQVgvMXIvOU5qVGhXcHJ5cjF3N0hqSEtyRnM1WVhjZFdiSzdFSlBCZ3dMczI3czNuSmZGQTRzZDl2N2IyR3NpQ25ha3kwZnpXRjc1UVB0V1RSNDdYL280QXZQYUJ6RE1wMmVWaDJ0ZlN4aGNTODNwMGRIdGUyL0tzbTczalllZDNidC9Jbm82YmVvY09IdWlGdnZST1Q0ejNyc1Q3cGkvSVo4L0t3WmlvMW1Ra05SdEZLVERXelNqaG13RjJRYmJXUkpZSXplVkwwOW1pN0dMcW01LzdVSUpBN1VpOThQb3g0VWpaSWduWnFmeHFBaldsclM0RzBJY3lhdHNlRy9xRkFPNzRxZkhleHRRUjA5R3RYSGQyNmx4ZHIxN05NMWlVY0NmdHNtYjFVOG1YeWZIc2E1a2dXaFFxMjdzMUFETlpvRElQenRVZFBqbC9mdnpENy96djMzNzFhN0ZQaHVVRkdCNmxZMXM4a2I0ZG9JcnNWRllEbURuUnR5RHVRUkZBbWxubjl1N29pd0NWT1NGdzFvRnp6czVwN1hhOWEyY0xESk53RHVEcEJXQzdkeURqTURUR3pCeHNaVjJha2UxNlpwa3JjbFU3MnJPZGEzbHphOWhvQUR5U1dFUHVsbUtZWHY3NXJZWjd5VHI3cUVLS1RZQ2hVU3BLWkNLT1FtRHlxQzE4a3BiOEMvSWtMNWlSb1BPQVJRUTY5d0lXN05CbnRtcU1ha1hZSVFDdk1nYTg3cWFUQVhYdVpGaVhUVkN0dHNPNmxaZXJWOGUwc0hWc3FrM0V0VGpUUS9sZVM2K1RocndiVGxNZ1JqWFkxdDU5KzhvMktuK1Vrckt5bjU0NGViSldGZTRLMHdSOG1KZm5BSDM1eHNRcGw0dFo0a3p4WUxxWTZJN3RPNUo2WDhLT2hyM24rdG1VbnhLeG80d2w1MC9GNUVGeHliczBuY013cDZjdkZvdGs0N1NkbGQ4dVhEZ1h0MExtanNiUWpSSUU5QmRKem1JUzlXdVVSVEVCWnJaNmUwOHFBeFBHd2NPZjZkMlBzbEV2SXlNamxWOWxVVC9lalJZRWVMcDBLV0NUTkxlblRKaXJZUC9ZcG5hWkRjbHdqaUxDckRGTzVjUzgrVSt2UzVzMVJzdDdKQXJyOUtsSVluWW5pWUlVbG5VNkt5cXREbDIvUHZiM2xOTmtyUVVyZHZlK0t2TGcrZzFsQjVjZm93QTJhODhtTTFpNG5kRFZqL3c1NXpkdFJUNmMxMmNvZWlNUDlXeVV4VndtUFN4NlVSWkRLU2Q1NGRtaTdLbTJPcVFweGpVWjFvYWQvS2hYbmtMU3NLK2w1NUlWNVZSK0JFQ2E1SEllbkZ0ZGZpTCtmdmVydi9lekg3MysreU1IRCs3clhVdEhYUncwc2lJdWlKUkdaejVvSm9IWnNNc1lPQUpHTFM2eUJ1OG01ejRDMUhTaUVPUTUxanpIUEhPT3dMbmVVWUdNZkFiSUVVeTJZWis5MkhuWk1kdVJaK2ZXZWs3eTFKaTROQnNnNjdDNW9Ub3VZS2p2MHErZkErMUpxd05uNWdPUHJMeWxESzQxM0hjcFd4eDdLZmV2WXNMTUxqbnZkK2x5amZJYzVoWnBDdW5vdW50aHZJUmRXbUw2aW9mZytpdVg0OFlXSUdHK1dadU9ZODg5UjNsZVpLTEhhckxrc3NySnhMSjVaSFBOc1BOMWxqNFRpczZpM0lhc09pYzJERUIxcGlWaHZ2TE1DMExIQjg3cjBpRk5NT2J4dFJ3YTYzUHc0cUQwZE1DVDQrTUZTTThFdkhWT3oxb1FjTmRKZ2VXT0hUc0tIRDQ0ZXFTOEQ2d1U1TWFsMGxhdVhGMW1qb254VTdYRHgxQ0M4UEEyd1BpRzQyUHR3YzBMQUxoeXFZdUN5Mi9BeHA2SWdNUTJXaHRURG1BbVpvZ0pOYkUxVEN3cWE3bDRwVDZMT2NmY29OeGxBa3M1TER4Ni8vMGp2WTFSQk1ZeVBDdUFFckRqaHd6Z0tDRGdaVkhQMGFOSHEzejc5KzRycGNBY1ZZQ1Y5enRaVk1VMmJYTFE5ZHdIZ2ZPYmIzNFlSWmhKeTZTRHVjdTdrY09SMUVjQlhkcE52bGVIUVZjN0pOL0FYUnJLd2ozUGt2b1ZXWlhaRm91MENVWDE3M295VStDYnNuSkg5S0pVdThrN1pwSFZtVVFGL05OaHNrd2Rsc0h6cHllQ1BFSFlwNW1LS0RydFI1RTdob2ZYVnRya2hSMGRTQytPbkpCTnl0MDc1VUZlemZrQWJlMU9mbHdyWDg2Umk2NzNWY0x6ZjM1OU5YQm9iTU1MLzhrLy9aUC81dG5EKzdPc1dYRHdETWRyV0IwUGg0Q1E0YldPbzBHWkd0aE0yK2QwbUdUYmIwODJKbEJyRXp3bUJKc2R1a3FIN3VZZ1VDd2M3dXUrZTY5bnpKMnIrTGsrZS9aSHYzMThqYzR2blhwRjhBa2VjT2lPTW9GRTZIV0sydXd5NlFCZmdQWWtPTFB4V2kybGMyQnA3S1FkMkhxdUJTV1VCWnNxczAwWElJbkM0aGZzd0FKZFl5OCtwZzBtSHJaZllKRmFTMGZKNzNtWHArVUJPMHZZbVFrQTBmMU03RnpJVmxJYk4yMU0vaFBJSnl2akJNeXg3QmNJU0kvaU1tbkRUdG85QjVzSFRNcURwYk1sODlZQXlOenh4TExRU1FFQzA0VjZBczdjK2pDeTRRQ2E0MzdLRGdEdHFnSTRyb2Fkc1RQYkdPQnVtUHpKOFpNVmVFZk5Zdi9yaGdPc2VRYmZYbW11alozWmlNYUtQczIxUEFHWW1HanN4QzdmUUdGSklwNVYyckdyVXVRaXdObEZ4MjRoN0p6TUxvYlZYTzZ3NzRFQm9WZ0hTem54OGVhNTREcTJkZWFUMHhPblV4OUlBcnM1czFLMmhucjduWUQvcmRpT0R3UVVXL2hRQzIva3lZSVo5bkdmTFo3eW5Ec1A3dlQyN3Mvb0lrQjFPVXZkYjhlY3RUN1IzZ1lXWjllWVRIaSsvL2JiQlZnbUhZR3p0bVh5TWxKNEVPOFFMb25LejB1akEzd3loSTFybDRuVW04bFhnR2x6V28wTGVMSGNhcCt3WkxLbi9aeXpZbEVlYXhMUHFDRjF2R1hMNXBvd3ZCb1RodENpMm8vY0hUdDJOUElUa0Evd2tvbVN5ZFFCUU9icWVpV2puaG9kcEQrc3lhaE1INlJZeUNNaVJMN1orbjFYTnNDc0xLNEQrTTQ5MlorVCtmbmoxMUVEZXpZTjcvbmFWNy80MXZlLzk2MEFSMmFOczJoaUNlWVMwQ0QvbUY0QldqTEhGbHpNdVMrYVYyK2R3OEtJZllRR0REMXhwS0VKcmNOa0VQREV2cjBUQ212L3E3UG9NTlZwNXRnclpaRFhuQTBsblFsajZ0SnZURmdhSmtRS2VBRnpPa1dCYzVjaER5MzBiNG9BY3paTXJpQkx1UVpEWk5ZZ2pBb0JuSXNoNTdFZE9HTVFnRkE5ZUxjQVI3N0t0T0g1WWRqQVV4cjhpRDBmSzdISkt4aS9GcnUxRGdSQURPY0JpN29FMUlhMHdBM2c2RXpYc3RSNldSWk5ZRXppVDJEY2xtYUx6YUdUWVhoWWpRNmtJMkU2eVdxZE13dzNtYlFsTVRLRzR6ZDlNUjRIVTFObmV0dEdZMStPZ2hEOENIUFdJYkU3UzQyeEpRREtmYzFRMm9pQ0YwTG1hV3RZaitIdU8zU290MlBuem5pSVRDV2Q2OG0zT01LSnY1d3lzbC9ldTVjVmZMbGYwUFpyOVp6SmFzZjFBU09UbHVvMXRWU21DY0M4SWt1OWxZRm56TDA4YzB0c3daU2RPdUF2elMvM1ZtUVBPTnRFZ0RRTlJBQXR5cmdZODRTTkR0STZ2YWQzUDExbEFvUkFubGtEYUZFNFhzcERLY2szMWtrNWlZTUJkRVNYMDA3cWJ5Qit4T1JRbnB5alJKZ1BqRTdVOCtYWWlxY3orcGs2TXhtd3U5STdjT0JBYlFJQTNNNmx6c2tMSm03aTFmWmpGSmZKVVczSHE2WmoweVlzSitMMXNYdjM3bXJIYm1MVENFY2JLSiswOUFGMWd3VTd4NHVrR0hJQUY2c25xbFpjWHJrNjNXUG5aZ2NuLytTaFRVTE8xTDFHSFBMUEJFSjI1QXZRbjBvZW1DeVlZSm95Rm1NNjh6MTVjRGNhYzUvUm1qVG53VG5pOXVzK2Z2TERWNlpmLys2cm1SUllWYnRvTDRsRzVTSm04bzhtSHdoNFdHQmdLWFl3TmxoaitLbnA1Z0MzVG9LZ2RoQjBRMW1Canh5Kzg5ZDBBQ2dDVUJvODE3Ukp4RGxRVDlwdHR3azNNU2MwVjdkaXpuTktvTEdLQnRCbEMwN2EwZ09lRG8vMFBDOUx0UW04ejVZNGx6c2R1RWhIbU1sclVTWWtDU25BQmRiT2UwdzNDOTZCODBmTU9iMmpsRVpBbnRLcDFZUkoxMDJHb0o1OUo4ek5KSjhPTEVnUS8xdlhBcXRsc2F2eU56WkV0eEtMMjVyT0pnSWFSY2VOVGdDakZSbStqbytmeklyQzVjV3dWTDFKUXcvaWUydDRtd0xuYy9OcjVkYUdwUnRTYzhQVDBkVFR1dGc4QVJWd1l1NW9aYlYvWWJOVFdsNk01WjJMYVVEblhSeFdCK1M4VEJTZXkvQ2NUKzNvMkZnaXpHVmhSa0NJcWFBMjNFMXVGdlpqN3FzVEZLZ3QwZVpIUFp2NjhKekJtRHNHd3Y0cEhvQXdaQUl3ZFlRcEdqMEFxTWNCWmUzUHpBRW90UlAvYUlIZmJXQXJXRDYvWTRyZDVPZlZBS1VKMEowN2RsYVFxT014UnpBaDhRSEdsSzNBdkpqZ1RVYytQRkloVjlPU0tVdk1HM25tN1FCZU1kaUFNMzlmalBwbVBKRnFONVlvQW90SE5vVGQ3Z3FBRXBvUFB2eWc3TWNVOWFxMFdibUFSa2JzSk1QemhVTEF2cFgxU2t5QWxBQ1oxbCtBUElDN2RmdEdCWnNpTStwR3BMbXpjNUg2ZHU3YVVTTXlJRng1aVV0a3lWbkpWa1lOcWIvN0ZjTFYzTVh0TWgyeDJXOUxZQ1ptSTc3cUZDVmlRTDdJZWZVRFZ2SFVZOWZIdEN1NUJOTGNETWtHV2FNc2plUzB0ZXNwTmUxRTV0MHJ6WGx3VHNYOXVvN1IwZDZTMTcvOHlzd1BmdkJhNzdPSDkvVnVYSWxmYW53Zmx3U1lnMUM5eC8xcHBEbUFpenhFQUJwckR1d0ZSY01pbVQwS3p0TGFXanlOWE9BWkljVnF3b3VyYUJyYkxETU5MZWF5Z3lDanhJMjVBdUluVEJTdUw5QnJrNGhBdUtYdEdRMkVwWUdYMVh1ZTI1NDBkN2J5MGNEWkQ0Q1g3UkRvdWtjZU1lbkZpWjdYTWVmbTRoZkJUaEpzemlYVThwdFhsU1dBVWdhWjNJdWx1NitVUTlKdU8wb0hySEl6OXltdkIra1VNOGtIZ2NlRTVVTXdJSXN0c0swQzBTZ0R3MCttbGxKYUtmTXFROUE4ODFUaVl5aWg1K2pvNmt1ZTFDVkdCUlM0MjBrSEcyU3o1bzBod0pDRkJKNDdFNWNvNzQ3MVltQWtMY05WNEt5elVpNUF4K2VabEFtTFlpTnRxeFd6ZWpDS1pqTE1mZXZXMFlyb0ptVG9oYkJ5L3RIeWNmWGF4Wm93ZGwvRmhzN280RjVNR2FMaGFUL0RmZ2N6aDVFRkcvcVZtQ1NBd2VLQThjbUVTR1ZpQVpEU29EeEZuc01jYTVlWmpHeklETmEvZWxYTU4xR21JdUU5eUlzeUhBamdtZkNqZkpRTDQ1VzJVVUd4djhneE1PSzN6ZWNZKzZRY3BTbi9BazhCSi9YaU92VXFIU3NRL1k2VVVQcEdHcFNNVVJFUVRrYkw4NE9ObTJuSlNJcUp5bUlPNWdrZUlqWkhhRzNTUW81cUwvVnNSUExrWVRSVEpvUUMySkNFMUpzMjgySXJkcy81QzF3REwwY0dtdEwxRzRWODg0WWRlNUpheW15WXFVNzR4S002VEdGaWZUdDRrcEFmNVZNdU1rZVdqSURVaGRHQ0VWWEpkSDczbS9xWUIrZXF2bC9QbjkvL25XL2UvTzczWHVzL2ZHaHZCREZMZ205Y0tjRjZIT0hIVnZyalBnZVl1UDBBandMVzJKc3RNakc4WExTZ0FhVU8wYkE1UWhMQjlaMFFBR2VOMzc0M29PbVdoeGI0Smhtc29zQXk3S1pZbGVjRkFHdVlsMmU0dHdBLzZmbmNwTkY5MU1JY3M4NVpPZklzdjNmUGozdHh3S2NCUGFic2N5NnFhOEF3Y0hZVStPYTVmaks4bHcvQ1dYYTVkQnEvczRjQzVjNWJ3elBZL3BUVDdoZXpLVGRGeG93Qm1BazRsWUZGQ3cvcGZrSCtoY3MwRWJZaUUwajhuNjJTcTFDa3ladmRtRVdBTTdHSHdRQXpRMk1kRzlOVVo1Z3VadWE1T3E3eWlyY01jQTNsN1h2SFhuMHhMbmwydWdZR09qT0FjeCtBd3RnRm0rY0pJWi9zbzRJbU1aMnNqQ21sZGhGSm5qZU9iSzdKS3VhQkhXR3Jxek1aS0N4cDFYMFV3SjNiMlRBMndMZGo1L1lDdVd1eGkySmNRT3h1VEJRNlBFQjVLdW5LSzlPSE5ycVhqV2ZaM1I5bkNIODI3bXNWOHlPTVU0eU9CN21lZVVNYjNMa1ZsOFg4TTFKWXNZSVhoaDFuK25ydnZoMVh2TGpRcmR1d3JwNW5BazZlbGVPWlo1NnBPbnM3OXVKTjJUbkdieGFzYUJlL2k4NW55QzRmZzltZEhJaHJhM1dMVFhwTlRrN1d0VnMzYjY3Nk8zWHFmTnFOWTF4YjhDRmtxL0NxajlQK2pXbTJKZFR1WlpabzdaTFJUdXpYNmtCZFM5UElBVUF5cWNqdlFEb2RPek4yYjZUNlpGOGcvNWp6NEZCYnBrM2VBTEo3S1FEZmI4VWRUdnZKUTYzMEM5QmoyVVpMeW1qbkdiSnpJVjRseXJ0ang0N1U2OE9LY0VoK0t0aFc4a1loeXhjbDUzZmxrT1k4T0VPSFg4UHhoOS84OHZrLy9zZS92K3E1TU9aWU1udlhMY21Od0E4bER2T0RlOEE1a3o5TDI3YjNUQmlQOHBxTjY5eHNRSnE1b3JtT3hXWUhBQVBrZkpvTFJNTnlIOW5WMml0QTNzd0pRQkh3c1RBQ1gwRG9uZ0JhVGI3Ritwdk9HV3dyTm9xUityd3d6RDNXNE9COTg0TUY5K0k3UjRwckFra2tVbGMwQUE1N2lVRExnMDRFSk5oOXk0UVJZY01RV3g2YWFjTEUzNEw0VWJzT3dIVVRna3dPSHFHelVqaWxaQ2djQUIzMlBKUHpLV25sd1k0aDRrdVllTE9xeWl5andhQkpMajdNNmduUVZoakxNREtBWXlYaDZnVFU0VnRyUW9ZSGlMM2kyR0F0T2xpcWs4WUhlKzJxQlBJSnNLeVBEWmw3MXJsNFJBaGh1VHAyU2tGc2JtWkkvU0QreG9DZ21GR2VmeVUyV1VGclJqWnRUZnE4UHl4RXVSVy8xMU1KY0w4eHdQcW9keWcyV21ZRmdmMW53L2JFSUY2elpqZ1RUOW43TGgwVEUxUlZGOEpJVjYxYTI5dS9aMjhxb2EvM3l6ZmU2bTNldENVMjEyMjFrZXVsaTVkN1kxczN4R2QzVmUvb2gwZDY1Nk04Yk1xcVJTZ1NIaVIyZXFISDMzbjN2UUpXUU1UMnZpWWdUM2xjQ1JQbjJ3NW9lTUJZZ2JveXcvbWxrWVZiWWQvVEtROEZVcEhzQWhiMm4yeEt1eStBKzFiYzRCZEZvVHdWOW55NTJEMC8rUElkanlJYzNUYVd1Tk5wMzZURjFHRlhiNHFKNmNQOENJVTRGT0M3bS9kLys5Zi9OdWRYRkxzM3Z6QTJOaHFHZktuWG43eVFzZXZYRzJteDRuTjE3TGZxajFlU0NWUWdyVjU1RmwxSlZFR0t3NmhIMEtMQm1LVW9WK1lJOGlXbzAvWE1MU0FWRkdqdHNSZzV1Qms3dTM0Z1hqZHpocTNON0x3dVZyUkphSE1iVEJucWp5eVpaTVdNeWNhMUJKUmlweDllYTVWaEs2dmZzSGlLUW4wakdTWk0yYWo1b0E5bDlEQWRQM2VrUVJTOWYvZnpuOGY4TWwyckc0M2NqQlJNK002RGM4VDVIL3I0NW04OSt6LzkwUi8rNFJmMjdOd1NCcE1oZDRBMFhTU05PTmNjUVNYK3VBOERFc0JKcHdoZkNtaTE0VGZRQTVENUlmZkc1RkJIcm9DS1hybWFwbjdJUnUzK3ZCclRyQi9yYzMwdllLeWJQenJYdmlXRmRGaGcxdDJIdVV1VEl1aTBPekFHb3BVKzBNdzlXSzdKbVRvWHpRRkk1UnZvNmdDbElBTGd6QnFMTXFuWmdUTWxJdDlBbTNMd0RFTlY2V0NLSmtTTE1lYmVidkt4VXdTR3ZqcHVMaTVBdDE4ZE5wMGVXK2xnVHpaM2xUKy9HY0pMNjFZNmdPYzRuTVBpZENRdjM2OWxPSW9wWVVLK0cvNjZIaXRxZGFxVDJybjZUanAyZ3Vha2pJTHdjRXRqeHp3UUZzbk43VW8rNzl1L1AvV1haa3VlVERKaFI5Rm1CUnBuQXFZbXZBekZUUkFlTzNhc1FQcDY3S0NHMW1KRVkzVlgwNkVwRzh1MU1iM3IxeE1yUTVrMWZQNVRnTUJRdkEvMXFJT3pwN2RodjQwSk1nR1Z2TFBWU2tOQSs5YVdSZ290M0txRXBPMitpNWZqTlpLMEJVU1MrZHUzV3loVEhpbnllMFgrTW5UM2V2dnR0Mm9DbFdJRmhHUGJ0NGV0VGhRZ2MyLzBMUFhLYzRIOVgzM09CbUhWS1ZQTGx0aHkxYXZsOEV3ZDZrZjc4Z25HdHN1blBPVW44K3FFclp6aWtYOHlwRzBCcTdiR3hOWC95aWpoT2g5ejFrQzhWUnpLaVpWNkZrV0QrVExER04xNHB2WjJ6Z2pKcU1HMTJ0OHo1Sis4dTdaTmZHWkNPZktrUFkyeW1JU1FISlBDUWdZWVRSa3ROUm12eHllL0xhS2g1M1MyY2UvTVEyUUtnL1ljZVpnSDUxWm4vMkIvZisrenovenpIN3orbmYvc2k3LzlZbVp4Qlp6UFRISFlYTEE0blNqRHNqUjJJTGVBaFowNE1wZWpXWmFyZDlldmJMRzVQcDNBUVlpeEVSMERBTFFQdVNjc0RxQTZ2QU9rN251QlMrNGhiQjNBMW9YNVE2RGJxNWt0Q0Jkd2RyQ251bDZuYUhiaXltQlREQzZRNGJ5a0R6Q0JjNldWYkdBc1FOZ011UW12cFl0YTJFbjVaKzkwQlNDdkszTS9Ud3ozeWpNRzQzQXZsbGRwSmkyL1lUTHN6TTUxUHN3QzN6T2xPRmFGMVJCNm5WbEhJL3hXK04yT3R3UDd0ZzdGUGt0NWVCbTJta0RDNll2dmh3QUFRQUJKUkVGVUdOay9UUzZPeExNQmtBQjl3Mk4yVGZYQ2wvWjIyR1ZxdUZpelRVMHRpOGJlMXE0ZHpnVFV1UnFhYjh1aUNrREtucDFNVjc1blV3NU0wWXBGM2lJbXpGWUZVRDQ4K21IU3ZCV3dDWHZQUkNBbHVUVTdxRmlseGd3RG5JRGIzcWNUU2piMW9Vd201WUFrSUtmSStBNXpUek9zVm5mWW1EZ1N5MkxueFdRcGtnMWh2VWlBTkFFTytWQjI2U2piZ3htKzRsY3F6K3plRmxVQWZYNis1SFFtN2NZN1lsM3lmZlRva2JTNVpjMXRxeXpMMExudmFST1RzdGdrd09GK3A0M2svMEhpSlpNVHJ5NXQ1aWNLUmgyYlMvQmJhaXNtdi9nRzUxN3VqbXk3Yk9WM3dtNHBYVHZGOEZtbnBMQlJaYjBjRTQ5NEpNQ1lSd3U1MVJNd1dkNGRUQTFFelhQVUVmTlQyWGxUUHZWUUhsTFNTOXJNT2pVSkhQbkVocHZ5R293Q2FQVXJqL29EV1NRakR1QmRjcHUwdS82ajMxQ3V6aU1Dcm5IdzBnSE9SbUhxUzU2a013L09WVDMvTUg4T2JGNS84RS8rOFQvNkY3Ly8yaXZaWHk1RHA3dlIyTmwyS3JPQXNaY2F5c2Z1bXdhRWRPeHBmV3l5NWRNTW1NS2VDVUYrMXdrTWYvdGNtOGJFcElYUDdPSTdkK0RNeGtvd3ZLcVRSbEFJbm9NUThCWW9GZ29ZazdiUDN2UEIwOUp4RzdNbFRMbThRRGsvMVZIcEpNL2VLLzBBUUJQQ05vbm5mREg4WE9OWmdBa1F5ajh3QnVuQXVlWEg3M2wyZ2JNdU5BZnVZUm51SmZ6eVJMaDFEa3hRbnNyKzdGeDEvbXhmbGZ4YTRlYTZ1K21VdFRnbFFtN0NoUzNYSVc2eGF6eFgyaVlIZ1RzbWxoTlJrcndVN0pLZHVncElDTHpQanFoRHlqZUdwUDRiZ0FYNERJOXZaVVZqQU5LSUFjTURHRG9oQU1GMmpUQXMwc0JhZ1J1d01oUi9tTEl3ZTdBM3k2ODZFc2tPNHhJajJoWmRGQkd2R2NCS3UyQjdYTVZzaVRTYkJVb0M5bXg0YW1PQkI1YzlTNkRGeVJnWjJad0p4ZXZGcHJGZ3BoaWVGZUk5S3cvN3VJVWtnTGx6WTFTM21ETDJydzAyYkJ5SnllZG1oU3psRG1aU2szS3kxSnQ1aDYvNEIrKy9reXRuZTEvNHJjOW51NmtUVVRMWlZUdlhuUS9ZYk5vNEhFV1lPWkxrK1ZZWXNaQ1o1U2RlSTZPNE8wWm1wRWR4T2loQkl3Zit6UFp3dkI0ekFETUkxOGlKdUtHWmNPUXBrc1l2dGt1V2dEeUZBaHdCc1RiVnRrT1pCRlVmZDVtOVVsN0FhMDZoZWQyNFB4T1V3OWtZWVh5OEZ0S1FYU1lRTEphaUFwUjhzOG1abzVPWDdyUDA3SS9vY0MzRjQ1eDM4cWUvT1lBc3NFVUlIRWFlRHVreFAxR3NSZ3F1eDZZcENXVXF4bDFYenYvNWxkY0FZSDd0dGErLzljMnZmN1czSlM1RDJMTGRrUmRIZUMxRExxQko1emRodHlBTkthaFJINWU1TkdMbm05eVpESUNJenRNWGtBQ2lYdm5qYnc3RFBXQWRjRXk2ZFNhZkNaOVhKMnpPQTczdXZPK0VpcEE3WElkZE9ScEFOcERzaEt2OS9uRzZGbXc0Vi83UXlZelBBNWtRdzRKS3NLVXpsOC84VkhsajFtaENqemxEZmVWUW1vQzNNcllDdGZQTzVob2R2WlNIUkpKZmVhYW96SXkzWVdjaXZ3VkFPNFpzZUdwSENzTHVDVHFlenhaZGVJQWhxVFNsclg2eFRoMEtFQVBEMWVtd1JnQ0c1aFljQ0Z4a2Nzc0U1TktBN2JYWVpibWVzWU02MkJZQjRPYVJUWEhOc3lLUGFTTEQrREJ4TnNzSEFaQ0wwNW5NQ2tBdHlEUDR3Z3BKS3FZQ05ucjQyY1BKMVd4TjFKMklLV0RyWmhIemxoWGJOY3NQRU5nektRMXNlMUhZS1paS0VRTTc5WWRKV3Q0TXBFV2JzNk9JMVpFWExySXpKNEpiNWpadVpsTHR5aVVlQ0NicTFsYVpyZllERVBMS0MwVjUrZVJxaXJObnB5cnZ5MkluWGhsYjdyTE1oOXpKNkVTWTFiZmYrbVZ2MCtZc3ZrbmRVdWhHSlZ6eWxpWnZKc0VBOEx0dloxSXdzclVoQU12ZTdEa3JFNjlFbTJIZjNBUUJHd1ZtTnhpQXhTMVMvWmNwUnI2Ni9LU2VNWDVMeXBrZEtIWUtsMDJyUmpFUkRlNlF6RVNlYzJicWJQVVJveDJ1aVJRRTg4cVMySmF4YU82am1EMjd1THhSMUd6WXplZTdMWTRpRytxS3Nta1RnbzN4RzNWUjNGN2tpV3VlRi9IVWJ4MWszTWlUM0ExbUlwYjVCQWlUWGZMSUE0V2NLZ3VRSm4va2Q1NDVWL1g5NnY5ODQ4c3ZUb1ExOTI5WXQ2WjNkZnBjMkVrbUtkS0pCOU1KTklJaGZDQXR3QndoaXdDWjZYODhteUZTR2hsSUZOdkVDdEpSQUtCK3VFQUh6Kzg2TXh4am04Wkp3VFhwMFBoZXhUeWZLQ0xnOCtJN1RkaHFNdEQ5RVVBdmovU01McFlDb0pVUjZSUm02YTA1bUFBYzlYdCthT2tDdFpZK2I0Mld1eXBDZFNJZHlUTk1SZ0puOTBxKy9GZ2xuczhkT010REUyelBiMmw2QjkrZTlUZ2R5aThkTzVFclEwVUI2ekZSUTBlMllJSy9PT3hGL3JFY3JtclNiYXkwbFZkNjZxclZiYlBWODVPMk83ZERiQVpBZ3IzcFVCMzRBM2IyMithcWFQTmE5dWhIdVc1RDN0TmVLWVBsd1liUkZJaG5pUHR3Sy9uWUVQQ2dIQjFZTmxzeGU2NGRPdXpzTXBQN2JjcnFIcUN2ZWdvMGs0NU92cmpzcUgyOWlZbnhZc0lDL1BQRHhjb3JVRkE4VDdCc0xuN0FyR294YVlyOHByem5wczRVYVBCV29FUzUwQ21QQlM0OE4vZzFxNzlOR1hZenN3Q1U3SndXMThGMUJkU3JBdXJxOFAwUDNvL0N1VlJSK2ZiczJ4dnhqZmtuOHB6WVhNVUNnYXZ3cjF6ZmJQZUZJUU1xMHJNdXBoOXR4WU9HdTZYRDlYWUFIMHJmQUZqeXVqeHhLRERUdEh3cGR1MEh5TmlMZ1NiMlRZN2xVZnVRcVExUGJTckJNOW94UW1qQTJmeXltU3Q0cWV6ZHU3YzNPanBhWmdWTW04MWEzaWdxMTJ2emJpNUNPN0JWZTViM0t5YjFjaTM1MG83T2tVWGdTeEd0and4WWhPVEYxb3hCRzVXUVE5Znh6aUdQUjQ0Y3FlZGd6SlNTNTdobkhweExISDYxZjE0OHRPUFB2dlB0Vjc3OWhjKzlrR0JHMGNCaFNJdUNybjJQV1lvRFRPa1FqQUQ5NmRoOVlUcVJ2b0IwM0piRTFRcmlSRGJuanRiWml5RGxESEFHVkFDT3Q4YkRtb2pMRC9sZTBlcHlqaUJvYkFMdTVYdjNxczc2eERtL043QnN6QmM0ZDkraFpxVVJnR2lBbWE0bGdSd0Zvbmx2dnlmOXlrZmVJNUNVQ3VBMUJLMEp4SHArenVmZXFJVktDK0FxWWlrZzczUE1XZktlSmQzeUNjNjlOVEdZSDZwYzZhemUvZTQ2SGNJa21Oakk1YmFYMzNRWUhZN3B3R0Zac0k2aFk3UHhwNnFTUm1ORm5xK0RlNFp6ZGdWcEs3OFNyUzRyQU0zcU0yZHdOU3QybE9mYStxbVdFYWQ4MkJ2elEwMVlKUjNMa2RrcVhYdmt5SWNCT1NGRnM4dDJXSy9GSXJ0R1J5dWY3TWFlSngzcG03RFRyc3RqQ3VFSjRuZDFMYy9jd203ZXVCWDNxM1dSbDRRN2pYc2FkV1h6V1g2emR2aSttOUhBbHExYmlsbVdvZ29Ma3lmZUpsaWozVkRVNXd5VFJvQUVld2ZpSFRqSVE0cVdQR1ZFRWRrRVR0ajlnMXpMUm01aXNaUlliUEtMdzZDZi85enp2VzFqWTdHVkgrbWRTTXlQcFhtT2ZNM0VaRGMrZmpJckp6ZjNQblBvVU96M2s3MjMzbnF6VEQ5V1gxS2tUQWxjLzh3UEdHRjBwalNtcHJYSjU3VUFJR1hsT20xY2N3ZkpIT1VHekptVFNBOHd0eUd4UEpJek1qQ2JCVHRZT2I5dzNqaTNFOFd2TnNPTnlZazlleVN1ZmhQajQ3M0p4Rkxac1gxNzc5QXpCMnVoeU1uako0cWxENjVJSE9qVVFablMwajdrRWlIUlZ2YWJwSlJKcXlYaUZqTVpoVEVMSVR3V0I5a0FHQ3ZtSXNjMEJjQTdOZzNRQVQrRm94NkF0UHAzalJFRW1aNEg1K3F5djdvL256MHc5dkpyMy9ybS8veDdYL3BpL0hyVGNNSGVOUkh1NnhsZUxsa2NuOXAwa1BUUWRBRExjTGtPcFVrV0FvOHdzSGhibElraUFsQkQrYnpiM1lSQVlOQUM4TGR2bWJWT0d0aWI1Yi9TQUtybHhKL3JPekQrOTk4Tnp6c3RUeGpjMHdGdkFWN0FvQWxVRWdVWHJxRkVjcDVnbGN2ZDNEM01HbzRDMklDaVowWEZSTm1BbVZnZ25BdjQrUXo4ZE1KNDVzMDkweld0SlBYWGRmV3M5anR3SXZqQWwvRG5mLzMrTUt5S2NHTkt5dUdlZXVWM3o3MFdoZ3FJaGJIRVVpZ0U3RTJaQk4rdlZaZkpEM2JtcGV6QVhObWswemI2ekQ1ME9XZm95ejVjazFuNUxoaVI2d3hYVFQ1aVJJc0QxT0pNc0RmTFZ6SlJySXF2TDdjOGNaQ1pKazVsWVFrR3ZqbU05RXhpY09pY21DM2c1aDZHcmNyTC9YUm9rZWEwQzNiRlhmQitJdW1aSk1RUXQyU1NVTDNvekZ6bktBSWdvTDZrUHhKUVpGc0dldktkUnFrOG0xQUQ0R3VXaSswQlhHNGt6L2NxL29jNEZXM29IcVdUZThwMkgrWEMyMEhiWEJhUUsrWUE3bW4zNG84dm1oOHpFaGRMNFdjSEF1TDNrazhnbVJpZE5USEpicngzejlOVjc4eEQ3UG9td0pRTElHbFg4bEVqblNnUHF3V05UQmFIb0NBVzJneER4VHlIWTgrbWdQbUs4K1J3YjhsYzJndVQ2UlF2dG55RHEyRE9hMVBYYUdObEJhYmF6Z3JDc1NnVmFWaW03L2V1ajVEeE81a3dKbGZ5NlFDeXJ2R2JjOXE2c3pHN3o3WEtwYjE5bjRvNXhUbjVkbzk4VU43YTFrSFJkdVJoSWpaMWgvTEtqN3FZQitlcWtsL2RueCs4K3NYamYvempINFVGQ0lpZUdmUFk3SzVjdlpSR3lLeDBKcFA2SStRTHdvQWVwOEZxZ0IwaEp3b201eDRVVXBuaHg1aUJaK1F2Mmh0UVArNExVT1VFZXl0ckovdXl6ckVvazJ4OThUL05IWGxsNGd5U0Zab0JSdWtraFFnQU0wbys1UDZjend0d1lnVFlod3k0cjloUjh1VmZicTFGSG90aWJsbVlTVXJzK0dIdUFVN1lRTEhqcE1ORnp2ZWErQXBBWWZTNXFBQTVsNGN4aWk0WE8xM3l1Q0JMK3NocEI4eE1IWVJUc1BHWnBHWENpZSt2ODRSYk5nQVBUdzgzS3FYTzV4N01heVlqaVNwbDhzNm1mRFdnRnlOajJSL1hwVk1ySTd1aURneHNIOTRMaUFUczJESzlxeWFmZ2RsTVBBRVc1ck1nN215NUdLZU9hV0xMWjYvTFYyNEdLQjRFbkJKT05KNFZRT2xhSnRBZVpLbnpZTHc0aHBiR3JKQnpVNU5uYW5KcDU2NmRBZWJ4TVBERWxZaFp5MUpzd01NMnJRd1Zsak9kV1d4aG5nRFlyS0JEVjlPSmI4YzBjZXJVUkcvWG50Mjk0YkRtdi9vM2YxVWVEdTVqWTdiZ1FxalBhd0dRYldNN2txYzc4YzFPZk9RQWdpWFJ3T0o4bmlVQUUvL3cyMGtiQ3gwTSt3T3MybTFGUUJRamZaQjZFYVowU1dSekdsTVAwR21Ma2EwYnl4NDluaktrcFhvTEF5RGlhdmZsTnlRQzhFM0VTNlZNS1VsbmNaWi9YMGw5M09Cekhublp2WE5YWHJ0VEg2Y1RBM3U4dHlRa1pFWHFiWGh0aHZmc3pGRk1ac2FuNHdZbm9KVkp5SUdNSm1vT0lWNU5hNGROd0pGMmNwY2wxSkh2bVV5bTMwcFplV2dNTFZzZWhSSnZsTFBUdlExck4rVDZqQkFpUHcxd3cwU2p3RXlrOHN1MmR1RHk5ZXlvbnZZVUtuWnA0bHJiQ1BqaG8zaGp4QjV6TjB2TExUSjVFTVZ2d3RuRU1STU9NNU5Ja1dJdUQyWXlWbnpveFpFeHNrUHVtYWI0TVF0SzFwKytPSk0ydHRzNTRzU1hHWmhiakpPTEsxL21kU2dibzRBcjVoK2ltSWV6a2UvRjFNRThPS2VwZjFYSEt5L3QvZW52Zit2Vi9YdlRvWGhqTEVyaldlMW5xQmpFU1FjTmtLYVIvcjllajJjRGZDaHlBQWlBRmtJbW5SWVNNZ0lCOXlJWUZsTXNqS0NiaUFHc2dES3lrTVlYRWhPT2hhbm10OUxZZGY1alp1cWNWemR4Vi9mbldUcDlrcG5MV3pwZzhsN1gxVVJsMC93Q0ozVkhNVnJwNUFUQTFDR29tZTR6NEcrZHhMUG56Q1V0bVM0SitQL1I5ZmxRQXV1Wm1CeVdDNWpiakx3aGZseTZBandZRUdEQm5vRWN4aXJ2N3VNbnJXNU44QlFUU1IyWUFKSW4xd21oNlRQZ2J3eW9kZVJxRDNsTFdURWZoL3B6c0pjQ2FlZmxsNUlGTEdVelQ2WExqL1l4S2hGSVNhYzJCSDZVRGkxQUVXYWxMVEhSbXduZTducjJaVXlSOHBCdm5oMFlaaktmZUJDbkM2aHRLd1d3MlpwMzdkNVZyRzA4UWY3Wk10azJUZjdaNEhSVmxsbDdydWh3WjZZbUF4cDhnR2xGb1M1Tk9zVkVFNzlpcG90SCtTelFFM0M2SG5NUHQwSEFTaGtaRFpnUVMvWGsyckJiTWhzWndFNXZ4Tk9Calh4b3hlb3lsZGdZMXdUMDFhdFpYaDA3dFpnVGxzeGptdXZpRVhFdlFNMXJaV1dlc3lGNVRRWEVuREFSdStxMTN1allXRzlEM09PbW9raHVSQW53bERHQ3dLUlhwQnk0Z3ZxbE5DMUJWN2ZJUllVT0RWZ3lmV0N3Yk5aV2Z4b2hNRmt3YzVpMEJNN2FVeHRyODJhanR0USt6RHJNZVRveHAwWCs0OUd5YnUzNnFxTm9tZ0pWZ0s5TzJlSWRKVk1GenNsVU1zWVZFUmhqeHJ4TUtOZjhVc1RFT2UxcU5DTm1CMU1XeHE2ZjhDUkpEOG1rNU5vcVM1Yy9KaWkyWm9RTGFNK0RjMVg3My8rZnJ6eC84TTlmZmZsTC85SHYvdllYbzlIalNwTldFK0dMblE4ekF6WW0vVFI0OXlwUWlDQjFoNzN1Z0VkYU1JMnAyWmtWOUpFQWJkTENtU3VOc0t0OG1MdWkvUTVNS2haMHJwYytnSkorTWVXa1dVUDdKNTROQ0J5ZTQ1bGVqUlZUSHZMWVRDVkp2VG9zb0gwMEI4NUZ0dE52RjlVMUFDdEFITkJ3K053NkNLWFMwdWlHb1R3Sm1FbTg2dmttTk92Wjdrd0hTZWR6RDNER2RMdTBDbXp5dTlWOE9zUk1XQm4yQkZpQUQxQTIyKzU2blZKZDZDd1lNM2N5NXgxOG96dndWUjdQNllDM0ZJSmhldTV4QUFTZjFhRjdYRCswUEVQL0tBakFHMTJSRVVGZjdaaWlmVVdNNjgvOUZJck5FcFFQeUxCZEc2SVBCdERLalM2QWMrMXFKcldTdnVHKzZ5em5sY2Q3QVFlVlBSMVE1cjhNQUxqS3NVTS85OXhueXd1Qks1aDRHL0ltVDBBSjhIakc2dmgzMzA1NXo1MDVtM3EwY2pFN2t1UWQ0QUF3b3lDVG51ckVDQUhEVjI3THRFMGlzb095MTFNSWJQVmlpUUNYOGdSSy9kOFBLK3pBYVNnTTJKTHVsUmt4bEM5eDd1MkwyVzJNZjNmYVVid1BFNkZjRksyV3ROcnoxS25KZ0ZBV3BnVEFUWjdhVWd5QWtqY0VabkZBbmpKV0h1MDRrR0JNN1dDaU1DbWJyYmJDL2syc3UwYTdhdytlSzZMc2FVdjk1RUhPZTltaXpKSnAvY2QzZFgwejdKaXQvdjdkS09GOHR5TTUwdVJhSzJrcGZmWEZmQ1I2SC91ejlyZjQ2R0hTSXEvcVh1KzA2NDRBV013eVFKWVp5Z0lhK2VMMXd1N1BqSmthMU5HcUxZeHNlS1NRVC9iMTA1T1R5VVpmeFJhZkIrZTU1djc3Zk51N2NkVzJyNzM4dXovOTRXdXZSaHV2emNTRStManA1QUVSSFJRWTJRckpwRitCWk1DakE2NHVId1hLMVl5YVhWdUcvYVJOQ1M0aEtwaE9aeVJvT0xYSk95d0t1SmEvcndBOEFYVU43U2h6aG1zaVdJNFM5ckFNd08xWm1FbzlNOWZMaTk5MVpMOFRwbHhTblovSndYUGFjREVnbC9PZXdZaFM2YVJUY1RQejJiTTZRSlZtTitIQkk4RHZGUUpVL3ZLU1M0THVRV1diem51TkJQSUwwTUcyNmprQkIrV3FEcExKS2VOSlE4THlIUTZneVpkTzZibGVRSW9MbFhkbHVSTVFkeThtRGNpNWYxRXliTkNyTWtsbE1ZTmhKdmE0S0IwVU9Ea3dNK21wbDFKMktjL3Qyd0dyWkZ6OEN1RE5qbXVycDJRd3R0b3NMa3BkZGN0K2sxelBydGtpazFFb1pXdU5LVVY1bVJJYXFFVEo1cnU1Qi9YRmZKT3ZCVlJZR0RZS3BDMnU0RDN5alcrOFV1QXhFWE1INW8wWkEzQjVsczg3MlNLSkQvU0JadzVsRW05bEF0QWZyWlY2d0pZSmd4OHZJRjJiOTYzYlJtdlJqSldNYk8wWHNsREZaRnZsTmNEaG9PRGxPMitwaTVnVUlnZGlsL0Frd1o2WkpVZ0NyNGQzM3Y1bGJ6VEFQRDUrc21KNjhBaWhWTlIvYlVpUS9BQzlEei84c0pUci9nUDdrNWRsQWRtYmxYOG1EZk1Zd05Hb1JxQW1aYktLVnZtTU9Jd2tTSTVKV1VCNU5Vck9LTUN1TjVlbU0wSkp1MXF0UjU2QTVwb29xMXdlUm51emJQd1dHZG0vNzJIaWxWeS9nZDFuWVV2TVZKVFc0c1h4d3NqcTNjYkU3L2VtWXdveHVtalB5OFI5NnVOdUZCalpCYkFtZzIzdWE0TlpDb2RpTXkvaGZtNTYzTy9Vbi9LUlgyWkZ2d25OU3VFWkNWSlM0b3VUSS9VN0Q4NGxkbjkvZjdiSDErakZ6eCthK002cnIvWWYzcjhuczhUWjVpY05LSVpERzNLejdWcmdFWmU1TklxTzNvQ3dZNllOQkFzbzgzdHVuWHNSaDNTS3ZEb3dMc3pLQmVtL1NUTk1Gc011c0t5a1N5amRBOVRjWFVBWllIS3Q5REZLNy9XYXU0NnQrT1A4cEJmbWFONFh6YllMbU5rUDNaT1NOS0JLNmlZSGdaNXR0UnpTNkJTQzh3U1FFQ3N2d1pNbnRtdWQyVDlsTXZwTzFlVGRuNVFoSGJIS2xldjlDTEF3YU9jQUFqT0czdGF0cEd5L1JTbUVzWWhaSVgvQXhBU1laOHNUczBSMWRubFJ1WTY4S2M5UTdIM2VHM3RMR2RKR1FFQmVNVTNBTHcvZE5UR2NGQ055UDBhby9yMWp6bGJpaVRVaHVBNUFNY3R2dFIyV1ZtbGhVd0ZiYWJMQmt3VmxycmpQNmR6U29ERExreUYxZmlPaE9ySGM5VEZ2OERnNGV1eFluckVpRFByNWRQamI4WUo0T3gwN3JEbmd4MjhaeXh2T3NIc3dqTmJ6bUJzb2dPZWVlNkYzWVArQjFJWGwzOWx5S2U5WXBwV01RSFhUeU9hcU14TjZ5NVlOSlV0dDRvdVpoWDJXaHdzUEZtd1A0K1lGUVRFQkdUYmZ4YWt2dnNTWTR1U3A4ZDZidjNpajVHeDA2Mml4em5Obno2ZnRIdlUySjVZSTIvaTVLSUh6MlRKcld5WTMxYitZSDdZcG8yQ1hKUTFLUnhBbmVhZjRqQzY0OHpITGlDK3REWmVuaks1blQxNFdjTGI5RTRWSDVuanBXTFdvM3EwZVpLSmhQakFTTkM5VG9YY2pieFMxU1ZibUlORUV3d3dDbmxicldYNXRCU0dQQ3E1MS9aR25BR3Jra0QyNnZJTW8rTFFWeGNoTHhUdVpXWmJuMnExRm1GbEwrSzBFNWFXanFaM3pIT1dLUUJYQmtLNjVudW1ZdmlqeGVYQnUzZlB2N2UvTEx4MTg2OGMvL05FR2JuUENmeHJXQWdiQ0l5eWtIWTdEQVdQNHQvVlF3Z0xPZ1NIUWNnQWVMMGNOSWIxSEtERm1FemM4RHZ5Yzlxdy96bXRRTDZkb1pRS0F0WnFrQVNUMW1rdVhEMnpIS2dIZVI4OUtQZ3I4VUx5NUF3aTNhNEd4eHdXUUFXZnlMNzlZdWsweUhWeU9LbzR5alQrbmNBQ2pBOWpKRjNDVUJyL1VlcGJDZEllMHZUd3plYTA4UXowMms3elhteExtR21xQjhNOW0yR3l5MExWVkQrb205emVFejdYSm12eTdCOGpLajd3QkplWEdkdmdlSzR0aE1RQlZqeDdyS1poVlN6dUtKUjFOTythbktvLzJYSkZZRHNBWVErMkxaODFEbzRyVU95YmZuem1BTlFHUkJkbkhqNzFXcDFZdUsvVUVhc0tzMXE4ZGJtbW1MTHc0TU5YaG5OTzVEWE5uVXFmS2RUVWVFb0JmdVFSK3dpcU5CdjZQZi9WWDVSZUwrU29EY0huL2d3OTZlL2JzS2RQSXVXeFNpbWxUUnFLdzJUUFJoT3lGaTlPeHZkNUkvbGJGOUpGZFFtTHVXQnY3cDlFQ0FNT2FUY290SHpLeHhhU1ZVbWVDZzd3K3pFU3BGbTltczVpdm9wUU4yMjl4VTR2dDF1S1hqWm1jdE1YVTBXTkhVdGZaL1h4T21XT1NKbmpQeGVkN2FlekpQQytNV01ZemlYam4vMmJ2VHA0L3ZhNzd2djk2YnZRQWRLTWJ4TkNOb1JzZ1FZS1VLVUlVRlEzV2FHdndvTEpseXlrcGNSdzVjVktLbldIaGhSZGVxQ3AvUUJaZWVKT0txK0prWlZkbGsxUmk3N0pJV1pJSFdhSW9jUUJJbUFBSmdHaWdHK2g1enZ0MTd1K2g0S3E0UWxMWnBaL3U1L2Y5ZnAvaER1ZWU4N25ubm52dXVaYXJkMDFlZCt0WVRkQSsxRDZheTBlNWlkRTZPVzF1RHNZSUFTKzluNDFidTZDUnV0L3ZYWFRBb3J4Zk1JMU94aUlkK1l3Sm9nbEdKaVJ0TkxaZG5XMzFvZDB1M2w2ZE13K2FPNW1tak81RThEc2NML2d1c0pWNUJqWnZuWkkybGVkTTZHWE8wSVpIZWw0WTJYM3hwb0QrK04zaUk4dm9oV0xWdWRLUVRRakh2Vk5uN3BiczRSYkJXSXdrelFmZ1hNUDhmM0hRbUgvc2M1LzRSMy8rNTMvK1IzN3l4MzY0eVl0akRXMGJpamFjbVRnT3JaaWFoa3hUd1F4QXhZN0FBMUkxQk1iN01ERDdUYUhxSTRha1dUbGp6cG9NRStyWmVYQk1ONHhwUzNPWXQwdUdjN1RUV25qU0hCTkF6RWRMODZTR2Q5QWlOM0NXZ1Bjbm9lNEJKY3dLM0REeEFyOEFjZnFObGNibWlpWXROa0pwS1pyMG5hT3A5ajRnR3pCTUcvU3B3NXBucGpUZVh2bVJxZ0hibm1FYkgyOFE5V1FxS09NQjVYbGFPWVBQdkQxTTJ2UXJ3Ykh0VkIxU0RBK0FwYzljQVpqY0I2eE1TMENGRUF4OWUwWjVuRFMwNWVOY2ZsMUhpZ2xxUDhCUFkxc0JrYm80TlBHK3VRUWEyTlc4RVV5Q0dRN2Z6bFBEa21HeGo0K2ZzSnVJTXE1OTg0Q0NpVHRnTlpwcHczR0xEbWg1T2d5VGh6UEJXeG5scDZNUXd0UHpORFdhTTF2MTZUWTBOY0gyM250WGR2NVZtdW5wM0FRL21UbmlyVUR2OWJUZko5dEpYSjIrOXRycmxldEFvVHZQemlTajBjUnJiWkw2eWxkZW1jNEJnQWpXdzc3NmFKMENZQVpDNGxLZzY4bVQ3ZjRTM1V5V1diaGlZMVZ0ZnJmMncxK1BQVllJME9wTVU2WjU2b1R0Y3M2RWhIOW1zVXQxL2xLbWk5ZXlMNTg5ZTdZbDRVL05oT1NidVFQdWJ5V2l5VStnU2ROSGYyNTNRTXo3eDVJZG9Ia3oyUmx6Q243dnY0NEpLSDl3S2ZORTdRNFk4VGd2Rk45cHgvWmtmQ1FiT05PUzVmVkdFNXRKemlRcFlMUUQvS3l3TEQ4aFA0MEliSXBMcStYN2ZUL1BqWXBSR3k5VG4xV0FPbmtha2trK0FFMm04YmtKMUxmcTFFeVUxbkREcGZzcnJ6b3hhUmdWTU8yb0FQNDNVWGd3KzdZNDE5d1ZIZHhMMVhOa05CNTRBTTVEbGovK254LzdrZS8vaDMvcEYvL2NYL3lSSFBJZnlwWjhMZHNTelU2UHpZWkU0d0Z3bU9aUXc1Y2JNZU9CQUdCQUtqQndFS2hOVTF2WEEvQkI2TzVyOEFEQkpDRmczaVpsTUErdEZJTWI0bjBZSEduTzBnU08yLzVsaG9VRFVuMWFpQ0EvcC9kOVFySUZUdDd0ZDhlVVd6azZYUE9ZZ3pib1dKT01TOXVmaWM3S09HbVdOM0FuT01BTTQ3bU9PZjFlN0FjRjUvK1VGYk12T3BSWHpPMDVRQXljZlRYUk4ybW5BZDVxSXU1NldxdHJKckZ1NXdKbXFmVys2S01pL0ZRQmhpRTJHN042eVl1V1JUTjFqd2FyMDVJbjRaU2Y5UGxpWDBtb2RaN3VMYzFxRFZrOGc0YTNBMkdDZExWUHR0dkR1WTZaQ0oySm9EUzAyM2RwWTlHZ2EwaHBBdENRR3cyclNsVmFleEJhM3J4TldGcTQ0dENaaUdGeHRYZG9vOXJnbmJ3czJHblZrWDN6NU1rVndIODZxTXAwN3R5NVdmMzRPNy96T3ozM1FmR2duOTM1OHBlK09HbS85TkluWnpuenFVQ1laaXZZenU5LzRmT3phOGtycjN4bDU3WDhiTTJIMEtJZnplT0R4dmVSMDArT21lVklJQW9ROXhzRlpPZC9PTVhqWENzbkY5Z1V4Q2N3NWpxb1hoOWtZcm1ZVm03SGxHZWZlN3E4ODF1dUkzbExBS2lKUVpJZmVPRlUwZVZtZEgrbzBZZWdSK2ozUVpPUzZHSUNVY3htSVVWMW1wdTNoQTVCVzJsTHBpSXVmem84aklGZU9ORHYwL2w0ZTQ2R3JZTXp5VFk3MFFSKzlpQzBZdE5tdGt1NVdHMGhUY3U1OGNTZDJvMlp4bXdPL2wzK3pOZmluMzBEcWpwVVduNGNPcDBzK2RMWnpqcURlSWY3NGVjLy8vbDJKMjlYOUhoTy9kQ1AzZDkzTWtqcmZ1T2Jidy8vOGVmbTMwNCs1Sy90M0g4QXpwSDRlejFveTJkT1AvVGlTK2VlL0JzLytya2YrRnMvOXhNL3NmUDBtY2QzYmpaRXUxbXZlanpmWnByVG5ucGF3bVZJUk11ZzRkMjV1Y0RhekREQTVuSEFXaXV1aHZNdURXV0hlMXdUaWRsbWhmL3NrVkxqaFJCVEJPNEFGZWpmRHFqU3JVS3V0UEtlRi92NVZxdFJyRUlFSW14bUprVUErc0dHaXZzdEtQQjQ1Y0hZMkhOc2NBRUk3VUlFcjdHcGxUWk5rNXVkSEVUQjR3Rmk4UXRjM3VKQ0crNFNIRm9DQUFTdzhsSmd3RTNnYURpQVROU3h1Mmt0bzMyMFdsSTUySlpwakNVOHdrU2duUHU3ZjZCcmJpbWxkSmRMVjljU3BQc05FZG00OXd6WW1ZQk1leXZTR1M4Qk0vdHNpbXprTkRGMG9MMFFETjRWVnJvQkUrVWxYRUE0Y2s2NUJCTVMxSjZ0MWtXMEdHRGZHR1ZvbG5raldsbGlmVHlobzllL2wwZENWRXJ3VytYWGNQNXFHaEdCUGZ2MDB6dVBQZjdZYUhVOEVwZ1A5QjhQcFRsWkp2eGVxL3ZRN3RFbXI2eWNPM1hxMUlUUTNHZm9XOGRyd3V0VTJqRXQrSlkyU1ppQjBTZGFLbjBobjNrUjRSNUxtejdSZXliUXZ0WGsxZXR2ZkNPQXU5UmlsTWQyL3VmLzZYL2MrV2YvN1A4YVQ1SlBOZkVHZ0dtWXdPMTAyM0k5bEcyWmovUytGajY5K3JXdjdYenBsVmNyMCtWMktqbFdtK1RkMGJ6Sk41ck12QmxvbmNvVWNTeHpqVmpaRnk2MkVJVEduSVo1OTA0cjlUcmo1SjBEdVhEZXZXNC9RYkZqOXU2Y3NUS3lkMS83MnF2alhuYnlsSTBGMm5HbXRyQ2MyOEtYVDd6MDBzNXYvdlp2Ny96Qmw3NjA4LzAvOExtZGJ4UUh4Q2JINkhjOGw3MTNtNndUSmMvQ3JGT25ud2c4aXdZWS9mZEhHMlcwdXRZaUlHMXFzZzBRWHU5OW13bWNQbjFxVEFtOGZNUmN4a3RXWTFJYWROUk1FWUFkcDFyTUpjYjFiR2dSVDkvS2hFSEpPWjVHcncxMFBwYXFQM3I2c1JpMzlvbkgzMi9GcHVOYXk4RlBzSGxYNTVQSGpoU1A1SzJkMy8vOTM1ODIxaG5wQUt4MDFIYUFtSG1MM0pEbExkd0FmalhaNjVrSDREeGsvZTcvbkd2VHRKYysrZXpmLzZFZi9PemYrNkhQL2VCUGYrejg4enVuSDIyaUlvWURCZytsYmFBdUxXeUVQZ0VmclE5cnVCWTNITm9kSmhGK29FTkJCRktBQXBBWkttK2FKd0Nsc1FXakEzeGp2eTBOUXpUQUNsQTIxelFBQzhDRHlkMzhvYzZLUVdINEpoM3B4b0h6WFhsb0dzNjV2a3NPNVhDTTl1ZjVudlB1QUhiM2FJVEFWeS92dXRubnBmbXNkTmkrTjdjNTRMYVdSUzl0cE1lblkwQ1RkWWJTRlhPbEI5U2pVZVdYcm05VGh2THlrR3QyUFRFczFkR04xdDg5UXNtMnA1eHo5SXozcEdBNFN1TmhyK1VPUlNoQnZ1dnFQS09MZ00zejZyM1JZZkxxTjJIeUxGcTV0OXB3clQ0alNBU2QzZHI3dEdDQ3lMLzVab0lITUxuTEVVWmFmQTA0cHBXOUFZMjgySXkzNFQwNktTZVBEZDRhdEtqeE1LbHRUSUlDS3hOY3RNS0xlUTg4Kzh4ek81OTUrVFBSWk84QU1qZThaOXBvbHNmQ202MCtCQVpXQy9wODlkVlh4ODhhNzhqdkV5KytWRWZRTXV0ZGtOTCtWaUJhaXN4R2ZURXQzWVRreFlMZFg3ejA3bWgxdDI1ZEh6ZXgxOTk0SThaQTUwWUZiTEJYVzJ5U3VlaEtQdEMzcXkrM3d0dlZqMmVGT3AxNnRJVW0xZitibVYxTzVVK3N6bC9OeTJRQ1EyV0dNTXpueTQyRzNBVS8vdkZQN0Z3dFg1b2sranFrb3ozVUVZMnVaZWJaK0hhN3R6MkhycndydHZlMWl6YVVsalRRd0RWMTEvYlNjV2pialFkdXR4QUZQWGlSV0M0L2VRYms3N3h6b1haWlhpVmtUNmR2cEZHVnAxM3RtRUtETC9taHV6Sjg0UXRmS09iMTcwMCtUOVU1b3Y4ajJmbVpnRFp3cGtBd1orRm4xeCtBOHpUSmQvN254YWVlZXZHRnM0Ly9tWE5ubi93N24vclVpMy94c3duR3B6NzUwdXhzdkR3VmNpdkt4b1FwYit6R3F3V29uTXFCOEdZK29NMnV5WXpGRURNOEMwUUExYlJ5UlFLOG1HZnNXbW01Z0h2QXViOHJ2V1VMdzJnYmN3NW83SUxUc3QwRlRzT01hY3k5VDJNMVFZRVpEMGd6aG5kc1RPNTl6enZMWmhoMWdDcEI5Q3picmsvUFlXS24rNTdmcnZ2dDVLSGkrdmFzVC9tNDUxbmFJOEIyeW81NVpnMWRhZWdCNE9nekZhNmViQUV3bVA2ajhrbmIwSC9NS2duQ3JPQ3FVMUp1dzBsQTVwbUI5L0lHYUJzNFc5YXNNeU93NnJDOEFsWk1nMDJBWFZkZWFiaTJDYlR5cTR2WmRVRHNZTnNtNUE1MUF3NDJqTzNCdEswUEVscXJBZzhtNUkrUDlzYno0VkFyeUpScG1TMllSOVp5Wk8rcXI0T1pnMzE1TFE2Sjl2MEQ3dkw5Y3JaajlsQ0xHVVNaRXlIUE5sbm95YlJ5SWczWENrUmxGVGFWUnZZSGYvQUhzOWhFUnlNc0ozT1EwQUZXclFGcUFLRnpIenQvRGNRa1o3THlRdG9pK3lnM05JQnFFdFNFMTNXLzIxNXRUd0I5SW5QSGtUVFNHbkZXMGwydjh4ZjJrODMxOFh5YjJhNU5iTHJHTnR2Z1pQaGJCMzQwTGYzNTU4OVgxdmJZcTc0Nm5LOTk1VXREUzdUZmVJWThvQm53b20zeWQ4YlArQVlQTVUxRjlNRHovVzkzbHVycUdQRHJ1L2JjcnJtdTNRRG84QXArNmRUV1IvTzR1VmwrSnVqNFJSdDl6a0tUOGhFNWo2bExXYXhjUkhPbUVoTjZnaXdwei91dGpwU1c5cFMzZkhRKzZrSTVPRjdjYis2SFJpMFVHejdqd0g3bVRIcm5BVGhybmUvaStPUzVaMy90dWJObi92NHpaNTUrOGNRamhVODBrMXR2SndoUjdSUGdDdEdZRmhzUUFnNE5BUkFubGtRd3NRRUdvYkJvdzJTUHhSWUFodERWbHFOQlcvWk1VM0pvWEkzVzNYbG1Mc2JZR013OURPQWdoQTdnTUlBZHVLMUxHR1FEWWNESHBwcUwxKzY3bm5jNkFOTEdVRG9NNWQ4V2xIRDVraTR6d3RKWUZ6QVRLRVh3NlhubGtCNVhNWjhmMWs2R0h1VXo1Y3M3WXRWdGdiMTdudDA2aXIybE0rYm0rVVBrT3JybWMrV1JYVHdBV0JjQXVBZWlZL1JHU3dJdzlPa0I5ZktkRUV5QSs0QlE1NmNjOHBYbjlnemdjMTFaWEhOdXRFVWI1OVF2Z0dDKzRTc3QwQTVicHQ5c3dLN3htOVpHYk1UTUU3UEJiS3ZEYUxsYUxQWVlvUlhta29ic1hlWHczZnNtazQwUWFNNFdrekJyUkpFeERUSFAwTGkrbVhiOFhtNXlPbldyRG5sTXZKYldpM0MwWllzaHhIcWd5ZFA4VElhS0k2dytGb0dZeUJJSTZhbXpUMDFFUER0NHJKQ2poZk5NUTBkUzlsVDJXVzA4OUs1TWJNVHY1Z0luek1CaGsybDFQSHVTQVR0Nm00azRGdEFjU1R0OEt5MGNrTFBuV254eU9uTUFWN24zNnh6M01OT1VQeDl5OVpFK2tPWi96ZHh4cTg3TkNJQnljaUdQRmFZam5aYUZObHprZEdaQVZWMjBrWFl6U3RETzRsWVlzYURueG1NVjY5dDg3cnMyMWo3YiszNFB2K3kyYjRrTzRGckl3cWRiR3lvUHVscXFibEx6NUtsV1NlYktwN05CWHgwd1Q0eGxlaXdPU21ZcjZkT1V0WUh5S3BzSllIcUVNdU1MSVU1RnFPVEtDc2laQVIrQXMxYjZEZzgyNXZadyt6dFBmT1N4NTdsQjdiM2JMSHdOR1VUVUlDMWlLTTd0MFJ6WGVWR1k5S0xkRGhnRkZobzRpUmx3eGdDSE9NREg1Q1A4dGRMWVdMdmVseHF6Vmd0cHJIeWExWVFaZUdrejdJUzBiMEtzd1dPMW1JMFpoRFlMcEFFc0lGNExTTWFzVU5tQWljZVZDYlBTdG1nalFQZkRZT2s1djVWSkdYVWN6Z0d1bm5WZmgrTHdITTFoTmxhdFBGTVg2UVZFc0ZUdnZ6L2JHMWNyKy9ZeEphaVh2QldUMnhxLzFYN09TY2hwdnV6R1B2MWVkVlRMRGcrVzdwZzRLdE5veTBPdjdsVTUxT2ppMkxPNUt3RldrMzNLN0xxMEFHcS9xdCtxOXpML2lIMnd2RWNJcW1kOGVzOTNKM3BzSU9BZUlaNTBTOHNuV2tqZlBZZThIU2EwcHRqb1VhVUJDNkJWeDRmU3lxNWRXWXRsck01RFl4cTB2R2FKY1pxWGlUYUxLaHhBbDljUFZ6aGc2WGpxekZPVDFvRGJDRFNmNWV5WEFibTQwNDltZ3pieHA1TlNKc05wSVZDQkJBM3U5YTkvcyt2TUpmakNDa2ltSDd1bHBNblI5S0t6SUV4UFpqTStlL2JwTlBSSHA3NDZqcXRYaW90ZFo2QkRPdHFrM3I0OFoyN2tUbmVyanNhRXJQTjRRQ3o0bHYwV0QyVWEwSUdnT2ZDbGdkNk14NDNtYUpuYVpKazREdlhzd1oxLzlUdi9jdWZacDVmUHRWRU9yVjhkOENWdEZkak5UdWUxTFkyVjY5ejRYN2NjSGE4eCthQ0R0dGxHUGNCNmExc2RvRkdUVTEyM3R0YU8yc0pwMFl6d3NpYnJUTUJxNjgya3hITkduQlVnQ3JUeG5GMXNLQzA5V0FlWHFhWjM1QW1BMFJzUFdkRklnMWFYRysxQmFhTGV5a0x2NFdFMDB2bW81d053SGpiL3p2NDhjZkprNFpoUC9yMFROZGJwdEkxVGp4N05QN1NsbC9XVW1OTWt3K0dZRlFpWkxEdFl3NC9naHJYQUdiQnFPSVNuQmUxdm91OGUrM0NOYTRoTjIrN0Z6c29Ud3RGd01SWXZETXlnQVduZ3REL1hETFZXV3F2SHgxak9EVmdPV2Z4UXZqMDYxemRCM0o0Uld3S1RLS04zbkZzYTJ6TW9BM0E5UjJNZXBxbjg4dWNDaG9reHR1dStlMjVMWTNZKzZScW1sTWVIZ1UxZUtybytWL2s4SXcyZlFFb0hOV2phYzJBVldRYVUrelo1QUhvMDdWblAwK29NUVFrbGVrMUhVRDRFUnhrQmdWeGQ5ejdOVTM3SzkyRXRxa2VtSHBzRzdWbjFrc2RXQjg4WTNkQnVDUk9OeDBqRGdnNWRoV3M2R1hVQjBEcFBMbHFYMHJpa3h5VnVYenZkdUcva05JQmZHWlZGUHRQT2dRWU5WV2VzYnRRQUUxRDhpa3RrNm1Nb2JNVWZyNGd1amUzV2poOTQwV28xUUN3UHg5QzBUL1ZDajlPWldIUUlOT1RwVVV2ZjRnNG1rT2ZPbmR0NSt0eHo0K1dndkRUd2Q5OFZ6YTA0eEwzM2VDc1BiK3d1RmxFdnZFbEp3YTk5akNubXkxLzlXa0I2Wk9mYytmTjVmclFrdlhUSWhya1VLeWNmM1RYeFdKeEJVOVpwTVp0cDZXZWJSRlZPUUtaem9lR2ppZnFzTXJmUUorRFVmc0JWM2RRVFB6RXh1UzVZbE4vS2hEOWRCOGF1NlFEUjNMczZJOSsxc1ZNNjN0ZHdJM2ZSSFBoYitlY1VqTW0raWhRUWkzT1lNVXdXOG9lMmxGNW55VitkaVVONkd5QkwwM2VITWxta0pDOFR6ek5CYTNLMTU4M2g4T0I1QU01RHF1L3N6OE14UjVONGR4NSs2TWlQbjgxZjg0bkhpanlXMW5BNzI3SmRpbXYvR2hsUTFYTTJJU2cyOHdqRXJ1WThwb2tld2h4UWgvZkdBRmRhQy9Wd0NkOGFYdnR1VnA4UVNRT0lpN1JtYVMwZ2tNYWRHaGRUQVdCQXJxR1h5V0lYL0tjdldIa3Q0U1BUaTRrSGJHSVdndWM5djZXSldUSHlsTHMwbGNNenhtRHVUMzZWeVRYRFRoTndOQi9wZnR2MmwzRFJWb0V6amNoMTk3bmVBY2lsdWJJVnAyWDNMSlBMQUduZlBVZHI5ajd6eE9TZnRFOFpDUGVrclZ3QmFOZW5yR1czVFVyNkZFV01JRWgzNkpUUSs1UkhDWTNXcnNVTlBWMVhmM1RlYU8zZFRaQTl0d20rNzU3ZmpySWRlaEUwZE5sbzZiNXkzWTB2WnFLM0RzUnJoc2J5bjEyL2UzNy8vdFY1ai9kR0QranNOdTNPQWhscEtJdlJpeG9yTDdBQUJ2aUdkcWlUcE4xcXQ5RzR5Mk9OcHZhMTJPT3RDUmxxdUEyVWFKOWYvZXBYcDI1bnpwekpobnd0dDY5M3hzenhSdDRkdkQ3KzhBKy8yTzl2ekxEN1lPQm9BcE1iR3B2MGhFa3RuK3R0OUdxQnl6NG12QURTb2htaklEN1BnZzhacHB0RXUxWkhaUUxhc3ZOdlpnTDQ1cHRpZ0N6dC9HeGFNWThNaXk4b0toRW1jMEUyOE80ekVYMzg0NStZT201dG9ZMEFzM0tveStyRThDeWdhN1dnMkIyZGZtdG5XdlQ0TXZlZWQ5RUhqMnNuYmVnMHN2SWJmWFM2NWgwOHUzWEE1TXJxUzVKcGRTQkZnR2VKanZKRU81aGJ5MkFIRndyRGMrZWVTOTZMekZlYkNPSlAwUkpSVU9laVRaV1g5cXlqR1Y0dTFmZnppRkVPM2pnVUx2eUVWdnpOdGYwRGNJNGczK2x4TWFsNHBPNzc5Q01QLzJKN21UV1R0R3hlSmt6WTBZNmJFSWtwdUhHWkVLVDRhWWhnWVRSbmpiMEJhNWV6VXhjOHBzYkRnRUoxQWdFQ0RMdzBtaUdPU1FqWGFkWjZiSnFMUm5TTk5xNFJIUmdQQThnUGN3RU1TMnNCNHp6Yk1KT2dqTjJ5TkNmUEdCRWdZVWp2U3N1UTBmdlM0L2JtdnV0TUZiNWpJb2QzS3VJSStsWUgxeHp6ZkRjcHRZNEJtTW83d0Y1YW5uTmF1Q0xON2JvNks3L3lMZ1l1Z3prV0RYd2RjTzdUc3pZWTNlcFBXeHU3ZWpTbGdYbGYzYWQrZlRvbTNScGw4MWdoYlBMZTh0dnlWamJnTE8ydDdGdlozUE5kdW10R2ZnRThtamxkbHg1NlpvTVlZTVVIVTk4K3RRc3ZuWnU1OGwyN3V0czJ1elNaMEpIUlhiNU1Zb1NiWFZWYmFIKzh3U3pDNndQTkFZRGh1VWg3SmdTL0VjQmFmZmZPT3hkVysxWk81ZUNhcDI3S0puOGc3aEJUWWhhdXZQSDFzVXZ6TXBDZW1CV3Z2LzcxbmZjREU0Q0ZKMHc2UHR6bmFOMlZEeE15Vitsc0tTYVhzZ25mNmpjekZ3WEIvWU5GaGRQQktrL05NNTNLMnkzUHhsZVdzaDlva1loeVBUWXVoTG5XQlc1R004RE05MjROM1V4cXN0MHF2N0pvRStVMDRhbHV3TlhTYzUzUDFnN2FsU0lERElHaWNzdExPNkF2c3dqYnUrZlprSDBDYTIybkUwQW55NnNCTG0zM0c5OThjK3ByWjNXTGlzd25QUDdZcVNtTHlkTW44aDFuSHFKVW1QeTErL2NUalF6a3AvemFRVHY2clE3S3hCOVJaOFJVNHQ2TURtcHpJNFJwODJtbEIzKytZd3E4ZmZueXF3ZVBIdjdDMlk5OTdGY08wQXlEWG51cHpjcWtpTXF3ejFjVmlGalN5ODVJc05pTzJkbjJoSEtXT285R0dhRGZLa0RPcmRzV1VyUTRJci9RKzZXWlJQZnUwdkE0NXZPWnBtWGVqdmx2OTg3OUJQdHVESEtqR2VON2h1dzlieis2UFFuR3dSaVlZRnlQMGE0UDZHZUNxTUhGZXFheDdXMUlHYVRsQUJWdnhJaEpPSWUxNlFUaS9nRTRvTE0wdnFXOTM4MlAyWkpUWmIxYjNzRmZ0dWVFTFVIQ3hBNWdCclFJeFFab1k2L09wMW5ueEVWbzgzVW1zQlhYc2o2STMzMGdISGhVYm5VWE0vZCtRM2NMSG5pY2tOSng4cTljeW05aGpxWFNhTXhVNUtTOXJKMWdNaTMwL29yb1Z0NmxUMk9YdzZUYmM3VDFROVU3ZDROSm8rNWdKbThuKzdLN0ZRanlINy9YbklMbHdnUlhGeXVpMmMyYmxhM1ZmK2hwQTE2eExBN2xxMDdic1RSYkIzRXpPbkV2VTZhS1d2bVpkVEozM0hObW4yYWlxUDU4bHRuZWpVQUlxOWpJTkU0TGw5QlNHeERrR2Q3bjBzVmNnNWVPTjJsbTI2WTdwVTNiNXZsaGxISTBHN2Z0eis2VnorWExCZnA1K05FOE1oNHVHdHlGc1grZVN1c2NPMnpsRWx5K3hzeThzcnhOckJZOW5yMlo5cHF6L002VmJOelhQcmpZbG1xNUE3YklobjMwOEtFbXZ5MjBhUWVmWjU3OTZNNHB3L2czMm5ycUd3Vnp5dWYzUUhTeDdOcGNoR1hhQjQrMUpkc0hWM041YStWZ052RGpsVVhZeksrLzhWcnRkNk9SWjZzU0QvRUpyaTdSNEhydWVPZ21DRDR0V056clF5azZsSjNMN2JkNUtkZTZxOTFMZ21hcnJHZmI3WVVtRGdoMUVHVEZnaFh5RjZHTDdjeU0xVDZObHBESFE4ZWJqTDF5VGJ4dHRHb1JTVzFDUWNEZjdOWkEwb3BCQVpRQStLd0hpSEVFOW1jYjFwbmpWaE93ZGwwL2ZQREliSGhnaWJ3T1NIdVpsQldqUFJhUFQyenV5dVd4eWQ3NDRxbW56ZzdZUzR2Mkx3SWV1aXYzcmE3WlM1UWI0dlVtQys5SFE2eno0UGd1S2ZETmR5NTgrY25UcDM3OThWUUp3Y3RuVWlNaTAzNTVhdWg1MmFOR2cwaUxBQ2FHVlhwRVFnZHNBSUY5MWRnYmFVRjZWZ0txWndWdWVrNURkRUZRMkxVd3ZOZ1Y3RmxXVDlrRndzb2w5bFRnSXE4VnpwQ3ZhcE1NdVc4QlpkcUdQR2tOVEFZT2VZd3BJcUJ3QUZSRFExcUQ5SlVGSUFGTjE5Z1RsV1dXZS9lNVRBK1pSNnJFM0srOFB1V3o1ZVczZlB5V1BtYjNmVHRHdzZ6Y1U2NmVYVUtpM2dtMnVrWWJuUWR3WGMrV2x6cnNwakZwcGJGSWUvTHNXWWV5b1orekZwaDZBRTNEZjNXUUh3QTFRV2RqVnFZQzVkUWVZNy91T1Q3V2pnd0pVeS9mM1BNc3V6MmdscS9yeW1zMEFTUm1hWE5wR2Fxam1kL3VDemU1MGFMZXFHdjhxcXRuQkZRZTdTL3RBek4zSWZaRzNnd0o2TmhYRzRFdHpTb2JhUGx4UjdNOUVuNjZXMGNDdk1lM3VRaHd6M1RhOGNXb2pSM1ZTanc3V1ZNS2pMaVdCMFBhYnVWZDdXczNqclRhcW11eTBCSnVoN3FjZnZSMDRIaHA2aS8rczRCQU5PcFhYbmxseXZIODh5L3NuRDkvYmpvbm5hUEE5dG9ZUU1udmNQbS8rZFk3dFYzdDNra2pabk5XTnB1OGloWW5ic1pzSkJBbzQ4ZnA2SHZHU05RQ2xBdTUxSm5BUEgvK2ZHMnkzQjA5UTlOOU5NM1hydHdDQlBIRjVobkU4MFBZVGJKbjFSMGFLQk9ObURsSW15MTVXNk5FOGFYUm5hYU9KbU9yYnc2QktVTjdDVUxsZlhTakJkT2dhZXo0elR1bktnTWZaL0t2VTdpY09VUDZ3b1ErbkhQQWhRdUJmQjNFakNacWF3b1pPcGlYNEpZbzhOZVN5L2lnK20zZit6SjBmd0RPdzQ3Zi9aLzdOMi85MDhkUEhmOTFNK29UVkNYTmxwY0dlOXNqSnl6RlhET3VnRVZqYVh4bUNocjJnSEhDQ1p5QmlOODNBbHJBQ0FENXRKck0wT0NjOWdFMGdSZDd3VFhEV0o5OFlGMi9rV2JEL3hSVEdkSVRZZzFzeFJUM3R5MFFFcTE5RnBCVUpocmNaajdCdEJoTVdXZ2dHQk5UWW5JZ05rUE1tR2ROK3BSODM2ZnpLQTJUWGlVMlFEUnBKbVJoMG9DdFlnQkNhZnRjd0drb3IxUEk3TkI3OHJMcmlMUTNMd3Ywb0RVejZXeVRxTEZ2N3hsMTBNUlhKN0FuY0ZiT0FlcnF1NDdGMkZPSDZvdithS0ZiQU5EcmVka3ZqNXJOTk9FZUFCNGg2YmJuOXFiZVNnYzlUWnE1Smh0ZUV3T09sUWY0eWtQOVp2VlpHZkc5MVk1K0F4MkJjaHpvdkRmTk4vSjFMV0hzK3dKNVppbWRhckdEZ1dEYTZvVTBNVDdHekFyc25kTVI5NHpuTEFQbndmQitHalA3dXM3NzlUVGhmL1BhYXpPeFpqSkpSNlJ6cmtwakJyRUpMRm9DT2tIcitYdS9FMThCZDlvekNxRUJXemMrc0lEbWFxQ3B6Z0loZlNXZjZtOWxJMzcrK2VkM1B2M3BUMmRDZUN1Z2ZuWG5oWTkrYk9mNWo3MFFTRjVvWmVHWGE3UGliTmQ1WExlYlN0cW9LRzA2Rjc3TDcxVXZIYTQwS1J1V041OUltK2JSY2FFOHVPUTlreTM2M3QxYk85L0tqR0VSaTFFRExkTUJtSlZYNTYzc2VoVktnR3RzMFVadmdCUS95R016VDNqKy9Ud3ZkRWpNQ0dnSlhCL05iVkRiamdtaE1sZ0VZL09CQVZBZFp2d25MVXJUMlRObkJweDFkdExXYnJSdzluWjdLcG93WFBKVVdOWG9xYlBRenJNaGI1NGJQS091b0dlOGdoNEErbGJoU2ZHUjhwTkxmSStYTFBVZUJXOXEvZURQZDAyQmIxMjY5UGJqSjQ3L21majlqQjZQbnlabmU3UDNKMnYwNDd2YU04MXZQRE1pdm1HMzNwM1FtYUZsM2dBR05GNGdhMGhEcUh4ZVpVZXNKNzdVTExsaEQvc3hVNFg0QjF5VG5HeGJOR2lUY3JNN2NneG9lSXQ1NHFtRzk4djJpVGtKSEpEY3pCRHNzUURTczhvUEdBZlFLaStHOUk2WTArNGY3RDNNZGJ0OGxrMHh6YTh5THZ2NDBrNmxpN2syODRZMDFkMkI0YVRwbW5JNDVYVXJJUVJ1TTRLUWYvbHRTOEhSb2VJTkdHUDY1R1RBbXFsa0Jma1BlR25FdTNuTUpHSjVxVGVCZGRLY0NaNlJCRHBySSthbDZXeEtaL3pRbVVlNkI3MU51dEo4SURBaHV0OEtST24wYzdRLzRPMGN6NXZ1Nnl4ME9Nb0tuQzArVWg1MWNrMWV5dVBjeXJraTE2MDBMYnQzZUpiSkJHRHd4QUJnbnZkOWh0TVY3cEZNRG55QXhhMjJpQU5vbjh6bUtYZ1JiWG56T0pEZTFnN2ZlaWZUZ0k0OEVGZFc4eUVtRSsxbjZCa2pDbmtJb2NuamdnOCsvdUlxQnh4TzU4TnJWSEN5V0J0UFBYbW1jcmJWVmFENWRoTjdiN3orUm5RNG1QdllvM2wzZkdUblRONFZ6ejUzTHBQQjNaMC8vTktYZDc3NHlsY0xERlVNR1NPRTZFRXA0YjJnTE9pTnAwNmZMUDV6TW1BU0RUOFBqMFFMU3M3Wk0wODIrbHNUenN4UXpGc1VEN0x3N29VV3hGUm1XcXVOVk0va1VtaWlqaXNlYzRnT1VSc0lnQVQ4cE1zbWo2YTBZZUJMbThZZjJoUFFLcDkyWnU3Z0lZTS9OenFncmQxZnRBOGdsWjUzdFAyUlhHZVBOWHJXOXVZeXZBdDg2OEZISVNOSFlsM1Bpcy9NTzB4WEp2M01QOWx3VnBtVVVjZnBXYjl0U2t1ZUhtak91UGw3UE02Y2V1VEZndHovQ0JDaWpUQU4zQ2oyTE1zVTVqWThCREEwUFdKSStBVnpIelBCQ0QyQVNERHJ5UTF6Z05TQVlJMTBpeVpkejJ6VklaYzM3a2JiaVpFeHAyMTlNQkd3b2FrQkljTksyckljMzJzYnBCblNFYnllMjk4UVM2TURTUjNDMG1qWEJCMXdCa1MwUGZjSkwvT0pvU1BnQ1Y5R2dHbGwzOVp3ZXdmd3NPbXErN1cwYmhxOTU1M01QQVNGcjdNWlJjK080R1RqRTlYTDhtVGxZdElZVTBMUEVWejVSNjFoZm42eGJJVGpsaGM0K0ZkU1M2dXByQnZvOStLMElxM2QrOUsxSlppT1FJYzRBRm83MFZBMHlxUlJSNmJEWEdXb0xhVGZld282QWp0eE90UTgrMitkaytjWUU5Y0NvU1liRXpDMGw0ZlBZM2t1b0lVNktvUEZDQVBlTTFKUTkyWE91SmxXU1FQZW00MVdoelR1VTlXVGdOTFF4WjkyOGdRZ3NEcElBczVMZ0ltQlRWU25JNzZJUTFzQkRvSk5POXdPb3g2ck5MbDBLcHRnUkVLQnFvdTlGTkZ1eWw5YTI2Z0xRRTlIRnowQkhhMlJuWnRkVlJrc1FmN04zL3l0OFlkKzZhWHZHdzMrbFZkZlNTdHNSL0RpUnd0b2IwUndJSkM2RklpKzB6WlFkZzJaN2JCNjM2aHdYTzlxKzJOQ0hFUW5aZGhXdkxLaG0xem5hbmpyM2xyQWhKYnFxME9pY2VzNHlSZWVwKzJMbk9jYytrWUhiWWlQZEVpYlpzcnRGSTFvem9EUnM0S1RqVGtwbWxrNGhLNFlYVjNSM01nVU1ETm5mTDJGUGR3SmRZVHVVVUllUHBIWkk1Qkc5MFIrdksra1BUeUNsMnAzN1lXWG1FeG95MVp4MHR4TkNKOG9KT3VtcU9CTDZVamJkK1Y3QU00YkozOFBuODJ4ZnZtREsxZis5M1pUK1BTeno1eDkvRVFBZlMxbXBqRUppbjZzNFF4Qkg0MnI5QWsvdXpHQXhoU0c1V3lySW84Wkx0RlVNVnpHMExuK3dRY04wUUlTcG9QbFM5cDdmUWVPdEdXYmh3STJFMTBtcG1nT21CMmowb3FDNDlHTVJzdU4rV2JZVlRuQURhWWVoTnF0dDN3RzFFb2Z3emp1MXROamFBSitwTjVlUjBGQU5tOEkydjlvbUFrQnJYU0c1WFV5SnY1TUFPNUxFRENaZERFZThOK0FaRFR6Z05hQkdXY0ZXdDhucGdZdzd4M1B6OWIwQUt5OGxua2dla1kzSUh4M2FLczI4K0tBalhUa054cHZ0SEdvbTZjSTdZQnZ2d0dYdEFXbE1ueWQ1NnVIOWxMK0JlTExCY3ZJeHkzQ3ZvRXpHdEhNZEhEQUg4QThrZ1lGSEVmVHJ3ektZalhpNWpWQzhFYUtHNjdqaVRCeVFFZlpBRDFhQVRJbUhQU2lRUnZTajRkRUhhNVFwQVJiL1lET3BUcHAydWc3bVJ0NFB5dzdkOFA1Z08wamdZaUZFOEFFcjd5YldjR3dXbGhUL3NFMFM2TXh2dEMwUWFZWWRuQWRpb1Vzc3h0MTRHUXJMMmwvOVpXdlZwOTlPeTNDV2xwODVqdmVJa3dxYjd6KytzNGZmT0VMZVl0OGZTYlduazZMZnZycFoyZXkydjU4NzFmT3FsUUgwWFp0K0xLOEtSSlhtdkI3S0pEbE9TRUdzbVhNZ2lGZGEvS1JlZUwwNDA4TkgrTlZHamYrWW9MaDdiSm9ocWZXL0FuNlU0YTBCeHMvV1JEeWxUSWlmZlJsTDZZaE16bWk2NVVtNExVcDhHUjJ4Q2s4Sm1pMjJwSGlSTGtCMEk4QzErNnhoenUwLzQxYlRlTEdpN1R0MDhVTDRjbUI3Mm5tWkgxZnMrWkdPVVlyM0NXMW5jNFJieC9QVTJXMnJVdW04QjQ1Y3ZpdXZzcjBBSnlISk4vYm53dFhicnovNW51WFh6MTk3UEN4bHovem1aODlmKzdjZ0FaZlQ2dWdIbXBySFlRMklVSkx3UWhBaWJaRSsrcnlEUGtBcitHa1lERzhGTzRIa0VEWUREVW1CTmcwQVFDb0VWM3pXZUM1WVZRKzFhTXQ5NzZKSDR5S2tmTFlIQ2Jhd0FKSXpQVkFnTFRRWG9jeDlOWXh0UVB3WXp6bDNaT21CakFNS2VVOWszYktIcWpkQkJMbER5ZzJyYzE3bzJtVkh2QndYL3BMUTF2Z3JQNWIrb2hGQ0hRbUsxcVl1dTVxMDcxM1AvUXlLcUhKWGVjK1Z0bTZNTnFQOTI1aFpQU29yT2k4TkEvbWlGWHVDcnl1N2RKc3RITHBCc1pvYUNSQkswUlJBRTA0QWVqV2tlek5VNE9RR0tiU2lMWTJOQ2s1ZVNXSUFHSE41TzlreDExdWlOS1hsMDRNamYyV3pub2YvaHZCdEVJd2YyRm1paTdVamlzSVBFRmUybnNUYzlXUm43SEpMYU94V21TMHMvRjZDZXl1QmZ5T2phYmFTbHVnN3hvcW02aTZNcnVBNERGOFNDc1ZGZkQ4ODg5UDJ2YjJvNkhURHEwQVpJTkg3NG1ySEUrZ001NGFPdlcrRlljZis5akh4cy8zQzcvLytaMDNteE5waURLbVBKNFkvK0pmL3ZQaWQvemh4T0o0dGdCTVZza0JabUNKdDNnVnhSUlR4M3ZSMTI3bFY5SkNlWUhZdGszNFZUWjlnWkh1NXpVaTlvVEpQKzJyRXdUUVJtODZvdEhtQS9ReEgwVUh6L1JTUUg1NUFrM1puRUo3MHJKNWk2QVBEVmw3b3MrMUpzMjFLNW5BWjdSYlMrbVplcnhqaVRobEJBM0lzelkzSDdEUi9OTDdTeXYyckhlTm5wUHFxYStGUVJOS3RVVTQ1SmNjS1BOMGdMdXJCNiswSU1uaG5oR0J0cU9ScTRmTzR3RTREM24rZUg4S2d2UUxmL0xIZnZqSFB4YkRjd2RpTDlZZ0owOHVQMDZDeGIrWjhHc0l4Mmh1VFRocE1CcnBuWVNzaWxBQUFFQUFTVVJCVkxSVU93d3pJM2lYaVlQTmMybW1DWGZ2QTdFUC8zNDRlNXZBNmg5OTRZV2Q1ei82L002VHJkcWlGZW01YVI1dnY5dUUwVEFqbDU1Y3BockxZNEFsd0tXL3E3bGlZR2FJT1hhQmpZQ25PZ3pJNERabElsd3o1QXAwTHNTa2gySXl3R1BXblJaVjlZYTVBYjBZQTRhRjB0RlpBQ2VIK3RPZTJEKzVXOUZzZUxoSWw3c2dlaGpDM3VzN2tBQkVsU0pRYVJJbnpZNEdJdUNRbFhFM0F2SUZ5Q2J2MWlRZWJYVUVRYjY3OVZ2RDlNUW1wZ2ZLeXN4OFpGNWdMWURvV3BxT2xobGdqZ2JLTGE2dmd3QTdqWFlFRk5LeEVsamFHSEEya1l0R016RlVQUWVjZXdab3UyNVJFbUJHOTJVK01DbG1qdUxZWEZzYWNwTzNwU21Qc1pQWGJtaW1vK24vbEJPZ2l6NUl3R2wwTndMKzBiYWpsM0o3SHBqdzlDRGsycDYyOXFsUGZXcDJSK0dOUVl1VUhqclNFRDFESytWaDhYU1RjWSszT3paZ3NNTHczTGx6T3krLy9IS2VIR2ZHcEdGaWtrYjl5aXV2N3Z6MmIvM3o2bjE1L0h1NTZJbTY5M2F4TnJTZnRQRFRGNy93KzhYc09Mdnp3Z3ZuNG0yaGNuTTVUVU9udFJ2TnJDMmwxcUtPZDBhelp5cklFeU1idGs3NHZZdXJIdXFsODVpMUEvRVBPL3Bxbi9pamUydGtzVHAvOUhCUCsxeXV2T2dPaU5YZHB3VXU2dSs0SHQvcWVFd3VNcWVjckhQaWxzamtaSldreVQ2eUFiemZNV0VaWFV3TUdtbVFyNnUzOG9zdVB4cTVXQnM2MndIemJQR1BWWWNubi96SXpybm56aGUvZlpsdkp1aFRiU09pM1R2dnZyTnpxc0JIK044Qm5KWGRRUmFVOVFFNER6bitlSDgrODdIbmZ1UGxQL0dwWjg4L2V5WU5vbGdJOTR2UTFTeTAzaHFUN1lzQmdBQ21NVFRWTTdNdjdza1h5cFk4OTlzOVk3d3FBaVAvYnVVRHlzYTZwM1RzQXNIMzg5WXRpeEhzcU5Ga3lrSE8rSWVMMzN0NkprN09QSDJtL0I3ZE9SQUE3MjlqeXFNMStxbmNsUTRVemQ5N0Y5OXJBcVhkTGE0MndYZ3pKcndUZzk2TkdaU0ZEK3VkbUU4Y2p6MHRTamdjVStoTWJoWVluZllYWkU1SHdSY1VmaDlOYUdsSzc3eno5azRlS3p0M0NtcHpwNG1ObzlYdldQVzhrK1lISUEzeDd4OEdySUVOSFQ0QXZsa2NaVEdCRDZkTnRIWjlaMi8rcTdTbjI1a2ZidHZTSy9xb2F4QWUyUUswMHNlMEVXNU1OMHhDMHFZcHhjazdsOXN4T2VwMkR1UjZyVy8rNlF5cmUrK3RKYkltaUtKc3dFRnJ2Sy9UYVZSZzJLdWpJTUEwS3I2M0I1cXdxU3BkWTQ3aGlzaWpnbzkyazZMbHlVUndMMW9BZnAzbjhzVXV4NHF3T3A2RHRZK3dsRHh6NnJpdUJVUjdhY1dWc2sveGlQR0R4U1hNTkNtam95SHpXSkVtRXhKLzlvTVJtOS93YkJ6UWlJdmZPN2MwRTZZbUxXZitnSzkxOTVqRDBJbm54bWpwVzFuVk5XcXlsVjRNNk5ReEZwdmgraXhFaVFmNWRLT1RaZVVYTXExZHo0T0EzLzY3Z2UzWFhuMTF3SGdtbnV0b2IvRGZqaWRXR1V3ZzUzZGRuMnVFNFJTeWdJYk1STWZiNktIYTkxdnZ2RmxzNkhmVFJJdUhrWWxsYjJCMHl3Z3kycitiRGZ4eS9ITWdQM0dyRHdINzFYeVM3MVovbkhQNFNQWExwLzVHUEd2ZTVVU1RvczlsTGpsK05OL3RDKzhIaUMxa0tRWTFEeWxta2R2eHJ6SFIwVWZhelR2NjIwWEdGbFdIbXF6VEdUcU1BTWFVZU9WS2kycE9OTmZEcnQ5SUkxb2V5eHhrVk11R3hZUGtlUEwwY0IzNDdVWnRUSWZLUVBHNkdEM1BQbFdja2pQUEpWZkZ4Ymg1cnhIQ2lVbEQ1d25FZGFBWDIwYnJldTEvNVlNMklHRFBMbDBieWw0SnpNWHRNRG40Nk9sVE80ZFRxSXh3S0ROQWVjSSsxTjRQd0htYTdJLzM1MGRmL3I1LzhHTS84c05wcnJiMU1SVE56cFVHc1BXRTQrc1pBUGhOcThYZ05CMWEwcGdjK2gxblZ3akRjWUxHbFl3OWVhMTA4Nng3R3M3dUUrUG5tYlp5TEVEV2k5dG1xSmFlejRkYlZpcnkxMlBGbjlYcjY1bTlad2JZU2lxenlmS25EVnp2TklHSk1mVCtBcUo3WGpRNGszdlFibm1YSkJ5Vlc5a010WmtnYUdhMnVqZkJRK3UwbW0xdHlUV3dOYWFIaHhybTAzb0JoODZJZGcza2FEczZxdG5iTFdIU0NRQTlPeWd6YXlnZnpmWmV2d0VpaS9HaVRwaHNXT3pzMnA1QURsaFAyb0daZEFHdEF6a0JQaHYyeEMrUkxucFhCMmthdm5zU2tJOWR1ektpc2EyT2xpREwwWWhpRGUxOWFqOTBvOW1PUnV2OTNmeW16TnB4OTVycjJvMW02dlNPZHZEY2ROTFJUOWxvZU1EY05XbXlSVHRjcjFHbkh1N0plek9QR1lWSnF3dnpyUFRaU3IxdndrdSs4bkVmSUd0YjREQWptUUNiOThRYVFWMGY4d1Vlb3ZHOW5RWnBFdEJDRXNQODk1azhlaGM0KzV3UlYrK2pCUURpbXJuVlh4cnMyejQ5UnhzOUVyaGVpRWZ3a0VVZTVNS0lpV2FOSndDWUtneXRkdXVpb2NrRU9nc3BTa3NHcUxiM290SHl0ZFpabmp2L1hMdXZIQjEvZnZzWHNwMTd4b1E0THh6dEtteW9BejJBTHcxN0psYWpqZm9DZTd5UDFrNXRoTmJxZ041Kys0NnYwTk5veFh2S3hwVGhHdHA3MTNOczA3NUx3K2hsdE92ZU1mbXVUdmpMTWVzUUtwc1JoUGZJcFlhV0ZyditKaDhQd0huSTliMy9lZkdwMHkvKzJWLzR1Yi8xZ3ovd21iU2N0SWNZZ3l1UVpiWVlHR05nSnA5THVOZndaVEgxcnNaWHd3QW9EUWdBQjZBQ0VrQUcwTXdJcndtR2JIRE5KRnY0NGp6YURoRmlQSE5wTXh0Tm9Pd0lzVC9tbHgrZ05Sd2tOR2ZxNmRrTDdSQ3hBWTNWYVE2N0d4dmFZcXFIZWxjNVI3UHE4NXFBNHdFd3plNWFncUorNG9mUXZQbFhNM2NJVmlQd1BsT0d5UkZNQmxKcEJLTU5YYzZycFBJeFJkQjZodzRKc1BwaFN2ZXNrR0xTS1lNQit6SHZTSWVRcEFHUjR0R0dFMmdhTm8zM2dHQS8wWXkyT01BZkxkUmJoMEFNQ0Erd20xMWdnTG0wNTNwLyt6N0FYLzVveXg1L0wwRGR6RHRNRjcwK3dFRlkwR3dUUm1WeU1FZHNJQXdZMFk5QXU3YTk0N2VPakZBREIvZlF4MjkxZHcwNGI4QXdrOGU3N3g4SVVKVFhQWWRPR0NoUEFKN0tzNEcxKzJpaWpDc204SzZYUTNXMmNFZTVLUUpsUGtBblRYWEFIOXcvZFc2ZVkrWVFLK05vSXh1eEkweThMYURnRTQ4L21WeFdQZ0RGYWxqNVNzLzJXOHJGODRRTG1zN3ZSbVlEWnBWcHc3bmVLcnZBWjVtbGxxOXZ6VERQQUZUYTh5ejhNSnlvN0Jmek5xTFl5SXNNQWVaM0xyeXpXL1k2cDloWDJTY3NRZnd3RTdzbDZKcFkya2FkbENIMHJ1b0QwTHlLTmkzNlR0Zjl4a3M2SDJESkpMZGNEbmYzOWF2dHgvNWNHYlF2ZWpnQnRGQ3NhSzkrN20wZ3JVMTlsN1pEbW5pVUFvSlAxbndTN2JuSjg5S2FSVU1wVGRJd3FwYWU5QitBODVEdmUvL3pzei82US8veVovLzBuMnFaLy9HWi9UM0lYUzJtNWwyZ2dRZ2padkNKdWJreExRMXBYVTlDdzRtdTE4Z0RFSHJZR3RMZ1hFakVtY1d2UWRuS0FCUi95UlZGakl0VVduRDNnQXZaQXk0bGxYQTBROTRFNC9HRWpPMXd1ZlFSVXQ0SHk5NHJEb2kwTUNKdFdEbG96TllWaXgwQXJHblNNOHdMN25RYWxzR2FXQkx0anYyYS9ac0daQ0xUY0pZQUhJOE9WcmhoZEJBMm5pUU5jV25ldzdUUmd1c2dBYTd3VmJVem10eU5HV25ndWd2RGRFTjBNYklKUDgxTDJ1aUlEb2JodEJUTGE5Y0lnMTE3VFJRbW1hVVE5UUJPTDRuWlBDYVNoTnd6TkNwbFozWlFKekErNElGd2ZmY3VvQ0IwTHYxUld5MFhRODg2QnF5amx6UjlkM3BXR3p0Y2R3SlQ3eEQrQWRhZUk0U0VyeGRHT0pWMUJMUHJRRlE2VGtQZ05icXFvMDZJTFNxU0J1QUQrRHBsNzhsVEhmR2J4UkI0VGQ2OGVXalo2RTVqTkZLWldkcnVTNGVaNlAzS1pTSVBNRDllZkFnQUNlU213NnRjMHFvb2s3OTBObDcyUGxNRjhMdVJSd1o3ZEsvTnNtYWVDT3IwWnJHbThTL0F2bFNRSDBBTk9ObldEeFF5ZDN5WHErOTdhZldVR1dYRWo1UU1Db2xOV2MwVEdKM3hZcUZZUEpXQ0FkeSsvS1V2anRaTEl6ZEs3YkZwTTUwTk1KVzIxbWFLQU1Ma2FUcnkrSTBuMC9HVWlMZnkxK1luRHJ6RjVWQW5OTnphRWMzUkZuaGE1S0pEZFEwZHRCOU4yanZlOTkzaG5zNkViWjlXN1A1NFRzVnJOT2pobDlwS0hqUjc2Y2hETEdkcHo0UW5SYVUyZmdET1E5THYvYzlQZk80SC9ydm5ubjBtLzhWV1ZHWFRGV3dmUG1BR2gwYnd5NEhnczdYVFhBdUVZcFNlV01QczZZRU5iU0ZDd3VGZVRNb2ZFcEJ4bGFNQnpncXVHcHJud3YwQWgwY0ViWmtiRXUzRjVySDdZZ2dOTFpnKzBKQ3ZHV3pNUmRob1RLUFY5eTd3eGxCV1p4bmUzeWxkWUFoY1M3MTNtUUhZNGNvejBHVW50VVBFUTZVeDhXZ3IxNEJQQWthb3pWanpYK1l1YUY5RTJ2SFN6NXNBbXFGd3dla3Jod2xQak1vajVGNTF2d1dzQTVzOU1TcXdCdnFaamFPUkdYWk1YVjNxRkhROEJHNS81ZVZCSWlhRC9DY2FZSUpGTTBNM0FqNDByTDdxREpRSmF6ZlgzOEJabmR5ckNDUGM4bERZMVR5RVdmNExMSlhWc2RwemdiT1hSdGlxSXlGRTgrMFo3L2w5NnRTcG9iZGg3cFNqZHh6dXJ3NlowTzZhU2NxWVg3YzhnQzVicU01WE9nUCtsZHc5R3J2T3c4SUt3dTNacVcvM0FLRm5sT2Q2NWduMy9BYXFwZHp6bWNyNjUvNHlTMVNYYU1FYzB1WFpCOUZtckNiQWxzYTZKa09CRnA1QkU2WUdLeFJmZSsyTitTNU5QQzdtOC9kLy8yY2FxWDFrZ0ZpSFRYRzRXb0NubXEweU52ZFFYWlNWa3ZMaXgxOE1KSGxSVkI5MTZCK1R5SXJERExTQkY5T2VhUWVtR0tDMVJrMTJiekZKVFBza0k4UC9YU3NKLzdOQjYwaHE4K3FHZHJSWEhRWkZSYWVpTHRJeWV1UkdHQmZPdld1Tklza2czM3hsQk16VDZWVnVKaEFuZmlNem0wYnR2ang4YWhkdGpUNjdUVDFtUUpQaXlqTnRPUjFwR3o4blQrcUxucmhTWGpvamJUcHRobEVlSE44N0JUNzNmUy85eHRObm04R3R4ei96Wkh1MXBUbWExR0k3MG1BRUVyc2c5aEs0R0xVRzBRQ1ljbTUzajNrQUNBNWo5T24zemRLWmxXTXhENXZpWUhrWUlhaVAweVNPNjJ0WUhvTW50RE1CSnIyKzMyOEN6cXo4bkdXRU1YbDhPUFQyR0I3VEhFcVRnRDAwakp2dEVUY2FmRXltYkh4aEw3VUJLYk5HcW0xS1o5cDNRMHhEU1FIZ2FURjdZbFlNcmxNNmtoMVFoMEZMZ0hRRC9HbGxLYXREajFCcGhBd1RtZ1JsV21BMllZZTdaM0swdW8rOU9lMTUvMTRqZ2tVYkVvZW1UQndEQmwwL1VKQWZndEt0M0s4V2lQQ1RGYXFWTzliUUFDUUIzODdWRGd0Z0J5aWp2eDIrSGRKbUlnTFE2RVZ6VXhFZ092ZDMyMUk3T29IeThzQ1oyeU4wQkUrNlcxc0RnSm4xVDVCcHpzcnFIcjV3NklDMEEvZTV4U2ZLVmlsTGc1RHpFYVpsb3FGclRGZmVaOTZRdHQvYkFYRHhsY1VnZU11eE44MTdBMmRtQVdFRzFNbXpqdjNhb1BRQmx3VXVBSXIyS3JpOFBKa1I1RHV1ZEpWWjNzQlptc3Azb2dVbkF2b00zVXFEeDhNMzJ3aldGazQ4SFpndmhzY0xNRlUyZ2FtRklHbWZtV3NzN2I1UTdHUHZNSThwdTZoOEg4VFQybGVlSDJudVpFWld0VFUrMVpuZ01RclFrUlFFOUwrUW1jTUd1UWpIUjd2R0g5RGU1aFZtVTRmcXJoNFVrVk9uVGdlQ3gzcjgzbmltaUV6bk9IUG16TlNKclJ4dGpVelVWZHdTWUt2dGFNLzRnYWVTOW1jeTFINU1nRFJuejJ4dHZEcnp5bFJhOGtWamN6WGVuMG5sUGl2U1BJODNLQ3ZBMmNoRldhV3p1R1NLOStEUDkwS0JIL3pVSjM3anhZOTlkT2U1SW1TZGZlcUpHcUJKb0lBS1lHZ1loRjZnRU92WElHeEtHblQxamdrUWJvdXhDT3JZbXRsUU8wMWVOYkcveTFTaWphMUFMdXlCMGpWa2VpUm1NVGxvc2NIK3JpMWdBVTQxcXdZT3lBaVVmREdyc294cm1uSWtZQmlVblZ3Uk1jUHNyQjNEWTRxNVQxdW1uV1RPQU9SY3dwZ2JhTlhTQ3NLbTdNQjBYTkdrVndkd0tNR21DVm1xUEJwWEhRSXRrWVpvNUtEK05Hb2RFQzBkT0Z1WXdIV3ZRZ3c0KzJSaTBXSHBvQXpscDA3bFFaczI2bmdvczRaeXNEZlR4dllFUmpPaGx6QUd0d3Q0RTFaYWlUcEdpa0I2QVF3aDFubTUxcDBCbWZtbXVYcCtBeXkwY3dCZUozbzY1Q3RQOXplQjNLNXZOQWZDMnNvbmpRdE5uWDRUM2dHZTB2dXc1andqaE80RHF3SG42aUpmK1ZnYzRsMTJaWjlBMmlnSWpUZk4yWVRZVmlZanFXbW44cUk1QXpPVGEyQllPWXlXTEVveFFRZVlWVTFFTnhQSzhnQkM2a0tEVkI0bnVrdlQ5VnUzV3FTUjl1NDlmdG9tRGw5OTlmWGErdGJPdWVmT2pkY0JzNFk0RTlyb1JwUE1QRmpNVFppbitQcHJYNHVYNm9Uck5CN0tZOE16WWpDakFVQzdueU8vKzlyT2lWL1poMFhmNDl1dlBKYnlXMGpFM0dWa05mc3g0bE1qemtBZmpja1Ywd2daT0ZMVVAyWTg1Z09kMEJZKzFTakJvWjNRZTVrcHhJVStNcE9iNkMwNEZHM1pDSFF6YVpEamtaV0lnTzU0ZTJ0bm03N3E1Smc1eWJsejJxYnkrQ1Q2bmgyNlJtUHRhQUhSMXQ0UHdIbWE1SHY3ODlNLzhPbi85dC83b2MvOStKLzR2ay90UEpXOURyTlBUTnRBYmRseE1SUmhCZzVyQ0d4bzVWZ0N2RFNDMFI1akZ0b21CcVRiK0w4dkp1WWpLWGFzMmVpVGJZT2o1ejkxK3RRd3lrZnlTVDNac1BsNFBmalk4SUJTVEQvQVU3N01BcGhLM3ZLUVo1Zm0wL2Q5Z2QvY2kxRzRoQUdNNDdzenpqUWo1Z1lIZ0o1bHdLVmxlVGFHUEVDNzdCK2I5Rm9Vd05RU2dNZlluUGV0cnJxU214UWJJNjJVYVFZUUExa0FiU1VWaDM5Z3p5NDlJVko3ZHNCenQ2ekFHZk51UHM3S0l2MnBVMlEwRXFBTll1YVFwejNwR3I0R0VudUJsYTZqUEpiR3BjNnVCRXRJT3pTdUg2ak9JeXhkZE0xMzREWjBxaXhvQm5nZHpBQURnbENpWThDMVQvZVZjUU5vOUhSSXc3WHRONEgyRzEyVmY4N0tMQjBBSkEzNUExSDNDUCsxd0FVWVNzdDdiTXp1bGVob2R0ekh0bktOSGJkNkF6N1BUTDdWUWZyU3BaMlBSMGQ5RFk2YzhqWXlBNEtQbldvN3FVQ2VCcXQ5ME13Y3dTdzVyczM0OEFJUWFRbms0NU5tK2M0Rms4aXJqUUFxclZ0NnZzdHZBVjVsTDAwZCtHejVsT21CT1lHdCszYWp0QUdrNm1HQ201OC8wNTA1R0RLRFR4Wk5sa2NOTThCbTFsZ2JXbVNqRHZ5WU1DZ2s2akR1cTJnZi82R3JlcUk5dXpyL1lpNnFhQXBFQWJqNEhEeVQrT3J6aE5MeE01ODRkWTdvcUs0NlFYUUYxanBjOU5BWnViOTVhbWoza1p2S1AvS2xyVHJZdnpmTmVkb3JQbVhpTU5xVXRyTDB3cVJsd2h4TkhBL0FlY2p3M2YvNTlDYy85cmxmL2FVLy93OS8vRS8rV01PdlV3UEt3aFVLNlhqeVJCTVpNZkFIRGVGb0RpWmlEUDMwNGhNRUpzMEM4eHhxMko3b3BIVW00REhON2Z5ZHVRL3ROZXc3Y3J3ZVY0U3E0MjJIZFdvbVI0N2t6M2s0QVhnNEw0MVpVUldUM09vRjltaTJSclArNCt4UFU0amg5cGF2NGFHVlNwZ2ZJOC9TNUlTVzVvTEpNRHZtQUU0RXl5VGkzb2FodC9LcFBwUmY3aXpnU0ZZOGkzRXNUeGNIaFBBY3phZFQyV20zVndyeHlHWXRob01Ka1BUM25ROFNKb0l1RDFyeUxQdnVPek9Ld0RkM280LzQxRWw0ZnFLNUxNWG9CQ2t1RGRURnJHalNKZVlGVklDZGI2L2RuU050ZHVmTUxPVlAwNkJCTXZPb0c4Qldwa05wMVVKcWpoZE1qSzlMMUZFb042RFdCUUs3dXcxUG1FNktrYkxzNUxTYW51K1JoT1BmTm1zUUd1MjZIYVBOOXdNQWJCb1VZWFVTVHM5dTF3bTI3NFRYNFJuRGZwL0twQTNjWXlQMTNucDNqVFlJTUpBQ1FENTFnc0I4WC9VSEZrNXBxTjltVHNBTDErc2NkWjVzOUh5amRYeDFTZE5KaldkUi9jN2FXYVg5QUZ1aFoxV2V2UzJ0R0RTVVIwdGF0VTlLeGQySVl0V2RsWHhINHN2REJkTS8xQ3BZR2k5UWRUSWorTFNZNDdFbjJtMGxmaEVJNlZLZCtrZXpNVC9XNlBKQ1pvQjM4cnQvdU5nUzE0dVB6ZGY2UWx0Z3ZkM0NqdnUxeC8xb2NLZXltdEFGOERwZzh4bG84a0ZMdmxkd282TFJwYXljem1XVWJBbjhKUzYyVUtQOHhOWHY4TUZNQk5NVGFVZWowenI2TkdnMGY3aTFBRi85MmxkYklQUEM4Tnpycjc4K0ppaWFNVzJhSGRoQ3FIZmJSTUN1NU1ENlcyMFVnTzVzNmt3Y2FMUzFEZE9FOGptMC9aejVhQU5scnJIQW5kS0ZEeDR2Qm9rdThrSnhSeTdsNjQwUGRXamFRdnIyVUp4T2RsSjc4T2U3b3NDNWMrY2UvOXpMTC8vMjg4ODhkZGl5emcxNE1MOGhqTVlRcE9oZ1dxL2hIcUVlN1NVaDA1aUVXVU5hcHEweERCc3g5QWhtalVjVDFJajNDZ1p1UW9uVzdIME1pbm1rSitqUjFYcDIxNlZGVUwxRGc5d09mc3lqTWZjTVp1blBBaXVnQkZBeVZWQ2pNQkNNOEN6TjBUVy85eFp2RmtQNTU1TzV4bkpmR296MGpqWVVsYmRUNXdCOExHM2VldjQ3QkxvMG5RN3ZxSzh5TzRDNmQyaEk2dXpUN3dFc1piWElvM2MzYmNUd0Y1T3pDVXVMWm15dlBwc0lHQTZ6TTlPczBkTXdueFl0clEyWUFiNS8zZ1dKRmNEZnltTlV3VHhCMDFJMnRNcCszandDUXZDRUdOdHMrZnNPdkxlSk91L0xZMmpmZHlDcmp2SVlnZlIrSnhxb2grL3FPalRUUHRFQ2NPaUFDRGpiTC9vdEhnQjg2MW41NkVTa3dXUWt2Y3N0RlBKYlh0THpIakNWTDhBK2MrYnNnQWpiNkpFMHhKa0U3TG10dkJaTWFGc0hjR0QyMEpuYk9JQzVUTHBNV0RSdVdpaXpDdG95U2VrRTVDbC9iYmJTK0tPT0N6MlVVMWtBT0o0UmNwUk5sOVpvWmV1SnlvUldiTXc2ZEJOMVVXTk1EdHFCUE9na2FkM3FaaUphd3hpRlNlK1JkbWN4ZWNnelNzZEUrYUh4RzVWUmF1THMzYmFJLzJ0eDdUeWp0bWlrYmRVZC9kbDZmVEpwOE40d21hZGM2RFVyT3Z1dVhVVUZWQzh5ckR5K281RzI4UDZpMTNMZFE1ZTFaUjN2clcxaENtMTdoV1NnYUptM2thNThyU2FWaGpraE5uRmwraU5KSHZJKytQT2RVT0RaczAvOGFOdFUvYWNuank0L1lrSVBsSStuTlhMUkFYTEFiRythbmlHOVF3TnVzL01hY1FRMkVNZllZM1BFUGhpc1o5M3ozYTdHTkNETGRnVXZYN0ZoTmVvYU9nSmsvcWluc2hFZXkzMEpyR2pzbTgzUzB5UUJ5ZGcxYTNTSHNqZ25Ea2Q1OEFVRk1pWXFSc09OQ1FlY0VnZ01QcXZvMUVONWVwOTVnNjFPdERsWDlwRWNSL2xnWnAyQlk1aVdVSFYvaFRSZHk3NXA2elJaTnVEeHRHaTBvTHl1RFhCMEhZUDZ6azNQUFc1emdBR0FBVWowQUNRZ2QzOURlSXRyYkJocVVwUjdITnA1M3VlQkJNQldZQ1I4dE9ZQnBnQmt5bDM1RlgvS3FTUFloU21xVmllZzR0N1U1VGtBa1hwNVlRbGl5WFNURURyYzA4WTBmK1dXLzNadEh1aVBOSUN1OXdpNDBjQktkL25OQW1mTHc3Zm5ldU5EL0JEQVJ3TjUrRnpsWGNBdnJ6S2NjdEdxRGJtbjA0c20ya1Y2aHZ6eW5vNWxseDhtM2tXMEd0NU1VYURCQVQ4dWUwc2IxM0duS0tCM2FXQXdHeFJvQzUwWjg5Vld4NjNlZnJPemFzT3JBZWZ4aDllK2YrajArdXR2QkU1WGEzc2RldTZYQVpXSlNvR0lwQ1gyODRsR2hUb0hIS1lkSzNDbXV4WmJCVmhjejlDTnA0Yk80VUlyOVlRd2xiWU9TTDdhWmp2M3RSTUp4UWx0Mk5hWjJwZ1NFQlV2UGZuVWsrT3JyS3pBRUNoYkU3Qm90MnRDcWh6cXRBQjdYVU5UOUJsNmxwLzhtVFptSGtnOWNxT1REczE3K0xrT2ovMVpETzB4bjlXR25qV1BwRDZ6V0NXQWxvK09qN0trTGcvQWVaT2M3K0x6aVJPUG50cTdmOC9mdUNQWWRzTjlxOVF3bktYUDRycGlpQzZOcGp1cjBtckFFYmlZM0NmdzFxQzN4N1pGa05hRUZ6ZXF6ZWE1Q1Nnd0FzcmN2UVJpdjVMd3d3dmE0b1cwV05IRzdBTjNvZUdYWVpzVmdJS2Rldy93ZU5qUVZqa1NpV1hXSUd5QnY2SDhlR2IwREFBbXBJQnlHQ2dBeWVRYmN5MU5hZTczL1VBZERuczZJYitWalpKSGhHTXQybUF6clFOSUM1cHJnWnowWVlmdGUyZ0taVHUvZlJMbzBicEthNWk5ZHgyWVh0R0JCN0Rad000azFUQnQ5NEVUclpscFlDS0JFZVFPMXdtUCtnRVp3dEhGdVFmRTZGQUwyT1N6YTlLbzNqUTJuWTUvVEZFbWwzUUIwaHE2N0theDVTR05BVW8wNjd2MjJ1N0pSeDBjbmxFR3oyeUE3VGVoMURhdTBWYTlqeFk2MWkxUDlsejAzWGdCWUUyZVhaT0d6dG1uNTQwd1ZyMldOdWlhQVBjYmFBN1JsV2YzWGZtdWxhWldsRFk2RXlhek9odUJDSTdFRG1zSjg5ajRBNHNTbjA0WXlHbnJtY1NhUEN0ZmFlRWJ5Z2ZlMzNqb1JqWmRXakpiTGcxYW1RNm5SYXN2c0xPeTcyQ2pMMXFqNWVXVWllZWVmVzZDTW1ucmU4b1NtRnArL2w3UHMvRmVTMllBMkpHMDJHUDU2cXUvQTE4WVZjb0hIZEIzWHpFdTBFdm5ZZ0dUcGZ2U014b0EvR2VieERkaVVSYUFpbmQxa05yT2R4b3RQdkxiOThzZitGMUhYMXVwQzRDVnZ6UTgvMjFhVng2YU5iOXVkU1FERklwSFdyUkRMaTNmVmtabXhHVzdicHVxMmw3WjBWbjVwZ3hUc3dkL3ZtTUtuTXVrc1gvL3ZjTU43Mzc5ZW12N05RcFBDenVJaElBekpLRTFBMndLR3BEUm9IUEczNWhsTkVLZzA5QnNCQ3VOWlEzZkE0SWFXNW9hZHhaUnhCaGNwaTdHbUxUYVkvWE1LUk1GVFAvV3p0ZGZmMk5pOURJcGFQeUQyUXZkUDU0dGorM3dabmJqTVJXa1NjblRkOHhFZU9ZelBKSDJ1UEFGVENibTJNSkh1MnFJRC9UNGU2N3lsMm5hRWkwYmVHUCtpYjhSTTQwNW9USkxFL2h0ekUzRFo5YlJnWTEvSzJxVURDRW1rQmFycUQvaElWeUVYS2NsSGN4cWtnWTRvNW5SdzhNdHQ2VjkwQUlKRFUxY3hMYUtrTkNhalFkTXRDTzIyenJMaHhyYURqYlRuQlBRMGF6WlJCVWpqYWcyWWlkZlpnSkF1TnBoNGs5MzM4aUJSazZqOUE2YkwrRFd3Mnp2bzgxMnFQZlk1aXVmNytxaExaM3FNQjFSRDJ2Yk5WSlkvSUJMWEpNV2NGdzhvWU1KRkxzR0ROejdJN1BHQW1JakU4OUtWeDNrdWJuQitXNUVocDdhQ3FqaEFhQ3dsVlA4RjVxcmNnS0VOZnBZOVZRbklEaThNblExZ3FwN1YzOG1vR2pDdkNCL0hTdnptelljcGFNOGxmZCt2YnNKVGlDR0xwTm01WEpjelI1dVZFZnhNUEhKem4xdkpseVNsZWhzMUFEVUR1VmRnVWZ4SFcwVVBUeHZjdEZCNndiMlpBUHdNWTJRQmVDN1Z4d1RuV2J2NER2YzZUOTVZUlpSRnhvejROVStBSnBybmJJNjJaMU5JZ0pmd00vVHhmY0IzZDdaVEQvb2lvYThXNndhOUFud04xNG1SM2haM216eTVnTFEzWjZHOHRVK1pHSzEvMXFNcG8yV3FqTFZmUERuTzZGQUV3RjJnZjgzZ3J6Y0xpb1hZQmJUOXVxVkludkZ6RTgrK2NSTXZHRW1LOWlBRXVFYTRZeVp0OTdWYndHSU5BaWdBY3J4Zkl5NWhzK3VHZEpqSk9Cem9GNzJTRXdPOERDZXdEbVk1Q041aVh6ODR5L3RuRHNuK2xVMnZJVDdTdGVCK1V5T1ljb1lGL1BPQW9jRXJSd25UU0E4TzM5ZzNnVEZ3aEVBYmNocFdDK29EcUVkVUI5YmRLYURLbytScGg0RXJIZjErQURJK3hqVkRpWDhXQW1aZXhoTmZUR3dBOU5pOHZHL3JyN3NiSmdmekFFYUFnK2NlYSt3czB2YmZVTmZncjdaWVkwSUFJWjBUZlFZYnMvUU5WQkM4eU1GeUNHVWFEeHVaT3FVSmllajRyajNoMWFjeU5hV0M1Z0R1clE5WUdDQ2x0bG10TkhvSkEzbFVCZHBPeUxUWEplL01qdUE3cmZidXpyNERieUdQcnQxYzQzdzB6TFJhMnprcFQvbGpHWStwVGtUbCtXOWxRRjR1bzZ1UTlQSTZmZUhBUkZ0SEs0QlJtbWgvWTFvcVl4K2orQlhGenVRMkk3S0ZsTTBScG9yRFpvN0hTMXZsSWZ5eEE4bVhyV0JVUk13SE5OQzdYYW8zeXUreWFJSDI3RVlHa2NENmpzRmo1S1hZYnAzMU1OS1FzQjF2WmpOUmpaV1kzSnpFMkNLYmZ1TFgvbG1VZSsrMUtUZXJleS9UdzN0WHZqb0N6c3Z2ZlNwblZPUDFRSFVTWE9mczNYV3E2OStaZXFEbnRKMjZPVFFYejI3MlA5b05tMGNIMFczbWJDTWx3WDZ1aFQ0NmxTVWtYa0VPRXZIKzF0Nk9qaTBBZUtqOVFiSzVFNCtXMmVMSjVsVnRuSzREbkNWd1h0V01Fb0huZGl0Q2Zyd2dOM0pPN1FoYytGbWUxYjBhYU81KytEUGQweUJHaUZmK050L2Q1Zzh4dElJTXlUSjVteFBzdWVlZTdZR3lGNVVRd0JuREVJNFJvQVNSSitFUklNa25kTUlnTmh3R21vQUxQZUIxK1Y2VzNiVkovT3Y1QXhQVTVsdDF0TW91TmVkZkZRWXhEV00rNkRKb1hHV0x4a052d0FFUXpZczJ4WDRHVzRHWURSVTViK1ZueS9neGNEQWlUOW9Da3NDRjZBbVpBU0V0d1lBbjdqRWZhZVo2cENVOGJySWRidk1iTWJjdGR2ZHgxaEFtWGNHUnB5NHhuMlhGa0VIK0NaTUJWcWZaNzhOVmt1N2xDYlREM3BZd255NG9TOE5TOGVFVnN0dUdsMUxSejJyVW1rR1BNQzNldW1nMVBsUUlUbE50T3FNNUR0MlUvZTdKZzhUc3F2ODdpL05mOXBuMTY3S2ZiQlg1OVE2QUg0bUkvdU9Yc3Npdkh4Vk4rMUovdHAyYUZGYks5OEdHSzY1dDlxR0RWK0hvaXdMVEgwMzRnSGt3eS9WWXpxUHJzOVIzWWZ2QWdadGZLMEpZZVhmamdIaE9ueERaZVhoT2FSakdLMjErcnUvbVRXVXBVdlJkTVdBbUdodFhUTUJ4b3lBejJaUlVocjNlTFVFY014dlhPU21IUU4rZ0tTZHlZQ0pQdUN5dGYzVXE0NjhsbHptdHRvUEVBS3BTMFZyODl6RHhVQzIvWk9KUmtETmgzbHZnRzRlNFhUOHJ0MWZmK09OblMvKzRSL3UvTTYvL3AyZFY3LzZhczl4TFQyNVJwcDFPQm9IQ1hUTXlvZGVPZ0lhTmQ5N1pac2dYajJqcmp4NnRKME8yWVE2YlIrTnlCdjZiS3NpMFJDTmFlTEFsaktDeDdTTlBORjAwNDZsb1kwWGdEZi9FUjI5b3cxcHlHekwwdHNmTDNQZEkzTlQ3cnc1cENkL0hmV2tWN3N0ZDhTVXRLMWhIM3grWnhSb0tMUC80SjQ3Ly8yaEE0Zi9sMGNmUHZwcndNK1M1YWZQUHJYejlKa3pPK2ZQRlMyTHBoVG5XMFJpSmxsRGFmZ05GSDNYZ0EwYWgwazFGS0ZoQndIU0dNR3M3cUVZNDlqUjR4T3Y0RUJDZ09IczJlWVRrMHZqVHU1M1ZzZGhEaE5qYkhWQld1Qm45bmVCd3d6dHF0N1NnSUhWT3F5T1c0c1dGa0NIS3pFa1g5a20zZnlJNGNPREFVcERURm8xb0xYVVdoMXVsc2ZVTGJCYlREdFYyQzNMR3RaN2JtbUhTMnVUODhic0JOSkIreVdzUUI4VE80Q3phNXYzZ2U5b2crR05KcjROTGwxbnJ0aGlMTk9NeDZNZ29SQStkU1pFRTB6ZzI1OFY3eU9oWlVaaXprRU13OXNCM2VoaHdtdnMvcFZobjkwTWVvRHdWOFhwR0lMeDNsTU92dXhMZktZekdaRHR3ZDBEQUFQU0JiSXJPQTdBY20wRGNKNEc2cVZzRzQ4QUpQZUJoVENuOHZkNzZLc3hPbWJzMHpWbURlOERFZTB2THlzRTBYRDRyWFFYWHpUaEdHMEJGYnBOR2xYS3NKcjduSTcvV045cDVHdVJ4NHA4K096VHU3dDVCL0lBMnNZQWFESHRNcUN6Umt6REMvRzR0TkZDZStQaHg1N016YTAwK1JPZkRJaWZlZWE1ZVBEK21BdU9IMzlrYUk3dkgydENHeURadUZZbjZ0cGJiU0I3c1hrVVhoMSt2M3ZoV3pOaGFKS1d1UUU5TFBxaTFhSVZHbTM1QTA0MEVScUFTNS9ubFdNemgybDdSeWI5cmd1L1c1eVpBRlo4RFowTmdFWkw3VVhXMUVYbkEveVpNclQ5MWw1b3F2NDZKclJXTHVYd3Z2ZmNZeDdUUVpBcHNUOXdsV2R2NWVldHJEb3RNa3JtS1ZEempEYWZVajc0OHgxVElBTGV1WERweXZzUEhkOS80N2t6Wi8vMjgrZWZqOEFIZDU1LzRmek9ULy9Vajljd01YQTlvaUhnellKdkE4U0pOQldJUnZja1MrUHA1ZE9pN21CR1dTK3cwT0RmZXVmQ3VCeE53d2F1NG5ZOEVtTy8xK1FmWWFRTnZ2bjJ1enRmZWJXZGxwdEVXWXNBaXVQUXpQU2hCUHR1c1dXdlhTNE9SNnUzOXR5ekIyQWFhK2t6QWN6YS9wakNFUGQ2d3pxZUFXekNBdGNZK3RGTURZVXhEZ2kzbEJ2VGd3UFBXbDU3cXhqS003a1lzNytmTU4yTUVYVU9kbnJtcjBwVG9HMEFQRDdkbTlCZ1Z0OEoyakIybi9zVEJIQld0YnJIYnB5VzFuTTBWT1lNNmM3V1JmMDJ1MDRvREl0cElEUzl1RDd0aWw4Mk8vZ0NNZzcvaHlxRE1oOHM1clZZQ2ROSmRYMDA1KzdjU1ZpNGtTME5SdHA1aDJRTE5DcGd0dUczYXpaMC81MGFwd0lDREtBRDlDek5uOTgwNTlLRVZnUk0zY0wyc2ROV3liV2dBdDNyQUFqd2FKdzl5ejF4YUZuSEptM0JmUURDNVE4RWgrSjZ4ajB4UUt2enBRM3EzRWY3TC8yWkg0aHV5azREWlBZeTZwbUVSdVI5WGZxOGQ4dHFlVmRVRHAwdTMyOUxvRVZyRThBS3JXZHhVRHlpVGF6RWROQThIZmkxWk1hTUJEQzRud2tEYXJ1cDQ4ZGJwUmVkcmRJOGVWSkFvc2ViV0h5MDltOWlzN21PMndHeWVNZ212WlZQUjhaN1FYeHg1L1ViOFdhSkt6Ly9kWHhoTjNGKzFIeW9iMVMyaXg5Y2E4WHAzbGw4eFR1RHI3RUpVMlc2MXFodFQzUjQvM0xnV0RsMUdHZ2xnSDR0M2JacWpSNzdaL1VwRFZvWmhBWVFtWkRpNVBQZHl4Y3pmUlV2QkxjWGoxb2I4cUhtMTB3T2pDQzhwKzVNR2JSdEl4dm1OcFBWUEtTQU4zNEF5anhCM092VnZGVHkyMCtlbUhqTXJZelNKSFo1U3M3RGhYaVlzSzNUT1RjeUxFMkhDZENsTENscjgxWno5Y0dmNzVvQ0owNDhkdmVIUC8zSnYvdG9qUGxrZ2UwLzh5ZStiK2RqSDMxK0lxbVpBTU9JZ2dRQnN0V1RMbE1BcGlYa0dPMXVPeW5RTWdDT1hobjRXSTMxK3V1djc3ejIybXNEVUd5QVoya3dPZHNUdUsrODh1ck83LzdyMzVzZGxERXpUdlh1NVhydXNRWEhqRmJkQWFMck53UVNweUd1Wis2bENUS0QzTDVsaGptVFJMMzZnQmt0STNEVXM1c0VJcndDSlZuZVRKczEvS1kxM2VzN1FPUEhyUTZFd1VIckFGQzBCTnJHcHEwWnp2bnV3UGkwRk0rb003Q2JsV005dnhaSHBObFhmL2NKR3FBanZBN1B1a1lBcENFdnYwWFkwK0dnbXdteENhVVpzSTZkc1ZmdjlieUpINEttczVBY0lOOGZzUHRjMGNLV3lVbDd5Y2VzUG9Ha2ZkOHZGb1E4YWE4aTlXbkhiUm05ZWhGUWRsSjJXR1V5OGVPWjJXMWpNcXNPUTVNbCtOSXFpM2tHRGZ4UUh6UUQyTjZWbDNJNGxvYTJ3Tm03d0ZtbkRiaDFYdVBmTGIvYXdyUGVZOXBCR3llN3VmU1ZsU2E1NnJMbzZWbDJldkdXeGRDWUxiT01pdW9nYUlHQTZlMjhnTVkrWE9maVVFZm5WdVkxQWJzN0Nxa09PdEM1WDV1b2s4NU9uWXgwbEJ2UG9ZZTgrU05mYVdMUGQ3UlFCNTBVWHZMTThFMSs3am8yL3ZYOGd2a0xHeG5ZTnhGdlhHdkJpZmZONzh5WXN6eU5sTFNmL3pPQ2pSN3FUVnVXcnJrUWFmdCtVd2M3OUYrTFEwcHF5a0t4QXJqa2JhTWJPYVNCODc2d0FFWEhaazVBMm5oUU9kUjU2QjFmZWs4TUVaUFc4dEllQ3VVNWZLZStNM0pEMTZsM0hYejVDL0psSkNEbXlBTndqampmeTNIeTVNRlRQLzdaei81dEs5dWVmZnJNemd2UG4ydkYwMFAxM0Z5UTlnNEQzYnhoMVpLaGZ3STF2YXJ2Z0k2QTJlMWlBWllHbXdtN2dOeHFQME1vTTc1c3pyUVlHMGRhM1NkZyt1ZC83L003di8rRlA1aEp5Rk9Qblo3Z1F3VEprQWd6Q0FOcWhsdE1aeG83RGYxNnV6MWZUY01JbW1MWWhxaGRuNTBaMGdTWUt6RFlsU3VXWlp1WWFXVmYwZlZtcUJoZ1liaGxxMDc0SzU5NEhUb0JDd013bmZ1WTNlbTd3M2ZNYU5KSTJ1cm44UHdJVzhJSXJQZTNVOGFCaEFQVGp2WXhRTEltbExiWXpSVm5PZzBBcU9NQW5UUWZIY2ttRkxTTm1VaE5TUFV5OHFtcWFXRXRJdzQ4MmF0cDJnQlg1M1NBQmprbUFiWmRuV2FkenRSMWFkOHlVZVREKzB4cUFtWUNzNklDemhKbGl5RjZacnhjZWxEdDBBZ0E2TEJtbE5CN2JKdlNRUVAwMk5mT0pnNWVHRVlZVy9tVmx5MGRUZkFCZW5tZUtRR3dTVy9zNUpIWE01dHRuUm5DdXlaQkFja2FnZkFoTHExb0FSelhzUUJmV1p4RCsvSmZBSUxlbGwwTHBNU0xZWmxFbEZsZGdBaGVXTnIvbXJUaWw4c21iVklOZUwvNTlsdnpHd0FEWXdDS0g1VU44RkpRYU1iTVQ0ODBMOE0wd1B2bVlydVFxS3RUSGZHTmZLV2pEa3dkT2xjcjUzU0s0OHZjTmZ5blRONmoxVXIvU2w0VmVPTjRKb3F4MlVZbi9ESzgyYnRUbGwxZVI5dGFaa2FIWkFSUlpyRllOTk5wREkvMUx2dTJocGJHbzIwSlIzdGVHck1GTHJtMlpsS1pPWmloMjVMdGtaZG9QQXBSZGFjbzhkUkFGNG9OeFVFY0VlMDkyM2IxcnJvYWxWaEpiUDVxT29FNm9BZmdQR1QrN3Yva1RILzFML3pwbi9pTmMrMUcvTUw1Y3p1UHRaU1VkKzdOaHRFSEF0MmJNZGoxYThVZVNGTjJzdGVPTUNjdzlja3hhbHBPVEtGaENPUzFoTUxRbDViSFplenh0SEhBOFByWFg5LzVKLy9rbit6OEQvL2dIK3o4bzMvOGozZis5ZS8rM21pQVo4K2VIYVljQi9hMDhDdFhWb3hrWVNMdExTY3lHSHUwbll3dEN6Y2pmaWN0bWszVGhKK2RJVzYzTFJOYkdJR3dNek1Hd3RpV3dtSjhjWnZOeGx0cWpZRjFLdW9sckdnWEJoQUlyL2NjM2xFZnpPOXplWXNzalFMVEdqb1RLb0lJR01UbkJSUisyMU54TkxPMENQYzhEemlCTlA5b3RsQUF1alJZUTM2QXRNQlBHcDdaVENub3lkZWFXUVRBMkRMTEJDZWdNUGtDb0xXRnRPU2pZMGhtQm9TVkJYZ3lMUnpQUTRHSHhOWGFGTWpYSUpOT0xUZlhEOVc1NkNUVW44bkhLRU9iemFLTnJyUHpLaHY2TW1jTWtHYm9kSTJXS0Y5bEdtQnFpSzdlOHQzZUFiaktkMzEzcEFKOWFYNTRSSjYzZ0hwcERLalZUZzd2QUI2SGN2cXRVM0p1Q2tDWE5PZmtmK0RBQ3FJbDcrdlJDZ2hYNVk1aVJtU2UwcWJLT0thbzZVU012cGEzaWZLNFgrV216VmY1eFpGZUl5dWVTZ1BPWlRqYVlmUjBqWmxHV2ZqWjR6OEFpeGF6UUtSU1V4aWNDNnhKMWVvSUxmU3lDYTE4OElaRktUTlJYTnVhQzRtc2xkbHlkbTV2N1hZZHNETTlvYlV5cnJMVStmVWRmOTVKT1RIUjNhOEJmODlKZy9MaWtQK1lLV1lrRURVVnBLY3BNdmdTa0c4ZExGNEV1QnZ2cTUvTzB0eUprYTM2a0JXakhzcUZnNnVoTGRxWVlZYkhvdzFGZzVzcGVqOEE1eUhUZC8vbjArZk9mdTRuZi9nSC80YWdSK2VmZXpvTmtMSVd3d1ZnOXd0U3p4UndkN1pKU2xSaXdqbGl5aGwyQWJGYVdzL3UwR0JXVS9sY2t6SkxFK1VCUVpQaEZ2ZDJtc283M3lvSXpTVXhZUE1KSlNpOWo0R2VlZWJjK0gzU3RMN1JwTWE3NzdhSFcvbnYzRTBUUzNZd25jWTJmQlgvMXZGSXM4YmRqY0ZzQlI5VEpoUmlOQXU3YU1MUER1TEhqZ2NFTVpLWlpFUElxMmtuTnZXa3VXQXZRZzVZTUQzZ0FTU09BYU9ZSHpNVFh1Y0MyK1Z6QzN5QXBBaDdWaDBTTWlBajNyTjNTMncwQ0s1NWhKYldSSmdJTDNDWG56UmNtN1IxZG9FYWJYbUVJanJibjAyY0JrR1RIcW16WTZjMlpCL0JKV3pSNm5xMlQyVkVRK214K2FxSHRBRGd2UVNLWGp5LzY2Z0lqcEVOYzRHWmYvY0JqWE8wdEVCanRIczBTMWdKcW5xYkJGUE90WjhoT2kwUUZZWlZ1M2lHWUt1N3orMFFYNkxNcDB6QWVDMGFTbmpqRTFvdXI1V2hRM3l5dmNjM2ZxTzNkM3gzT2o1ODNiM05ES1BPT2lSMjBXTzVINm9iR3ZmQzVPMiszMXM3SzZlNkdYMDRKbXhvNVZTUEFhREtwbTJZOTN5bTYwK2F0RlBsWmlJemtxbldZejVCZittaGhRNGErQTYvQkhETWJ0cUMyVXJINFJrZ0xTalRoZVpuWnVSWDJYbDR6SUt3NklkUDNrOW1Ob0MzaDZBNktKdU9penpJa3phUGw4bUFTV25hNnl6N3JqMkJQVGMvN3FjT2FlRURib0ZrY3RLS0g4eFZ6Rmw5Vmh2ZysxWG0yYm1ta2E5M1hLTTVLNXRQZkNxR0RWcWFxR1NiUm4rNGdFWkdZUS9BZVVqLzNmLzVjei8xRTIvOCtBOS9kdWVGYytjRGxZT0YxV3ltdFFhOVdtQVdnTU10ellhc0kxUnBySXNKMG5aaUxxZGVsK3ViazQyUGhtTnlnVzNMaEJybXNldkQyYWVmM25uNU15L3ZmUGF6bjkwNWMvWWpNZFROSmdjdnpiRHh6UUt4NkpWcitmeFZMNDJ3WHVqZXR6S0ozS2dzaHcvbTFVRnpqNGt1bDgvRmZGcmZmZWRidVM4Vm43bjdEemRwc1NhVWdBVlFvaEh5TExnek05WjdkMjErUW9aZXo4V0tLU2FPSFFZYWpZSFlsYmNEOHk4aDM5VVVFMHBwRTg0Rk9nRld6NkFIUWVSMlJCc0d0b2FIWWtTejlmR3Qzb0FBL2FpMGhORW4weERhY3VYU2lURGhvTnNBVllJMi9zOXBORlNXeld1RGpkQ081SmhlSjJNNFBkcGxkYVE1QWF5dGZMNGJlbHYyeTU1NDhlS0ZFUnhCbzd3SDZDOUZSKzliblJiVnh0U2ovcFljQTU5Wk5GTSs2bW94RU1CWEgzNjhRTWZXVXc1NXNlMXZuUXlOREcxMDBEbzgzM3RwN3FNWHJ4WDVpcWxDc3dOaTlXZzFCNEUzT2dxSWF6L21Fdnl3Z0h2WnVGZDlsN2JxTzZCd21oVGtqZ2RzeG15Um1XTEtFeGdxajQ2WkRWaGI2VXp4NUlEdGJwdlRPTlVUY0NvdndGSjI5bnpQR3hsYXhUa2RYV0JVMXRNT3JnSFgyN1hwN0hhZHJKVGRkTUxhYWlXdlUrbGlQeWdPRkJ4dFQ2czB0MkEwUk9NZWVrVmZJSTUvOFFhWllFb0Fpb2ZqRWVWV3RxdTk3N3Y4cHczU1hJMG9OcUJGT3o3ZXlxdk5yQ2JFNXdyblBWbzArZ0Z4NWcxYS81SWZIZUpTc3RDeUl1eDJQcHVzckpFZkh0Uk9BSHExTDk0dUJFR21HTnU3c1pGVFVtREQ4T1dVOHNHZjc0b0N2L0x6UC9YYVgvbmx2M3ppMHkrOW1QYVJkaGE0aW9aRmN3Yk80eUVSc0gzUWNrOHhaVzlrYXRBb0dHSDcxSUJtZjJrSW1HSjYyWVNiZXhuQjA3dGpFRVAvYytlZnp4dmtoWjBYUHZxeENXWVRyODRFNEtVMFdZSUptTC8wbGE5a3cwMURpSit2cFpIUkN1dzJiZmJacXFWTGx5NVVyb1M0NTk4UG5LOWQvV0FFeU9RRXV4dnRBV0NiYkNFTU5JZ3JsOThkZ2RDeDJGMzVZQUF6anZ3eDdNRVkyTXo2SnJEcVFYQ1ZHOWo1RGZBQkVuQnhZRWluMytvb1RUYkZtd2tjKy9UUmhPMUdnT1VheldVV2h3U2loQ3c0NjExTVM1TlpBckpjOGRMdVNIM0g3SjFZMmRMVGt5ZWZiUCtYWnpLSmtIc01uZFUzY1E4Y1ZoN0FuREFBZzAxckpwQjM2b3hXZmRaa3pnekZBVWtIajRtSFdvb2MyZ3h3VEIwSGNIT2JyTzRsMXJ2QXc1QldHeFBRQmN6ZVJ5dmdqbGJ1eWRkQitORnVPb3I0Z3RCdkdyTE5GQUJKRCtjTjhIQ2pvcVhadXJiRk5SbTN3RWs3Z01oa3diUXhibkFKdkFsRnRESTZtd25TZnV2UUFEQi9jcDRiVmxjeUFRRU1FMjJyUTFtMllNQ3RYQVBJOFFTdGNzb2F6em5ZL2RYTHFBRmZMbGhiZFZKR0duUEZHVUN5REh4dnZDR3R6WDZzRTVDSGQ5R0V2NEwyQnM5akxvcm5YQWZFNnZGUVNwRjMvS1lwODVsbXpnRGF0dDI2bXd4NmZ0SWNaY25JZExlTTVWdlRUUjJOQU9qM3dOOTc1amZ3L1BYYVR2M0hQRmVUcXF0T3pTZSs0Q0dFeDlWQjU2dXRUTGJqSXpMTlpHRnpZWHdNOEkycWRGNXM2bU95aTYxNEJoMU11MWJtNllBcERhVm45UEpBYzE1ODlSMy8vYlZmK3JQMy8vcXYvY2NuZnVabmZuTG55UDQ5TXhIeS92dnZycTNzSS9RSEgxZ25uK2toTTRWVlVIcEJEY1NtdW45M3EzdmVBbXkrdG42M0t1bk1tYUtIblNxNlhkb0ZidzB4QkV5bzZKbHAxVzgyYS81V0FHdGk4RE5wMFk4LzhXUU52WC9uZEhacHR1bURDUmNmelNSdU5DbmVBdHlpTEtKZ1M3YUYxclZBaWkxY3BMc1BQckJyOWxwQ2FpVVk1dTEvaHhWY3V4cEg0SG45K2dxREtINEZXOTRFTHNLUU1ZK1paVFpkNEFKd01TaEdIdTIzeERBaHdkckFHVU4vV3lNc0o5ZTVkVTFncElSZ2JNRUpCUzM2V2xxNk5JVk45TGwxQUZQQ0pFQjVBUXFRSVh3enJLd3Myd0lSQUxKQW9NVUYwZERxTnAyS2k0VEtCQjl4dkJFdGxOdDM3K2c4dmJwcDBnKzFncXVmMHhFS0VtWDRxUVBnQzgydWVxaU9HUmdSSnVRRCtQNHIwN3EydEdINUtyT09lUnVhQ3lSL01EZXhLV3Z2c29Ncm13bmdEYkIxZm9EZU93U2E2eHg2YkdVRVVONmZsYVNCZ2hFUDhGQW1KOWZMQWMrZThhbXVILzZjYmN3cUs3OWVJemJlRm5oUVp6RGxxdjBBSmZBRXJxNnBtL1lZdWh0bDZJaTdQblFzVC9mVTNUczBaKys1aDQ0NkhzQ3ZZOWJIN2crUTNNUGo2SU1IMU0rcGZUOFlkOE02ZmNyQTVNbDJqOUEwM2t4dHZXZmZRN0wwVnZzVjR1bFRUZHpwNkVmN1RETlczeHAveXV1NzkrVHB4TVQ0VmVCK0l5YVRtOW9LYjZxcnFJM3FPV1ZoMzI2aTNXaFBMQnVCOS9jVThuZmJQNUZaQ0MyWXNJYUcxZFVjaVZHeWRuRnZNL01vZzk5N01tczRkRHhHaC9JeXVwTTNXandBNXlIUC8vdWY1NTdiT2Z5Zi8rVy9ldnMvK1E5L1plY1Q1NS9idVIySTNMcWFlU0Q3THlFOWtoWjFxNTJxTHpXVExiQzM0Zm5lZlpqQThDaXdEaEFzT3pXNWM2VWUrdm9NMlQyendNM0tMTDB3WnVFaXhyWHJqUUNaeTlRejVmZnBsMS9lZVRpM1BVSEtyMmVxT0pSbnlOMFlRaUNrRTAyU01HTkk0MnEreDNINmdQZkZ6QnRMeU81bjIzdDNmS1V2WnpPMXpQdTlPb0MxeGgrbzdabk93U3c2d1hxcjJYZWExZjBFNjhUeFZpS2V5SCsxRHNXR29ZU1ZMaE4zVFU4Lys3Z0YvUHcyMVVYZXpDalM0ZE5OVzdRNHhvbUIyWDNaWG1scWdOTWtsTzltcW1rWE9wWXJYWitoWHVZZDE1Z1pidVp4d2orY3FlRGd3WHpJYzNQYkV6TWI0dElPQWV0eWo4cytYUm1nNUo3OU5ISDI4UHlPRTFqUFhVdDdPNUIyUkRNeE9aWDgxbmxtYnFtOFJnd3pzWmpLWitqSjY4V012UldIWWtIc0sxMlRaTXdYTFdScnBac29hV3ZwY1l1UzFtS09GZzJaTUJwQnUxdm5VZDBBSmszSlNHWlBHYVlQaGk5cG5yVTN3S0JkYzYwYzE3ZEl1SzlPbjkvdG5RQVhnQUw5dFpOSE52TUFqYllyajMzNXh5NGJNeUFPZUFhTUEvUnlFSHVaZHE5RDBBYUhxOHU5QWx6ZjJLWGpuVHZSNG5wYWZVT3RQWHZNY2JReGFwNDg0clB3SmI1WWZHVjA0ZGVyODJJZWNwMm5BYi9jaVR1eUN6STB2cVV4THpEY3pCbzZqZEh1cXlPTlZWQjg4d2Y0bkE4OWs0RU5LajY0bkdlSGpySHJKbGFCTi9BeVA2TkRaNmthUU8wK0hycFdPVzUyL2ZSamp4WmorVnQxbnBjei81MGRVNU41RmZ4M09Ea2FiNWxLVDR0bDQ1NE9JWDVDbDJyZGhDb3ZuMEMxKy9hOUpLUGlrbnZmSmhlMFliYm9TNEgyd3kyYVlZS3diNlp5MGRBZmZ2alI0ZWRMRi9NVWlUZncyZTNtbVhRTzFqdHdkVHg0c0FidFFCL2dyUE1DMXRvY09BL2RqQktqa1RrZm8wUjFSZnYxNXJ6KzRNKy9pd0tmZStuRlgvNmJmLzIvL04xLy95Ly8wczdaeHo4eXczQXJsZzdzWHphbHhEc3QrWHBESzVHMmNnL1M2RFdXQlJDWWliWmdnUWZ0YUNZVmFqUWdmT3IwbzltYWNsWlBlSUFEbjJUTWVUR3QrV0pCdUU4VjZFVjgyY2V6UFp2SUdqL1NoQVBUWDZvRCtGLy90LzlqSmxSKzhxZCtldWY3UC9PWm5mUG5uMitUemJNVGZQeGlaYmw0NGQzUlNvQUtieEVycnQ2cjgrQXBjaTNONWxJdWVMd3o0cjhSQm95eE9kZ3IvNTQwQjhkb1laVnY3SktaSE54VGZscVJrNVlFdEIwalZQWDhoSXBHczh3Q3k4d3hhZmJ1cHJrc1cyVWppOUllVFNjR3hlQ0ExYXJMb3cxWmFXV3VvQTlRWXR1ZElXVFhEQmRwTmVpaWpPT2hVZm82Sk0raTY3akFsYTRWbGpRMzJxYm5DWWtocFRKNWQybDJ0TFIxamJDNFYxTFJhOUhBUElKNkVpN1ArYTA5cFV2eUFabU9ibHRKTjZzM1M5dHdGaEFaN2REV0xFU2c1UUZkV3RRQzV6VTV1STB1QnBSeTVRUHlPaTRtRW5WVmJ1WUpkSzhDVTI0ZHdOQlpSMVZSRkVmWlo1NmpkbEEvNmJnblAybXoxUzRUMFpyVS9iQjJyQTA5YjVJS0xiMnZ2WjNhVHQ3U29kMTVEdkM2enQ3dW52cWhIMXE1cjh4VG50N1oydDU5aTAya3pkM01FbTczbEozbXFnd1kweWV0VWpuR2hBREUrMjVwK213aUVLQk9lL2ZjYkpWVzIyZ0wycmhKWVpOczJ0dEloMnhwdHpFZmxBYk5WcmtjeXFOT3l1Q2FjN3gvcWhOWFZWdDNvZitpbTBENUZ5WlVyN0t1RmFPcnp0NmpVRXc2OFFiZVVUNEg4d3Q2c0kxNzduNDl2TFlBOWpSeW93UFhIZHdESDREemtPTGYvZWVYZnY2bmYrdXYvUWUvOHQvODNKLzZxWjJUZVJkY2FYTHNYbHJ2dlRSaU9ncTdrNkU1MDRGUWdLRmdEVVA0c3FYdUNvYmVPUmJ2MlRTQW1FQlRhU1FDeXg1Sk9EVW1RY2VzUWNIY0I4ckE5cG5jOVd4SlpKWGdWMS85V2xydnBRR3AzL3l0ZjFHUW1GZDJQdnJpUjNlZWZ1YlpRUHp4blJkZi9QZ0VWcWZKbGxscG1Vamp6c2RsYUlFeTV0WDR5bTF5dzZRaG9RTE9CSkQ5eTFEM2VzR2NzQXJHSlhCQXg2ZHJ5aWtTSE5Ba2xNNDQ2OXZDTUhiUzZnRWtYY2VnaE1UcElBaThOQXpqTitHampXQjJIZEdqVGN3d0k2QkxDY3o3N2ltZklhajBEQWNKakU5bE5Bbm8rdEN5N3cvbGVTQ0dCNjFhdmpSbjRNeVdTbWlaUXdpRGszMlFvRGo4bHNiS3U3YktVNE9XRFVDMHEvSnc0VEtCUyt0aXI3ZGp5NHBGWWFUVVJKOHlaN3FZOWl3OVFnb1lUTElwSzYxTytzcjdZV0NRdjNlYzk0ck9wQ3p6M2k0UTQ1VnR4NHc5NVkzT3dHQTBzcjZiNHdEZURzSXVmV2tCT2RvanZrTkhZSzhUbEw2MkFLUSsvVjV0VURTNDNZa3JhYmdtRFdVZFd2ZWNZOEJtOXpyZWRnOHZBSHNkeHZiZWxCdU55a002M2hzYmZNbEkzOGpBd2d2MmYvVjFEVzA5TzdTTVoybXhodjNTa0RaWFQyQ090M1dZdlRuYXJmZVpHMHdVYXlPZGwzQ2ZJc3lobFFsMzExY3dLTzJnSTE3eXVjMEx1VVpPcDJ3Nm5HaHFaRW1EQnN6NHp1cFYvQ2hmOUpQR2RKN3hpYzZCRzZZT1hCcHpSaHYzTnhEbUQwNzJ4dE1uT1NDWEZEZ2pCOHJLQTNBZUZ2dC8vdlBydi9xWDd2L1gvOFd2bi9taEgvak16bzJHWHUrLyswN0JjZ3BYMkNLRzVEb3d2alRhaWNuQTl4djYrTHpQenBSOThtb2F0Q0VuWmlVc0ptVnFvNWhwb0cyWEdaYmdFSWo2MnltRXlRU014eGI5Uk1IQWZRSTRIaHF2dlBwcWtiaSt1anVrZTJ4Q2huNys4NzhYZUFSb0RhVUVoQkVWNzNpdVkzWlBPVmU4V21FVzMzdnZuWVptNys2Y2JtVVRzRGJwWjlnbHZxMUFMRUNaRUxBL2MvU25xMkt1UTJtQkFGTCtDMXdDallvdkl0NkZOSEJEZlIwS1JsOU1aWGx2OXQwRWdNLzJzYjZyQzRaY1lMUHN6aGdaRUw3MTlwdkRpT0tIa0hWMjRlMzVndzA5NC9rQk1FenZBT1RTSWtEb3lsdkRieHE0OUdod2FEbWcydWZSbzQrTXdCTXNXaXN3SmlRMEl0NGVURWJiUVZCMVVOT3A5SzcwTGZ3WUVmVllSUUFPd0VBbnA1d21qOUFONkV2SzBOaUdwOHF5MnVSb0FyZnJibWdVNG1WUGwvNkFZR21NWmhkOTVhdWpjM29mbUZuUnFTN3UwYzdSYlJaNkpQVHFmUzJURFNBRUpPZzdybmExcWJ4MXJsd2tQMHgzNWhtSGQ0RXpEYzU5WlFHV1B1VUwvT2FaTkZZVGJ1cTY1YjExS0t0OEs5OWVuSGZRMzdPUlk1NlhwdWVsaDU3U1J5K0FEWUIwZHJSR3BpUDhJcllHYlpsbkJoQ2VDVTMwcTIxV2g4aFdiUkk1YjZqU3RXUElSRnJzTHBNQlhwNE9zM0tNS1NoVGtielVaZVJ3YUVVSldzcVArTlg0d1QxbDlheEQyc3FxYmNpRDU4MEZhUmZyQk5RZFVDL1BIUjNTR2luT3kvM0JiOUlsOC96cDVlOEVBSXNHaTU4dk5qR3Y3U2hJOG1ZcUV1UGtlR0Z4VFZvL0FPZU5vaC82NU1QOGkzL21aOS80YTMvbGwzWSsrdnk1Yk1zdDA2MlhlNmdKSE42WmQyKzNyMTFhNVJYdWN6UWd3cFIvOC9YQStVclgrUUxmVE1PNk5ab1RiZGpRai8zVlVKbzJzRFNkZmRuYmpyZVhtVjJTZ1FDYnJ1RVhFNGdKd3NObWNIdUhwdnpOYjc0NVd1dll2dXExYWJCZmUrM3JNK1F5S2ZMaXh6K3g4MFRBakZIWUgwODJNZkxNbWJPQit5Tmp3dmlnc2xvOU5VQ2M4R0NTWTltZU1mU3lzOXJxL2VFUjZtNE5PRDkwT0swMzRTQmN0RUcrMitOTkVUZ0RDV0JKeUdnUm1CRlQrMDZiVUc2Z0FvNW9NZ1NYM3pLUEFIVTlFRGhhWVRaYXpOZ2gxN0pXdndsd0ZXbGMwdGxuaFYyZlNiMXl1eVk5UTBHQzQ3N3IwM1BJcjJzNkZMUTJxUXAwQ2JkeW9JK3VjSWEyVTdyVjhGelNOc0NSdnpSTWVPb1kxTjJrcm5iaTNVTG9sbGFrZkpsYmFsdHhsQzN1QVRqTU5OcVJPVmk1QUFCQUFFbEVRVlFZYlpSVlc0MEdwV3dWMHpXMGNrejUrMFRqRFpRQjRRS2dCZXhHQkVBSDhFMjVkbmtwRS94S3E3STUySGNOc2RXZHNKdkk5UTZicThNOStVaC9YRENyL3diSzJzK0pWdTRyMzFyUXNmWW9sSzlyVG1sczVVZDM3VG4wNzd2bjJQUHhnTWxkOWZDODh1Q05hZHZLSWk4MDlCN1BJSzJpL3ZzYUZXMzAyYy9lM1gzdWlEb1NIUXJUeHJmQnI4Nkp6Vi9hd25MaWI3UTNzcUNOM296dVRJQTErZXdFVHE1R1Vlb1pIVFI3OEhUQ25xbE5sTTJuY2d4Z3g4UG9oeWFVRG1GRjVmZjg4OC9QTSsvdmVrdWhMeE5QVlpyNldrbUlsM2dUNmNqSmdqTDZydDVrRU4wdGdQRWMvc0hMUm82V3FRUHJCMmFOWWRsLys4L25YbmptbC8vQ0wvN0NQLzNWZ1BuWjdNdVgwemg1WDV3c2lNN3RnclZjeXZlVlNjUGszOTJZaGwzdlRwcXlYYmR2Qk5CQSsxb2F3TGlEcFc0UlVDWUpOcy85N2N6QXZPRXdDY2JlakdFeG9Fa3lqRzBJcGpFMTlreXlkYTBIUnRqWld6VWVqd0gyMHZlYkNNR3dqeFZWN0xuenowMkFKTjRXR0pBMjhsNCt6UVRqY0pxK1hHbkxoK29RemhUcHk3WDdTVGRtWjN1VXR5V3FwMCtmVGl0WXNXbmZyNjc4VUMrbHRWK3VYam9PSGlEaWZKeC8vbndUTWsvTVpDU21OL0VHZUxtcWlidE02N2lZclE3ekVlU042VEVubWhEZVI5SVFNRCttTm1GbW9zYWtrYklBMEh0Tm5ubCszVGVadHJROHZ6RzdTVHZQb3FOMGFORHljWThaNDJidE0wQ1hzQTZ6SndRNkxnZVFOYUhvR0lBS0FMZHkrcTBOOXBXTzlBQVpIVm9zNGMyTUlWMEZvOFV6bGN5UzRZVGJpa1RhcnphNGxmQlpOU2hkNEdJNFMxdkw3THliN3JMVHkyUExXM244ZGxyMU9ZQlZlV2l3M09mVVRRMUd5RTNNOVgzS2dNYlNqWTkwSGtDUnBxOHV3R1BWYVhraEFCdTJlSUNBLzlCUWZhUUpvUENqL0cwZzRWbjNUZEFPamVOM1pmTE0wS0Q4dGJYMjFQbk52WjdIdjlLUXBrL1ArNDRmdHBNTEdVQ2E5b3VIZWlobHAvb0FSNUt5ajBzcFVITjRQN3BVUCtDbWZjenpjUDJqYVZNRXBHc25lSk9MMGtRek5tS0F1bWpBMzlrSWFYbnJtSGlmRFNVaTNHaXE4UWVhb2FmZnZIcVVYWjJZc2FRdmYzbWpDYk1HT2tzUFQxTldQTDlwMHZpQzVrd0duYXZUTnRKY2V6enlSZ0xrSm9OSFlkc2R3UzQrRHlPbTNnLytEQVgrNGsvODRQLzVILzNxTC8vdFgvaVpuOWc1Lzh6Wm5idVc3Y2FnaDVwVnZSOXgzMzIzZUFKaVlpVFR3QVN6V2NwODNYTUJNNEMrRlNPc09CclplSnNCUC9KUTlxMEVBRmd3QWN5d2JSZWdqNTFvZGp4UVNYOGFJZFBUMG5vQVNFcEZqTGs3Y2RXN05BdmdDQ2oyOWd4TmJhSzIxZENUZGcxTFF4dk5NSE9FMVUzS1FxQStVZ3lPNHdtUG5odWppeXJHeGlkNm5RbEFQZldwVTZkeTZYc3F6VG0vMGRLaUdkZjdqUERhMncxd0U4Q1pYTnhsMkRmZmZIc1cwWGoyd3hvU1FXUnpqRUREMElSNEdMdjNNTFlUR0JraXJzN0JzQkR6THJ0aEw4NmlsSHZvN2gvUTZROWEwWGpWZ25ZMnk2WExTNmNGZk1RaWtTNEE4NTZKSnRya3JNcnErcUlUYlh1WlR6YndWWjdaNGJsbjJDa0JGTHFoN3hMa1pWTGhRZ2NJaklKNFZtUU1HcUZIY3djejBWb092TnptakRKbzVDcFFNUWVjMFpiNnJCMXNvR0N5enlnQUdMRjRTWW01WmN3Yk41ZDI3VDR3V09hTmxUOHd1RjIrdE14dGF5c0tBQk9SZXFMRDVUUlhvSUJuZk9yODFCWGZBanNnQVhRZFFGaTkwYzduQUhhZ29kMDJNQjQ2ZFcrbHVWenNYRU4vSUs4TkhMd2R2TWUwZ282TzFTRXNGOG01MEIvdElDMEFyWU5IRXl0bGgvZXEyNTZVR2FDb1kxT2YwWmlycjJzVEt5VWhzYzVBWFM2bnhacERXUjNCQ3RKMElwN1ZWczZoU1duT3p1S2VyYjRuVHl3QVY0ZU5iOUIxNVdVeHphNlpwaHlZSDlSUkdWNTc3YlhwZkNoRmVQdTlWdVRLMTd0TzRSZDBUaUpNbW1OQUMzWENPL0lhTDZFWWdvS2xMZGJLMU5vbnhjdzhGUGtCMWcvQU9jSTdmdmxuZnZoM2YrMnYvdXJuZnY1UC9mVE8wZHppTHJ6OWpVSitKdHlHSGpFcG0rMk5BaG1aQkRSTFBNczdoZjJNNERPTFh3OHFYS0ZlRU1HRlR0eHpZQVdVb1czUkt2aEpBbUE5TEVhMlFvMzdFZ1ltREJvRnMyNkxGbWdObmpQTExIb1lnWDBrTTBqY05uN1BLMFJuRXh5WkpvZ2JRTlNvQko2TDIvMDBBQ0VSTFdRNUhmZytrN3ZSS1VEYlpKc2g0TEh5cGoxWlJyMThYVzFiRkZQRUlCanFpY2RQamVzWVlWVXZES1lERUlUZjk2bytCNGJFakQ0SnUrZm5mdlZqbitZeVp4VEFhMlcwditvN0U0aHBJYlFFN21IcXYwMmU4UEt3QXV4R212NEdKTktVQi9BZ0tBNnozK2kvT3JpZENUbnBOd0dZOUJQYUVZNEVpalpFcXllazdObnMxZmNCWHMrcnMrdnFyQVBVRHBOUFJGVVAzN2xSTVpHTWUxbmxyOWdKcHZaYmR1OHhIUVNxNmtNckorQWxQL1VhODA2LzFRWFFPTFNYZkIyZTFlNk9qUTlHUU1mRlRjY00zTExKMXI2ZU81b1pRR2Q2UDlBcHc4cTlodUhNTGxiZTZjQ0dqejZrNFk3MkYvL1JKdEVSd1BYcThKNTdUalIyckxLditRWGxBYXptSU5CQnZqN3htbE5hT2paMDlENEF3NmY4OUgzMzdKWUdJRk5uL0Q1dEZCK2grYlJaNE95VGovL2xjU3R0TkxkL2VmdVljT05aTVdXc1BON2Z5b3dXMm9DMmpiUmtCb0RpVjI2WnlrU3BVQlkwVlJlS2hIeVo3YmJPU1R1djlzbU0xWDNCaHloVjZxZWVScWpTdXR5b2VLT1Z1UjA4eis0OVBOSXphS2V6UUg5TC9XMzRMRjFwcnZMcHJKYlNzbmtiY2YzVWtmdVVENWtFNFArL0IrZnpHV1gvMmkvLzNJMy82bS8rWjQrLy9QS25DdXpUVGhEMWhGY0M1cDNiRnlOWUFOeU1xamdaK3hNOHd4b05RR3U2VjBQZjdoUXo5cVpsc1BsQTN1QTdtcm5nZmo2Kys5T2MrY1RhalBKby9zS0gwNkx2bG9hSVlVY21GdXl5cVdsMGpXc0ZIT2F4aWVxeEFQTkFEUStHM3I5MGVjRDVmajZwRDVYV25ZYnJsOTZOaVp1UTQzZDV1MDRDNEp6S0gvbmhoRStjM1NNQkhPWTZYajVzaDQ4bFZFOW1tMzY4ejZPWlJoN1BaUE5JMTAvdTdnb01VQXdKTVk2Skx1VitsTTBzZFc2Q0JGVkgvcVNHaUxjRFJ4c0o3RHQ0cE8zcDJ6RTV3SGVORC9ONE5DUjBKK3BFMUl1Z2VJZk45RlIyZEJPSE5FMDJ2RU54bnduVU1RRkZYOXJ3NFNQNWh0WTUyZ2lBaWNkRTNvQllESzVzdEk4VkN3R0lOR3hQR0dmVm4velQ5QUhEemJSYWszTXpxUlNBajdtajkybDBSaVZqMHl1ZDBWaDdIbmpxMEc0blpPOEhRaFd2ampOQnJ4TTFBZVZrRmpGWiswSCt2alBDU2FzVGdaQTVCNjJNUU15d3I4bWR0cmNQTkI2dXJTdzhHblN0OU5yM1dpTXNIUUFOTzExNjh0UVpTM3ZQekUwd3FaaXhyeU9xL2RoR0FUTXdjWTFObmdhTU1heGNFeU9GdDR2Z1d0TzVwYWtmRExSUEZEUDRhSnF4VlpoVllNeFlSM3Iyb1NMcUhXeHhEUUF3YWdFS1hEN0hEenY2NkR5V0Ywc2RSZlVHRXVNS0dDanFWbWJrMEtmSnhobmxSVWR4dUlHWk1rN24zRHNDY3VGejdXSDBzSUJuZ2EyVXBtM0tDNmhxQjM3ME5YcmFzZ25CRmtOZGlVWm8zbmVLZ3hHQlR1aEtQSCtyRVFvYTRSUHBDejA3SGp2L04zbDM4dnRaZHQ3My9WdnoxTlZEVmZYSWJ2YmNwRGhUbEVsYmpDaEVzZ2JFdGtnNXRpelpwQlZKaUJEYkFtd0RHVFpaT0x2OEFWa0V5TVpBRmdHeUNlQk5ZQWhHNEpXUnhKYXpzR0dKTnNsbXMxczlWSFYxMXp4WDVmMTZ6dTkybCtWa3oyN2RxdnY3ZnIvM25udUdaL2ljNXp6bk9lZktwK3Q4MVZkemQ3eWJXODArSkxmTFk2enV5bjNzc1NkeTZ6MGRIUmQ5M210MUxZc2J2OUJSaUtrMjBvc0hLcGZmSEFCdlZ2Nnk1SXY3VGs2dVhtMTBVUFNHTUxzbDV6cWZPdm4wMFFRaUk0OU96WVNtMFZDQVBSMVR1bTR5RVIwZXpZMUlUNlEzZjZVRG9XODZ0RC8xNFB3M3Z2VUwxLyt6di9udDNXYys5VUxEL0F0dHBtSXJ4SHluRWV6TXFWNWxuc1VGTUJITnRwMFdCM0FYVEUrWVV1dEZDU1dyWUJ1K0o3dUx1QW5Ka1hwMVBtZXZaT0tqc2xrUks1cjFmQ0QzdzJZcFlaeHl0bDRaV0JzdTZnaFlFMVlJdm51dVJTOHB1TmxjcjNVM29VTFIxUVdnbmlreTQvR0dXbnpDZk1lczVJY1N1a01zek9wcFAyWkxWR2NEOHNyakgxVm53aUZ3bmhBS28yTXRzR3l1dFJTZE5TTis5MFI3U2ZCMzAxRDF0T0RGeHZEdWN5L1lJMFNrQWxwTTU1WHlQMUVISUUrV3cwYWJaVmt3K0ZMUWNRbFpycjIzSVh0dFh1QzlhTDdSUnYzUXg3UGJxWDRIeDdKYWV5WDR6WldqUGdhNnpKUnRwN3VZTnJUaWkyVUI0NGM2SFlnSDZnRWM3UGJHWFVJNXVRb01NZVdKRDNpaS9sdGIxTXZ6Rmcyd3VBeVJ1WXhZckt6K3pZZVA3bU5SY1Y4RVZHdnhRU0FLVEtLanVIYjBrcjk2YjRmdjBsQjA0Q1ROMURlZ1ZqWW1xUGYrUTJ1RVpxR0tVUWxRTVZMeHJHZ1VnRGFMYmJvM2xsOTE4T3lNZnJqbHludWpwekszRTcyMVhhL0NMd3FFcDlQVEFTVi9nTkMxU0RDSEQvbHNlNXlRYjdUeW05V3A3ZzluWmJKZ3RWVW5Kdit0blFQT3RkV29qMnRuMjZyMGNpTVRtK0lEZktjeXR2eEdWbHRoU3k3SUQwdlpkeDNJNkU0eWJINEZmODZsTnliRVBmTk1lOVU4ODNRanlJeVVXODBsT2REWnhMallhWHFnTS9BU0JIdHJ5TnR2SXhKNVhXbVRmL1JoTUpqb0I5YjRJN3lPL3hoZjBBV2ZIaXp5QW9pcnM3SzExM2YzbkdqTEFORWhqdjd2clNGWVc0citLZmM1L3pmZi90VjdmL21iZjJuMytjKzhWT2hicjE0UG1HMWVkQ3ltUHBRZzNlMjc0Wm45S1FTNEgyNkxTR0NOWWZZQVBwU0ZncWdVMXpYTTh4MFRISWV6ZEd5OHdrb2NjRTVnQ0M3aDl1YVFBMjFsSjJxQm9JOGd4eHorUnJ0b2VidXdmUFRjeXNkVVphVlBJMHg2NEpkZWVibWU5L1R1cWFlZjJubDNJYjh3WURDUjQvWDJKM3BMQ09mMWpTeUQyZitqUEs0RW91ZGFWZlZPYnhsK3Z6aGo5UlV1OU1uQzdwNHNydHBrb0NFZzVYa2s0U0o0Nzd4N0x1RTdPM1ZnWlFKd0lYNHN1VkhLMHJDTXVDeU9aU0Y3Qm9CVENFSnJsdHVudFBLbXBCUm9GZzNVb0dBaEdnU0VoQlhJUkRzV3JwbDdQMWphSy9qZlJDcExydUZvQUZ0UFYwb1dkdU1ZeXBKbWVtN28zek9wd09RbkgvU2RpYUh5bitpWWFNdEhxNTNpcG1kSHN4VEZVSGkyY1l5MzZra1IxZHRCd1NpVi9MWHhaSFZnTWFLaHlTMCtYT2dBZkZpbFJoSDhsdU5QTFQvNUFybFpqbHhuZWlBTG1LVTRTQjM5Zk9vWWRMaXNVVkVIMXl0blFDSjYrcTRkT2hIdDNSMm93NnBEb3R4SDJtZGl3TG5SemRVbXJpR0V6bUxLbjA2b1RyWE9tR3ZHUkJjQU1VR2x3MEJEb09LVC9HZ3o5NEF0VVhHSHhTK2Q3OUw0elk5dkZEbWRCSm51ZWZMcHhFY3lwUTErdThld2tlL0ljREtKanI2anJmWUFTQjJ6ZHBtTXc2c2JiWFc3MVFjNGszbDBYL3JYRXUvQTJXOTVHTEhZQlA5b2JkN3l0ZDZBb1VHbWJTb2tIVDNpaTJkTW5IMzNyWEVWb2VuMDZOSFJKSjZ0UnEzRTVScFRUOHU2R1NOQW1pN0xYN25DWWxmOTRuRnloQ2F6VDNvdE9wTmUyZ0dTdk5NRlphTURXWkhueUYyOFY0WUpWYkgzM0NEY2NOeVVYSGQvS2kzbjUxcUsvYmYrK3UvYytudi94ZS9zbnYzRTQxbk1iYVZaWk1LaEpxQ09SQnhnSm9iWk1GN1BaNThNeXpJQjh3aFhDbUhtM1hmeHNZVHdTZ3hsUVJsT3N3VDQ0UTRHWG9RRFF5MG5uZENhbUREN3lRWUkzQmZ1RTdxTjRSZ0hGSndFNFAxVyt1bVJXZDJQNUVJd3VYSHUzTm5kRDMvNDJ1Ny8rdWYvZlBkbWUyb1lJa0ltNlFrVndTT0F0M0o1WEMzNDNyNGExMnVUU2MwRHRETEdVemJEVFlEakhYSlBaWW16SnV6QVJxQ0E1NTJFVFRnU3dXSjVIYy9Wb241QUFvZ1orc3ZEeTFSTlVKNEtzQWthc0p4OHM1eTlYc2pNdVJoc0U0dlNjYmNBam1PZDJpNXZDejBnRzR4UXR1RTdLOWVCTnR1SVFucEtMZzEzQUtCeFgrY3dROXZxeXJvYmdONERJUGtLcVNMOGVHUDVzVTZteGt3WndMOWZBZGw2MTk3c0doaXY1WUVQd0lDQzhkY3FTNGM5eXRYejA0blUvbGx0V0Rub1N1SG16U2FzVXhsUDdndUR1Uk8wRjVCdit6RU13SldYZGpsWm1zb09KeXRuVGRCSnMralRSRjRqRm5XNWZGbmtrSTROdUVXL2tnQ2tlU2xDbS82WWFESng2ZEJack02aDM0MGtwSis0N2NyWndFSVplSzE4MzJmNzJOcHlQKzJsUlErZGtnZ2pkT0R6ZDUwMU9mV3ZQSFRDVFBMdCt1aFFJRGlkYzlla0o2L1RWcXhJSDBZT3VHaWl2VW5NbWN6TmhXSGhqM3pGRnN0UEhkWGhSRnNZeUVjZTVvRHdpS3ZKZmVVNFp4SSt3Z2lGdEVEblFpdHZBUzFYa2Zta3NWeE5vRmNtM2lrSElibDVqRnpSbVhGeDl1eTVHWTArOC9RbmtYTTJFM3U3dDVhakUvM1JNY2lUdmdKVzErbWdUZ3I5dEhXcnUzcnFiSlJKVnRHUWNhS3pKSU1mTE1xYWt2NFUvWG5oaFVjZSt0MWYvOTNMdjVNcjQ4bG1hNFdYMlgwc25ja0hXbThlRWEvdGdabGVGRUFjek1JZDF4MU5hNUpyMUNUaWkzalFFMjdLaXdHWUFqaEdPUEwzbmloUS9saU1ZSzBkU2xoWUNLem5BekVFRTZRbFlBVEtzOEJuczlCU3FUMUdGMlNmWmVDNmROd2M3MmJOQ29kS01vZkJOb0hSNDQ4MWxHTGN5QWZaWUhyeUxOdGNDQ25aV0hpTkNocGlzcmdmMkl0clhrQzMvTjBFVkJuYWNybUZOejVacmQ2dE41TklmUUlPRTE4bVJGalFEelhCeVBLVWRuYTFxNk1BOGl4NG93a0NMeDJCZE1qZk1aWlNkTERNRnExTkd2YVJSYnRjRlRkbkh3aGdNYzJjOUo2aGNENUhnV3NyZ0twQ3NTWkZCdFlwdzJ4MDFIVWRwckd5SWJ6ZEFZYy9nYU5ObkNnRUJXUVFVdkNORjRDYjlXdWhEZmVRRHRvU1hqeFZkNTJmOXZDUjZrVFVueXl3ZUpVN0xveG9OQXRwQW1ZMDFRR3craGVvb3lFclZmOHdUcGloS1pxb3h3Qld6MHV6M1YvM3VFSzRwcFk3NnRwMWI3R3VJd3lzeTJyYUFTaFowVVlMM0RpRUZmOW5raWxaODZtZDgwN0JhT2hlcFZhT0w4c3FWbC9mMGNGcHNsUm5LakgvdmM3SENBQmR5U3ZySHhoTGc4Y0E1K3pacytQSGQxOGJMRmZmT3J2dDlWRktkazg5eDFLTVB2SmEvbjNONFg5T0ZnTlcvblI1eVo4OG9RUGpoazc0emE4TDlPeTU0a2x0Tk1LYlRxSXI5aWZYU1pCSDUrbzhBdkgwaWh3SUdlWDN4VXR2YTdHSUMyM2tqV2Q4eWpQSm1jRUZpT1h4anBGMlpaa0QwRGFuN1JaWXpXdG54YjAzYWllUG0yekJDM1hYNmVzc0dRczZEb2FGZ0FIODVLNk05WCs2TE9mUHYvek1OMzczMjkvNW8yLzk4aS91SHM4RmNQYk5OeUlvSzdqZU1rSUJFeS93NUc4MFEyeWk0VWhPL2RrZWs1QUdUQmpNT2dIaUFBcVRFVnZ2U0hFSjJ3YXdENTArTTBNaE04cUhFdzZXTTBIZnYyYzlIWnBoWXdyWHM0U2RjTE1xTVd4V3ZTVndsR2xOUXF6Sk5TQkdzZmpBUHZIME13TWVZalVCQTR1SnBUb3o4dnpidFlHcllTemFCTnY3QzJ2Z3VCNU1ESEdwRUJwZ1lFSkxPd3haRGYyNFV4cElmRERNTTh6a0R3U01RdEFNdlI0S29DamFBRXIzeE8vTzVGdHRrUmZoMVRhQVlhaTc3WWNNaElFSnVxSVpDMklObmRjd1ZyME5tVVdGYk1wUjh1aHRHTGszSVp2U0NGMWpzVXBqU0M5ZlZpOXJWcnNvdVlVemhzMU9BajlBRTcxWWFUVm1RdmE0SDB3V0RtLzI4Z0pBYUVyaFdEektCamdBR21EanM1VjRSZ0ltYUMvTWJvUnRNVms3K2JTNVhsWkh0MXdnTE5peHoyZHZqVVpjUmg2MUhSMHNaRkYzWmM2eTduNjd4dzNoR3JwcFV4VWVROERlS3lhN1RqYXM1N3BKdGFNRkJSZjVrb0kzQ1NrL294cVd0enB6VXloZm5iekV3VTVzQjNvN3kvQXVtanA4ZDZEbnlIbWJNODJPZndFV0VPSkNtZERIdmdQenV3MmQwQUdQQVNPWGhLRy9ldWpRNHVib0JScnkvNk1odWJBTmdHdnE1U0F6VmkrT2xRc1JhNC9POTNwMGRlQWVPYUZqK0FyWWdQSzVjKzlNK2ZTTlc4Tm5WWjI4UngvM1FKLytQSGFtQ2ZCMjN0UGg4UnVQUFBjaVp2TTNGbDhwbTdWTTlzeXRpR0FpazhwWnF3UVB6QTZVNW4zUXhzcGJ1dXAxWFZhNmttRWRoOUduKzBZVzVuL29FakJIVTY2OURSdG05RlViZ2ZHTTlKSlZPc1dTNXovWFhqYjhuNHJqOHk4Ly80My8vRGUvL1UrLytVdC9mbmNpd0R2LzFwdWpYSVJ2ZjRzZCtJdXVYRzJvbHBBWUR0cUUzSDZ3ZHBkYndMdUZHaVdrOWFLRUs0NHVFSTJKbENyT0JyRExHbnNnaS9sazBSTW5zaUNQeEVTOU16OHpZTVk4d21jb0w1K3RkM2ZkU2VBSk1ndHdYV3ZJMHovcDlMQ0VSend5UDU1TjMwY3dXZUZabk1LS1dBTkxHZGRFSCtGYjcwTUxvbnJlNUJmWHcxZy9jWDkxS012Rm9BMmpRQUdUL1hMWHNMVE9xbzZKWU8yanFDa3hZUVlBQkl1MUxJOFpKU1RNNnI0czFydWpyR05OMVJZV3AvYjZMZC8xbHV3RkNzdVNCRURMdGFFTWswaWJ4YUh0emsxSmxjRks1YzRBckVORHZjUGtVQzVaWUt4bHZBUEt3cDBvQ0xwSGhPbUF0LzJSaFc1WnVLQnM5UU1XTEdFK2FmNUd3MVlLK3NNZi9uQUF4VzlLeHhLbXZOTGZ6Sm9kOEVySmxHTjBaSWl0bm1PVlZqZDVhNmNRS2lBbkxHczdwcDdkbjNiMTdPU2hmWjJ1c2Q0QXJUeVdsU2tpWXcyTkJ5U3JpMFZPK3dKYzBVSWlCdXlDaU45Q0l3ZDhvcFBKTmlEdDJxNjlPL0J0a3psNU8xYWR1OTkvOWNBTDlHVkZTKzhZMldua01IeXBMZEtnL3VUVk0xUFBhYThPTi9kSDlYT1FMWFhBUjNuNVpDbXFuL2JoRzdvQzFGdDEwRWFsbnBjV2pYeHU4dU1OM2x1ZFkvYU1ZaGxOMHFBWEFIWG9PQWdCVUorT3RtdWVzL0tUdk5OTnEyUzFUMGZJVmNaU0ZqR2xQV1JRblR5ekxlT1d0N2RvMiszUm5oMUdLeWJPTHpmcXRuODZJSDZ1UFhFWVN1UmxMTzJBWElkRVpoZy8rNnZqa2sweW10R0Z4Mk5VR09XMU1HVnEvekgvODVWUGYvb1hmL3UzdnZOUGZ1bm5mbmIza0swQTh6V2R5SkxZbnlXN21HbzQxSUlNRXpBeGttRHJ2NVByWVlpOU1saG1oTmJRR1pNSTdYcTFsR0gvaXRWMGJldHBLZlBCaHB2ekpnYUFJRWVLbHVCUTNGbmxwd0IzeXRlNUhRUkxQdllUOXB5T2d6S1VhcDRITk1vazBCTjl3SXF0UEVNeEF1aWFNazQrVkJCK1FNUmEwaTVnTVJ0Lzl4eFZXc08xRDNkYW8yaUVna0pRR2xhMk5MNno5TlJ4czFRQnRaNmVwZUNUVzhOaCtEb0tXMTZHb3NvVlZyVzVCVjUrK2VXMWMxNTBzTTBtcFFBZ2hIUHI0R2FqSVoxY0U1b3NFcjQ4NTZhMHd2TE1yUE8xYTl1RUsxVVdOeEhocHN6aWtZMGtBRGVRWmgyejdGanh5a0pMSXhsV0h4ZkdjZ2MwNFFmSW9oMFFOUkduTFp1bEJwRDlSaDlLNjkyTU9rRUh5NUNseGMrb1RzUFQwTXJRMnNtZGxiRE5XZEw1YlloTFdlVkZwdVR0R0tDcmp2aUwvK2p2NU1lbTVNQVovUit1ZzFiUGlhYkpBb3c3Z1V1eUdLaXgzSGNIQU5ieXhTcmJ4Q1JRUmxObG95UGZ0MU1ISXJ6UGV4VW5MTENPZCtTMHVtbUx1cW1qNytybjk2RTZBL1ZDYy9VQm5zNHFNbWxaNk9TSFh1ZzNnU2E1Rm5yb080Q2FQTWxDd0FhUUtaMU9WOTBlYmQ5eWFaUUZJT1d0M3NyMytjd3puNWhQOTRmM2xXVVBhYi9KblIwaThZNk1QcGk4S0Z0ZGdLRHJkZDNEU3pSVlFXMGI2N2xQYWIycDVvMDMzaGllR0drcEh4OEIvTFNwdXVJZnVTUVQrSU9YYTE3aDhPNjE1b1Vjbm1NcEcwMUlweHgxOHJJTWRSMjlCZzhKQmxtaFk3RGxZdy9PWDM3K3lXLzh4Vi84K1gveXpWLzYrZDJMVHorMTIxOHM3SzMyeHVET2FFQlJXRnd6MjRFUXdnSThFMjRFYmlaUCtMb1Nmck95L0Y3ais4cWN1TWM2eVdvNGVKQWxtdGdUcUt6Z2NSUGtMamphQ3J4RDlhUVBCSmlFMWphUysxdkh6N0xkWHpwQ2E1SEtyWW5yVElrcTB4RFV4alh1V1FGSVNPL2N5M3B2NkdWNHVQNFJla3BpNWp6TFl4K2ZZWlpHekdaQjhvdURYYUZWUjh2RFp1SDNzdjZYQlpVYlFkM3lmZThIS0Fsb1FkcVRqOUVEb1h6L2ZWdU10bUdUdllZYmhwK3NIYXp5RTBWdEVNaTBaa0NTd284RldKbFZZRndiRSsyUWdQTVJBb0pqdVd5TzlsWm5xNlZPNTk1NTdQRW5abms1YS9WQ0ZxTTNkMXhxVWMrbC9PUW1WTWQvSHdDYnhMeDNLMkNhSGRtV2tpOVFXTmFlWVdETnE3Nkd4bG1DZlhJWlVBaWpnZG4vSThFR3lMY0RLWnZwMk1OWXpDd1hoRGpZaS9rV2h5L1J6OUQrNGIzOXFrV2EzRWtPZ1BvajFkdTJyTUlPN1pGTldiMm56b2dBc0F4Z1JqLzdxRHhlNk9LcDA2ZG1aSUFEM0ZnMmhYcnFxU2VXUE9GdGViS3crVmU5MjFBbmJSSE12V2cyL3ZHb0pnSUk3Y1FtM3pFcTRhcUl4SURrMFRPUDU4OThxb2lhcHl2dnlhekN4OXNiL003dWJIRzZ0N0tVYlFjd1VRWlorbzgrOWtqM1QxWDNYQnZ4U3VpbmNNY0txT3p5ckQ3T1cxbld5MjFSNTJpZjZlWldEbk9WOUZsM1VOeDQ4bDk5dk1XY2pQb2s5M2Z1QnJZQjg4VGpSbk5naVI1QXArb08vYXo2bXhkTUpKL2llY3VtZG5hdGZOQVBUNzFNUURjNTM3cy9IVzEwdzhQbHlraiswOVZyVnk0Mk9tdVJScHJBelNnRXRhZkcwSmlKem1qRjFhZVRTVVNuVFdSQ1I2dHpOcUloTXlkT0hpKzg5T0cyNG0yUDh0TzlYUGpRc1dTdnVaVW1DbTgxWXI0WnZmZGIrSk1QMlhhdjVtK085S28zYnljSHpqcExBTXU5WlNKZTJLSkpTbXNHTG9janIvL3hqNHF2dmxxa1ZaMXgrbjc4d2VPN04zSjVvT1dSNkhvMWkveEtnRDl4MlRDQStrUUJ1cVREalFTVmJiSE1HdjE4N01INTkzN3JiNzc2bmIvK0c3dW5QL0hFOGtmTnZoakx1ck9kcEY0VGcxbGFoQVBBNmMxOFQrcEdrRWJvQ0Y0bndYTDZmcURFdnJQSVdBaHpKaVFVMzNrNHk5bFFyY1FKb2lYSEF1ZTVPSlkxQXZUMXRIcGhTa05JSFIrV3NUZGM3SEpWNlNDVWUyV25qUGYydHBRaytVdkExYWQ2bFo5ODkra1FmRTlJUjNpelBnYkVxZ3VoRURZNHZzNkFrcVV4KzNLTVJiNkcwUThCcy9JaDRPNnZMUmJYcTM5TXBMSFVsY1g5Y3JYSlNUNTc3Z0hYMWlaQWZOakxpa1FQZWJGVWRZSVV1bXBNeDBLSldRMFUyMThLTE8xMFp0RjNXazZRMWJ0ektlU3l5dVd6MFFzTldDWXNGWFhRMFk2bG1mQ2pQWGRQWDd1LzNzR1g3czJ3OC9TanA4ZHFaNDNoT3hjUWkwam5KajhLeVpweGJWeENkUVI4d05vTk9EZkxTSjFQUFhKNnluYnRiRDUzVnJwSUc1T2NPdnJ4TDBaNy91cWpKdTVZdUFCRk8vdHZoRFkrK09xaGZ1aG5RcFpQbGhKTHo2ODgwUnBaOG5ZaFJMZzNYbjlqZUc4bDZNTnRkclU5aHo3b1lsU2lUamFmK3BCbWxZM29IY3JuTDJkVmpyejJuUFRMZWs5V290c0FTRi9JNE1oOXo4b0xNQ3RqMHcvNURWaVhwM1N1Yi9YWTBveU1wQXZUU1paRzN1aHZrbnZ4SWJCUGJxV1R0ODU0dVlkV3graWFqbGwrNk00NG1UcEVXOWUyY3RBQi8wUjhxSU5GTmZLWmV1OU5hSEtUV0RHTGwwYWRSbzlHZTE2VUlXOTZMYit0RGZ6SmZNM0FuMHhNV0dteVJVY3NEMWVQY1ovMERGNXVkZGtzYkJQNjZHTkxCZm1UUjIzMjNZakJQYjgvdHVEODNIUFBIZjNOdi9CenQvN0dYL3RydTFkZWVXRjNyZUdSRFl4dXBtemlEeEZ3Rm1SRUJPcS9DQjhoOThCNXdESWlFUTduSm1RYkVCQkF2bXEvdDJFZEptNURRYy84U1hEVyt3Sm5hWlNYOUMxQTd6bmxiVUsrbGJHdnpianRDU3d0QzNtczVBR3V2VDBTQW1mbEFPZkpyMitHcllhQVRsRW00aVpkRTBkcFVVUVpwdWhaWlNZQW93VkFCa0FFaS91RUlCbXFiMzYyc2ZBb3B1cFN5dXE4TFJPbXpOTHIyRmpleTErL2dCNVlzMURIbDdaWEg1WWpxMmk3cHFPZ0xHc1ZXcGF2TmxZT2NIYU5WZmZoc2RxSVJoOU9YamEwam5hYjhnQ1ROZXkzZ0VNSHlOSVhZOHJpTXRIcUJRaVc5TnJUdHpqMkxGanRQSmxQbmhKTHU0YTRxNE16YjZEOTNCbnFiWmRBS3pDTmJwUWxKdGtrSXN1ZjMxcGFmdW9LSG1DeGpTeXFhYWNodTQ1NjhYaUJyUGtCQ2s0VXJKQ2JMVWdiTmhzZFNDL1VEbjNIRGNIQ3F3eCthajVPdy8zRFBXOXBQcGVSRldlZmJJSEZnN1VGdUdpSGRtNnlOQk9NdGNFa3B3UE5ySWljU0pmS1Z3ODBSeU1WQW5ZWnAxMUwvdU5ISWhhZnMrN3FJQ1J4ald6Ukk3UWJZUFJNeDNhTm5Ldi9kazNiSFdRV2Y3aVNQdUJkOHp3NmJVRDFnUjZVRHNocEE5bVJyNUhIakhEUlJVZGFIazc4Y1YzNG4vUmJ1ZXBtSmQrVnl5YTZlL1ZidlBTbUl1Q2I5azVkMU1sRXN1Zk00M0F0S05jZU5PcTUxZHRrSjNjRW1abHJOVTMrbnJQWkY1bFNCL1ZVSjNXZzgxUHY1QVZQZlgvdi9IdVR6cHlLZE5xOCtFWHVWNXkyZkQrVzRQemw1NS81eHEvL3lxLzh1Ny96TzkrWlNaUDNtdFc5ZUtHOUtmS25HWVlDcHZVK3ZKamRzSS9rSVlad00wUy9uYVhDZ2tGSWdyUUFFQXZwM1JJMjM3ZU5la3dvTEo5aXdwb1FVMGpuVEFJbXhBUi9RdWRpVkp3azV5dmZlVzVaMGNENVE0QmRuUUVsV0FkaFc5ZEdLVkk2UW4ydzF6ZUoxS0FrL3JGK0tQYmNxOTZlQjNhVFRZcGxhQ3ZlbVkvV2psNDJkVElVQnM2RWlrVkJ3TGd5dEpsUGNmeVNYZlBKaXBvaFdhQkg2TVF2QXh4THY5VURsQUlTZ08rRm0yYkh1UXE0RzdnRGxJdSszclNOL25VNzArWUpuWXIrSm9wdWo4OTBqUmhZcTJpQ0Q2emw0VTNwcGlPUVR6UlluY2htWFgzb2swUURsaXErcWhQTFdlUURjSjVGUVNtaEZZYnVjMGM1ZkdjVjJjc0VQVTYzWVJRd1ppR0xrSmhSQVdWTm1VWnVvaGRBVndmMG9XREFrNHhRNmhNdDM1NVZuTWtkSUJKZUNEQUJqUFljYlU3QktBcm9HVkhnSHhvRCtlbkloOGF0WEtzTzZxd2pBTElpRFd6VS9vTlhYNTJJR0w1VmswNjJqUDMrOTc2LysrUGVwOGNhbEpkNm9FV1ZXclRvZVljNld1eUJCMFpXUU5tb2dZd1l6cXNMUHpBYXo5THFyRXgxSGhrZG1ScEIvMEJtNWVkMGYrT1pNcmZ2ZURqUDdwV3REbUo2dDJmNHlkMUhINGYwMDlsVnZ2cDNhM2hpcDBIZnlhcEpPQ0FLNExqamRKajJhWkVQWHBKaDk0eFFEdVdDZEIwSWIrL201S1prVll0amZ1UDF0NUxibGx5WDMvUFBQN2Y3MHBlK05OWTArVlllZnBEbnRZcndnYXpsVTlNNVczUnk5bXdiSENYVFR6eitaTHpTT2Q2WXhTZ1AxcmxiM3EzVDQ3Wkx4ZFBKT3Byd1JTY1IxYWR0bzFmVm5Yd3pmb0M5NDJNSHpsLzdpZWUvODl2ZitmWS8rclZ2ZlN1L1lVTVV3NHlHSjBjaTBPMHNRenZHQVFhci9ZQ3c0UU5nak5JSmZyT21lejB6UVNRNENPVmNBUEdoZ0kyZzViTnpqeEJ0UW1iNE9JTFZzOTJJeENscXduVTBwbU9nQlJ3ejFNMkhlU2poOTl3UzNHMVl1TXAwUFoyWis1dlZ6SElka000bmhhR1Vod0FTMUtuSDFIZDlWNzl5SHVXYlNSSXVqTUREOE01K0lGNWJCWUR1dDBKWnpJWm93SG5xdEdjbDYvR1ZCMmdBbldYUHJPZHQrVG1CVXdlZ3kvSUFWSURwVWdCOW9maFJWb3FJRGtCazRwSUZvaFBnQzlSNVRJK212aW1vVGdiWUhVOFpndVJSS0czQkQzVWl3UGlGUHNyU2JrcUpqejRwcGZSenZicEt6eklaUDM0czBYbFNXRmF2ZXRxdy9aSFRqd3d3NGYvc3NSdXRXSjhzS0tNRG5UZTZXUjV1MUVHNVhUdFlQcW9QUEdZaXN1OTRQaFpqOURoYVZJMTVCTllxRjR2T3pENGd3Tm1jQnF0VUhkU0pzZ3FkRzhXTlR4Y0RlZnpSRmp6VytlTkJQNmVUMEs1SDhuUC84aS8vOHU2VlQzMXE5OTAvK3FQZHYvN1gveW9lM1o1bCs2eDlnREtkYlBXYk1FRnltbERKRTUyQUx0N3A4RWQrcHY1TGZtYmtVbm9kdjBJWks5U0U1YXpSZnFzRFB1Z0FQTytRdDhOMTM2VngrdTZhRXg4SFBHdVQ2K3RjejJpajlBd0dkWlVXdnl4dXdsODBLb3ZKeDJyU21XRHN2bEdmNTB3TStwUy96MFc3Um1GN09zSnRRYzdsK1dEaHFNRGRlU0tmc0hxY3pWM3g2cXMvbU1nY1Rkb21nYmM2QVhOMVVpNWFxNmRSakk3Zk5lRjFaSkhNUHl4S2FpWTZsejRaK1NoREc2Y2o3emwwSXdNK1BhZVRJdjlvK3JFQzUxLzkrYS8vMDIvLytsLzVlMy8rWjM4bTVlN0ZrZWYrZUFETzYyd0ExYnh6ekNUWW5uS2I3YjhsQ2lCdUQ4aHRRcFh5c0NpSUdhSnR3dVNUY0xubWswV0kwUDNwZVQyK3B3aU8rejAzQWlrZU5qOTBUS080WG1nS2dnZ0VSZDJFazhRdjRTMkR5YU55S2tNKzg2TEp5cEQvNUIxSXE4T2g0bGszWUp3SlFlazlQTW9UZUhDNytGbTlnZkhFRXZjSnJPbWNQWWMzMEpPZkNSVytUTUk3UXRUa2lKbDF1WHJsRmdHdG9WTjM4YUVtQVZrdjZNQ2xBYmg4RHVXcUE3QWV5NzI4Si93cEdoQm9RQzJxd1ZDVWtMTGkxMWFyYXdHSkRYZlFZbnRUeGFMUkdza3NIcXlRTFdrb0lRVnhxcC9UTmMrZ2w5OGlOZEJhRERocmpadURkWHk4dlNkZWVPR0ZlZU9NMlhRS05wWjRpZ0VJOEsrTTR0OENBWjJCNWZWQVU5dFBvRUhYS0N4WGc4bWhSeDk5YkJRTEcrekh6R0ozQUdSQXo3MkNLQk9LRmc5bWNWTHpCOENhWmM2WGJhTEpIdHI5bWs1a1RVcjNXSFRlMm1FVG83ZmVlWHYzWmlHaEYzTnBzTXlOWUlUK0dYRndkNmorMEpHY0JuUURvdDNiNUhuMnA0NDMya21PYkdZMHcvcmFCcHpWWjhsT3FOeC9ja1Z1cGtQdEdhT29EZncyUFVGM1pjN3Z2aXRyMHh2WDNjZVR1UzZQNkx6eENwM28wMWEvalBYaEpkRER1N2tlN3h5ZTA1SHFHUEZzM0RCZE55RXRQK1ZycjdMSXhucGRtVGZpNk9qV2FOaEVJUENWQm1qTHB5SjdmcFh4K3V1dkRXK0JKaDQ3ZlNkZlB0RjBXZVpIaDJmanA2NTh4Z2Rac0ZXQzBRbTZPcjFRMldTekJUSG95dmZzQU03YVFhNW1sTGZYcG84Rk9IL3hsYWUvK3UxZis5WFgvOFp2L05Wbi84d1h2N0E3R3RFdTU0YzdjQytIZnRJMGUwM0VoR1JqaU1VZmFpaHQ4Zy9qaGhralNJRlAxekZydUhTZk1HMEtqK0VmbkpWRDRFanNnSHNDVVpaN3dqYXlQS0ROWXVUV0FLd3NLYjhKSE12WnNaNWRncnVWUTdoQXZVL0FuN2ozdkU1bStmRjhIOHRIdXFyd2dSSldGOC9NV2FTSG9TclFuSTJQK3Q2RkJNQUVreUcrU0ljVnBnU1VXWXFFaEk5YW5SNXNKejBXN3FZa2Vyb1I0UEpuZVNaaFhWcnVDY1BGQWRrK2dkOG81SjZTY0EyY1BuTm1yR1p4NEE3MVV6ZUtQcDFqU3NubmJEaTkzRE5aWTNzeDFhUElDVDNhREdqMjNjSGQ0RGZYZ2svSC9jcHZwTEtlTGR3c0VLWGdPaVRSSnNxM0V1enhKeDZMRDRlS1RYMXJVTWZFcWVnV25SWnJqR3hRTEl0MjBFZThOL3BKZHlEQU4xSVNaZ2pnVEpMT1psQjluOURIYUFPUXVTekV6NnJQV09JNjNIaktMWWEzMm1uM1AvSXhvQmo5aEZKZDhVYWRQYm9hS3BzUVpFRURCSHhnaWV2Y1RFTHBSRStkOFpiMEFMeTZMY0M5enkxVW5SeWI1VHpmSzRlY2owbUJseGt4M0FMcWFDUlVKaVBFQTNqa1ZyM0pJSUhReHE2aDR3YTY4a1QvQmJZS0s5MThMSm5jZU9PYTUzUlllTHJ5V0VhUTJ0QXZjcGl0THVuSTR1akFDTHBRd01YREh1OVlveXR0Vmc5eUxiK1IzMEJTWG1SQVdPZm9kZlhEVzNuWTFkRXhBRnVicGNWcjRBMG81M2ZBdWJrc3VUaTRsM1FnWEV0aTVwMTJmdFJSdmZYVzJ6Tks0dkt3VTkwN2RaeklyaTcwblZYczhGMGRqVnFuYnZGaFlVQnRZOXowRVA1KzVNSDVtNy80SC8valgvbUx2L0xmLy9Jdi9zTHVwZWVmM1YwS2xLKzBVZEFEeFRQZnkwcG1PVjRwekFVUXNBejFUQUI1QkNxbThUSE8wRDRsTUpUbGM5c0FZSnU0dzFTblp3aU5FK09BMHdoak1yZ0VqSmd2eThCMTdvNFpqc1ljVmcvbExPR0E4K1FUT0h0T1hwUkJHZnlwbnAzODlzQ1pNRkRjMGFTRWQwQmFYYks0SEp0YkE0TTNZUFg5N3AyOW9YNWdSQmoxMWo2Qm1iME9MdFpKQVdjQWJCVVRpNW13MElFbHFLMTBTMGkyY20xMHBKY25ZZ0RPZHA4alZOV051NGdsVEpGZFk2RVlsYkFFaDNZOXhMZHIwb3ZGNFJyTk42UWUzekc2Nm9RcVBIV2YwN2FrMGprQklyNHN5eVdyZHE4dFM3aVhRQ3NYN2FUM09RdE9La1g5RDZjUUxFcjdhM0J6bU1DeDN3YzZBemNXSi9EMm5IMlQ1Y3ZWSUUvV01kcmhMUXROMUlveXJtV1JXMWlqWTdOc2wwS3pvTGQ2ZnZLWkZ3S0Z1dzF4ejQweXI4NXYwUk9Zb0pseUtqTEFXNkNHOXA0SHVyYnpkRjk5Uld4TXA1ZUN1NCtINnE5c3Y4KzMzN2Y0Y0hIMWZNaUcycFoxTzRaKzFYZU9Da0JqaHhCQjlJODhrMFpGN0FsRE5uV1FKcWNXUFZtU3hrK0FPQU5FdjF4YWUxODRmSGR1aCsvcXZlbkU5a24yMU1WdlpZd0xxTzhEUkhWa0k2UGtoQ3gwR3FWSXU5Vi84cW0rMmt0blZkMDlkRitneXRwZmtUcjRwcDArNVk5djZzU2ZEcHc5dHkvOUFaVHVrMTAwbFErY2NGL0g3TjUyR3UyU2hhMU9Nd2RRbStaYXNtWDBaZTl5dXVQNUExa2VDOHlYc1RSV1RrVHl2TGI2VkhkQXI1NDZDUXZndE0vM2p6UTQvOFl2L05sWC8rN2YrZDJ2L01JM2ZucDNyTFhHNzc3eG80YkhsNHNKZldTQTl0N3RGZ3Nrc0RiWW1UZDRCQ2hpQ3c4SGhIZFRqRlI1ZC83YzJlSkJHeExIVk5iT3ZLUXpwU0I0QkpkU09ERWFrL1NlaU8rVGRRSndBZkNBWnhZRndaM0pEUUxjOHhod3dNb3R3Tk52K3dZYjZzNzFGbUNJZ1RZWlE3UUJtYy8xbmNBbmZGa3Z3ZnlBM2JoUUNIMU1aMkhwUEZicXdmd0ptNk5VK1RENjMzRHhXdTl3eStmTEFydlZwSlNOWHV4V2Q3VjNIVkw4eTAyKzhTZUxSUVpXOXAyMnIzQjlmVzZJWG16WmhKVndzcXZvQVhRVFFHOW5XY1BDbERRUTJFQkRod2V3K2ZFdlhhakRLMTc0U0RSak5kOU02SUdQRHFHTXFrZHYzbTdZemcrNGhzMHBUQUJrR0Uxb3QzQTcxdjRzb1k0dkJOdDFtMENaRk5KQkRTQUVGdVBEN1ZuMHBmQkRzMmgzODBiMExOb0ZuWTYwb0VXNlYxOTdyVGUrZkdKOG1NZU9QcEJTdHQzak8yc0RJUmFocGRqNDU1UDFPZ3NtNHAxMnFndGUyNEZPZE1hbDloNDVFZjNTOXVIL3cwMFk4WW5hb3BJOEhDaS8yVDg1b1BFTVE5UjE3cEFqZFhRWEw3dzdFNlVVazdXdVE3TnFiZVl0eU9MTjhvMFhONHI5OXFZUHJwOTdkYVpWc0Rqd0RJdG8vczQ3N1dHeEp3dXZ2ZmI2ZEQ3SGN0Y0FIdTJWdy9KN3g1dG92OGtxMmZMMm5tNFBLQUVUK1pqb05Bb0NVa0wyZEp5eEtYcVlLR3lSUlR3WFF0b3VXcm13Vm1lbC9lWnFTTy8rNWtQSXE3THVwV3oyZEdhdEExcWJhSEhmaUhZUmtpZzJtdzR4WXZCTm1OK01MT3NnNklrNjBUbXl4ZFdEVG1pb2d3YmVYalBGUnc5RWo5U1JtSHpPUEVuT0NzbnJMVDhtNFl5UVoxL3c3cE1aRVNyaW1hdnUwSHNNbHVTSzBUWTZqRytsZmFDSlBMcHRkR2tQYjY0NG5lT21iMnNKLzRHSmxHSGdjUkdkS0w2WnJKOC85L2JneW9zdnZqeDZEdlRWMS95R3VxNjRmQlB1dGJ2Zjc3VlowcjUwZWl6MnUyRlVhZTJOODVFRjUvL3E3L3oydmIvOXU3L3o4Tk5QZjZLM1lyK1hBSHRqUllLRTJaMTZTYTlab3NEOFBub293T0hUS2phV2lkUFFtTDl1R0o5WUVWQy85WVliV0xpbUovTTU3b2lJSngvSFdIcUVxME5aQkVyWnZwdUU4Z3lGNE5hWVNaa0VrMXNET0xPbUhac2w0eG5ubHFkZTNtL0QyYjdNcHdrWmRSV2VkWmpsSFFES2E2em5sT0pPQzBnSUpZRzRXd0EvaFNETWZsOUt3Q1lhd1FpaDYwODg2UVd3ZHZvU25iRjZkL1ZkbGtzamc2NU5mU3BlbllDSFQyMjhFeTJEc2FFUmZ6NDY5bU5rZHhRaWtuQlRBR0tLaFg0NnY4ay9Qc2wzN2RXdzhoamwzcVBkMERCbE1kcXA2Q2xUZWpIWjZENTFxaDVvb08xakVlRjNoM3NBM2pVclBmMW1xZHVrQ1FqWWs0SS9VR2dXY0dBTmFSTWFLWGRvbTRYdk9iSHA2Z3ZBeHFyYms0OHBvL2JyV0xrQWRFb1d1K0F6WDd4NjRabTNLUU1NeTRFSFVBS2FxVnQ1ejk0TXZXM0FNbDg4OU16N2hWako0N0VXdGJ6WmxxN3ZaZzJ6b29BZVZNSXovRmYrUkpRRUZ2SlZSMzVPZ0tGdGFJSk9vamcyM3N2SDlRVnFLeFR6cWFJN3pBVm85OGpMSnJlbEE0ckxZZytVdTc2NUZZQ1lOamlFRFFJdzlXR05vaGNCMEhiUDZIQ1diQzc5UUdmMDlTa1BZS2RlRHZrdjJWdWhjT29rblZOZW1FQ0dnUGo2clU5YytjdVRPOGVCUHA1VkozWHhqRFo3QmkyVTUvNTJTalBQUjBObE9YeXF0NTBhMFpYT001L1UyVEw5T0RCMU5jS0NFOXVvamk2aG14RzRQTjl1YTE3UEtCK2RoZUg1UGhPSTFjVW9VbGxpM3VtbE91bVVqTDVjLzhpQjgzTnQ5L2w3di9tN3QvN3lONys1ZTd4ZysxSCtMRU1oc2NmcmpkT0lDTktNYnN6WVYwL3ZQa0VkTVBFOW9uRHNtd2dRU0k1WjJFZzRoWHJOU3IzQUhJQzdoL2lHL0ppRmdJaUdZWmlBOFBjTEgrSzZSaEFJeHdCeVRFZDhSUGRwMkRnK2FFSzZKNmp5Y0hobUNkVVNrSDdNN3hIOEJCbFlxYXc2T0plVjYwbjNXRm9yWGxrYjBjQnJzMnlUZUxIMnZsL01zVEF2bG9tZDFQakZIaTMwaHpKcmkrY0oxTmI1eUpYbHRaWEhJbGRQZTQyTXRWcytZK0VGR0RWNHdzdFlBZnRaM2xudTZtY0JqQTVRR0oxOFoybDM1UWk3RXpablFtZnJNTG1UTmgveXJHb2JFSTZIZTdUQnc5a3NLUHFPMmtVYmxnWmE0OU9tZE9pL25YYWhHM3BXbDBkTzlWcW4yblMyV1hUOGxFYWJkVXlzR2E2dks0MG9kQmpBdkVkbXBaeDdRaThCby9ZWjVjdzk1bVRweGtjOGdMQmlub0ZzS2FZanNRRVJaV1R4SzQ4VlBoMU0vSmw0NmF3bGNtaHlkQ2FGb3BmZi9Mb1UzdXkrNTlET0lnbDVpYlhHQyttTzdMbGhoamJSMkRWRGE3THNHZGE2NkJ2dEZRSTJJNi9xeHQxanVFMDNXSXVSTWhCYjc3N3pDWlJueDhQb05YeE1Qb3dVZlFlbzZEYXltcHVEdjN6ODV2alVmV21Nc0tRL2xwd1o4ZWk4K016bEd3bExzOXdqMG03NnMrckJNRmx1ak9uTWFxODAyczNsQkdoMUJxNHRzRjN1QUhMTGtFRXJqWEhmWVNSS3RxZUQ3ZmY5dWlXTmRraTZPb1hWeVd5eUpQOHJZWUQ2aitGVDUwRU9MclJHd3FncU1qWUNYcDNjekVXVUVUbyswR3BhdkFTd1I2TXpkd21yZTZLVm9oRVowR0UvKzhsbnA3NkFXcHUxOS8yMk16M1lhTUJvZHZSeFd2RVIrdlAzZitkdjMvcWJyZmg3cEUxZkxyWUhNd1U5RnZBQjVhUXRtc1djbE1VT2NsNHZ4VGMxUXpKU0VjRUpycGhJc2JoYlR3b1lDRGlHc0dKTWRobEtFUnpndkhwRHoxMGVRZEVMamlXWUFtSHNKaXp5Y0NLc3ZMeENTUjRMbkdOa2pPSEQ5WHV1OTUxZytlN3d6UDFudDBaNENBaGY3bGhqazJaWkI3UGFyTEtVNXlXemxIeDY1WWFycmwzcFRTYWIxYmJ0TTMwaU40TTNwbmc1NWNHR2J5eEhkU0M0UGtmUUs0T2c4MGRIV0hJNGs2ZEdKS05kWFNPd2htZjJHZ0d3ZHdOYU05SDc4U0g2UTBLdEFzN0EzUDRiNkllK3dvM3dnYytWTWdCamVRdzRwOFR1V1RaTkVUK0lyc2pGY0swaDVpZ0x3bFFyNE1LU28vemNEcFIvV1hZVUZWMENVMHBUNmdkek9RREpjMW5PckZiWEFBamVvcjlPQU8vVWx4c0V1S0hCRFBON2JqcWthWC8wS0szbm1EYktFUkpuTWhEdnBnUHNHaisrUEhSQVE0eUlpR1pvT1p2cjFQWmo1a1hLazF2bDRheXVNNmZPdEpmRDZ5T1h6eno5ek1naG56WTVOZW9hUGt4ZFRYSzNOM1gwMllDbGJJZStOdDBaT3BmdVdLOUZReGYwNGVyaDlrRWpIVFdyVHJ0dDZNOUZ3eDJqM1dTVDBLR1A2QS95TVJicmxBN0kxandIMnRqSEF5M29JSDZRTWZUd3ZHdG45eXgvdEJKQ1NXK1VPYkxWOC9MZDlFY2R0Wk9NYitDNnBmTzhVRHFIZHBCdGFlMEQ0a0Izc29lV0szb0orSzg2S0U4Wnl0cDRQZWxMdTdaQ1VON3ljMjkxMi9UWFhNUk1mQWVlajJURTJHMXdGbTgxZ3VNbkpxZndRWjNoaFRKbSs5YTlUbUZON3E2NjBrdHBHSFpvb1F6eVJ2N0ZTbXNyaTl0OHhzUHRpVU1QeFg5OVpJNi85STAvODcvKytsLzUxZDFESnd2NGozQW42NlVBOFF3ck1Db3FIMG9CV0QranBEVWVNQ09DbVdiTVE0eHR2NFIrampJU3FrM0lFVzBjL3dFcEVDSG9GSmFpYmF1REVGayttMkI5eU93UHdSVlJsZWQwRUpZaGVJTGlreUE0Qnp6MjBrekN2VC8zUDdmZjNwMGhnZjBQaXErS3NZRElpcWFHbmltRjN3VEZ4a2I4eVFCRm5RNElwV3ZvL21ETVBwbWxyRnkrUGtKazRwaE9lZTNXREt0YjZxM01tMDJpZWxhOUZEZGczSGMxY0QzaVRnMm5QYTRuMlBONnFKU1NUOUtDaWlqdHdXaGZaOW5YVVF4QVcxMVpRY2VqNWVXRUZhM2x0OUhKYjBJNmdCalB0cmZCVUVSV0lYQ2xZRURLTTRSWm5UeUhINzZqcWNOOWRmVGJkL2ZKZ1VNWnJ0V2lvWmM2OFlOUzFrdTlxZ3lkZzRCUlRNL0puKy8wUU8rRnZHYW53bWptRlVqOHpYZHUxWTd5NG9hOVh0cnJqVlJPbkZpQTRPVU1kN3JtV1M0aGRUbFEyN1huUWdyNXpOTlBSWnNWRmJBc3RFQ2c1ZCthQU1qNHh0OXNEd2ZXOE5ZK08vbVJSYXNhTCt4RkcwaTdEYisxeitRbWQ4bjVkOStmZGlwWEc1ME83UjlhVnplOGNTQ0hkMEFLMitRdU0vK3dUMXVqb2JRQVNEN3pkcFFTbzkrZG1NK1hyRzVySjdmbFFrTzlLRC9wOFdzRFJjL0lRNTYrajE1R0Y5L3RiZUVlZzhGOWRhVm5HNjkwSG1RODhkcEx2eWIrbE8xNWRGSE9MSWJhSzRQYmFaTU5uYVg3MHNwSFdVNDRjYVA1a1VPSFZwd3luWlptNnRDRTZvMzJaYmwwNmEycHh4TzVtejc1M0F1SnpacFV2OWlMTEp6MmxaYVgrUkJsUFB5UWx5aWYyWDMvMzM1M05senl4aHlyT0MrSys0L3ZYREIvK0lkL3VIdXNkM28rOWRSVFdlTnJ2M0E4UEY5bmJPOE9FOHk2dkkvRThmV2YvT3p2L2RkLy8rLytseXptdEQ1RnFlZHA4bVJVc2UvZThqRWJ1cVJ3NHBsdlpFbGFFY2h5WHZITkFYVWdiTW4yeFlZbTl0KzltbkRyMFZpY3JCbEFiT2c5UFdBS0lMcGdFNkRObjdjeGV4UDBqWGdZNnJ6LzRITWVRTTRhbVUyUkdqSXU5MFpnRURNWHpOMy94SWZmUjREekg2OGhJSXVMWUxOc3RYZ0p0emVCbU9oVFI4RGtsdWU0UHd5Zmo3WDgxT3k5clR3cHM3MmRWN3oxMmpUZDBGbzdQT041OWRjK240U1VGVElXbzJ2QWQ4Q21qaStGbUJqWWxwYzdqRHhzMU1OMVpKVWxFSzY2YzExZThqSFVKYUMrQzEzemZZdEpaV2tyQjFBUEVPelZRYWdoMXdxaHR3Y3ZLMllzdC9LWUNicXVVeTdBWVJKdkFRZ2FVYkNwMnRDZis4V29aVVpFS1NiKzhqbXJtM1k3M2NOL25ZQU94N1dsdkF2SXRHazZJa1B6c2thZjR4a0gycU13b3hnZDBTemZMcTFoTERweGN4d0VBdkVFNzFpamxScWpGbEJSNXN0Tk9GblljaUpYQXdPQXhYK2xhOWVUYzR0NHVLbjJtak9mZVBwSUk0RzYwR1ZCZGgvZEhKdnM0dW4xYTRBTEdMUFMxc2lDN0JneGNGOVlaY2ppWDI2UEQ2M2FiWkxPaEJWd2RKSkE5UEM4Zzl6WU13UnQxd3Q2Szc5YmFPOTVMb1ZUYmRiRWhjS2x3WCsrOXBSWS9tdnBaazZodFBMM01Gcmc3OGFUWlpXdVVSd2ZPN2NpUzEvYjBCOE5SMTdpbFlsTG5aWlA5eDNjWURwQ2ZKYjNwck4rTHdPSkhwSDNQV09rNXp6ci9qeFRmdVRpWXU0R2szWkdGazg4L3ZqdStSZGUzRDMzL0FzVFM3N2NTT2kvTnRaSGExRlA1T2pSTTZjblAzbWlIZm1pcXpvS3YwMHdNd1JOeUJzaE1RTEYxSXZZVU4rUEREai85bS84MWYvek43LzlHN3UzRy9hZGJEaDRNR3VTTldLSjVORVl3dWNFaE0zd2d6ME1CeGdBWlhyMjdtMys1NnY1WGkvbkV6S2pPNU51OFpKL2puQmhJQ0RXaTVuQVFrVEVKUFFZdllHMWRMNWpvalNZdlowYk03b3gxd2djcFoySng1N0RaR251QjJlLy84TmorY1NtWXBVanlmWkN5RW1lNGdFSDVkdEh3ekFLR0Fpb3gvUlpLSkxDenliLzFjRiswaFNUTDV6ZisvRGU2NDM0dEhWYzQxc3o5SzRjM3dIbUxHbnZIZ0h1d2dnaGExQjB5d0JNaVcvWEFWS28yeWtPb01ZWGJxWTdDZG53SlY3SXkrYjdsRW1kTFllRzRKNmJjcm8rKzJUSEx6UUZhUE9hb3ZJanRHaHRDRDEwci95NUZqK1dZc1BIcGFobzRaeDh1K1pUZUJOYmp1RHo4N3V2SG5qcSt5aHFRSVMvMHMrKzFIdnVMSFg3Z00rMWxiS2E4QVJXbE5CSUJFMVR2M0hEaVBDeDFTajN4cHJCdHhJeXVnWHFvaGJ3R1gxMFVLeGJvWERLQUY2UmZGd3VtOEZ3dVZHUXV1a1UxanpDNmlpMGxiK1RkUXVrdE9WUHlxYnJ4NDQzZks3akVuV2lrN1BneGREY29weHpsZWNsRE10TmtVdWlhenJCTFo1NkRBRzlUY2ZRcUhZdEdhMHllOWRxY3JxMXdKdThjRVBwZ1BCSnZkL3JyZkdzWDgvUkovTWIrS2UrZExMTGsvZlFwR2ZWZVZteWl3L0ExajNsMHdHOHFUbHpiYlY3ZGJEb29hclNvYTNmZU1hYS8vRDVKU1BxNVZtbjh2MldacE1mZFp0eUtzdkNLL2RubTRJNkUyNDhpNE4rOElQdjcxNTk5ZFZHZ0NkYXhQVGk3c1dYWHFoajRHZStNQ01kZFgzNTVaZXk1bk9QSldQMEVkVjAxazd6QjU5NjVaVnhZUUJsTDg3UTFqZmZmR3M2WDNyTHV2OUlnUE12L2V6WC82ZGYvN1cvOHBNUHR2bjFrNCtkRGxqZkd6K2ZkOUloTFArYkliWGhodTB1Y1hBMjNZNUppRTZCTVF2aG5VSzY5R3lYR2s1Z2toZXE4Z1BaKzhBRWlxR0cwRElUV1JoRmtCQ1IwaUFpcGZaZDNnNTVFRHJuRXFRbFFFVnhEWFB2OXptYkVDUzhjL1NwL2s3SEppVHlkUjRLY0ZkK0xNczExTExvWXl2RGdnZVRDL1pvbUdlcnE0UEZRUmwwQnVxclhyWTFkUUFJQXVjRXF2TGE2REswNkJuSENHamdpbTdvNTJsbGpQVzhDWERkaTZiTXhGS0FOUlowU3M3Zjc1aU5rS0tkbFhlZVhTRkRhdzljMTNRSWZJVlRmbVZzRnZtb1l1a3BCK3NDOEVqRDc2cmVuc1cvU2Q5MUIzcEpveHh0MmtBYjc3eUNpRklmNzZXNWZKZER2OUt0RGRaWnNTbDJkSm41aWVveEwwcW8wMTlBc255QkxNR1pnSndPU3BsMXlwUXZ5MUNlQUhyNUhndFpETEJZbGRzZXdtaUlua0IyOFZXTWI3N25RcjRZM2tZdzJ1UE43d0JNT1VZbXRwZjFXMXZlYTZSQlliWEhiM1RnajhjemVRTEJUY1o5K3IyL0VFNkdCZGttRTlvdDdYYStrOTlacDdBMmtJL0gwOUhydkxoNEdEOWU1bXM1ZnY3ZTZLY05hMUp4dVVacytEUVRwVFVHM1hVRWVPVmF4Y3dpRDZEdnhSQXZ2ZlRTdUdua29hMCs4Vi85bld1MDQvbEZLNWFqdkRaNlRhUVR2dTdKaSt2QVVwdmtkYXZ0VXhrUU9rZHlvUDBpYWJRZkg5SE05VTMyUFc5TmdYcFBYdDNmWkdhVG9jUHhrT0dpZmpyaFk1Mmp1ejFMdjZ6NDA4RUtUMlVNZWNHeWtZLzZ2QnA0TXhTZmYvNzU2WEN0SHNRWDlKU2ZUcGtSd1BMV0pyamorN2syNzdlbzVTTUR6di9Kei8vc1AvcTFYLzJWd2xpdVpCMDNFNTIvVDZENFBiNmVQYkM3bnQvb2VuNnJPNjFjc0UveVRidTU3ZXFCaHduZTg5ZHN2SmUyTmp5NWFLK0gzclo5SSt2dThOSHlBczROTFo1NjhxbjJKWGkwTWhyaVhtemxZQ0REbXJEUEFlWFd3OW1yRnpFSjNjM2lxT3ZMS3lkQVNMQU40UXdYSFY1N3Y2eUpnRHNyQ2FDUFN5T2YycHJoRGlUOTZ6bW5BcmdPblB5WC9GSjZUbjdmNWZ2TkNreTRDQXROb2NCakxld0JJYVUxbWRDak0rbklVcjhYdU52RCtVRGw4dzA2dVJkWTdzQm1BV1EwVTNhWnpRcXdxb0p5SzBvaEFFMEJLTkYwZnRxYUsrTldmdWxyeFpQdmE5aDlPOERnWTdadng2ekNLcTJKRkVLOFA1K2xseGlZOEJNZnpaZE1DUzE5dmhXLzd2Sng5azk4c1hoVmt5dzZSS3V0K01SdnB2emlSa2VKdEt3NldnRm1JbkhWYVZuWm9oZFluMXhTTEV4S0NMaHZSRXVMVGxoakxNYUpneTJ0cVJaVy9lM2FyWU0rbnp5Y09YMG1WNFRvaUt3bHdCMk5ZdUFBTUYvM3VMeFNybEZtSUlzTGZYa0xPQUFBUUFCSlJFRlVsZG5YNFltWWJidm8zV2puUTdRN2ZhWk5udzQxMlJwdkFZdFplM01DM2hvTzBPMDc4c1JUWnlvNzY3bTMyVlRVdkEzOXpWWXFBb0xIQ25NN21jTHIrSUM5eUNMZ01WRUwwUStkRHJVM3RRTzRiTUFNaUJ6VGVkMXJpSjhjWFkrMjRya1pDY2ZhNzhOY0NoZVh1TjlUdGZzUmI2Y094RTcxeVpxdVlic0w1OCtsVHhrWHlhdU9oM3pQUHVISlVrSzZ1MFdma2dNRU1PclVrWEFqMEpVSU4rRHoyT05QNzE1ODhhWEE2YkdNbVV1emdnNlB1VzFZNlBQMjhZeU5MSWJSS1hKb1JJZkcyc1BDcDc5b3ZRRW0yYlN5a2d5US85R0JLbUdmRjhBckxWZUxFOERyT01keUxVOTVlRFVhZWNHM2VXbHpiZVdTMEJtaEk1cG9MMTJPSlhNcXd6czY5YTV3d290dDMzdnZRdHZpN3ArMzFudXhnYjFYeGxCcU93TnpJVUFiZHBBL200dVJBZnBMRDJ3Vit2cVBYcHNPK1BGb3c3bzIwZ0xhUm92blcwUm4vL2VQaE9YOG4vNkZYLzRIUC8xbnY5cE9aMVZhQTRXYkpNRDhkN080SktHOUZkTlp5L3RpL0xncVVzaStEQWdRVEM4TEpSQlhMNGx4TnJuVWpIbzl1azNMOVhabVdZZTVNWUl5QThHcmhhYnBCUkdOOWVDKzM1am8ycjJzOUh0MzFqRFZmVU5FOXpBUFFOeUpxNTZ4d2J0TmNzYTlFSlBHZ2dGS0NUeUIyUTdQM244UXhEOTVTTCtkL0t6SzhadzhsZVdlT2xMa0NRdEVtOERGNlo1NlN6dDVWSWNSMUs0bm81M1ZPZm9OQUVaTDF0c0grZStWQ3l6R09pby9sdmUwTXlYeXlhb2VwUUtRcGJPZkIvY0RueVJRUnZjRkVNZW1QdEk0MUZmOVBMczl6M0t3NEVIWHAzM1NBTW1sdE11NjBzYXQ3VDdkMityckhzdDd5OWZPYmpySVdValNKQ2thWEt0ejRmSXcvSDIweVI0S3BGeSt6ZkZKYjhBVFhWM245MVFPbHdKYWIyVk5XN3ZPM3drTXRCVVlpNG5Wc1J3dFBRUEE5NHROT0pxd0ZuSUZJZVNIbnVxampUcUJMYnpSZmhCQVZqbEFselhvdTdUcVEwNDNNTjU0c3ZGNnlVQ2pEL1dlRG1ydHc0MEd5MHJkVGRTTzRUaHdyQnBoVC9KZHBjWUFDTlRSVTBmakJGQ2lVZ0FkMXdXNXVaRzhhQVE1QnFyeThnbzE0RS9Pbm4zK3BlR3ZDY3IxQnV1elE5dXRQZHc5NU5DQkRyNXJHOXI2ZERxMHhiR2w5VnQ2bi9lbmsyYjByYklCTTFyTVFYYTNlK1h0VUFjYjRzdkhkKzFRWjdTUnIyZVZKejgwYzZBSHVydUg3aSs5OE53ODc3bEhIMTN2bFR4Nzl0ek05NWlrOWJJR3V6TmVhdVFHSDA0MzByY1FSVjNvQlNPSm5Gb0hzRFowNms2ZFBCMGtVei8yMFJwZmZPbjVYK1JtNEUrZDJlLzRCUVNDb2QyK0FIYVltaFVFbFBlWnl2VlpMNGdBTjIvYVRjemVCekdBanlGTFl2K0Jacm9mZnJRZHZScVNQcmcyeXJZWWdlQWJkbEs4a3c4QzJvTzdOOCtacGNXV21GNjV0NFhtTlFtSk1SakdFclRMSE9ZU1RPQXNPZ0xSS1RvTG0rQWorQ1owOGwxdmdGaWdJMjlDc0ozYXM1MkcydXYrU2tNcHByMmxKMHdtTXpZQlZDZW4rNFJvQkxqaU55RlQ3a3d5N0FtbmZBbmV2aUlRUkNsb3d3cWRXL1M5M1FJZWZmZVVSMEVyajJVTUJBaVVwYWtYQTQ1REtiR3lWbDVMNkJmdDBXWkZXUUNZdW84UmJDTWQ5Wk9QWjlTUHdLTy8wM2YzbGJGL2YvdDYxQjdIcllEQU13QWFyVVp4OStoR3lhVjNUenY4bGpkK3FCdVFIdm8wekxXdnQzdEdFN3NyZTNTcURNK2JHR1Axek9aQnBiR0FCOTI0dlh6cS9PZlp3SWp0dFFIaTBEWUYweFpoZWdjZk9EeEQxR3RYTDR4TUhUeDBiN2tXanJjeFVaTkx0MjYzWU9wSWJkaXhaSS9NTytmTWN6ejY2T25jREdlSHIxWjFpbnlwK3RYTlc1MmZhaGIvM2U2L04yM1Vya085NWtzZEFJRmhNYnJwV1BDWkpYenI3bHBkVjNXelV3TCtmTmhXNGFrdnV2N2g5MTViYldoU0dUMjkrVWJIWU1oOUxQaysva0N5bTJ6b2xCeWlFdWFsc2RIbWVHVStXUmxjSWxlS1VCbjVyaTNIQzk5VFg2TzBQL2lEUDVpNnVvZitpNzRMM05RZkg5VmpPNGVubGVNNk9zTm1OTlZHZkYwZEM3NHVQenVlM2E4MzhuUXMzcmZ4V1RRY3VZZ3V3TkdtVGhTWjYwTWVYdU8xSFFjT0xMZUd1c3ZIY3o3UmNqdGRJNTkreSsrNzMvMTNNN0g5MkdObmRsLzcydGVpM1hKSFhMcGtGSEV0di9QTEkwc2lxT2dBR2h4dWRJVTNyM3o2VTd0M0c4VXZzTGRRcGM2dHQ2Q2d3ZWhEOHZSakQ4N05TditNWFp3TTdTakVZWXlKWWRleUJsalJHRHZNRXdNYmFHK3VBWjgzcnZORkxSZkR6UUQ2M3I2V1pUNThldmRBRXlNSWRPTEI1Y05FdU0zWGRiMWhxZUVPSWduUHNmK3gvUG1VbklZdzZxRURFQm9EZ083V1NRQm4wUVVuK1grek1DemR6akFMbUV0TjBNcUxRQWhWR3Q5amRWOFFDMmJYSVYrL1ppaEhhUGszT3JUUnNZSFM5cG44NXhwWW5jTnlJK2lFdXBod3p6QXFTQ1RVTEJ0YkZ4SnVBcWM5STlnRG1jcmNyQlJLdS95MkZhNG10SHJLWjhWN1poYjRTRk83YmdWa1NkWGttU05nQ2JWbHB3MHhwNDRKWXNuMndHUlpiaFNuV2sxNzBCaWc4TFhoZ2Z3ZDJ1dDVpMGdjRnM3d0tYcnRsTHJPaUtOOExObVYxblBDd0p4K3J5RnVpcEF5Y3BGbzczUzg2cXE1S2FpeXBmV3BUcUpIK0daOVI3TlIwT3FtdzZCVXJqc21ycnZ5UENza1V6clJFL2oyL3IzQ3BPTHhBeWZXaGpzSEQ2MlZjSmV2WE1peUxKSWljSHY0a1pOakhiL2JFdDhISDJsSW01TExRLzYrYnpHdzVqUWVlZkNSQVV0V0ZnQTJ3dVBlY005dnUvNVpWWWhUWTIzM20rRnlMOUR4bWZXU1hkQkVZSjJTY0ZFaFd4YTJIQ3ZtM091WFRoUmllYWcyWHM5RmdVWlhJLytCTnFZL2NMaG40K0hKZG5aazBkM0ZCN1RTU1NjUEp3Sng0V0hvTkozZXdkVXhYcTR1RjBYVnhDZDBvR05HQW1qb3dOTWxqOHRLdmRIelhSeGE0cXpUcU5jcVg4ZjlMd0Qybk5NaG53V3VqVFpHZVVoVVovV0xsQ0Y2ZGU2NlRtYnI2SUg4emVya3VCV3QwZnR3ZWdGb2wxNFc3MjNFVkRvSFhlRUNVUmFEejBqaFdLNk94dVl6VDNJbE40M04rS1c3WEp2L3hiLzRGOE1UcnliNzlLYy9QWHkwcUVtZTNoS09oMlQ4dlZ4QkQwZHJvWExxcCt4ckJ6Sk1vdkh0T20yaGdLZkY1T2NTK2JFSDU1enFGelkvN0VZa0VWeFhhdlQrQkl1U2JMMHJQK042OTk4YXlvY2h3NnprTWdXUDRBMjVIczdYWnZOdFJQZjJYc3JKMXlXa2FNQWljQ0dvN2g4VnlqWENhNDhGTVpTR1BYc2JyNVRHaEJmclJrK0hRU2NmckFjTXBQa01NNThUQXRhQm1mbTlWVXA3azNsa0wrZ2RZU1FJMmpCQzBQZnQwM1VIeFhYZm9YNGJtUGlFT080VFdreVdicnRQYUNpa3RteUgrOUp2ZWM0a1kxYTlNbzBlOXUwSHhOVTdxemtSSHJwS0M1aXJXZW5ZdjkyWk9pMFFYN3F4ZUdDaWxSRGFpMWs5YmxlZXVubEJybno0eWRWQm5Wam1kMjd0RytVMTJVcUJQVU5aME5qM200SGdwcFFVenpVVG1nNzVUV1g2enByVDFxV2NwUk8yZHJmaGFYekJHeDNvZkthMG02ek14R3psSEl2dmh4cmVYcmhjOUU2ZGpZNzFjSmJ5eERXbmxEWnZ1bkdrUlNEeDA4Wk02bjY5TmdKU2lxOGVVK2ZqZ1hvR2hCaFZFMzJqM0lIYmdTSml0SUgxUkJsUDU5ZlZlV2l6V0hVMFBkNjhnRTd4Ym9oeXVyMmxBWnIwKytzZ1RUd0JRT1VBN2llZmZQSUQrdUNiVTE3cThIaGhYbWlubzhFSDF3Q2QwY3E5dG45MUdJRWNqblRvZVBSSUxvZ01GZW1tUHNJeXErczE3U3BmNERCZzJYZVJTeGR6czF3TnlLOWViYlZuZEQwWmlEelVITXdEZG1WTDk0Qy9WYXZ2OTZuOGE3ZlhaUE1BZUcwZ28yamhXZW5oNkhab0I5bllaTlR2TzBZbzhYeVRiWjJ3K3c3WHRSVmRuTkpMNTlNaDdZa21nSDNxM0IzU2FjZFdqcnJnby9xbExzTmI4ZGJ1eTF0ZVRuV1Y5OVlPTWdCb3pST2RPRjQ0YXZKRC83VkxPbkl4ejhabmNqRHgvNVh0KzdIMmplN20wTkk3RFowTUhmUy9kUEhLOEpqeGVOcTZoS24xai9HZm93Y092dnUxcjN6NTl6NzdFNS9hblQvNzl1NVFEYk41RVhDK25VS2JBREk1Z21DR2JMT1hSSitHdUxzN0FDdHdLNzJKbE5ObmVyOWFNNm9tNUx4Z2xKdUNqNG56M3dTajRkOFNIRW9UVWJJQVRES1ZTVXhvUjdZaGRNS2I0TGx1N3doQ01yd3Z6WkZtZDQrYjVRY3dXWFYzQXo0VzdEclhhaWl6M1pzQVdmeXhmY2NDdjVYbFVMeS9heStGdm5iWnBJd2htVHJQakhvWCtmcG0waU1obXhDOXlwd3d1YXdsaW1LaVkwMTJyS3g5bDYvblRXaXAveW9OOEpyYTQzTUc2dEd5emt0OVJ0RDJnSG1VS3ordHliT3hwTkMzMDhTZFVDSkx4dmtzWGJzV3dMZ212dlY0Vm9aNjMydzRZU3RPK1Z1d3dRcGtYVkFpd3I4cElvWFFhUXJWWXYwNnRHdmFIV2plS0wyM3BmT0x6MUp3azBkZGQvTFpvZHYxK0x0RjNIalo3Z2FvL042c09pNHBDdk5vdzFJV3FaR1I0YVd5SFN4ajdhM3BVV1YxUURwcmRKYlg4SzkwTTFvcERjcnk4VnA4STJ5UHBUejhtbnBINS9nN1FGRDVKb2U5aWNPaERzcEJBL2tDWjk4dnZIZHA3aHVWb1lNMGdCUjRVT1o3QVltaHV0M2wxT3U1bGdTTC9IZy9INjk2TUVLbVZsWE1SQk1PSzlHTFpYVUVSM05CSEttZStLdk5mT0x5dHZXQjBlbmQyVGlzZU81NFIvYmxSV1pNdHRtdlJvZ2VmL2E4NWFPN0R3YlNEd2NxaDVOOUhkVXRvNi95SGxDc1BmSjJiTC9iZjJoNHZDNlRlR2JBT28yT1ZqZU1iRXRQUE85WmgydmFoUGF1a1kzTkNNS2ZFb3lzd1FGOG9vUExYNzcwejdYMVF0MlZGOW5FbTlHTDhrVi9iZGpxcjB5eTZYUU4zdUR0MUNONU01RU1SOGk5emFpc3dEUzNnR2RXTXRyRTM2dkVJdUR3ME1qSE95M2xKMnBvbHV4blJKZ1lGK1ZoaFBaakQ4N3ZYcnIwN3RjKzk5bC84SmxQdmJ5N1pCWVRFT1RQTVZseXJWM0J2UFhXVXV4NTNWSkVzSnZUVFJFR0VXWmZQYmZHbnlnRTcyRXowZysyb2pEd0doRFBjcU4wTmk4SDFwN2ptTDlTRklMSklLN2ltMWZxNFNsanpDQ2NMR2VXaEdzem1kWHp5V25QWFJrUWlMTXpuT0s2T0ZxdjNmWjNVejQvdENnSnpKd2VIemlPTHhyTDQ5ZVN6bUcwM3hoKy8rY29UTmM4dThCMFBVUFV0WS9DNnVtM3cvTk9RTHg5OTl6MmZmc0VaSVNGY0E5bys2eERFbEttazdyYnAyUHVKM3hMWUwzTHJ0ZFFKV2hIQXhoQ3lvTHdLUnFCa2t0bldHMFduSVdCUDZjYWt0dVkzd3k4dk4yNzJtYjA3dnV0VGtzNWxxdURKYzFuUDV2UUU5VGFSd0dsdTEyZGxTR2VtSElPUHdNV0FEcktpcDZsQTBlVUEvaUpWYVVRRkJkNEMyazZYL1NPTkdmcXRMLzN2ZStOY291c3dYK1RoR3VuUE4vWHNKNkZNd0RSOC9KUkozbnJxTTNLVDN4M3JFTkRFUXd6VHhLSjV6VlA4Wnppc1FBb01WbXd5SVJpVW1nZDFsSnc4eDltOTd0L2RVMkE4bU9qdWJJMy9xUFoyaWdwMTBQZm5lUkFmZENHOWNaRnh3M0JXZ2JNSnFiRnVPYzQ2TGNKdnVRbUJEU2lNWi9CeWw0UktDelI1TC9PMmQ0akQ4MGJQVVJ0QkU0NjBOTHFGQzgwdEJlUk1CT1Q4V2IydmFpZFBvMFM5cGtJcHpNalh6cnh4WStSajY2VmNLNlJNWHgxL0h1eVByWDg5L1ZqazExcGdiTzhIZWh5dnc3NGphNXp2ZlpOL0hORjBQbmhZYytWWkw3N3ZZeTB0UWpHYjNVOGt0NENkRFRoMXNDenFWTDNHUVJvcm56bDRybklwclhZWnkwME9kRElpWnlnMTZWR1p0NGRpTGZhb0JOTzIwWStQUTlmZEdyak5oUEpGSDEvN04wYUNQOW1TMWpGQ1RwRzZQTGhXV0J5cFZuUTZmRWpKSVVOOGRhd04wSU9jd0pjMXBDaElTdmlhZ3J3ZmdxSnFBajBVRnNybXBDNUt6U290QTdDbEhyTmQyQ3hDUkltQUNDL0FZZHk5L1dLZUVQcThWVUZVUGNTdG1BOWk3a3ROK3NNRGg4WCt6cFpkVFd3aUtsT0NqcjFpOVB6ZXlXWnYrcmwybnp1WGZkOU8xM2FCRko3SGRLN3RqM25tbnF5UHJSaHRjblZkUUNzTGYxRWZJZzZLWStEZTJXcnMvdGJYZTdvOEFBVXV0Uk9lWE5WM0dtMFlWSlUvdkowRUxSbE5jbGpnWVJuNWVkRXU4MkZjZWYyVWxabGI0YzBhSXZXZC9icXMyaTFVbndRcjkwOWgyZlZ4ek9iY3FxM1oyeU03ekNzbDI4Tkd2QzYwSmFtbCtvd3hxcXBIT2xYbStxSWV3NXd1OGNsUlZZTTBUMXZWS1NNNlZBQ2IzTEZEK3phamNCWlhVUnMyQTNQYzN5UzhxM2dnR1IxS01LMDd1UlhFRG1rTElBS2VORklQWHpLRDhnZU9IQjE1Tjc3QVkwdzBCbGRwRE1CZVA3dFhDalIweWpBYzYrLy92cmM0ODkwdlBxRDc3YjRxZERPNm40dmw1WFhpM0dWY0tHRUpiczMvL2oxWEZEcjdUZGprYWNMOXVnT0dRS0t3RHczNEZoNDBVUDdoVVF5VG00RU1HVGVJZ3dyVGsrZmZuUm85bllUbG05WHA1TVBQcng3L3ZubmQzY1ByN2RMZTNhVEVYVFZOc2ZsUUFqZk50bEJ2K0ZUOTRaL3liZDdtM3k0NXR3T2ROaE8xOURhODlLZ29kL3VPNVFqbi8xSG1uOUpUOTNuajVkZUdVNTFkQjB0cHR5OU9ZenQzblpmbnVzWno2NlljODlZYnlETitjSVFSYWNjUFdrYjBSTzdwL05EUC8zMDA0VXFQaExkTHV6ZXpvcTJDT3ZNNDQ4VW1sZDRiaGlsMHpqU095M3g3bXFMNDk0ci92eERjMnVhOE9QNTU4U1I0d2NmTy9QRU4xNTU2ZVhkdGNzdC9yaHpQY3Z0YkExc1pyM1pZbnZnWHJ1ZWdBZStobi96T3BqYkRXV3lnZzVGTURHODF3SVQ1dzNoY2ZIM1dOYjBzYU5OK0FVOHR3Tm5yNjQvbUwvRU1JZ0E4Z3ZlNi91TjhpYXcrd0VBSmMxU3VHc28xMUQ5OHRYM2lvY3VpTDhObUxoSUhzaGF0c2Z2QTVYNWlYeURqNTQ2c3p1WWxYVXdoZUN6SkNZc2wzbDdjMHpWSXp2dUY3Qk5FT2RHd2pTL0NWVUNNUUtWNEVudnVrL1gvZE9qcXplTHBwdlR5M01MVEpyYUsrU3dGTkdPVmF0bmJwSXN5ODM3RmUvMWV4OGZjUFM3ZWExSmtkd1JyT1lESnBNU05pNExjWjdacmRPTzYvblhydVJYUEZSZGpDSzBZMXNRUW1pTlFDeEV1Tk1JNGxMMHVoSVFuVXdJdlkzOFdpR053SkVsWjBYbjF0NVo2bDVaUXQwdU5SSmhGUjFzRVlWaFpuOXFSMmYzL1diNWVxUEpIY3BkZXE0dGxnMExwY3IwM1ZhZGE5OFIxdTVNYnZhY2pZRFV3WDYrRnk4MDJycCthZnlTbnFXa0ZQaDB1OWV4a05EUmhDTkxuSFU0WUpIaWpwdWxlMXcxaHZNbWU0V09VVUt2anBwUlJRcjQ4S24xRnBsNVBnQjFBRG9IcTh2dVpDY3lEcmhBaE56TjIwVVNoK3N0YkhqbXFhZkgyallpdTV6RmRUR0RRak5XSjBFMjF5SUdFOGNpS1l3b25MUFVPN3FMWVRhSGNqUCtYN2lZckNhNzVoVFFUWFNObFd0NHJCTnhrQ3VBS2JwRlIyS2toMDQyc2JMWGh4M3NaclFZTFNaMlB4bCtvSGpmb0dsQTV0MUd0SlpWNjNpc0JiQ0tkUmE0dkg4MjkxZXVyaHQ3QzRiaWpSSGFyRWFNWjVZcEc0R09IaVMvWEZGazJDY1pIc3V5WjNSc0NjQllvU3hSL3ZMRjE2UW93cEFoblpNOU1zaWZUbG1razVHTHd6WDZ3VkE1YWtUVEp4Qzl0eSs5M3N0TDdMU1J5MFI2bGQvWVBUMHp6NWFITXB6Szh6eCtKOTdoaVEyNk1zYnF1RXMrOHN2NDBrNGpFZnlVM3VJeG9hVGl2Y1Y2cTlCREQ3UmJZRDVyazdORzRKN1RtZDdzeDhVOEFoOEpjTDUzNVBBL2UrS2hoLzdiVjE1NGJrRGxla3BGU0s1ZkRuQVRzbHNCS0ZjSFJZMHF4anNCUzhQakZIaDhPQWxscEIxQk1IdzcyU1NHMVZ1enkxbzBNY2dEWFVLbEpqNDFZQUppVjdKV0FMNGx6TFB3QWZqMzNZSVdyNzIzUHpKM2lobHRNOVJXYkxHSVdGU2ZlT29UTzM1T1NtOGhBS0hDMkcyL0RZeGVWbFVGZHdEUlAzbEk3M0R2Lyt2RTlDMk4vTGEwRzlBb0V5RHJsUWtaUlFCQWZHMWlrS1d6UXM5djl3Q1NHR2RBcTI2Sjd3Z2tLOURRWFhwV01XdU5Nc3lRdWJUeUJoeGo3ZlpkZXZjdmQ4MTN6M2x6c1RyT1FwT2VWdzhkaG12dVV6NXRkQjFBeTlNaUMrMWIyM1NXdHRhNExrK2c1Q1VKd0pKU1RkdVRDWGtCY250N1R6UkFOMnpCNkZuZ3dTOHAvR3NzMEZiQVVUSkR6TTBpOVYzYjFjTW9nZUp0ZFRSM3NTbTJPcWlMTkl3QTFyYThQY2NQcTNQaTJ2RGJNNEFaQUhwbW5sT2ZGQkhkMEVxOWxRTTB5STgwWnZ2WHZodHJsMEVkMCtMNW1naGpjVzJUZjU3empMeWs0VmF3UWc2dWFmdDBja2s1TWRGaGFLTVZoSUJaZXBhZkV3L1VSYjF2RjFtd29wU3NRajA2eGdjL3FVeTRZUUR5Yk10WnU3aHFabzZnZk0wcjZOQTRVNmIwZUFpd3VUdDBBSGlqYzZJWER1MisvMVFIOWJvN2s2UTE0UC9uMkdqbWMvc3VLY0FkWGR1VEIyMEYrUElGMlBqZ3RLSFl5RmZ5b2szelROL1ZCUzJ0ajNCTlhUenJSR2QwOGtuM3lZMnlIWjRqUDNpTmJxSmd5QWxaUUUvWVk4UXp2SWtHNy9aU0JxT3dqV2RrRVM4Y1UrNTgrekgvVTZqVjdhTjNkdzgway8zVHg3Skt2V0VYNkZ3TlBCSEFrdTE3V2I4c1hjcXliV041OGYxVzV6UjhMY0VBRkVBaUVCYXdtSGwvSUlYU2E0L0ZuVkRydnZ5MkxlQW9majJjYURZQUJyUlphdkl5VVhTSmd0L09FbytCaUc4U2pLOFNhQkM4UjVwNFBQUDRHbDVTREwwOVVaMGV2ODhSQVBXSjRVdEFGdk0zSWNYd1RTQzJUL2Z1RjBMV2ttdVl1NEdndE5JTUtMZ2ZQUWphdHJERVpsQ2JsWXRXQTh6UmpYdkNtMUw0V2RGcGZPcU5HQWkydkxWWng2UXNHeHg1ZHZZL0pzUUpxR0d1ZThxV250QmRDcVE4VDdndFNaWE9SS0JyVHAyRzlOT21QWnE0anA3YUpmeHYydFAzdVY2SHFWMlRUMlh4QlFQTTZWcjFZeWtXNEVGbmszNnNiOC9QWGdXVmpROFVZSHNMTXFBQjNESXBhV0M2Rm1oNGo1dE94Q0liL0pJSEdzcmI4OENURW1tbmMwWTEwZHFuaVVCMVoxVVB3TlVlQ2d1ODBVZkg1aGdnek1JVFY4MlhxeFVtNVBoLzErdkM4Z3dQS0xERzh1dFdwN0tQVm92ZjZHdTFtakJFdEI5Z3FhN3lWMWZnOEZBeHl4Rmw1SEltU2Z1dTQ1S0hOaDN1N1REcWlyWU9kVkxYcVgvdDhwb3p2MFU5bUpTYzBVbnR0UDNyQTlIQmdnb2dKVS8xTjRlQjF3eW5wQzVEeElSa2QraFBNbVBFWUpLTUZhbU53ZUc2ai9qM0hlcW1EdEp1eDNadCsrMlQzRGlrSFJtcUowS2pzWWI3NHJ0N2puNU5tNDFnMVZrOWp6Wnl4a2NkUmtrbmJiQSt0SFJmeDdiYXQrcUR4dEw3Vko1MUFmS1hkc3FvUUh6ZU9tR3g2dXB0L29LY29KZFliOWZ3MmdnTmZaVWhQM0pOUnVRdmo1WHJaUDNqL2VmN2I3MzUrd2R2M2Z5NVJ4NDYrU3kvakNIVi9pdzlqUXhKWnF2US9TR3BZVnQ5M1FDcFhia3VOL3kyd3hjQUppU2pTR3psWnNwbjIwMkNTaEFDaEFIa2lEUEQvZ1Q4WGtOd1RKdWhGdjhUQldVNUJqcGVHVFJSSHkxUDlzWUxWZ09Rc01FTTRUQThmdUtaWi9ZWXpRYmRBNkkrdCsrRUhhT2NEb3plenJuUW4wM3AvQjZRVFpFR0tLcExpZWU3anNQNzdvREJ5bW5WMmJQU29wR1FNSzRYK3lZRFhzTTQzY1c0SkxwbWR6c2hpMG5KQ0lwUExoM3BqVDRvTUZCZUVSSUJhL1d4cTVtNkF3VERlV244Sm1SakVmWmJld2kwbmJjSUtKQlFMOWZ2Rkx2OFFZVEYvVzBmbW1SdHBUVFM2ZlMwVGJnY0lYWUNTbncyY1VZNURQV1IwVDNIMEcyQUkzQ3VZekRLa1orOXJBMnIzYmRDekxQcTc1TkZReW0wZ1pMWWxjMEVHTkJDUis0YW41dHlieU1NNmRHSnhXOEN5ZVFqY09RbmxsNzd0Y01rcXJJb3BQdjRnbzcyQ21iUmNjK1F6K0ZKN2RXWjhHR3ZpSWkxREoyUDA4UVJxOXdvVGRsRG16MmwxbjUxeHdzUlN1akMvYUZUSkorQWxQeHBieUk3blFNcm1GU0tXQUxFSnRLNFUrZ0VpL2hFTWMwbUJtZVN0UEpQbno2MWU2eXd2Vk5GWm1pYk5qbzlwejRzUk9CckpDbHUxeUd2V1pxZkhpblg0Uk5kbko3REU1L0QzL0xyNndmWFhOL1NicDhybDRCWFF1ZmVZYVFsTDIzeXFZN1dKMGpISVBDOE11eGRzOG5PMEp5OFZpbnBoajRaWEdOMHhTZFd2RFo1N1ppdFNHK21TekRJaEs1ekpsUzdibFJnWXRCS1VFdjZkZWFpVytpRWUvSmVjd3pOaCtYVFZ6OTFJUmQwQnQvSW9PYytNdUNNN3YvbXRSLzl3d2NQN1ArdFpvOGZ0aHozV0EyYklScHd6dnF3V09Xb1ZWT0I4cnRueis5dVhJNUlyY0o1cHczSUw3WVduaklBWlg2bFVRYUxLRVpRc2taWVNsbU8rN3ZIY2dSTU53SWZZUzNBT3VucjJheklsUHh5U3NiaVNTVEhwOFJpQ3lrK0FFYlcrU2NENWllZmZXNEV3M0J1VHg1SGlDaUxneUppRm1IWkRyOHhqSEJzUXVLMzc0NU5zREFVSTdmZnZsTVE2Ylo3UXFJQUNJdDNnTG52OXhJYzdvZ2VYSlpyejdnSGVDZDhSemtKb3U5OHpRdXdxMS9wZ2NlTUlLUXRiKzhYVkI3QmNtNzFBdzZFRVV5cUh6Q3lnVGdRQWM2ZWNWMW5xYTVUMzFHRVBXQk51YWU5RXdySVFsbkt6L2ZvT2UzVVhnbzN1L1NKZkVucmxsVUlKRFp3WHE0a1BsUCtXMEFqOG9FclpBQ3NNZ0dnYUFQQXpZcG1JZnBrWFY3TDhqRTZBYzdhWTg4UXo0MTFyaDdWUWQwMzhKM1JSM1VFblBhb3FJWERTM1RSZGpUU0x2VHdETERDVzVZNGZrK2JLazlaVHE0RWxyUjlGd0E5TU5iMnc4MlBBRkl1RDdIUERzRHYzcGFQZXBLcXRUTmhlM1JFNitVQ2lqNWQxOEZZK0tBY3o2a0hxdzhvb1BFQVNQTVNSZzRpQ1I0cC90cklRbHFMYmliU283cnB2TWl6dVJwODhrWVpJOHBEUlNyc0s3YWFYcTRGV3JrQ0FDVGpLZERTYVhpZkgvckowNmZqQTlrb1R5Q29Yczd0R0xucG5rK0g5SE8veisxM0YrZDYwamZ0MU5icDlEeTNWNDduMTRoYlBxWGZ5K3RBc3FRdTZNZDQyc3BEMTdGbSs5eDR1ZFZQSFR6akUxOTlTbk1pT3ExN1pOSUlaYmtBVjV2YXQyZHZ5Mkp5b1k1T3RIQTZQbExnck1LWGZ2RGEvM2pqM3EyL2V1YjA2VE12QXI4RXgvSmNvR0ZqN1BmT3Y3OTc3ZFUzZG4vMGgvOTI5Ni8vbjMrMWUrdU5OM2R2OTRyeXQ5dU83NjNYMzl5OTlzTWY5dkxGZDl1TG8xVTZUejAybHM2K2lBRnNBVEhRRm1WZzl2MW0xbWhVL1JDZ1VtSlc4N1ZpZkEzL0IyeFNjSHNuWUhENlBBTEtoZkRDQ3kvdVB2bnlLNk9JKzFMVytEV0NuaVJweGh4amtjdC83OFJJakNNSVRyKzNhNHVoSHdxcVp6QnhTNytsazdGNkVhNGFNZ29QZklIc3RtUGZtbkFCMEpTajY3Vmw5aVVwejMwQXNPZG1BcWc4cGdQWXkrZEdmc1NKL1pXK011N3VyV0RjL0dicW9sem5LRngxQVd6akN1aUZtU3huVnF1NkUyWkRUSi9PRFhpMTIzRGVOYUE1OTZlZTFXdnAzOVJKR1NhdVdFbjhuc0NVTXZybzcxeFBJMGVoQUFrWENBQTJXUWFrZ0ozbldMQkFDZjNRalhKUlFncnpYcHNTeWQraGpTeDRDdVRRVml2SUxnZjY2cWlkZ0FwZGdLNzIyOWxRdW1sZnY3VnRVM0IwbFhaR1QrV0g1cjdiRklwL0gvQ3JsMnZreVVaUmVNUTFRQVp0ZVdzTFVQNU45TnlzTG5Yelc3bnFteDB6ZTNucmhOQWV3THMrc2xVYWxqZ1o4TW55WlIydXhVSkFrNHNvUGxRM2tRWUEydjRhcm9uWm5iemIzbExvSlhxeVVaYVZDR3lDbGliQ2xUdFdwWnVSY20yWHl1ZmIwdkwwVlYzUlluUXBHam1tYm1UZkkzMXVoN1RPa1lucTVMdERXN2RqMHV6OThLaDdUdlQxWE4zKzhCQy94aFU2ZVhRdFhxSzNoV2Z5SUY5d0FHMTBKanFaemYza21yekgvMTVaVzkzVmxYeHNNa1MvdUp5MG13NTR6ajJ1RFZKNm9hWDhubkhONmJzNktwdThmZVRBdVYyQWIxKzljT1Yvdm5YejJtOGRPbkRvQWNwSU1NODNRZmZ1dWZkMlo5K3kvMERMZ1l1aGZlK3Q5aUZJRWFORGRHcUhza3U5cCt1OUp2RUt4Yk9RSkhnYmE5dXVYSmgzUFVVRFNsRm96anNCTm1HaUhCUERtM1c5OW9qT2I1Yms2T3N4M2tUUVdNTVIxeWIzNnZQODh5L3VYdmpNWndhY1E1RWhPdUo3Q2VabU9XUEVkcmkzSFNOZ0NZaHJsSHdBc3QvSzJ0SkpzMmFXZTZydmxIZ1V2YlpTN08wVWliRUpwblpObVN6anZtOVdzWkhDQ09OWTFTbGpvQUZJN1FESXNuTFB5RUs3aHA1VFpFb1NPS3ZmTm54WHR3Mm90ZVZnbHFwbHhRUVRNTEx1QU9NSG5VOWhNd0FBc09Jank5ZWtuVGh4MTVVcmZ6VDFDWnpSd0tFZEloQW9QNkVmZW5SL2FCZFpLVFp3WGhFUy9IN3hOUzJ4WUVjWjJtSUZJbmVMOStzQkxSYnFXSG5kdDVYbUV5MU9NU0dJQnVqQmluYjRUWmtlREJpOVJKVzdSZHUzRTdpKzMrS2JvR1RTKzZQKzZrNTVOejRDUkw5MUJOcUtMa0FEdjEyM3k5dDZicldSMzlub3ovdjlQRE9iM2FNTC92ZXNRejZlSHpwRmo3cjc2ZXpzbG9nSDZNLzlBbERFK0c4eTZCbnRjaWpiZFdHaS9NUEtGSWx5cWxkcEhjbGlGMWxpTTU5VHB4N2RQZjdrNDRIczFkMWJqVTUxUEVlYUU3TDZrN3ZwM2gwQVhUN3hrbHRsTm9LcUhOZXFWZEZUeTZlc0xPM2M2cUk5dnVQaDhMUGZQaDNiUGZlMzlCdmR0N1QweS9mcEZEYWQyV01GSGRuQWtCdDB5ZE1JenVKUElJMldhREN2cExxUG5xNTdGb2diN1dnajJjTkhaUUZ2bnpvbUl4c0xkY2lORHA0UlVPM25lZTR6SGVHMWpCMjZJVS8wUjRQcDVDdmI3NDhjT0dQUWUyblN4ZSsvOWorY3YzVCtpMWxDbnhKOUFXd3V0cm4zVzFuSTc1NHJ6QzF3ZmphL21MZFJBeW85WTJpbUU4dHlZR0dmMzczMm8xZG5ZdVB4eHg5cjNUeWw0TUpJQWJJRVppYzFRcFRTWGMxU2ZpOXJtKyt2REFlWU1lcU9kZVFCZ2RqYmViWDk5TWI1bEZMOGwxNThZZmZpNXo0L3hBWTYyNlpDWkdRVHhFMm9sb0JvMlFJZDl6Y0ZvMFJPZ3JncDlTYWdjWGpTdWIrRWNiRnpFMXp2VUhUZFVaZXd2Z1BtUGVGbHVUc0d5SlVSbmRCeGdYRXowUWtXVU9abkhwRHVVNTN0NlJBVXRjQWJXT1E2eW1yYXlsbit0RFdwSWR6S2hqNkc4WUJsM241U2RmeDIzcnkybGxPcjd3YThZMWttbkdpZ1RQa0RLWFdxOEZFYWlyT2lYNVlpYVNKaEI5UVVRRjNRL0VES1F4Rlk0QUJlSndDY1JZNmdMd0RkTEdjV0RzQmoxYWliWmRoZitmSVhCc2gwS3RMYkFNa25jS09jWHJjMWdGWjU5amIydkxxUkRTNmd0OXFmbWVLNTVybU5oeFJRdVo3ZHJIVHR3MS9wMWQ5OUZqaDY2MHdvT1RmRzhDYjVCQUt6VFc3WFBhT2REcDJPdE9qSGFORGhXS1NqQTdMZHJVNXZvb3hLcDBOVWx2b29SOTUrcTZlMmFDZnJNSk9pNTAvTTFxSkEzbkQrUmlOUHp6MzMzTFB4NlBidXpUZmZDS3pVWDJmbWRVMzVvbHNFSmw4NnNtMnpLMDk1aSthNEYvQzc3OXhrVnZucWp1L0syZW96amR2N3M2NUpOeUx4SCtqRkIrQWNQZEVVUCtpeHc2ZHJ6clJucnBFUEhhcDZHVlhpeVJydDljN0E2dUc2T25sR1hUZVExdm02N3lBem5uTmZPclF4NFNldHpzM3phM1N5OHNjLzk3VUYzWWRmOFZFZUR2bCtKTUZaNVZuUTMzM3IzUDl5Ky9LMWd3ZVBIUHZHMDU5OEx1RTQzSnRTM3R4ZHUzQysvUU1hc2o1QXNPcU5BczlycmZiTGIxLzhaejYrVSsyYzFiODdsMi9uN25obkxKRmpiUjk2SWd1YXRXV1hMVDM5bGZ6VkpoT0JzdVhpUUd6dEJDZGNLUVVNck5aUktRbmcxZXRaTEFudnF6OTZlL2ZpcDEvWmZiV2Rxc1JjZWlmZDNjSjJZczkwRUhyc2ZRMlpCaHJKek40NUV4a3h6WVFpaTgxa0N1Wmh1SmpmdnNiSWNtbnh4djU5VFRMV21iaTRMR09BRHNnQjN2S2Y4K202TnhFWkNRZUFIcUVFVmdIZXdTSmNCc0I3N2s3UFdGaXlML0Mrazgvd1V2R3BRTkZLeTFreDJIZEthczlpRTZHR2VueUdMRFBSRHhSMGY4SWxmSkhKY3l5cjhwRTJtVHAyMU1RWEplRHk0RFlRWnlyRXJIeWpGNHQxWHgzbjdJUE5WT3JVenJHMEFpRkNPNU0wQ1R5WDA4UzRVb0JPV3E5dHp2bFovZERMNmJrRERWR0ZPTjZPWGxHc3VyTWM3N1NWNVFzRGZILzg1dXVsdmR0R05aOUtBYS9PeTFXdGh2T0srM2R6YVR4Uk9PUjMvKzMzZXE0WGxENThLa3NuaTdtRkF1aC9vcmVRaUcrMmYvSEVYTThFODNJam1PZ1I1MnZQYTIxUmI0cUlCdTRkS3E3MVN2NUc3OEFFMEp0THBnUURjSWI4ZUhtcytSUEQ4RXQxRG56bDZEOTdpOGRUeW12NU0wUGphSXRCV01IN2V0dTN6Wjh1bC9lKzNpK0pIL01HNlo0a1B5aDJ0THlQUkg4ZEwxbWUvWTJUVWJTNUhHRGV6ZWVhaU0xbjN1VEt6L2ZaTlNOS0k1VlRUWFRMUy8xdlJic0gwcHRYWG41cDl5Ly81UitNMFhJOGZ6ZzM0Zm16NTBiV3hKNGZhWEVMYTFKZFp6K2FpR0pDTFdrYTJ1Q2xrUTJRb24vVDhmYWNaL0Z5QTI3MGNhemZSQ1ZnSHdCY0FHemVZVndPcFRrME1ycGNnNTZoQnc1bDZTeWQxL2YyMWxFM1lHblN6LzdqaVZyTDBGdTRWalFMWGdCYTU4SHlKQzgwMlo0b0NlUElNa1BBYU1hb3E0dWw1YmJKUFFWZ0ErYzB1Q2d1VVQzbVNKTDlHN204SG5na2ZEbytrOHpydFZSRmtPbXNzbExRKzJEblJ4YWNoOUw5K2NIWmMvL0grMisrL2IvdE83ai9iOW5FV29pY0NSa3ZxWHoxMWU4UFlIdDF1UlZQRHozc25Ya0pTa3cxUExzRGdCUFNTN2s1Ym1WaFcwUml3L0hETVl1TDQycCtQVUpNRVZqVUdHdmorNG44U0dqdUJUQ0VldUpidTMrdC9KS1doUHpTN290ZitOTHU4ei81RmRQaVNVVERuM2dKUVRBeS9qTHdaa0VLNFAyVEp3QjFpanNlWUU2UVBMZUVjb0dQNituVUhBdU02bTcyckRNQzZyQS9ncU9rb3pqVFd5Y284cEhXeWovZmxRT0F0Vk1IWlBhZW9veTdnVkFyaThUMk9UVG8wNlNZQ0JYWHBDV0VObnhTRjUvaU9jM3lLNGZsd2FvRm1Nc05zZDZHY1NQTFdmbDh0VXVJMXpEVHRTdUJKZXR6NnAvaXNBNmR3SG5xWEY3eTNnN1gwRVFhZVRrcytKa2pnYWZJeXFjNHo3L3d3cmhZZnZqYXF6TkVmYUhmckUxdnJtYUJjc1d3UUsxS1ZYZkRXUHhRSG90V0d5azNtbTFXejdRN0JXYjVLQWN0WTFuZ3RpSStsa1cwNmdDb0xSUDN6a3NoZHlJeUFMaGhMdUhnZDU1UmplRkVoemF4K0pVMVZsNTFWZDhiZFRUYUNseXFVblRoR2xqeVFjREFpRHJQV1ZvMFdrQWpaREFReHUrZWthZklDaUpLbnVYajJxRUVERkNhNkx1Vnkwczg5Nk9OUmg5S1IxajFYQnVQUC9IWTdwV1hYdHE5OXRvUGU2WTBQWU52YXpRRjJtdkR5SzY2TERjSkkycms5K0NhR0ZVdjRJeG1JMlBSMnYzK0Q2M1JkdjFldXVLM284Y216WnBnak9lbGw1ZUR2dUNaNTZUWHdVOCtjMi9SbGVVc2pZTmMrNzYySFZpeXBTTldCN3pHUHpqaSszUUszWGdvUHp3NmJqUm1QUzkrTEwrenNGcHVVZktnRTZaRDB0STNjbmE0VUQ3WDZkd2NlKzFTWi9YNXlJT3pScjF6NWNyYi8vZS8rZTUvZCtmNjlWNDBjZktuN2VNZ2h2TmsrNnNlWklYRWRBcGdweWNSRE41YXNDK0NlT25wb1paeldpSG9GZlltT3g3S21qbE13RkpPdmVFb1FZS0loWWN4SWtDK1p2L2FDSGt3UzBXK3BPSnlsam1yeHJCUm1wLzR6R2QzWC9qS1Z4Y3dBMFJjbHNzb0hDbnFhejhKMC8zbkpuZytoWmx0d3JQSHQzNHZhOEF6TnEwaERDdk5FajZDTUwxN0Q0aTRjRyt0RGx5Q3JCWWpySUdBTFQvbHMwTGxsdXNFcllET0FwZ0VxVHlVc1ZueHBGVWVoTXp1ZE80Uk1QczNFQ29UZTRhRTNBTjhuTnVRRUNpT1lKYWZ3M2VqQVBuZEQ3cHpyN3pRSFIydHdKUFBES2Y3UkQrZGdtRXltcGoxOTRudStLQ2NDUjhyamJvc2VzUzc1TUIzNFBUTUp6ODVHeDI5MGZKbHdQdjg4OC9QUGVEc3ZtdGNHZDVtWWVrMFFBYU1EZ3JJQlFKOCtCZ3BxN1k0dGNNbnZ6dGFpRmd3ZkRlSml1MlVVcnNBaHcyTGpGU1dUM3dOWStYTmVsT1c2NnhMYlFFTTNHS3VDOXVTNTB3MFpXa3BYNTQzbXpCVUpsK25aL0NFcXdWL0hPNS93TXN4WHJMZ0FsUDFOWXJCM3pFY2xOL3ZBUWV5bmJ6UkR4dUZBZWd6dlpUZzhWYS8ydGZrN2JaVnNNbjhGejcvdWVqaE5XNzUyWTIwU2l2K2V2WlFqeWY0WllRazFsbkVCMTg1T3JmNXh0U2ZERTYwUjNWSmFxY2QycUtqMnZUQjcrMmNCdldIS0xsUHhnRzArbmRsdTcybkZ5c05xZlU4NHcxTlZsNUx2MFpIOXVoRS90RUVyZTVNTk1uZXBIUjFYR1dNQmswZStFSlg3QjNEb09IS1dSMEZTMzd0MXpNdjlCMDV6SkNyamt1M2VuWFhReWNieGE5ZDh5YWN0UHgxeU9xbGZ1TVMrYUFsSDRNdjMzL3JuZCsvYytYYVAydTkvM2NlYlVqNjhLbUhzamphd3RNd0l5RVdhOGtpeG5UREZhL1o0WGJ3NW0zTHdLOWNiZGVvZ01IK3Q2eG5BTUNIYWptNGNMcGdjS3hSRnFsWVUvdk5KbmNKZVg2OGdQeHFTbkkzQVRuUkRQYVh2dmlsM2FleW5tY0NjRVFtcG82QWZXZzV4NDRScmdXV1M2ZzJZZlJKb0Vad1UwbytXNHFvTFJqSXlyQklZdEwxbTFCcytRQm5oeUd4aUFnQ095QkYrQ0daU3ZjNUlYUUp4S3lpck4wRDhsM25HbkhjcXYwc1pCMFFDd3E0cUErZkhwY080Q1NnMTBzL1lMcVhCMkFSNjB0UEJsQjZYcjAzZnlnUUE0QjNqTXM3TmxlRk9tNnh6SzRybTZCcWQ1VnphYXpCYVVQZjdabUJwdEt4N253UFZiSnNham5saUc3VDd1cEJFYVo5UFdkeGhsM29MQklBaUxiaGRNOG0rejdseitmTXVtRlZBenBnNDdmUXRjMC83ZDE0R3lCVGFNK1JsNWxwcjk1ZVBneElYUnYvdlRUVmxlWG9PVTNTa1ExTnU2NFRFQ09yUXdOZTZzNk5oSkEyVnNJWG93eExoaS8wbG8xakxmM0ZhMHZKS1QxM2tlZklBc1BDNkVQNzhJaEl5RTg5bHh1bGpxMnNBUU5mS0dzd01xVUxnWEI4bm1kbTZON0Y1TWljaW52ZXN5bkdXY1RIZStmT1RtZnd3dlBQSlVzM3h4VkVwaGcvYUhtajVlSG95ZlhBcFRXZ3IwT3BubzdiYXpQbW9Sc2VMdG42RUpCTjRxUHB4dTk1YU8vUFhHdm8zKzBPZ001SzdodlpucFlRbVRYS2trSm5nK2F6OVcrZjVPcDJpMnlrSVY4KzBZZmw3QjQ2Mm5jR0xmRkRaN3daTFdpRlBrWUNaSVBzcTd0OE5uQ2Q1OVZMNFh1SE9paERwY20vVUVrSG1aanIxWDJyRHl2N1kyRTU3N1Y5UHQ2OGVQRjdOODYvOXcvUFg3elV0Z1UzZi9MNHlaTUhIejF0MWoyTDQ4b0s5emxacjJYdkErQjhNRXZETG5ZMktEZWNmRGpoZS9UTW82TllRVU9LMkE1cytaN0ZKQ0lXd0JOQmRxSzBrWGw2Zkw2bGE0R25MU0FCeG5NcDlKLzc2ZjlvOStSeno1V0dCWmVBeFJoTW5hUG41MXNaWW9aemVzdUV3dWQyYlFQbjFaT3ZYcDRWU1RBeGMyM1B1WVRaOEhSVDhzMXkzcGR3eVkvUWhtQTlrMkltVUV0QkNlTHk4d0ZuQXExY2dpUGRnSC9QRURZWmpBQUIzNzRyeHlSVDB2akJKQmxROWJ6aE4yQW1xR2I2Q2E0NkFJU3g4Q3JMYi9ldk5xbTBoWFc1WmdjNllDNTBDNytJcDkzN2VMWm5STkwxcXNkY251RTNDM0Y4MTFOL2pkUkJvU25sc3FIVnNrUW9tUVVaSHdMZXdRRlFLOUFvR1RlRzhpbWc5bW9IcFFQRW44eksxcWxRVUpPQXdBN1lxcjhPSGkwY2ZqdlUzN1ZGaXdWQ0xLSUpyMHRHMEpKUFVVZjNRTXJKcWlaM1ltSm5pWHcwOEk1Qmk0cldhNVNXVmEwakIwQXNhRzFXcDRQNXBQRkpaMEVtV0d0ckJJR05kVmg3OVhCdnI3K2V1bTJ1RDVhZWRKdDdpdlhNMTg4OVVTVFU3TzBzdnpWQ2FFVmtFMzNrYit1VWhKNENyT08xUTlrWEcyMnNIU05iSFZxZGJqUXltZzRqL3l2ZUFHZmtBbGxrOE9hdDVVOWVRRHNhVVYyeVdLUFhYS3R1VS9kaHVqWXRvTjQraFZMNnZqb2I5M0NnUDJSZ0Q2em5TamRtdTExeTE0azMrSHlucUJLSDM1dGNxd1ZldW5Zc1gvNUVYVlJYL0Y5dW94cFFvdWtFYS9PU2w3WDR4UGYrejdQdWo0R1EvSzlyOUFiLzFXMTlONi9rR2ZWRkR6bzJkYWxzM3o5MjRJelk1NjVmdi9EOWQ5NzUvWHZYcnZ6K2hZc1hDNE8rOWRXbm5ucHk5K3dMejg1N0E5ODYvODd1aDAwRzNjMm5kREpYeDZtaU5UNzkyYy91UHZlRkwreWVlL2E1M3I3OWRPQmNlRjEwbTE2empYcXVweXlIVXFwakNXY2tuZUhSWlRQMENaenpha0o2TTRJZWJNajI2Yzk5ZnZmRnIzeDU5M0JEdnRzQkJLdGpLRjErdzRtQm00UnFGazdNeFdIU1l1NzZMU1dtTGVZVGdtWFJVUmJDQ3dDNE5UQ1RnQUxVN2ZxQWNQZUZ5bGt4YVRqbG5pZ1V5bXpCQ1FVMEJQVjdzelkyQWZFOElMMGFRT2xRZ0l0aEo4SFcyN09pMVUwb212STNZRFpCQnV3SU56ZkhrWWF3NkNmZm1mZ2ppQjErQXorYmkyc0hZTFQ1dmUvYmE3K20zUUJ2QkRuWFMzWHluTTVPbWNwZ2JXMWhZWk54ZjFqMWdGMDl0a1VDNCt0TUVWaE9GTmh6RGxZcUM0YkZxanlnSzI4QXpQcC83YlhYOW56bmEvOE41VXVETnU0Ynltb0hSZlJiblp4K08remV4dSt0ZlliTGh2VkNFWDBDVisvQzNNb0RidHJQZnl3UDlRbHVCdndBSXJwdlc2N3FBSURpalNiLzFBRTRlWTVzK0cxaXpFSWFaYXZmQ205Y2JnODAyRVpmQjB5Z0FMRXBxZEhGV082TDF6bzIrWW1yUGhxNDhva2J2VmxaYW51Q0J4c2RIbXZ5ajkvWnBsZ25pK1lnSjFhYVhtbDFvWEs5Um10b1hna3M1OW1MZ3pWYXA2cmROMjR1YXhtdGpIYklzYzZhckdvL01IUE5kNGZ2enZWZEg3MDZZSFFyQnltNkR4eFhCK3V4N1JsMzVXTXc0SnBuOXBtbzM1TUY5WEZmaUt6eXlTMmY4K3JBVm5xZDFPUlhPZVJyaFdXdXVSQThwMHRPY2lLL3c2VXhZdHJ5NWx2Mm5iNmhUd1VPZllEMVBGTWJ5SW82U2Z1eEJHZk1jN3g5K2RvYjN6OTcvbjkvOHNIakwvN0NMLzNDRjcvNnRhL3VEdmQrd0Q5KzkrM2QrYXNYZDEvNHdrL3RQdk9GTCs0K2x3dml6Mzc5NitPSytPU3p6KzZlZmVhNTNaTzlzdzBnWVBpRWsyWGxIVTFBajdkYjE5MEV6V3F3aTBVMVhNdUN2QVNrVTVURERWSFBORVQrMGsvOTFPNkZGcUNjZUtpbG0vbnJCcHd6U3NQMmNtTUhBaGhEZEpiZS9RSzNCRS9kQ2NvMmlZR2hMSkRGT0JNckxKQVVlUVBkQkFLZ091UUhlS1U1bU15T01HU0I4QU9LU0podEh3bmtDTzRDZVJPb2FrYUo5ZGdWUFFERXJUSHVoNVRFODRTUmxUZEF6N3BLU2NYQ0VqU0F4bUtlZWxjdm4zYmtrbGE5VjZRR3YrWnl5YmgrTlQvOUNIbkE0d0QySTVoanpXVkZSTENoVC9XUjNyYXdmc3RqOGltOTY1NjVuNDdhN05pVXU4ZkdJZ042d0dJbXdqd1hBQUVrOVhNQVRQbjR6ZDBBbk9YRll2WjcvS2c5cDg1K3o0dUNBMHFLNmZlV3YwOUthdDhYeWw1bEp4K2dwSzVHS3VOakRjZzhxdzNveXc4OW05b25Ca0kvdlFQUElZSkVIZ3UwbDFXUFZ5eFRRQTNZbDU4OWNBejg1UWZJdlRaTlI0SS9ybXZiY25Pc2tFQjdxYkI2dVJtNDhQQ1hTMk9XOWxjKzdOYVpDSjJjZHNScnUraVp5ekIvODJEN28zc3p5cnU1Z1BpZTFSMDQyODlHSFFxam1uSnRETVlpMXlteGVMaG0wUFYyTDBmZWVBZWNmUmZ5dVBGQVBmQjVPMXgzN0gzMHVVWUtya3UydVRhTW5IUm9OR3g3Umk3eTRpN1k1S2V3a2lrVHY1ZWVsSC9BT1R5S2YwWmNhelN5T29uVkFUSVBWcWpqZ1VJSGxVdW4zVE95V0VaU0lKeTcxQjRrNnJDTlVMaHBwaE91WFZ4VTNEM2todjVObTZzYkh2dXVvMXRqc2JMNE9CK2YvY0tYdnZPMXIvOTA3MlFyMU9Yb3ZkMjN6cHlNR2J2ZGs2ZWZUL0JQRnJHeFhsZGw0NlFyRGMzMjM4dm5GekI0N1EvaHZOTFM3MnRaei90U2hBWnd1K3YzK0tHTE9TMDhqcEpkS3pTbWQ4bnVIanR6YXZmQ1N5L3VYbnJsNVRZK2FoVlEzYlJ3SmFmakE2R0tuY0htQ0M5R2ZDQkFjWnFRT0FuUXRWc2Z4bGNlYVdhWEVPM2J0MmExZ2UvRk51LytBS2dMN2FQb216QlRqZ09GN1Rpa29hQVVOWlFhZ0NJRXJEbWZ4MmJZdVNJNHVGOE9pem5zNEdOMUdxSjZCWldENExJcVdKQ2ZmT0hGaVYxV0pyY0JRYlBkcHpUeWZlMk5IMzZRaHhkblNnY2t0QVBBWGI1MFBmOTgyM2hXYjNsNnpqMFRlY0R0VHVqZ21hZ3lMcEo1czNwcFROUkFEaFlqVURwNGNNV2JlcDdWeEZLK2M2ZjZwbnhEejBLWTBFQ2V3cDFtY3F2dmg0OHNwUVJ3MGpuUURVaXJ4NWUvL09WeGRXenVEalRrQWdGd3dCSFF1K2JBUTNWMVRSNitBMzdXSjVyNy9tRDhzS0x3YWhQSzZDUHUyL1BDNUU2MVVaWm5Ibi84MGFFTm55MmYrTU9GOEtIcnVmUHYxZ1piVmRxelkwWEZLRXU5NWJXOXQyK3MzZHFqZmlkT0xoKzA1Ky9kL1hEWFFIUWlDN2FFRlZWek9QZkFsZHdyUS8vcW9IMFdBZ1hyTThxeTJFbW56cDFua3ZiOTZrMys5ei9Xb3BUNGVQYXRGWC9OZXNaTDlkS3BYM3R2N2NyR3dyYzN0clIzQTJUMFZ2NmhvdzhOclViKzkvUUFEYlFKL1cvZldqeHhYOTNjV3dmOVdieHl2ZHZVNllORE91ZHlkeXhRNXRZWVdkakxlL0xQcmVFVC9hUW5IOXJxbXJvS2E5dktWazcvUjQ0QXIvVDR2TXBmaTB2azQzRGRkL21nL2FwTDlZdzI4cnU1ZnkxaVVoKzBNaElobjE0NEs2MWpmTi96N1dQODUxcy85YmwvL0sxdi9xVVhQLzBUbjI2bzNWQ3pHTlZqSjNwRitVT1A3VTQ5K2RUdWNJSDVSN0tHYlY0VXJXYklibWg5bzlDNjR3a1NCaDFwZU1haWZQUE50M2V2dnY2ajNYc04yeTQyT1hJaFFMbDZJMEJwVmRTekw3K3crL0tmKy9ydXovek16K3crOGVMTHUwT0IvcVZlODJNVlhYSmV2bnhJblJIL1FPL3BBemk3L1ZtTTlmNzNtaGlwVTQzUkJFcFhIRGlYK2twV0NBRmp6Wmg1eDB4RGNhOGgwZ01EVVdGOGRrSmJjYWdwVnN6bXh5U3hNRlpFZ0Y2YXhVQVE0djUwT0dOaFpYbDVHOGs3YjU5TG1RcTRiNWg1cWQrUFBmNkp5anBTRE9zRFJTeTgyK1RZdWQ1a2NxYVorc2V5L3FjeFdiSDNtZ1M5V0x2eXplVXZOUXNQMUdZNEZoaWU3VlU5Unc4VmdwWlNzRngxQk9yRUx6bDFyVDZKZStVQ212WmtxSDJzRGx1cUVuakt1NjkyY1F1eG1CUHRjUU54TlkyMWJwNGdLbkdwek50U3lwdHYzeXV0Z0h0Rkp1Q0EybldkSStDa0hFM3lOaFEzM0h3NDE5V0psa0N2WmRFM2R1KzJMM2VWYk8rSUZtKzBiL2l4RSsxY2VMS29DbnRmNTFCNW9FaWVLNFZKWGkxK1dTamNuZHB3c1hSY09LZUxZdkF1UUJONEowNndUTE9NVkFLZGN0OWNhcW51YmRFcHlkbTlmSzAxS3A0Yi9kZ29SeWVDcmhRenVZZ0daRkFjTE92cmZQc2xHM1dKdlQxd3VEYmR6YVZ4cXduQzNoNGV3ZXVrMzA5YXFuZnRFNEVEWUhRSU4zdVR5aU81SDRLZXJQakFNTERRc1ZuK3pVVVY2eklVeVJ0WmthcU9PWm9meEp2b1dwWmRxYjYxanh1RlpVeU9SSDZJOHhaNnF2NDlIbDNXaXNYOTFlRktRSDcrWWh0aDFWeXgwMkt2bDM5NGRaenlVNVlPUlg3a1lVWis4WWJsTEw3WnFjTXU2em01cThqQjlIWFZXNlRUL3YxMXh0RTdBMVF0K3d4b0szOS9kVEpKYitRMTZ3SEs1RzcwcG5QY002eHFJRGlUeUYwVHY0M3VOM1BiVktXUmNYSytKcGJMUS9ycVkyU0hML3YvWCs3dXBFblBKTGtUK3dzZ2tjZ0VFdnRTS0FCVkJWUVZXVjFWWkMvVDNkWHNicExkd3huMmNDZ3pMUWZwUmpQUmJNWWttdkVnM2VZd1IzMERIWFRVa1diU045QkpNMllqc3huVFVKcWhjZW1GWGZ1S0hVaHNtVUNtL2ovMzE0SHM2dEVIS0FUdzVQTzh6eE9MaDd1SGg0ZUhSMFFVSWR0R2xIa202YXdVTENGY3dJWlRReFB3cjYyRnByamNhQ0FtUks2VHZ1MlAwc2ExZHpXYWQzVC94TTFHKzJYL1gzb3BoYmZ4VVkvbmtzWHpHTDUxZHVQM2YvVGpILzFQUC9yUjc5V0pGWHBzUTExQ1NnL1BwNU5wb054bndueWhZQW1HL0NuaDl6Z0NtUERqYU84Z1VFTG9hQ2FKRHRYT1ZKbU56MUR1WEphdnZ2N1dtNHR2LytDSGkzZGlHbm45elRjWDY4Y2o2TUpGOW00b1ovVWcxK2lXeUNWMC9XV0VwZ0R1RFJobTd3WFc2VW4xck13Y2VuZERZUEJiVUZBOWRCaTh2cWM4QzA4d3RaV1I0ZmpTVXZUV1BVSFN2WDJiTHFwN2FBMHFURTBZWWpENThtVGdRa1pZdmZmZWUySDIvWXVYWG5xcE5BRUNHUDRNOWRrM3VaeVpPTE1CRWRqNGtYc24zbnJjR1dtTWhwdTFxQ2ZhbHVaT3UzUEJyVUFqSVdSdC9xN0IwRHhvMmdFNjlVaWRBcjkzTTZOZnd0cjc0S1BlNTl1dmFqaEx4TW9pc0J2bWFyNDBHYUUwcE9ENnhmTXYxdkZaQkErYzJYV054cWZETVRMUWNWaHNnUWJTcWdNOEVTcjFMbmdnQUF6dGpiSTJVbGY1V0UxbnRNRnRDMzEwQ3ZKbDYrM3llK0l6NHJrMDUvdForRkQ1aHQ0Nkp2V2t2VzdFYkVCcmx5Y1hPdlN4NmhIODZtVStpK1p0c2xyOWpTSWFWejN5ME5HRDIyVUlqVWNzaGxBR2VLSUsxQ0lJYVdpS2hJMUFLSFZvK3lzY1M0UHU0bXBIZ3RFY1d6cyt2WlZKYzM3QUZ2QzBabXlQZFJPR2lac09BQTlRQ0ppM2FORmdpdmpzZS9LR2M4RkVzN0tVQTk0U2tNdDJVYzJteEhCRnJVNUV2b0w0ZUF0ZDBnd3FEM010M1g1ME1MNHpGM1daeXFmb0NJV2ZwRk51ODB1YldKSnBmZk11bjUvQ2hHNU4xOHd2UkliWWlBcitUUExxL09ValQ4ZmpDVHBDdU5QK3dlbWJkcVorVStiTUE0ejV5ZmVtUm1YeC9QMDU5OExaUC9rSC8rQ2JpeXRYcmhRaDJJUU9CWkVZRTRMdTI0czVQZGNnQ2VJUUl0Z09Nc0tNUjlPNE1vUVJ6a1lRbm80Z050eTRsUldJWDN6MitlSlI0aFBjWjdLRjZibUxtVVE4YzJheEx5WUNHekVGN1pXdXV2Z01IMm5IVEFhRVJNMDBGcE4xSTI4R2F1SVBZN3BqZ0JFK3luMUFFeThHYUVhVEhjMWoxOUV1S2M5RUh4MlJMVkc2bVJpcE9pMEZ1N3BPUFdsL3EwdUJSQWpRU0YxM01qSndZcldoTWJNR3dXdzRUMmdUSW9TeGl3YkpGOWhSTy9LZDRicDB0QkdMRml4SVlhdVY3ODI0ZnhFd2xEWHVpeStjT0I4aG1NVW0wU2JBUkFOdXdSa05ML2laUlRTK3Bia1dJejhWekhtbkZRN3RJRnM4OWE3NEdzaWlOU1MwdHFxUG9KZzRjT3Q1Zm1zOFlGTytSVVFsOUdKK0lHVFYzY2hBQXp5ZTNmV1VJZjFxdEc0Mnl0dDNjaUpPaExrSjJLcDdhTUl2MjBrYjhtL0JyREZ5NGN3azlFWWZ3dkE0SGFpTzdFRk81NUZ1ZjA3aVFYZjRZR2QyUUcvalVxZlN0bVlIR0N1Zk9XTG5ZWHVkeUI5ZHBDWFVjeXU4N011b2pXRDMvVWlPekZML25kMTRwT3pSeWNBdHY3SzlSMnZHSzA0RUFtZElXdmVubmNFU3QvZ1YzZGNPcnp3MTgzejIyY09ZYVc3VmNVendhQ2ZBUjFrQldpYU4vUTVGQ0YwaXJKdkhRb3ZVdzdGTzhpcmh0eFRPNkRodG9IZ2g4QlQvK3BCUWJRWHRFK0EyZit2dVVUcFhqZGJ5UXIya1JYOUtpOS80UmQyOGs5ZWs4ZXlkNExsNEk3U2Q3MDVHOGwxK05rU0NiM1ptRSs0clQxckxoOS9oUjdBcnArN3BuS1hkREF6U0ZVekpCOCtKRHk3ZjhaUlJobWQwZkc2Rjh4c1h6cnp4dFRkKzg1OWR5ZHAvZXlMY3UzcTdaczlYVnh3TDAweDROeHNoN1FheGhoeVdXRk52SFdWdkNJT1lNVHpYRVQ5Ykp0SWlYTmFqRVoyS01IN2g0T1hGcXlIRWcvUzhoN0ljMTJHdXV5RVNqNDBIdHpPMEQ2UElZeVVNNGw4bzNVeFZwSC8yQjhIREIzVXhYOUJBTUFQbVFFQzJMUnFtbmVKbzRDWUoyTEd0M0xMMXAxMzRNQkhUaFVsTGFmRTQ0bnJXKzJJUXp3NEhJR2pxL1ZKRHdoak5iSzBWZmZ6eHh4WC9yYmZlS3VFRWp0ZGVlNjBXbEJDd2dyMHlhTVh2WjNlLzB1Nk90SHVabzZjSUFzeElDQkVHeWdaZk5lUXdHOFlFbTh2N3Rhd2d2Qkc0cE51WFlUM1l0bExmVkwwWUZqMkVwNEk1MzZVVHo3dDlURUlrZlFUWHMrQ2RScG8zTVdjMExsc2JmL0pZNDRKakRiZDkyT1ZEUUJvSkhJb3BwL3lmMCtuUUNPRkgranVwR3czNTVaY3ZGeTdVZzdCaGd0R3dqc1RmdURxM2FOYktaUy9XcVgxMjg1TVMydkJSY0lkOGhLQVZkbWh6UHllZHdNWER1SFNxRTZPdUJnNi84dGplc1pOZWE5M29wQ096a2xYd25oQUU1OG1UZkl5dlAyM1k4bGFlNWR5RjIwZFdiY1lFa2FFeVFhMnM3Wmhxd2taVnZqb1EwcXM1MFVKOWs3TGhUVHg1RVNMaW9LM2duYzdyNXMxYlpmWTZGNU1PV09CRlB1Z3VqbU80SHBXQStUb0FBRUFBU1VSQlZHUWkvV0dVSUZUcUVRUU51bmwzZTZWSEFPQmhwbE5IQXFwZ0NQektUZXQ1R3RKYW5qN25jeFF1N1VwblhFMHMzNTdGYnI2bXF2VG9TWjdLVVErNDhYMkMzNEozVTdaM1JwalN1SHh6Z1krWmNmRGhHejVSSi9OVEp1TjlFOXg5czF3ZW5lZWRNb3BybDNrT2JPTElmMEtubUYvUDBmMG5QL2p1di9tamYvU2pNMi9GNU9Ea0V3eHZ0eXhNWUY4TWRsaDJSdzI1SnV4Q0h5NHRrWWlGaGJKZlJsZ21RV3lmWWZZd05yL1JCMEcyemJZT1JpQnZSY2c5eWREcFVmSjRGQUhQbElqTVJBY043eURiTWtJc2VZcjlPZ1VrVWpMd25MeUhTWW9aOWpBSlFobVd6ZXFoOGMvVVUyTmFUTEVWalVzOUh0WUNoVFNjQ0NQRXRhOEFRWDhrN2xSK2F6UzMwcEEwS0EySHh3VzQyT3NNRzIzLzZMcWRGVjZuejV4ZXZCcUIvRVUyN2RtTVBkVUJwb0xHcjF6Q3hmT25XUjAyL3NFRXBNa3RBbHhqQkp0eU5xSWhtcWwvLzRNUDAxQTN5aTVwc3M3Q0lBM1Y5cDAzN0NCSU9BZWU3UkthRVo1cGRGeXFRcERnczRVeGVzaVhNSzBPRDFEd3ZRZG45VXFqeWlVLzh3aUNvUzk4Z0ovdnRlR3NPTWNpUU5reWIyU3lUV0NiMXBqWThBazl0a21iYWhHOHpCdnFlemkyMWlRcFdCNEhYcDRYNkt1TUxFOU52ZU45RWNGdDRwRi9QRGhzT2tSWU02K2doV095ZEFMc3JOVUJSRW9TbXZ5dTBVaTllWUxZTDRNR1hRSWhEYjlPQnFGQWhJZmxjekNkaWZRNkR1a3NQR25oa3l4Q1Y4RXdHUXdXVzRHNzlrWUpIT0tiSDdCYUR5NjZmYlFRMG5sNXB3TkNSMEcrMC9tQ3RZUk5GQnBDaVM4dzMrYzJXZXdyTnp1MjdlNEE3eGYrbURpWVhXalVYTlRrVDdpQzB6TjdzV2Z6QmZKR0szRHo3SEFYMEFvUElHc2VpLzQrTFQ5M1BmT0R3VTZlMm5iUlBQalNqdUJLbTVyT3c2cmdLanZsS3JQd05HV2xIUHcxNzJjVUtyNFBZT1dGb1kyNUMrelp2bEdpd0lsUGRiYmtpblJzNjlQQmlTK25obzh5MVpyK21Ha0tWcEdldC9DOU42Lzh5ZmUvOTkxLy9rZC84T05zYzNnOENES2pucDQ0d3hDSUlwejFjQVFBQWhaUkVnUHhNUWtFc2Z0dGh3dHNlbk13Ymtscllhb0QwUWEyd3d3bGhFUHd6UWllUjhtRDBLYmw4ZFZsTzBNSTVvZjg2cjQrVEl6bWZza2I4eVJCQkxnZWxpREozOEJCZ1BpdDhSa3lKWmQrbC95S1NVSkFURkdOVlozQ0JFbGFEV2UweENSZE51WTBoc1RWaUFrWEN4d3dBaUZoa1FNWXg0ZVRZS1U5MG9xZE11T1o4T1hKSWcxR2NXRTR3MndObTZaVVE2L2dSLzQwSmdkc2ltZXpJd3NhRE8xSEM5U2dNU1ptYmNITkxyOWJuWUozUmg3VjhOS29qVklJZzMyWldBeGFnaWNOamZEc085d0ZvelZaNjMzaE5IajEzbTkzNzZSMWgxUHY0UlVlZFJCZUgwL25vUEU3OWFOZ1NEdzRjRmluZXVJTG5aTU9wMnpJTVczUUNFdWJqSURSL0t3NHMvR1R4bXZDVENPclNiTnFsQzBrRzRaQW9iMEhFRUlhRHVyQWh0VHpVVmJWcWE5SlNQZ3k2a0kzazRHOThYOG1pb0p6UXZoWWhMVjNOK0twY3lENEVid0h2OVdJMGxYOUFqc2JPYmpLbm9reE11cnExWGw5QnFDTzVYQTZGSGhIUHhwekM2UEdrMG5LdmNKWjNtaW8vbmd3Q0NyY3FZK2QvclF6ZFhJY0U5N1lEWHhPajdrYmpaK0hqTWxIN1VuOWRHdzZ2OG0vMjExUDhNS1JvRTR6QndFL00vL2dhOUV6ekE5ZWJVSWJRbmNCbnRVcDNGQnd3c0V6SllkUWJmaDd3NngyVVpTSE5BSzZnNEhtdkRkL3ovVStCWFNab1huYUVwdXpORndoZGJnRmQ5cUJCVFdGejBCUzhIUzFxbzJZNStLNlNOa0JqNDVNM3BRV3VCWC91ZFNjLy9FUHZ2TnZ2Ly85NzYyODlmcVZRZzRORUlIV0Q5TUNXc0QxN0hDd0ZVUVhZY000RUZLejVtbTUvRDVMZzhqSFpwSWdLOElYOG5aRFNQYmpKMmtVYlZmdERWR0tnYUtwc0VsaGpMWjVZdmt3VFFSMGFlWlFUbXZPa0p4d1JtUVh3aWpmZllLSlA1TU1KYWpDek4zd3pBUzNCZ2IyNm5uVDdqREJMTWRXVndLVUw3WkdCMzd1T2hpaHlrbzVBdHZ5MVd2WFlqdCtrRVo2WkhIaDRzVTBucFhGcHpuV0hSUnZ2ZmxHeFRQRUJvTUdKNzJ5TUJDTldUa3VYVThKOEFoYzVSREc5Mk4yc2ZEQVJCTWZWMXEwVldJbXB6YmlSWEF0R3JpMHdLRXhXZVRBRnFrcytRa1poQlplNEVibktUVDB1UWMzZTNFR2Q5SzZWd05iZG1hRVI5RWJKYnI5bGcyNTlqMUkvdnkveFZja3R6YWJZdW1jNUwyV2pvWUFVVGVhb1dkbUREalEvUG1vNmxSOXM0UlpQUFhRK2ZOMlVTKzJlRGcyMjIvQ0MyL1ZDc2dVcVl4ZTlaZU9heW1rQ1gzNG5XMW1lVVlRckhCbGRTczY2QkRqUXQ5d3BKNEZmK0JCYXcxZElOamtvNk5QbEtJZGdmZ1VUL0FUMm9DNWNCNityM3lDQzN4bDh6Qy81M3ZCbXJqdStLRDNBV0dhNlBqYVZ2bnZKaCtUb3NtOTB0TGV3ZjR3blp5T2c1a0huRG9ONVlESGFFVlpOV0lLN0o3RjhjMGx6QXBiK1BFcUtIbktqL1Y5NEE5ZlNyTlhPQk8wVlU0Nmhtb3pvWitSaUhyQWtUc2NxSnV5WGVWcm5HLzl1OHVTUi9NU0dLTUloYmRTYk9XdGplbWd0RnY1Qk1wU1l0akEvVFppSlloMWNQQmgwWloyVXJSZTh2TGdwTnBaMWZvNSt2UGo3Nzc5TDMvd3ZlLzk1SGZlZVdkeE5CTU93WGtKS0FpZXBaalR1MEZLRVRuZjNEVWtnc05Rdnladk1selJpRERVdzloMXhXR29rMWRsSEFLYktJSlF3eVhPK1M1bkVyWiszTU1jMFl2QUpSenloUjlRbnEwUTFNZ1JRc0FjMHhBOEkzSTFkZzBpTU5EZTJtV3VoNldjOUEvbUhEekNXcUMxWUdobDhVdXRUWGVTaDNyU0VqR2xvYWw5TVpSN0p5NWw3TXppWDdwMHFlSXhXV0JBTnRnTG1RQVY3RE9CbVdpUjNvT0pIVm5uQlNhVGYvS2o5V21JeXNGME4rSWZyaDYwZGZucVhQeWVkNTkvOFhseVQ4Y1UzR0ZlRFJQajVyRm9RRENEeGRVTk1nMWorYnZlQlNmeTJodXFVU1NPd0t5aDdtQWpMS1VocUt1akRud2FyMjFSNFUyaklReDFMRnlqakNaTXpzQU5jd2FZZEhTVzlCTFE4RkVpTUhueVVWWjN1eFhLeHdiOFBCZk9uMi84V1IwNVFoUCthYlJWcjhBT2w1YnhncE1HSnBpTXhhczNZb3BTdmdsWm5pMDM0MUxISk9TYjhyZmozUUxYT2dOMUpIaW5uS3ByQkpFTmRKUmgweUptQmF2YzhCNjhsUnZiRW9mVkZwYnY0VWkrWEV5bEhTRUpGdlJ4NFZsbWdTNjNUUUpyNVJiWmZPaDRyTGJOZHVjSzNuc21mOU9KNFJ2NVVqd0VOQ09jbFVsdjZiSjcwazY5L1FZZjRheGVyVTJIdmlGQXo5dDBtK3dSVk1hbFVackFLb0owNkQwTHVuaHJ5QS84dUVvOGNRUXd5VitkdkFkZmxadG4yVWtEYjJNV1k4TGlrZU5iQzErVHJ1R0x4QkdYOXcvekdLWE1kMlkwSTg3S0kyVjVweXhsNGhGNFZRZHBsZi9jYWM3LzJZOS8rSzkrK0lOM0ZxKzg4dExpMkdvRVhCYVlzQ2tmUHBaejRZSkV6ci8zK1NDRklJZjJaWWdWNFZCTGkvTnhQY3k0UDc3TnUzR0l0cW1SMXVkNG9LUFpOUDVRTkNpVEt2YlFpQW9kVFRPcnRvSlV4S2pEVTBOSVJMS1NTb093d3V0UW1ORENpVVRMKytSWGsxN1JZaUEvRFRKai85TENOZkx3VDVsVVROb3dqV0JFZ2g4aFY1SW5BY3pRUWFBNG9XUTd6TDZiQ1NPZEFzM29VUVNNaG8vUUdzSXRwb3dJakFCWmd2SUVGNmRvYlhlakxYTUZYSWtnNEl2TWhISDU4dVdzK0RwWlBzaU80SkwzRDcvL2c4VzEyRXovNzMvL2wxV1hsMTkrcFd5cEgzMzRjVkNZTS9LeU9HSXJFMWsvKzlsUFM2UFY4RzlrQXg1MnhPUEo2N012Y2poQk5OTHl3WTVnbkExMTdzVG5sMGFtSms2djRVTktxT2dBbldsWFdsODFydUJSWXczdWZHT0gxc0JvU3k2cVlHbFpRVHJYTEV4dHJFS2JOM3kyMkFHT0NYWENJQWpOdTI0UUdoVVR4SllSRHVHVnZHM2l4Qk9ERUc0LzNxT0xqejc4WVBGSzZzMy9GVjZQeEMrNk5zQVAvUTdIamd6bk5FVTc4T2w4Q000VFdUbTNGWGczY2p6VU1STmkyUU9hTUZiSGFlZzl6NUdSUUVaVFplY09qZEc3aGFmOWxtTjJDaHozYW0vaGJIVWJ6NWdUdVJ4SWJHSjNKWHhrRDVnazY4N1IzRUg0aDkvN3h0SEQyU1RwZHVoOEs3aHZMVTJuWTFlK051VnR0VGFYOHRpRm5hQk84MmNqNS9ySlBaS0ExR0hBRjNkQ1BHam5OWFpyOVNCRWVJM2dSVUtFTU44T0xzdCtIZHpjdnB1SnpwUk52QkErMnBmSjYxWWMrUC9xWExMRVJiN2hFYU1KaXBGS0VKeEdCaTVoQkxOdjVUb1ozS0pGbHkxR0MzL3Y4RXJkTmFpRUZKMnJGWjg2L0RuNG9UZ0ozUmwzSitOM3ArOXZKUmlUMklJYjhCT2lGRHBDMDI5bFRoem1HSE1ERytZaXdtMDZqdUxWMUFlZGxSTjBKcGlITVJveG9XaStTMXVsTVBaV3NNTVREME56WnRlMW1GS2ZLK0g4alNzWGZ2TGQ3Mzd6VDk3NjJodUwwOUYyMWc2MFpxSnRjdW5TRURVQXlFTGVmUkhDRUUvcmViVFVKc3ZITXdSRUJFekp6cVgzMW91V1FFM2FJbEtZZHp2K3JYVlVGS2FTZDlFZ1E3NDlRZ1RSU2Q2eXFZVzRTVnpwOXljOVZuaEs1QURWaklVUmVuaGxPS1EzTHkrTjVJTWhEYzgwRGp2U2phMkxNS2JCam5CV0oxb3FHNWhBNDhYa2h1cVlnWllzL3M5LzlyUHEyYTljdVZLQ21iWjROalB2di9INjZ5WGczL3Z3L1NxTFlGQm5kbXU0QW85aE5lRzdtZ1U2VENJbW81Z3Nac0xIQktNeUJ4YmY1YUdCRVZMcWFodlZ3Yk9oUHkwMmNxSkdLNVUyekt2Tk5yT25JcVFHTEFSeGRZWGhSempJZXpRbjhieHZUYXRTUUVNU2FUQm8yME45Unk4TjdnZ3Zvd0t3emNpSzBQTGJ2cjN3ZGoxMlh2V25TYjk0NFVLTlJ0aW0wVXNqQkxOeXgzUGhibHdIZlpjSERjbzNkRkdtTktsSzRRZE00SGZCaDN5VWR5QU51VVk2b1hXRjVVaExIQ09VTTZmUGxqWXZEdGdKUHhlN3VYRDFxbFdGOWcrSk9XdVpobzJkY0RUYW84bmFOaFJjY0RKbW8vRjN4bjlnRHlLTEQ5aFFwNVBoOWxnSE51UjdhWU5MRTEzdDZVRzVTSjcyNUZBUG9XbEdtV25OMjNjZDh3Uy9CZndPUi9Cc3BPTFpwU09HTTdoQ1Y5cndtRzhtYlNHMGN1bTh5T1hpT1dueVNqekMyVjI5Q05QbUd6elZJN1NLaysvMVBnU0NhenlNRitaYmFsUFBpaEpQWG5VZVpuQ2diYkxsaTY5andCZndLTTFNR0ZhZExBb0tEWHlYL3dSbHdGbU40T2JsODNCLytaVkxmLzdxeTVjWFo2UEo4RStlWGhMeWFGdUl5LzBKUXAwRjZDUnU3eUJuL0dmNWVKYUdIWVNZdU5nZkgyS0VFMjlsTjV1Y0VPNTVYLzdHMGFxTDBIbDMwTnBXWllTSkNLQjhpSmRIR211RXNHR05lSGxib1dSTW5wUUxGbmVycGxvUXQzWW5ZZzJSYUNscHpCaU5ObzlaVXJVaUtzSWl0TWJwRGtibGFOdzFGRTlhV3BmMEdMMG1BMFA0ano3NmFQSExYLzZ5Yk9nWExsMHNadmdvMzZYSEZLZXp1T2F2L3NOL3JIeHIwL3cwYnNLY2U2SHZXcHJHWTI4TTVablZML3dFdHlWNEh0OXVocDNmMFV6VmJZYWJucG1OYU5YcXpueGdLRi9EdW1pRjVZS1lNa3kwMHViZ3E2N2dwQnBSTU9tZjdWbmhyOHdpREVtRjQwVE9zbm93d25qaE5rK0pocUNCc3pXNHJVY1J4b0VQM0lNMzZjV3ZORWxQNEttUHh1SnV2MmZsalJEY3lHaUVZRUlUNytFWW51QWMzbTdmakhBazBDSklEa2I0cndlMDlRYzVHU2FDRGIza0F3L0tkejhRWlVKZXpDWWF0cnFLOTFsODZyMm5vWnMzOFozWnlIZDBSdjlQUHZtazRFWWY1YXZEbmJzUHl2eWt6aWthOXFvc2RaRU9QN1JOZkxtME8vbmhuZDNnVmJsMnp3T2pVYVB5dG5OeTBIUkNtK21ZSDJkbS9IRld2aXBMeDZ6dXRaZDZOSDhkUFcxU09CQ1hQakRwZ1BsQ2c1c3JvTHk3N3MzejhpbDY1cnM0NFBST0hCMkhkeTQ0OVY1QXM3MmhmOCs3anU5N2tsV1krUEpSMXZ6MjBiUDN3dDd2bnBYblB0L0Y4YTU1ZVdtelgvNHVlQU9qVlplZXlSNzhKeTROMloxTWdzdkp6MjgwRnIrRXZkOEtlUjdDbXkrZWVPWGIzL2pXLy9JNzczeG44WEoyb05NK3cxcWw1Umwyd1U1UDhBV3BRVEo3N3Y1SVlReGk5eWdlQmpWSnMyemtaVnFnM1liT2tHWnZZTjlMT0NldjhvT09RR0hHT0tqeE5mYnJKT3RhdnBueTk2VkJGZ09JNzBMY0Vobk5BQ0Yzb2Q3N09tRTV3blI2YUdYdUxvZlROcE94d0FIejFBS1RQUHR1ejJudWdMWHpWZkpsK3RDREc3SWZqYVoyKzg2TkNKYnNZWkU5R2l6QU9SSFBGVnJoK3grOEYxZXV6eGV2WG5sdGNlWEtsWnFZczd6WGZpQkgwcmdKU2E1MDVVckZCSkhPeHREVUVVc0JOVXUrTXdPZjVibUg0OHRjR2c2dE9BMlpKclI1TjBJN2d0dW1POUVOUzhBRzhOcVBHQTZkRm1OQ2pGQm9EWFU1U1laeGczc2hUYlRpd000dzc5NTc0YkZ3V2RGVDgySGpaNDNMRjY2TGhjODgwL2hDcHBSSjI4N3Y0R3AvbHM5cVlHakVSZ3kvNmw2TEN5S2tacUtMd0NGNFB2cjRrMnBRdEdDbUNzZ2d1RFd5dHNHM0pxLytGeTllRE8rMXdDSmtSdWhNZWVqWGpiVWJ2UGZLOXM2ek9tNUc2OFlpUmlxOERYVDhiVi9tdHBmOU5xSVpYNHdHVHhUOTlPOStXdWFubkVxZlVkQ2QwbHBQbmNselR2UFJhVGh1TENndkR3TDVFL0RIajU0b0RnUmZ6VS9nOGNCbGhLbGRNTS9CU2MycDVMMVJKRHFEeldiN2xyM0xLMTFmaERPWE1STzlQVUtRMzVHTmRHN1JJclV2V2lLVEdwOW50SkN2eFZyU3U5U2JZSkkzWEJGUW51ZmJhTTdpTUIxWWxwOW9xT3pQTXJRU05POHNrMWFPZ0pZbEFKTkkvbWhHb2ZWOTd5V3Vja3VvNW5uU0k0VDAwdUlwY0UxY1hrKzhkZ0p0MDVSeWxsK0tsbGRLQ0Y3Yk5ObnZJeStTMThyU3hHRmkwbHlBZkxnNjRqL3hoNnVyb0sveW45ZGV1dlNmZitlYnYvMWZmZXZ0dHhabklvVHFaT2tuR1NhSEl5M1RobVFhd1NDSGdLWVpHRXJ6VDdXald2a2hSdkMxdTEwUXRkVHNtRG93TUR1eVNSU21ETVE3RUtTS2F5OENXcnBHMUhzcXlEdmFlUkJjeEsyeUl5Z1NCMGZSOUZBT29WM0ZIQ0VtUXVwWko0UU5pbGpZSzdFQ2VpWW03VlVRdXhSTld4aW05cXpCMFh3MGNnMlNiV3VHMVJqTE8zRFQ5bWhOaDZJUmMrZjV1Ny85MjdobzVURFcwMmZLcHZwNXZEVnFXSlc4NUs4akE5dmh4SmZmdmRpbEJYWkpmcjl0cTR5L2RScXJwY1FhSUZNUVc2SkdydkVxMi91bndpY2RvKzl6UEJFN2NkTm9ocEZwdE1GaGQyWjBZUGpUc1Q2N29ITWE0dHdiaDRSMFBnV1hPbVREU3N6ZWZ1WWFkWmcvR3ZxajdDcElJMVRYa0NQdzlXSVFnaG9lK1JyREUzY3orWnJnRWpSTW5SV1RBUTFVM2RpY3hhVnR3NzlnUXVoT2hEbzNPT0RVaEdmd3FiRHkzODNFTUVIRnBBQWVta0NSbjBhUSt1N0dKazFZTWdYd0tGRW45SE1TRHpNUm5tVENBRDg4cXd0KzBwRVFQcWV6THptYk9IdngzVEsvbUVEdTgveWtQWEhNNWx3OVdsQWZuWUY2bHBLU2ZHd1hLclFaS0RDRzNreE15aUtvTGRtSFg1MHNyaVVBMjNSb2Z4R3JMUjhYZm5pODZMREMrTldaRlUrbFRrWVQ0QVJ6djJ0TldwMWRBbHlyYzdXZC9PNzI1RjdFOTZaZ0Z0ZHovMTIycVQzQ0dmM1IxTjQyMm9KeUExRGxKODlwaCtvUEZsZTE5OEFCQmdKNTRrZzN6K0tid3pnY20zMnlxYmc5VWdaall1WTcvaU44WndTdGZLNm02b1FPeXRkMndhVGUwcWh6cXlwVnBhLzJueHo3OHM3WlU2Zkx6bXBIdVFQaGNnZ20xRlFZQXF5RG4yQW50bUVBOWw4RUtEZW5wTEdSRGRNR0JoeW1rSTY5bDM5aW1TNDBWRUkyb2Zkc3BnMCtHNTdsVjdTSmFFSkJjdlNCUXZnd2dYTG5La0tGYVJDbW1HZkpES1ZGc1YybEhPWU0reGhnQ0M1NVlQWGRCa2MxQVJuaWk2ZXVOSHVuaGIvL3J2UHh1TTlabVhjL0UzODNVd2EvVlRqWXFkM1BsRzA0N0NRVGUwT3d5MnZZdDNNZGk5Qmh3eTBoRkEyZVZrVHIxT0JNSHAxSnc3K1Z6WHpVdzhUU25XalM5N0pwa24wbkNMbEhFY1IzQThmdGFHNG1mUjZtTHJSbHVHWmVtS1hhOXRPd3hCZXRuaEJPWVV4ZFVZeWtWVSsvQjIvdWV3TVo1aUlZakVKS0c4K1B3am5hUGV2bjh0eU4yVVk0OHNIOEdnYWN3cnZmNEhZWDROZWlHa0pGaDBUd2xqYWNUQTNaMmR5OWw1NVpnUWJ0N2h2QkpPMElhemdxZ1phODFRZjkzTkZjbzVSMkxyRElzNzdIbmk5T3c5dENnNkEyaWN2TFJ2akZMMzVScXdtdDZsUXUwNHU3OUphVjgxdC85ZFZYazMvdjVZQW5CbFoxQUlzT2hja0VMT29OQjhvRk01emdDZmZoV2VYS3d3aWlPNFRXS0psbTFKOWYrRWEwNW1zeFlSek9uU25SczRNb1RzVmtsb3lLNTlSVlBqb1hkL3lvcm1EQ0Q1NlZLZDdlOWdFL0xrRTk4Mzk1ZFR1YjkrN3ltUGllNS9MTzg1Zmp6bmZ2SjQ0eTRHUnc0ejFjZ1cxditxR3I3d08zWjlmRWs5ZVVRUkVEUXM4QjlFaE5KOUttajB4V1Zxcm40TS9Hb2JXdkg0Lzd6bHFZaWlaN29MUVB3MW4yNEF4aGwwS2E3eTl2QkFpRFRFU0hNRnFEM3laT0VNS2w4U0pJdlE4V2kwaHBITFVuY29TVUdXb3VTb1NCWmJVbHpDTWt6TUt6WVNQQ0VJcjJYWUtrK2FHRXZud3hvVEttSEdVTUlkMWJTMEdvNUJWTndHbkpOZnhKM21DY3NEY3Z6NWhESXlVZ0NCaFgrZkNHcVQ2TFpreXcrSzdSZmUxclgxdWN5WUVEeFVUcGNOaEw1VzJvTHAzR2dSa25YNytsZzUrclY2K1ZRUEI3NmtxQWEvaUVsWEorRlk4OVhGVnYyaktCS3Q5Z2ZsbVZ4aFBjTlNvMEtBM3AyWlVtVjkrVU41T0E4RmI3bDdnbjMvTGFTTDQ4T1h4VDNqUjRHdHpnVzlsRjF6MzBGZy9NY0E5K09JQVBPSFg1UG5WVGJ6eG0wbFdlN1BucURqYTQ5MzRtQTFWUWVZTzdvWjI2eWxjKzdsMzNDSVRreHpaa3Q3bjFhTHo3QTNmelhreGM2WGdzMmYvd3ZmZHpYTlQxNGd2VEhtSENHdG54dWdHNy9TdXVYTGxTUjNFUnBBS3ZEMldwZzNvT3JFWUIyZ01ZMWRGN3orSVpIY0FIMk5EZk5maG8yTHNkbVQrQUw1MFR2SUpoK0ZTOWFlR0REL25DbVhMQXBwUHdUWDdLZHduS0FwZHI4Rk1mOXZ4SlVWVmU4WUVmeXdCZStRdEQ1Nkc1ZDU3bjhsdmNxWmYzd2xONmhBZm1uVGpnOGMwN3NNS1B1M0s4bjZzeXlSL3g1cDA0ZnN0RHZYVk93cVJGbjJrUjllR3IvQ2VUU3ljdzRxRVEwakFDa2dtMElTWkVxRGdHd1JTUXlCMEljZ1JNS2k0a2lZdHBURkpCK0NCVlBJejJlS25SbHZZWExadW1YVUltZ3RkUWxCYm5HaVl1Uk85bGtPUmYrWUFoNVdKZzE4Q0ZnTktDUmJLSk84ektycXd1NnVndUtBT2M4bE1ueHl0NVp3R0pPOEVzdmZyTFcvMW90UEsrZlBueTB3WWxMbVloWkRTWTBmNmtVUmFZdkpmUENDL2ZUUGpNNzhIWE1DdE5XRnFiRHluUEZWRHJuZmZxQy9mVmlKYWpFZThIajlYUGVwL0w4MXpNRThQczdsOE84cWdRb2RabHRtWUZQbHFlN3hQSHZYZ2krQnU0NFJFK3dFWGdxRE44dU1RaGhIc1pkaytrNnRUVWcxZU1ZSkVQMDVqTnNZeEsxTWZXci9CdVVndjhaV0tKd0NLMDVwcjN5bkRwYU1BdzlFTTdnWllNSm1XaU16clFsR202Zm9OZlhZOWxsMFR2ajJWUmpQeG8za1pVNmlaUDd6d1RqR2dMRi9MVklTc1g3dnpHbjhMd1FpOG82ZEhpWGhxSysrR0hINVpKUXdjUGZvS2ZIUm84Um1rVzhzQnAxNjkzeGFNczBLS1Y2YjE4cHE3Z2N5bmJYWjJSZCs5VndPWFAwTlR2NFEvUHluN0dmOC9vUCsra1UvYVVBemZTekR0bFRoQlhQRUVjY0lMWjNlOTU3MW5jdVlOSGZ1N2VveEc4RDYzRTgwMDluNVZXMlgxMS83eDk2ZVUvKzg1dmZlT0ZzOW53bnREZG55RjhMOCtNdGhNRVdNOVBhOTdKRU4waWtHd0Z1MWpKZnJpSG81RVVZbTBvRS8vQzNXeDJaQU9hKzF1eGtXV1RuSzNZclZlejBPTnhOb3F4ZWJ0REliZHk3ZTVHMncxemNDOHlEQ0dVbVEzM1I5YnZIRWl2bnoxM3QwSzgvVG1CK1VtUS9VaThOTUNnUHVtVE1BMHpidGgxcW9xSnY1Q3FMaktvZHdWTEo0UElDSnY2bURBa2VMa3ZNYTBnTVBYSlRId3FGQnNtY3dGaGt5RnBUQmNhbjkzelB2LzhzMnd3bEJPbVgzMXQ4ZEdubjhSa2NXZHg4dlRad09Ua0QwdHQ0eGdmNXJnVnR5K2poNDM4Sm5DdVhydGFObWlOTmR5eU9CYS9YbjdKbU1maUVYc01uNHdmNzJiTUZteUs3TW44bkUwVU9kNXFPM0E4eVg3S0ZxZ3dqZGhubWUzVjBWNEUwNzVNZkRCajhDOHVseXJNV3V6bmIxL21DRERxQk15OGw5RzU4UVc0d0lUNW56VUE2U3RaZFpRNlMxaFB2TVEydXFtRkxJbGcwaGZzd3ViZCtIZW5jZFVwMU9sTU5OalR3Wk1sNld6dDVpVnVSTkNjUC9kQ2FUUVBva2sreWdpQkFHR2paVTgyWkdkcnR4cndkdXk4MXorL1duWlpSenJaNzloQnJMMmdLWTA0WmloeklTRmtlLzhVRCtWbjRIb1MvM1VUdUdXcXltL2JEcGljMjEyYXplQ0VEWlRQdGVEVWsyQW13alFDTm50TzQ0T2Q4S2N6R2g5RUFOckQ1T3laVEE3Ry85aStIaHNSakdYbENYN1lia3NBaG4xS28wMDVZODgrbHJ4S1lZaE5PVVVXekljeTBidWVpV0dIR1RzQmFDVUNQRVN1NWRuWTJ2THNLTytCYlR1bUVrdmYyNjZ2NDJLalJ4dkx1eCtsZmcrekJvSEpqYmtOUCtNdFFtbzZJU01oUFhIUnRtaWZueW5EbVlkTWJFeG8wbFZiS0V4Z1ZScHIybFg0RHk0RlFyVmQ3OUxna2dIQjUvSnVoT2JlZkRxUDhFZlMrKzRTZCtLRUxldWRNd2pibHEyejZKRXNmakQzVk12dVF5OTFNVmRVblVyZ0VMK0VldXBocm9heUF6ZktNRHBSTmh5QStma1J6aGN1L05sckw3Lzh3a2FNODdGY1JZNEdJV0UreUtIcHV0OU41VmNpaklQbEhBR1VYYmhDb04wZzYwNDBHYnR1MXBBSzVrUEF3N0ZKN3lRTjhrS3N5WkVSRGhCWTVvOTh0eUlRTWNySkhhTWsvVTZHZGlaaURxeGtneDhhVVliVzRjbnlwQ2l0UG5tV1YwVnBBRzN6TEZORllOSG9UTENBZHp1TXJUYzI2ejlsS3d0OEFsREZJN1FKRTBSRmJIRTFxczE3YlZxNG1FTUZDRUYyeWxVTGJRTG5aaHFxcGNlRzNmS3dBYnYzZDdJcWpVYUlZV3o2NDl0bUdyVDhUUXk2MDlpdVg3MVd3aHRERWJ6c3kwN1RZRVlvQVpnR2FrWmR3K0lTVi9icU5LandZK0l3WFhURHFYcnNlWjdmY0t5eHUwOFlITGdMRnVsTW1FYTJOMDUxZU12ME14a2pwUnpGWThkdmpjWEVUTzlKb1JFS1RETWlhaVNqVWFxN2hrVXJwZVd0QnRlaitjbkh2aGZ1OHI2ZFlmM2Q0Qkh2b0VtWnZPQWhDQ0FNdlhmazB3U2xGbCtCTndLelF2SlJMOHdqWHpQNVlHaGhZWkwxWGswSU9zZFBzRHVjZU9oSUM3K1cvYmhOME9yTVRmaWV5TUtZelFqcnU2RTlyeHd3aWFldW9Vd0xsQ0RkUEFHZTZnNkJvTmNwMHZSY25pa1FPYjBtT0ZNV25PQVRvejkxMEtHcm4wbE1kMW96TFJ5dmlBTkdPT1VxNmpkODZMUksrVmhxbjFNSDlWTG5ta2ZJM2ZONGJoaGhnS2R4MVBocitIbzBabm0rZkZ3WVQxb1Q5K0FGZ3duejRSdHdsMEFNdlFYNVdOc3c2ZkdGT0hVbHUzN2ZRbHE2a2lVUWs2QmRGUjJTbGJwcDgrektuQW0wYjNsNHAwN3c0NElISTU2QkFhelBqWEErZi9EUXhkTkhObjcvVkRiRVA0akJzdnJ0Y1JhSlBBcHpia1dETVBOSzAxbFByeDNKR0pzdzc0YllqS0p0M01yd0U2UFdySDJRK3lSYUlIdmVnL1R1aENnbXhUZ0lKaFJENVBsZ2tCeHNSOUhPUXBVZ2ZqMEVaKy9tU1ZFYWVnNmdOR0huWDYza3kzTUc0aVdzYTlZNFJKVkZFWnJ6Y2hvSTdjTHlVTVI1bU1aWGpCc0NwOUFxVnl4RUx1Ym50WkgzdzFpWXptK0VOakZqcndhYThkbXpMMlRGM3VlTHp6NzlvaVpNZVJIUU9wZzZDSmM3MGVqa3A5ZW5hWGtQRi9janNObnJ3U0pmekdNb2FzSlJZNk4rWGI5K004UDNhR1Q1eG0xcWYvSWhWS1V4MFZlQ09zOXpQbURhZHdtOS9JMkFUdU1LUGx4Nm1ubWUzMFlsY1BLZnVxcXhwTUdrYVphV1ZLT1gwbzJYOFkwaUZKS3NOWVQ4Q1JVVUR1eDh5V1hwT3dLQU5TZTE1NzJlQXh6cDFQUE94Sy9HZXlIdWFyd2lSbmlNQ1dGdE9RU1gxL1hnbXp1aVhmMTBiT3o2aENLYThJdEhJL3V3dUJjK0VUNWdqSFpIdTYvOUh3S2Yva0VqOVEzOVJTVHd1RmpOMEZrK3FrSHc5d0lxSGhJYnBaV2lwWFNoV3ZDZlk2V3lqSjVHZi9IaXBlTEZtNWtjSnRoNmxCQjRRc2ZpS1dhTTBNUUtTVjVNVnNqaEF4MnNpVWllSHR3cjRjSENuSm80RDM0SUluaTZlZE9aaHp0bDRnSy9UcVBoYmlGSmdPTWh2SVF2Uy91UEVnRWZPbXo1R3MzNUxjK0Q2UUFFdjYxeVZJYXJWMVAyY25YZnZOT0dHaWZkZWZodHFmYlRFTm9xRjA3aERGeUVzK0M5MEFJMzlNOXZzSEpmckh4Q3crbTBLMTdhNnNUVnFmQzRXZU02U3ZsSVZqYjg4czZQUjNHRHhYL2NFZEVWdk9qSjlRNGZ3aE80ZFZ6cXIxM2hHZlI3Ym9UelJoeEFYemgyNGs5ZlNpUGFGK0Y2TzBkSzNjMHc5RUdXQ3hNbUcxbHV2WnFoL3VGczllbm9IQnJNK3RIc21oWUJkK3RPanZuSjBNcE05bU1DS2hyUGpld25ZVE42cDU5WUxJRTV1cmxuR0JpRzU5ZTVnWmt4UzlCdDJYVzUxT1VYSDJpRUxWL2FJTjc3bFRCOUMycXhXMUNVelRvTUl1KzZrdStVZy9qcjZZSGQ5ZnJ0cHBmdklacThCY0lYY1JGVFFGek1UemhqTGczdVFyUm13K3gzLy82OXdBL09FRDdISmZIZFBYM3FUSHhscjFWOHc3REhhWlNZOXVLTEYwdlEzSEc2aFNPbzBva1o4dk9OZnBTOHVBV3hNVis3ZWlQN01mYzJvZHRXVzFiVjdMa1F3UmE4Yk1XdVM4alZwY01LTTFhY0VxcUUwSyt6SDBaMUNZVGxQRThEcWcvNTQvMDAxcjNmdkorRzh6U3VWcEhLcTcrY0szN2ljUTBqRkh4SlVYWDN0KzNBRVJiaEJiZzBZWHJwMHFYYVk0Unc5STdkVnFkdEZlWjZlSXJBemtudjVYOXN2MmEvYllTanprd0phS0NCd3ZQNHZNTnBBVlRWRFc0U1Y0UHVUaUl2SXhRMVpvS2hhSndPQjEzQjMzNng2eW5uVmpxTzA1VzN2VGRlZU9GOEtSMUdUc3daZk42TmFveVViTVNrNDZVczRIa21DamdFSjljK1c1MHl0ZGpjQzJ6NHlSNFoyTTJ6MVo4QTV1UE5GS2J1UnFYZ1ZBWCsrTzU4ZUxVQis2ampUL2dTOEpieTVPVWFnVmRhWm5DcGJxNmhPYTErQXRvTm5XMU1aZVFDVHZocEhMVndsai8yZ1MrZG5TQS83OXpCQmc2WGQrQVRwQlB3anVmcUZGT29mSFIyQTZzNFdFWTY3OFFEUDA4d3lnMzRSOERhWjUxZnVuZ0ZlNHFZRStIaGZIYXdCTDk4bXE3SzZoSFNyN2NPcFg4Rnc4YlcxcTJYejcvNEw2NWs0bU5maE14dTdKeW4wMmkyb3pYZnlwN0JxWGtZSnhNVDJUK0JrQ3dQamlDWlR5OUd0cmNFKzdPOWtSL0Uvbmd2RGVwb2hxbHNzQmlPMEN3Q0J0R0c2UVRPZWdTeVZrM1RFbWpNd3l6YW1VYU9JZXlGUUhPdmpIeFl4clZ0SWhPR05EUy9NV25NME9kUTBoUlJDU2xwa3BZWmhaUkJRT1ZpY2t4QmFBelRZeWpEeHNNUnJKandnL2MvcXM3azBzV0xaZGFnMmIyUVk2Z2VwSlBDVElMOU80cXBBck44d01UV3FaSFJDRXZvcDRGM0hHYVJuS09ZUnE5Y0FvN0dySUwyUzZBeHEyYllVcnN0UWUzWUxocGFjVGJ1enFXTDJodTZFUzJIanZtK1k5czFsZjMvdWJwQjBaVEVTWmFRbExqVEdPdHR2NndjL1BGT3llSlloTUplWEg3d29TdjQvR095OHU1Umh1VWF6ZVhMbDJ1U2xNQVY0TVlJUWw3cXZ4R2g1YUJhblNHL1pzTmhTNWRwMjJCek9LdVJqT2NENmZEUkR0N0xMTENFeGI0Vi9yWEczaU1uMW8zdWZMdVp6b1k3TFJoNG5FVGpUL2xzdTZxcG83V0hpZzZBNEhJU1N1RWpmNWxBMFB0c2JPYW5UOGVmUFh4dXNRcjZyZ2QrbXB4T0ZRejI1RkJHbVR2QzY4aEdkdG14VWI0bHZOTHhuc3lHVDU0TEY2bWJpV1M0d1N2d2V6eXdxS2Z2ZUpLMmpIK2tvU2thQ1pRUVRWb0MzM3R1bW9RZHZOTks0UXkrQ0RMZkJidTV5UXZmeVYrWkV5WStnVW80ZzZOd21QUjliOWM4NVRJVGVTZGY1UW5lU3lQUDJXcEFIUGdWci9JUHJid1RhTXVsRlFkdk9pSDBzUGVNVWNsMjlwNlJuMmViYTVWYmJQaWlCSFF5VkNmd3UrUTNzTWkzZU1YRDh4RFNiQjVkV0YvNzlrc3ZuSHRqUFFMbVNRVEttZlN1Vy9lek1DSkN4WEI5TTc2NEd0TFI5ZXhUSEJYdTRjTm9tVEZwSEEwekgwMWNOdVpnT3hwa0ZnOUVNeklNaFZnVFpUWE1NOHdPb3hpbTBxWlhNVC81VWtJaERKUnZKWHpjdmN6MzhGYVFubThoa25jbW85d1JlbC95SnFjUUNhUHMwb3hLaTJiYVNGa1pWaUtjRGdEaGlra1IxWlV5RUp4OUdLUDdiYmhXdzhFd3B2dStsUEhaSjU4dlBvNHZzNVZqTDd6d1luVk1Kek1rNVlOdEpsMFZ6cVJ4QzNhckE1Y09pc1oxT0JOTm04R1A4K0cyWXdvQjQvRUlJYmJDVHo3NU9POGp2REJ4a0dDUzcwRVkwd1pIR3BXM2oyUERLTE5HOGpSU2FUeWxvQWhDUTFNdllPUFpsYWZVcmI3bFhvTEY3M3JPejJYQXVOMElmMVczbVBmVGlHcWZsR2VKcWh6Q3Awd3JLWitnMGJCTXBpS0xUaEZNR3IwaUNXZWRXdy90dTZIRE01ckE5ZUZNSnRiaHE0bHNFUUpCYnpHS0JzbzdncTh2dWh1cW14anJ2VVRTV0ZNbTRjOG1XaTZXYWVETVdVWmo5bVZ3UjMvekhzbzNIMEZZR0NtcFd6Mm5qRWM1OWYxc0ppSGhCL3o0b1FWSzluMk9vSFNDRGcyWWJad0c5MFZHZytwbHNaSFZuZSsrKzM0cERiWFlJbkQyUVFTaFhPeFM2b05YYjk3SWFmUWxuT0xQSGRvU2VwWmpPMFdjM2Ryb2dkQkhyZHFjS2VYZHZwVkZNT29Xdmk0K1Q2SHFRVEJManpjRnNNQW40YTN6RUdqRWNBdUhmT1dGRW9TSlBIVTM0cEVIUGh2aE5qUXZvYllVZEZoTS9xNDVPMURiYVh5eFBiZnlKSzN5aEZJK3FxMUdGT3dSbXBTbkV0akJDZUZhTUNXK3RQSkhBRXFlZkdyMVgvSlFQeDJsdzF0TnNsTGUxRTlUcUQvNVBubTJkdDR1bnVvZy9DcDMxNnV2N3A5OTIvZis4dlNSSTM5K1BqdW1QWXhBdmgzQlpCS0xuMmpFWDltUkdadlpsRGRqaCtOUmNYUjFmZkZDdG5ZMFBMc1hJWWZvdkRvODJ4M0tUTGpqaEFxSkVaNTFva1NhZVJ3K3dvQzBPL3ByQ0JiQlZZMHV6QWV0R051aUZNdG1hUnk5dzFvWUxBUWhoRVBUYXFBamdBaHd6elJwaklDQjF1THA0RjV5TEYrclVhWSs2cVNuTitub0hjSVNJR0JIMlA2V1ZZTEJ3VWNmZlJRT3lpYnlzVHM3YWRwa0R5WnlnbmNta2NOa0s5SHd6c2J1ZkNlQzVVYnRwSWFoQ0swN3NVM1NCcGhTTUtQUkJ1WXpwTGM3MnRYZzBIdU5oQlo5Tnd4b0V0QS9weC9iVEorOXNvUmgxUzUvY0d5YU12Nk0zbFJDQmJNMlB4S2RvMUhyZ0VZTDdnYVZKRlcvYVlqd3RmZXFySC9sSFp3dVF6N0NKU2tDQXFGV2JXbFllUVB2N3RXUjVsMU5ZT2FrR1kycGFKQjNjQXkzOEFmWGhOcjk0SWY1aTREQlF6eFNDTVFhOHFkUzZJRkc5bGloUmVtc1Nwc0t6UWlNb21rRU03TlZ4WTFBYUI2STZTTDRGaGRNdnVFMHNFaUQ5cGJJdDViY20rSVRjRFVDaTdDbmdhNGZ5U3EwME1CQndGejZLQ2NteGRseVQyYVNialAwNnJwbnppUjFzYnF2TisxcGwwbUhIUmd0NkVnd1BPSHNEcGFENlRqNFM0TmxsQUo0Z1IrZFNRbmR6Tm1JaTBmRUdZR0dYOVVMck9JWnFlR1RFbktCeUYwNmpPTlpuWFhZNks0OE9QUk0yMVllQWYyTUp6cDlwVWxlOHZGc3pxZnl5bS92eEI5YWUvNnljQlpuZHFWTE5nV3JlSlhYYU54cFA4TzdPQmZQdU5pWXRTdHpHdFc1WnVMYUtzMTBFOUg0ZTdXcCtDWis0UUZjK0VsUUYzaXFjdXJOYy9Mbit0YVQ2K2NQN3YvajF5KzlmSEVuaE51ZlBTQm9nRngvTEU0eEtXS3pJNHRRbmpCOVpLTVpMbExIb3psYXFxdUJzUjFoRmcwNHF3N0x0RUdMWVpPcm5lVHk0Y0ZTS0s1bWt5UVRTVVdRTkNEQzJWbDRKcjh3RGJlMmFveEphd3RGSGdvRU04Mk1xMDhrZlppa0cyWElYQXpnemtaVkRUakV4QkExTVJVWU1KQ0dQdzBaY3hFZWhuamlNMjhRcHMzc1lhVHd0L1RuejE4b0d6TlRoMkczSVRZR3NKK0lvYmZHOHN1Ly8vdktuK21qeXM2Nzk5Lzc1YTlvRDhybVpuY3RrNjNLZUJSQnJIejF2eG1CWGNkTkpWOFRmV0RkU3RsRVNvWFVYYWlHMFk4UnpzdEd1SHp2TzZhY0JubGdKWFVvMlprOFZHYUpJN2dqcUVyd3B4Rk51cmxQSG82OVVwVDg2aG9ZZEJoSnAwTk5nZFhCR3JHSTQ1UnJncURNQzdFWkRpNW9vclFxbzVUQk1ZMFJmazluZFowRGF6VXNJd1NqR2J4azBreDZ5L1hoMkhmQ1RoNkcvcllMbmFYeGVCT3ZHa1doTnlIMGFKay9zQWMyK2FrZlhQQzhNZnA1TWZNS2pvbjZOUDdWMC9qRlcxdVBFSXlDVWFhQ0NGT0N4TWtrekJVNkdpWSt2N2s2aWgrMDFEZEN1c3JKWFQxZ0dJM2R0MDN5QnJhejhWVytmcjM1Z044eTNQQnRCcWVUMi9IaS9RaG5BYnlqa2NKN3c5OGpGZVZJWXhKTnZuQUxwL2pUeUVhb05NR2h1M1psSnoyNEpKeWxxVFlDdmdBb2IxZWx3U1Y0RUsyVFhqbDd1dXZDamZKOTN5dWNsUzEvN1d3dnJPSUpZdzZCenlsL1JyTVZKL0hrd1FWWHZYbHlPS0hkSEpRank3VDVLamM4VEhpTDY3Y0FYb0phdWMrVjVxeHlqNjdmK3Qrdi92emRmL0ZibDM5amNYWi9Kanl1eGIzbldseUhIcThzTHB6SlVETStuZyt6VzllaG5Vem03TXRpaWxzUmFMYzJZejg3RThUc0x0NTc5OTNTVkUvbjJKMXpseTRXZzl5TkRmcDJiUndmajQ0SXRGUFpNSVordDI4MXc2VWcwbXBBUXRpazRvR0QvSmlqM2U0WWxzV09GWVlJYXhRRG1NRmwyd3ZlaXdqOHNNTXp1Qy9NME5xVFNiTHlMb2pXOE5qQm4vbFgzK1BCVVlJNURWcURxNDIrUTNUTVNwTzFJZ3VESWJUZytkejVzNHVMcVlNaDdNMllKdXpkdTI3NEhaaGN4MDZuSGhGUW4zejhVV0JNZ3p1VFZXN3g2MzYwbmVIWm8zUnNFUlEzTTB5M3dRM3pCVC9uV3hteTNvcHcyWXlXZFByRW1kSVUrZkFhUWZCTHB0R0JrMllnVFhVa3dRMFhKbVhXNWt6RmVBUmc2cGFBRVNNSENpLzhiaE10OWFEdHFBc0U5WlZZd1VXZWMya1lzNDl6bXlGb1dKcWVobGtvQzVMN1Fia2Fwb2FqRVJnVzI5TWpzWEtKMngya09IQ3JnZWg4Mk53Sk10cXBpVEg4VVVQcDFJdVBzUU45Q1Y2TFRFN0VqbTl4aVR3SVBvTFMzaE0wYUI0LzE5T2gyZS9sL05sejJUWHg5T0pTQk9xTGVhYXhncFBXelZadFQvRStwNURaTFhiaGVEelFkbTNqeVV4aWg3Z3dWYW9aT01ObjVlY2UrSTFGNE02NWtvYlJENkpzMEt6M1IwczJhdU1UdnBZNUNJTDRacFoxT3hMcldIaDhQYkErakFacys5Y1NvSGdxdkFpVnpDdm1MV3ljUlpzM0VZZStPcS91eEdLampVWU9uOTdmUzVscm1RVFVRVENIOFk0aTFJM0NkRTRFR2Y2a1JXc0xjQVcvaERDNkVPZ3VkREtxb2ZVTDBpckRlK203UE82SWJmK1d6NUhNTDhsWG5JbkhwYTM1SWJnSnpzd0JHYTNnRTNIUWsrbkVOelQyZmJZcldBc2R4SDBtTkxzVDhKdFpRM3I4QTA4VUJaelhacElJN09wYzFVdEhvYTA3VFQybTFOVGh6bDBqa2NCU1BOOThxWDRORHhvYXZiWFo1cmtUenBkV1ZyNzNlNy85elQ5OSs4cnJpOFBSN0I1blFuQmZiQWw4TGVLcFhJc3ZlRWx3RnlKY2YvcnpuK1hRMWd6WHFtZTE0WDVtZ0hrdHBNZWpCYkVoWG91MldEN1NhU0M4SEU2ZDd0M2JkckpJcFJwV0JDVGswczR4Q3NNL2NWS0NOci9aOGhDZ0pnN3llOEwwMW9TQjNuUjZZWUthMEUxRzFZTVRkaHBINVVtYVk2d3dPcUZNczNIcDZSRlZPU1dBOG94dGFNdUdtN2FkVkI2QmdRSDB6a3d2dERQeGVWOFFEaHBpQmxVVlp5dnBhSG5xWnJKTU9YWTUwd2k5YzRDQVlYd05Md09QdGxSbW5zVFZIQWpuWVRhd3dZM2ZnanJqYkw5TlhOVTluOFNwQnBnR0lDaG43N1gzWFF2bGhyVWlmK2xQNTluZlBjdGJnR2ZoMlhlZHdWSjdpWUFyN1N6NFB4UkJMUzZoUmNNQng5U0I4TFpwbEhmd0M3ZmVDWEJKVU5qL1dYclhmUE5zNUlLdlB2endnN3JURnVWQk1LRWplaWh2SngyeS9LV1Z2N1RLOXgzOWVFZDRudTlvajNmOEJqTmJNZHN4cndrZEdxSHFQWDV5UkJnaFQvanlISENFR0dGbGt5Y2s0Z3R0M0FGSFJoRUJvM2lBc0VVN0poR1RqMFlVNnFJT0w3NzRZc0dETDVWakpDVU1icVZURDNtMnh0ZzJWdlVhM0lvckhsNnp3ZFBnZzBDZTBEeG1FbTg1MmttOXBSUGtEU2R3b1ZQMld6dElUUnFPRXM0dFhPVXRESHhnQUl2UWZOanB3UU92ejJCc29UcXdWdHNMTHl0VGVkcW1jRGpidS9vTkRzb1VvYTNURWg4OE9yYUJWWHhsaTQ5M2RQRFBhdXpyY3hEKzZPMjMvOE0vL2VHUDF6YlNNOStMelRtb0tRRzFFNkpZdGJVWi84MnloMktTbUNWKytjdGZscnNZbjE0VFlrZWptZEFXMTZKeFhMMXhMYmJZUGlySThlYTBJRnR4bXVFMkxHWFN1QlUvMyt2WjIyQXJQZkRxZ2ZUVWFRUVB3MVR5MjZFNTVDclh0eEMrdkRiU080OUxuZlB5QkVUblBsWDNNQUpCWEV5U08wS2FkV2JDTURucEczdTRSUTRhZ2U4WUNVR1pHRFFLQkpiWDdiaTVhY1FZZllheWVWM003MzE0dHI1SmR6eW1FVVBrMnhFY2s4ZXQ0R0UyL3lGb2hkWWNlMExzWVRveEFvVi9NdzhXWmh2MUlNaGRQRFJHbUdCa3p3TFlCTGI0OWlnWVFUa05wUVgwTk5xSlg0bjIvTmtybk5YNXkySEs4MjB1RGMzbDk5Z2NKWDM2UFZvb25JcGpIMlozK0FDLzl4cWdTNzI1em9HTllBVXJQTHNzN0xsOCtmTGlrMDgvSy96RHIwWW9qcmdFbVE1Z0dxcjNBNU83UzNucjBYelpMazNtV2NHb0U2VGRNUUd3R3o5NDBITWs4clNJQmsxN1VyTTdDSm92dnJESlY4aVJqam1uWHdjVytkOU14OEcrWEtlM3hQVVBiekhORUN6S3hHY3o0aXNUVDJpSmgrQU0zcS9HcEVFd2M4M1QyZUJGNWd5NG1RbHFDNStVcGJPWU9nMmUwVWJjcVR2YXFmUHdIaUUrZTEyTGcyT2tsYzRvRlMzZ1F4NXdpdzdpQ1ZPR3lWSFBiTnY1VTJscHJ3TDgxL3M4RDUrQVVSNSt0OUJzRTVMM05iTE52YisxVGRoemZ3dGVnaFA0OTA1NzlkNkt6Y25QbVlyQlhJMWVmVU1MOUJGZnZjRS9mT2QzWFFYcGMvTG4yOGVQLytTLytJZi8rSjk5KzQyM0ZuZXoxKzJoYU13YkozSzZoWjNab3BsdVJ0TzRFMDJ4amhvS2s5Mjg0NHk3blFVNzY2MjRPMzN5d1llTFd4RlE3LzdpRjR2ZE1PNk51N2RyZWZXWjJBNlpBMmdlYk5JOFA2NG5IaTN6aTgrL1dOeklSSnBodTRaZ1l5TEVjV0cwSmxnam55YU5tVEFNUW9ReTlRejllVlhQelZoTmtKMElmNFRVc3NwbVZ1a3lJWlh5WGZKeUtjUGxHVkVSdkJtbnRUWUN3N0Nja0xoejJ4QzFaNDE3RnQ2Z2podlE1dUtMdUJYeXhLQnRLNU5QczBiSGhtb3lDR3dhcUgxNXV5SEV0a3hUMHdrRlRnS0FrTjcyYkRKUTF4aDRNRHA0aEJHMDhxcXg0Tk4zM1pCRW16ckFrZmg3MDFTNnBPbDdDMTM1L3FmQ3hKMnlDK2VKNkxkbk9FTXpvUGdOMTZCV25yUTYxandtamcyRDJyL1hVTnBGTUREbkVKS0VGYUVKTi95T2VXZVVEM2ZTT2plT3B3d1R6YzBJTVJPeEJLQk8zbERjOEpid0VwaTh3S0ZERk5lZXpZTTd3c29GTjgxVE1Vc2Q2NDMrd1lzZUJBNCs4ZDB6amMxa1pkRWdmTW11VFNpb3NIcGJJTUdsN3NoR0RsZ0lqR3pvRnRPSWZ6eW1HanNKcWlkN1BLMlA2NS9Sbjg3QjNBVzRqUkpvd1RvSUNndWU5MXNkN0d5b1B2eTh4VFUzSXI2QUoyZmlFTjlPSGRTMzJsRmdaYmJxVGl3TE5NS1g2T1k3elZtK0ZBVUIzVnh3ME85YnVURVNGQWpoV1ZCQ09Jc0xsMHdud3lOVHZyc3lxa01PTG9YT3U3VnNNSFFIOVl6M3BOR0dwQk8wZmZGQzhvS0hLYzhJeFVuZCtWcGxvZ05GUnQyVjVWNXBwTXNsUERlYTgrVzBvVC8rL1gvNGQvL2xIL3poNGtUc1JiVGZTK2ZPTHc2a0FkeUtIUzUrU1lzWFhuNHBwb3lEV2E2ZHlac3c2T2I5dTdXMDlNVjRhenpNVVAyajl6NVkvTjFmLyszaTQvYy9LQzNYb3BTUXJ4azVtcEs5bEUzWUVPNldPWDkyN1dwcHpWelAySW5YWTlmajJHK1k2Sm1nbzVIUXBxM2kwdjFqWEVTa3RjeXhWNGpySTZJMHMvUnordVZpV3BwNmFkTmhOb3ltMFprOHd1enltOGFLTVRVU2pFK3pzeTh4eHBLbkJRUVlYVVBSK0tRRHMzMGpDTitQTThTbTBSMGpOREtrMHBnZTVMZDNHcDI5Rk9TbHNUTHhlRDRZUEN1VDVrd2dsNGRLN216SlljRjBacTBCVEwyNm5pMVl2YXRhcHo3ekhrOTZqNmtEV3NwNEpwZ3g2elFrengyNjhYaVd4MXgraXd1dDNxbHZ3OTZMZHZ4V1AwTk5IWmJHQmpmaUtuZUN6Z2s4aElVQXQzNFgvUWpDNUNNdlpjR0RlTDZaTkxVVjZ6UTZuUjFoWU5XZ3BlL3lFZTlrekFMZzhrMis2Q2lmd25kb3lLZGRQUG1BRFl5Q2h1ejkwYU54ZDF2R2tjL1EzSkFZRDRpalU5QUI4R1hXVWNBNXJQSFdvQ25maUZLaUk1MU44a1V3M01hUDl4L3dobUJqMXVGbmNwQTdZT0phaXF3ajFuR3J1MGxsWmFvYkdBbGdzRmhCcVc1NENDMTBSdW9JVnZWVVozWERpNE1IK1hubm10V0lOSEhtTTdoV3B4UmFhUWxuNVExZUFuVGxXNU9YS1pCd1R0UytVbXQ0STV3SGwvSlMzbHplRDMycm5PREFOKysxTzgrK3k5TTdBVXlDK2VxT2gvT1hkdko4OGs1ZU9pS2piN2I2NmtqVFpzYXNNVHdrYjVjZzNYTWhuQzlITUgvM2E5Lzh0Ly9OUC9tbkwzempOOTVZM0EvVDFHS05JRzR6ZHVGYnUxdUxreTlkWEx6NjF0Y1dhMkhRSjdFbEhzbGsySVdzcHJMRTlQMzRleEsyL0lMNVBmUHJwZUZvcU56cWNDSWY2Tm9qSXZkcjE2OHQzbnYvL2NYLzh4Ly8zOFg3djN5M0ZySllxTUZXYTJiVzBteDJQU2QyUXpabUlRdzBpMm5BQkErM09vUnlJYmlBU2NlREkyeFU2V3Z5b0RnQzBWbzQ2NDAxQVBFbkhZYlhHTnk5RjNjSVRxaGljbHFlNFNnNHBtSGZ1SHF0VnY4WkZSQVltSW1MMkoyWVJUQitOWnprS2RBSWpTQUlIQWVqMm1EZmlSYTEzMEhxVkV0Nnc2aWxUVVk3R01hWEZzUE5iM2RjN0oxZ01ndVRIb2lwYVJpVVRyODNTQ1ArczZ2VHorKzljZWQ1eW11OE5qNjg4MXZuQlEvd1BjS2lhTDZzODVONEpwZ3ZxRDA4MHNIeVZBQnU0U0N3TWQyVXkxUWFIVnM4WVdHRUlnNmEyMXNDTHJ1TTVvSHBQT0hWVUJjY1ZlOWxJd2VIVU5wdmFOYkNxeWVycEVGSDlZV2pyV3pPSlg4ZGpEcmhCMmdkNFlablorTjhuYkJKU3dza2FKNlZmMmlIenB1WktMYlBCdzJhNXdXRjRyTnNtS1hEUlNRYmFUbk5CT3dFdWpvZlNCc3lVdEFKS0k5SkEzeE1ZK3Bqb1JPdkpmVUJyM2Y0VFI0Q25JekFVd2RCK3FtYityQTV3NDkwb1hyVnNTTG1HL2poV1A3RHgzQWl2YUM4MXBieFU3VGEvSmFHLzdVdy9LQWM1UThOL0hZSmJ2TWNUcXQzeXZCKzRCell5M3daV0l1ZWlhT3NnM0cxbmZ5bHIzMTJvZ2lnay9NNGo0VCt2ZzhzQ2dDSFBBdW1LdkVyL3VkclIxLzRiMy80OXRmLytiZGUrMDF1Q3ZIbnZGTXp5eHRuVGk0T25UdTVPUFBhNWNXVjMzNXpjVFN6NVB2U2M1M1B5ZHl2di8xV2pvSFNRRExzRENQdGhzaTNzdnlWRm5VeThjNmVQMWMyeDlzUjJuLzNOMyt6K0t1Ly91c2M3L1IrYVRXMFZodkpiT1M2bEtYT3IxM0pjVSt2WEZsY2lNdWFRemVQNTVSbXcxMGI2NnpUcHRMQUNmajBpNlhGaExLb204MlcybWUxQ2QxTWdkRm9LNWh1Si9mNkZnTFNsdkZIQ1pMQVRmZ1R0b1N4cXhnNGVkSU9hTlNHcWZMeEhqT1k0QkdPWnNaZll4YkhOM3VJMEp4bGJsV2JvWjVobVVaWGpUdk1nbUhZbk1GRU1EV2JabWlheWRhYUVJd1d3QzVablZjNkJBMDZpVnFJNGVSbGFNWit4dnk0SEhPMmgwYUdpMHZCM0EyQzBHb1QwS1QvOHIzUitFeFl6L2ZPVTdrdDZBYzMzYUM3TTZTdEhjOEtVUGhsMGxFMzM3bnB3YWM4YW02Z0d1UEEyWjJEY3VBa0ZTd2hDZWR3REkvS1VrL3Y3Q1pvbnFJMnhRbE95NjB6L0FBeUpveWFRQ2I4RXBmd01FTGkyVkVhRmdHWWR5MmNld0hIME5JZGZLdVowRVpIbC9LOG43clVoRkxna0c4aXA3Rm4vNGQwUm1XdjFtbUd6MU5VMGtUQXh1V1VJc0ZUeEpKdjc1ZzRyUERVV1lWMUEwdWJFd2hrUXBWK1NKdW1kTUNkemhvTVhBWEJZZk4rSTZrUllnUVFuaUtBeFlQcm1mZ1d4K1didFBCSE9PRTE4ZFNWY0o0NEZsQjVCcE13OUo1OC9KWkhJdFYzdkcwRTBYbDYzZS9WRTQ2SEwvZm01Wmx2dEx5RXNlVjMzdjFPV25tQ1dYdFVSOS9odklScitGbFpSZHZnclBicGlhY0dmSUhOVmhLVGgvanFxdFBTUHVIeks2ODV2N2s0OGNxYmwxLytYMy8zbTk4K2NTRzI0ZHN4WnhCS3p1ZDZuTjc5WUd4bjUxNS9aYkYrN3N6aTAreks5c0VISDlUS3ZOMzRJTzRQUW5sbG1BejdMT2ZEM2JoMnRYeUMxelppRnNud2Z6T0xNTmpPUHZuczA5cWIxNm9vRFhBclJNVklIUHNONlM2Ly9NcmlWQVE4VzZMM0NGUkVESEVRekVraENLaW5keGN3ZHFqMmpLREpTNW9pOUZLb2JzZFBGQ0hITmFkczJTR3ljbWF5WXhqZEhaTmhoaW83enpvYURVSURZaWNGSzdNTDdRVlRISWt0VmYzOFp0K1Uza3BBZVZSRGlYRHhEQ2E3bVhtbndYQkRrKytEYUZzRUdiUEcySnhwWlZxMHlhQTBrYXFyUDRNVGR3RmVlZ2IrMlhCeC9FZnp0ZUtzWklKVithNjlZZDU1UGMrK2U1NXkvUGFzbm1CVU53SVpMbHcwT3dKRTNlMUpvWTRhaGdhcm52Q3BNUW55blVZRWJvSFF0THBQQnltdDM3N0pXM21HOGtmWUdaT245OTZOb05VUU5UNHVaOU1vZlJQWHFHWTA0Y0pSNFBlZXNGVWYrWHNQdm1QSHVuR3JtL1FhTjFNYW52RWJUY0dlUHhIRWJlSmdNNWFYemtFYmtaK2Q2OWcvallpWTM1aWwrRTAveUI0czZtWjFtNUVlbTdXNy9CM29LbXN3cVp0NzhROGVDVHpnWTlaUXZ2andyS3pCQVJ3UFhnckc0TFI0Ym9sTE1ISWRsSS8wdlZsWGU3M1EzdVhGVkljdXloWkgrc25MUGEyd3lnQXo1UVpjSmVienJlUDFDRVI2dnl2TnNoN2lmbGs0KzE1NWhJV2xRVHUvcTJ3ajdBUy9DV053cGVYVU4zVkk5SnF2WXQ0UUtHM3FOUG1JN3hKM2VPRXJMNXhmV2xsODQ3ZGZmLzEvK1BycnIwZUxmYkg4ZGc4Y3pvUk5VSFB2UUd5RWgzUGlRMzVkdlJ1WHVQczNGeC9mK0h6eHdZZnZ4b3h4TFRibW40ZHB1WnV0TDM2WjV6dlpZdk9kSDM0blBzRTNzdHFORU00UzJtaldsMTU1ZVhFb2pPNjZFVFBJQjFtNnpPZjNhbWJqNzJXQ2pmZkVqWGhzY0UvQ2hBSjc1TDBNeTJ3d1g4eU5BVUlnUW83R1pmUDFVTExpYW55MENBMEJnVHdMQnpMVUg4SjdaOFdTam9lWnc5Q1RzSEdOZG9FeEJEQndiMW9OZzF1NnV5OE5rekF3VTM4ek5zYnJNY3ZRRUk5bUdNdkg5MEUwUjh4elAzZHBsZW5ramFzNTVQVjJWcDJaREhRRWxZbS9uZGhpSHFiUldqM21KSk9hQUV4am51MGtWZEkzcTlzaUZkS0pwRE1LV0d4dGhHL2VsQ0JvWDlFV2RCaTBtZDdJZ2lhRDZhUEJoN25sVVJma0xZT0pJcDFiMmtxQzh0VGJkNDJzWkZIZCtaMXFVTXdOQk1IaGRlZEVHb28vV0p4LzRTSklNZ3lQcDAzcXRaWmh2enJZd0FuOCs3TkVlU2MrMytEa2ZwaVdtcXJwZEtLdHBlejB0eG0yQncvQitZTUlDajdEQk56Tm1JTFdOeUtROCs5SjhpaFBoMnhkeSsydUQ0TmdKa2w5UTl2MThBQ3RsM1pOZUppcklGQXRqMmJicFkzcG1MMDNxdkZjUS9YZ3l4YTJodXZxZ3I5MHVxZE9uaTY0dDBJZmZzMHIyY004TEZXKytIZ01leVJKd0djT3NKb3Zwcmk4NDlkTTRERkRiTVY5ODhDaFRBaG0zd3lUMncreWVNS2lMZjdmTkZVOHF0NzlySFBXV2RoUEk1cytaWmdPNXp4SGFOZlo4akVMWGFKQkowMXZYY284RVEweVFxMEZYUXRQdENlTUNTYjJkcU9RN214c1ROWSs5TkxZSXFETVo4a0ZYclVCZEhVSnpVT3RHT0VwTEZFczRrL1YyK2dNRGZzeVVpRzQ4UXk0UzloaVd3YmtYSVNzUEhVKzZsaDU1alBkYnNwMUFBQkFBRWxFUVZRemorQ2JvUHhXbkZJN3NDUkQ3WGc4a2VSVFFqbnZzYXE2OHNIR0x5UHc1YU1jQVI2OC84b0w1eGNQYjd6eWpiZmYrdFBMbHk0dE51SUdaMGV3Y3pseUNhSy91SjNKamlEd1JyVGR6NjVlQ3pNNmp5L0RxUXpIYjhiRDRzU2h3elc1ZFRXYm9sc2hSN1A5N1c5OWMzRTREZVpFekFJbno1M09RbzE0YW5DRGlYRFppRlpqUUdjaTVIYUVzNU5TYU5VbWdBUTJQWm9QWGlEa2prYjdRQ3lhTmdIcVBjYnp2SkVoTlk1QkJOZG9QQmdBWXhjRHA5RVU4VXA0MFFOTWVMUkp3NFFpN1FIajB4aG9jT0R5RG5FMWVvc1BocmwwSUxSZEFsN2VZS0E5Z1lmbmgzZDJZYXVSUVpqRS9nQjM0czFDY0JIVzl3eDlrN2MyUnljcCtISzNyYWM0Y0lmWnd1dXBGcTJkNW9CUFU3OEE3amRZcHI3NVZFRjlmWnZMNzJrRVNoSi9HYk51L2J2eE5vMXlHV0ZQdWk1WEhlRUZudVZwZ1lHQVJzZU9IUS90ZXlXZmQ0U0JPUEE1TUVRblNzcHVJdDAzcEZ5UjA5dUFnN0JFQndjaE1GbFlFRkxML2lNMG1Db0kyQktHeVplOThXQ0VBaUc4a3Q5bHZvaVp3U1NaVVkxeWRUaGcxZ0ZiaXUwdXdEV1kwTUV6WEduSWo3UForelRvMG9ZREE3akVGVS84U2hQQjJ0OTdzVWMrcDd6a2xkRmFDWUtpWTlPdUZnWWxENXNmbVJTcEVSRnRPZlROLzZUckNWL21EWG1ER3gzd085aDFBb0xmQjlPK0tBVzlPS05wWm4rUWdjL0VvZ0JtZGZJZUwwKys5b3ltWGM3M1JPajR1WGtIOThvWDhKYjBMc0gzcC9jODZzaWF4L2JFUzV5SjUzdW5iZnpKanhMa1hmTlp2Njh5SW1DYlhxMk55Nk5Hczh2OGtxcnBsSkd6Z0JhVmY1NHBLWGlOdDRhRlAvS3VQSmRsb1llcjB0WGZyL0NmKzJzcm42K2VPckhZRGdOK2N2T0xMQm5ONU1tMW5jWFBmLzd6eGViQnJFNjZHUytGdEs4RGFRaG40NVVSTVJDZjBmdlpxZTNEeFpYdnZMUDQxLy9xLzF5ODk5T2ZsOXZVbVdnTC8rYmYvZnZzZmZ4cFZzREZITERTTmluSTQwWmt1R25qY0VOaUd1dkgxejh2NHZLNnVCcU45TjE0UEVEc043N3hqY1gzdnY4N3hUQUVNMEpqWEwyOVFIK1FKNkdCWVlvUkVtY1lwWmtvUFhrWVhYNU8reVlXVERwWU9iY1ZJZW9aZzJnRUdxaExQaHFoQm9FQitIVlBFRS8rcDdnRkJuWkNuUGVBQUpZcDAzc0MyNFpJeW83aVgrVVVBNGFSbkkvbzVCSU1sNmZGeW5aUFhqZzdidUR2dW5YSm5xdXFlOHFadkh5YnVpdS80M1lqbG5yeTY1eCsvZStVSTU3bnZmSDluZ1pFTzRLUDY5ZDZrL3hYWDMwMWRXelRnM2dqMlBZSys4cHp0MjJhZFI1a1RuWFp0eC8rYVRXcGE4aDNLTTlwNm5tZmQ4SE5TdTdzMUE3ZXhTdmJ0TkdNVEV4QTI5M2xjZmdrcWxzNit0eGJkaFRNVHRTQWM3REFBN2l0SHAxNkVWalRFWU1WWGNTTGFBbGYyVmNsRzN3Ri8vYlc5djFFOXBiQkQzZmpDaXJ0Z3djV0VQSFZSb3ZnUE1VNzhOVnZXeHZ3VHhkdlorZlc0bEgyMzNpUXV0eUxKbnprOE1sczBKOE5sTkptdGpMQ2NEcUxjZytITDhHNHVkbmVKTjdoTHgwNzRZelhqZHoySDl3c3p3Mi9lWENvZzlONXFzUEFQL2dwMTNRd09rMTBtcnhXc2g4NkxYZnE3QmxPYWtWdXluZGFrZnE0aEtyYm5uWTBnbzhXTEozTE96eTNOOHg3OTBUNnRiamU3eTNIYjNWd1Z6ZGh2bGNleTh3bm5YdlZOV0M2K3cxbjZqc3dna2tlOG5QM3ZybHZtZGxYOGZab1krUDl0Yk1uRjBmT1o0OElIaE1SSENleVhQbk5ERDBlSHcxRHhsMXFYNjUwVlJrV3hjU1FpYkhmL00zZlhIejNXOTlaSElobThnZC8rSWVMeDcvM284WEphSm9RUXRXNWZQOU9yUVRjZDZJUHdid2RoMzBNUTdBZEQwSkxvSVNPdDNheTJDUmFwd2tLQ0wwYllXaTJtdUM2ZXZYcTR2SnJyeTZjZXVWYjdaY3IvekFZWnFUUjJZc0RNUkFLVXlMNEVFK2NOUGxLMjcxdUNrdzhEVE9SU3FlVFZxUFdVREF3b2R2RDEyY3JyOFQzN1dIZ0JDdll3ZWU1ZkZGVEgybmtnV2w4QTYveVI1c0EwNlF6c2NJRFFQQmUzR0VzejZUT01DTWJwbmYxT2wvcU9YZnhKMC9QZ2pRVDVsbDZ6NTFmMzhYcFBIMXJHTHdidk0xM2Q3Z3hnakFaQ2c4dWVPWlpZRWMyTkZWZjc4RXhEVzdnRzJGQUEyWmlzU2Mzb1d6MHRKTmVxeWFVTWt5bVlUMjZ6dzgzSk5MNVJ5TlBWMU1kSExQRG80d285c1VPa3FpeE8wWnpXbzNwSWxvcms4R0VXc29mVTQ1dFFRVzBSUk1YdUVhajlINWd0cW9QckJPWDhETVJUQkNpN2IzNDRjT0w5MTNYeHJXSlYwZEQ5ZVJqVEF6aEc3eHpLTEFlaUNuUU1XLzQ0OGphMGZCRyszaXpvVCtNYTUxUm5RM0JOc0pUTjdPbGdmTGhGSHhNRXZnYVA2R1pQQWhzUzVmQjdEMWVmNWh0RGRUTGFmZG9hU1V1NVdmdGNjTmhEeHUvUzlqSGJxK2ptenFqbGZxNjloM3BEbGhlWDZhL2NzQWcvK0dzanRNQzNudEJuQzhIOFFRZHJlOGRwL1B5ZnQ2cHMzTGd3RFh2aHorWlFnWU9NSnI0bGtiYmtyZTZLR3N1ZVFoVC9sZGVPTC8zM25zUFAwOWplSmlhSEl1UTNoZUM3OFptZHY1azlzV0lrejdiN3Y0SXdhMGc2a1lZZGw4MDJhTkhOaFl2dmZUSzRxZC85VmVMYjMvdm5kamtJdkJvb25yRHFJeDMwbWpzbWZEZ3dNTkZEbzFmbkRnVFcxNW9hS2p2VHNCajFsTXZuSzdaYlFLZFJvMzVhTkNmWmw4RkRhS0l0Q1JjTlpEbEJBRGIyYTJZREhoT0lBakdRMFNoQlhRejNZNWw1VUtHa21XN1RlZGluVDRta0xjMEk1UkZRMVRseUFNejdFKzl4QnZHOWw2anhSemlnWmZ3b3YyQldaMHdmZVVWZkdBa2UveUtyMHo1bExkR25xWGZpcGxvR0VrOW1pbUo1NGJGTVAzcHU2UVJsNDNXTy9HSEdlVTkrWFQ4YmpnbDZwZmZ0SmVwdDNZMWVZQzFjZFlOYXRMTG0xbkFiM1VpbkdncWN3QXFRYUlPZ25yS1kzN0RLL3dkaWl0VVNpckJYRGIxbEt2KzhueThML0VqeEE1RnV6T2tmZkRvYmd1NENCT2EzUUYyNHV3S2g1K2VaQ2pQeFZDWkRpQm02eWNNTjIrYlpPMU5oOUJpWUdmZlBaN0ZVd0lCQlRmVHNiaUxoeGFQNyszRWxHVkJVQy9USjVSTm90bWJneWE5dW5xemNVUFREeDdWczNBWW1Hak54NDRmcWUvZUVkYTJneFhuUm9RdXYvL04xYzNGMGRRWC9vd1dINFVYN21SZm10M3dJQUd0UEhXUzNtaU5NTVpEVDNFZXN3TlRtNE1vQ0ZpWGZQQWcvTUs1ZWd1ZThabjZDZWlISGdUMzBLTkdLK2tJRGovcDNRRVBacVF5dlB4bC9nR0RkMkFMQ1N0NHJ0LzU1ZnZlWitWNWgzdWxLNXhubFBNc3paSi9LMDd6cjIvU3VmS24waWhJV3ZYVG9mc21udEViMTFuNHhZdnNmMnY3bnRYZCt4SFc0Q2laSUxPdmVqaDE4c1MzejE4NDk4YkZTeGVDZFo0RldkRVcxNkRiZDgzQ1o3Z1dBanVnMVNTTUlabHRQSzlmL3dJK21VZXpyZVlIOGV2OE9CcE9lclY5MjR1cnNWVy85MmtXWldUakdjVENJTFhQUmxaUGZacEpzcXVaVUx1VllkOXVOQkFuUWhCd0pjelQyN1BMOGdubEwzcHJhUU5HclB2NWhtQTJuMEVFQkxPRkorWkVRSGE1SWZSc1pjbGtoVEVKVDNENFM1dXRtZWNBTGo5cDVDZWVjakFyUnBmL29RZ0EybU5wVWRGb3ZNdWZpaU1lbXpPdGgrWkg0OWV3eFBITkNqWGVCTHd1T2o4UXBKK3dxMThhcWJqaHIxekJUOG8xNmRhSDNSYmZWVDRqaU1QMVhYYlNZN3d2WDNuOU5CU00rVlgzNVhCVXZVS0NwM2trbDErSlg5OERoelI3ODRZYjlXZlRKVVJzalhyeDRzVmFzaytiZG9RVHZMbWsxVUNrbDg3djNBQ2MvNjB4RTh3YURWb0hwS3B6bW5GdGVHUmgwbW9XTFptWFdNdUtWS2VqMkd6ZXlyRGpKeU0wd3lPRm40RE8xbHBIVnExRVNIS3pURENYNENnbzJqaVBDc0xPWnZqVG1VNG5ETllSWkU2cFVUOUNETXp6RFQ3d1JKM09BMTc4RzE2UnQ3UjRuamxrTGRwN2lGK2RpM3BieXUyanZWTk1NaVpKcFRYcUV4K3NZTFFxbExmUVd2aFgyV0Fnd09GUC9tQ0Jwd2NQK3dCY1BPdDc0N3BIamdTVWxZZmlpUTgrTUlqam5maVBNN0ZwSDNYNUY2L25Xd256NUtjY2kwelF5U1ZJS3kvNUNQTyttQ2UvQzBkSjIzQ2t2U3pUVDduZUoxVzFJemlzQlR6SlR6NnluSHhyWWp2dndGbnRKM0UwQnZIQXhjU2xMT2FqWi9DWWY5RFJ0K0JQNUhKdFZLWTA4RmhsTHV0UU1LckVWejFrLzUyL1hGM1ovK2ZIVHNRMEVTMWhtdzB2TTlHM3IzMFJIRVJ3NU5ueWJEWTRRNDF0RXpmWmw0RDk5RUYyWDNNUTZtWTIzdi9pNXRYRng5YytqWjB3TStUeDREQmJqVEZNK0ZrSFQvdmVINFl1VTBudXA4NmNLcHVZM2NnMHp0cFdORVJocjc2VHhTejI2aURvUXVWQzhjR1lWMmh2Q0VaN1BwRVpmc1FWdUwwOUpYNmVFY293R0FNWUFtR2EzaWMyUk1jcDRjY2hxTGdDNXNERWZudW1hWWhEKzhJd3lzWnczaW5MYkRWdEI2TzRkd051djJqbkNwNDVrMlhIYVppWXg5Q2VDNTFONDAwT3FSZjNMRnpieTJsYk9KZUdFTmlLb1RGb3JvcXpoRW01dzdEaUNON05WUy95cCtBZlJxNlgzZUE4U3RacG53bDk3eWNQZDBHSEI4NXVkSXM2TWNRemQ4ckVqbG1wdGVDQnA5TThHOFdreFFYV0ZwNGdoWC8wcDBYRDFlMElNUWNNM0Ewdm1UQStGWGZOMHpsazljU1pNNHNqR2NxZnlUTUJldnpVOGZKcExlRWN3dFhPZCs0aHNJWU9GbnhHSU1LMWxZdDJTYk93aGVhcExNSUtYZFhISGN3bUU5V1ZVQlJIV3JTV0Y3NWlUdWpHM3packhZQkEwRXBiNTFvR0graG5GV0I1ckFRdWNLQ3pUZmQ1UnhERWZXSk1UQzE1N2tuaWRHU3h1U3RUZVlRbXVNQUJKdkNtaHRXSmozbE0yZXZwdU1SaC9uZ1FRVi8xVDN5NDBlZGFnVHZIdyszTDN0SGVGLy9objZSWEgvQ3E4MDRVQlh3Z3Y3MjhWTHlqVGtzK3lNZjY3dmRzdWkrZjhiQUFsOSt1Y0ZiRnJmeVNUdnVUVHZzVTZqazA4OTIzK1M0dndYdmMxL24xdmVFaDdPWFIrZU1seDcrSnAzN2FuenBWdVlsVjVlVCtsUS9YcjkrNnZyWjY0UHE1TXlmKzJKNEF3Vm1FNCszRjRRemZ4cmJHTE1DdXR4WEJ2QlhoN1hCSFFwUUwwSzM0TTkvT25mdGNKT0ZpWlgwMURlLzJZdk5HbGkxWG5OanVnaVZ1UGR1WjRHRXFPWkp5cm1hNXFrWmd1R2JyUllTNm13YXJRV2xFMXRJYjNOQjZ4Tk5RTVRGN0dtSWNqOGVBTklnVGtoV1RTYWNSK1c0UlNqVzZFTTBRbmRtbHRKLzg1bzlhRElwcGw4em50NFpDK0VySE5VcTVHSUJmSlcyTWU1YTh2Y2RFWUNYc3hkOGJtdG5TejZkRnlKT25nM1B3SHNiVGhadWd3TDdQTHR5TkpWcFpOS0dBVW1uQXBLRVJJbVduWGNMcDkxd2FNeWFjMzU2RnFVL3RlWjNmM2lkV2ZldnZIZWZwaTRralhxNUpyMEhCTDIzUEVQeEl6RmxHQ09wRE82WEY3RzNZOGh0WXdEYS9nNkEwNUpTWit3aHJPeHMrc1BkSmNzbkxPckRodGRkZlg3eHkrWlZzMDNwcGNUb2JBcG1mWU5hQVM2TUxMbVlhNThGeXhZcjJsOUVkZnFnZHk5TGhvVEZURUsxWFBLT1U2VnpRY0dpTGRtaHBvUWg4b3cwdkNndE1ZTW9vUmo3MjNvQ1AxcGo1SHpldXVZSXBjeTNtUDR0VGtrVnIwOG1YSUhieXoxWmczYzJSOU9XK0dUNmFQWjVEMWVXN0tEaGxaMit0RjB4d09RSkdIUTRmT1Y2OE51V3FBLzlwT0RieVluUFdVZmc5TkN1K3lXL0MvVkRjQVdmMGhSNWMvdHpoWEZrRW5OL2F6MU1CRGlITDhKU2ZDUDRFdjJjYlVHVkNudlRLeEN2MWJqbGFFeC9kMU1QN1VaNG1yblRDd0k3cHB6enRTYnA5VWY3VVdUbmxnUldhMExQRW95VDFvcUQyc0lFM2VhazNreGVaMGEyc2l2bHEvL253a3kvKzNkYmozWHRIangzNXlVdFg0cGNjWCtjRFhJM1NnTXpXYmovT0tya0k3TnQzcnNVZitiTUk0Mnh6K0RCcjlyY3loTXZkaWNTT0hES1VkSDdnNHpEZVpnNkhkZlJQTGNrTzhVeWtIRTdQZnpoK3JKNGZSMk02R2czN2RPeUQ2Yy9qMnh0VFFvVDdQU2VJeFBTeGVpU3oxRWZ0dnh2aWhGQk1JSmE5MGk2WkM0NmRQRnVhOTBvWU81S3NHL0ZTS3hWbmZ6b0NBWk1VRTlFc0NFUE1tWXYzUjIvZ0grR1JiM3lPZlpPM2ZhYTN3d25za1NhTzdJZnhLTHZJbVNRNkd0OXRET0RVY0owV2h0R0F1UzB4QVpWemZMU0RtckFwbVJqN2U0UTY5Nmw5MFJ5VklsLzE2bUU1clRxZFJScUp0a0YzMEhoV3N1TE1uc0k4SFBBeWpkUEt5ZklicG4ybWp2UGV0OVF1akt1aFJzRG4yd0c3L01Gc2pIWDEzYmZrWGQvemgyMVhuZUdBQUdWNjBpR1p5Tk9CbWh2QTdBUTBXeWZjMmFtdnRTQjE3OFpEbzFFYmpRWmU4eENQbERTa2RQSlBRcmQwSWZrZERTcUNUTFVmcG94SFc4cUtLSXd2OGZHY012TzFiMzFyOGQwZi90N2kwcXV2NXp6QkV4SE81eGZIWXZ2bERiSHBCUGgwRURvclBxOUdVRFdDQys2Wm5uaS9NQlhBUUdtS2FhaVdsdThQQURYOEw3eTJ4d2tCM2NJaVRUZit5Zyt6Ynd4ZmJHNkJqM2UyVTNaT3l3N2ZISWk5L0ZpMDQ0T2hvMTNwVEFqYlYySXRncGs5MlpGU0s2dVVBNTBVM2l1cEVRaUMrN1NiOHRIZGp0MCtRdG84aHpNbVY5S08xclBUMnVyKzRDU2VFcVRIa1NQeHAwNjk4TmQySmtsMzkwZGp6clh2UUFSTXlNZDNmaWU4cGRPb3ZhampBWE5vTFV2L3Mwak9pbHhMNDdudGFXTndYSDdoZ1lqWlozL3MrVllab3JFdEFrcGpUL3ZBUDBlQzJ3UGhwZHEvSmZpaktPQ24yaUV4Y1l6cTZsaXc1T3RRQW9kZHdPZU9JNHgyaWIxb3JOa1BtMkxoUXY4eTN5U3VBelBzWEdseVY4UEM0L0tmRVJOWmo2Y0ZrNm8yUFVNVCsyaVhkaHo4NTJkd0c1bVJCd0o2Mm0yVkZQN0NzelhYaGRmeUhjL3FpQ3owWVJiMURNcm5KcnovMFNmLzE2V3pwLzdIci8vV0cydW53bndQNG1WaDl0dEVIc0hDQm53OS9zblhibDB2czROamxBZ1JlMFNVMlNJVFhJaGs1WnFGQ0d6Q3RGMWFDb1FaaHZCZHRrbU1ubkU3bW1ScHhVR29IbFU1R3JnbHJEY3o2ZUV3VHhPRm81M1EzREFBd2VPUVN0b0dvZ3FSNjhrakFpT01wZUdXWmhBaXl5OXRJaUZpeWJNV3ZBeTBtdW41ZmNNRTdoT0k5anArS085bzR5YXUrT1NxRi9pNTVOR3l3UzZmeVdzMGNyK1RhOHhBSm11a3oyOWxMTmtHakg1TFR6QXpkNVJ3VFF6QlVVWUVJNWdxcjl6OW5qcGoxQ2xiWHVKTXFEaDc2aUxlWEFObnNQWDAzZFIvY0NDT2tZdFJBc0ZzWHNDUW44YW1MSG50eGRXVVM4alBlN1ByR3E0R1d1K1dIVWZWTmRvcDdKeU42ZUtOTjk5Y2ZQK0gzMSs4ODg0N2kwc1hYaXcrMENoakFLbk9uZSt6VHRCRTJoTkNPT2h4NTl0ZUk1aThRQWMyMElJdHNCdU5XY0FFWnU4RUhjM1VIZnlIb3hoTVhZYU8rSkUyRGw2VGo4d2plSWRRM3pqYW16elZvcFh3c3BOYUtsMitnd1BmTncwaXJyV0JDT3daTVlIWlFoY2REQzFkK1RzUmdEbzRXOGMraUd1aURsc0grVGdMZWJqZE9ZTVNISEJlSXdJanlhUzFSRno2dTV1OUhXL2hPREEwN3RNM0VremhLOElVSHd3UHFTdmVkSUY3bG0vUE8vSFVYNWsxOGd3czB1QmJZUVFsN2xUUC9lbGtCTEFJTFVSYkc1ZE91NU5YdlUrOUJXMXo0ak9ibFpQQWttZmtMMSswclRqSllPS2lnV2R0WEpBdmVhSWRGdTVUM3duS2M3VkJiZDQrQi9lLy84VXYvK1dkTzV2Lzg0WFkvVmFqZlR6WnlteHpla09NVFJOOEZHSDlHSjZEN05VSUQ1cU5id2hzaGh2U0R1VmNRZStPSG9rclVUUmx6elNiTkoxcTVJY3k4WU01eklyclFhMllTaXNPRTBWSWM5eFBvK0oyZEREQ3V3bExFUGFHTm43THo5SldEQ3Z3WThZSnhRanBiZmZSeUFLSElhYUFRVnQ3YkFMNzVoMmlqZzF5M29rL1RQd3c5VG1VVG9vTDRHcktmWkNGRFdrNUJaTzlwb2VwTVUyVm5UamRPSnRoMVdVcjJwaDlkU3NFWi9zanFMai8wcnJsVWN3SVRCcEVOQXpmazRzWEJXTUoyZnhTYjBFNUxxSHIxUTJvR2tQZWEyRGl1cGdDeEcybTdvNzBHYlBMN0ZuRDhsNStybW04NitrTTRhZUdpTW5QcEtCdmd2d0hqc3BmZGt2WXByeGxlM3hhUGtGRUFLbXpPS3VodlEzbXYvbk5yeSsrLzg3M0ZtOS8vYmRpcW9pUUNsNGVSL0NpdUxoR0tWWjdPcm5rUWVZaW10Y3NNSW1nQzYvRWtCVXpWUnAwQkFKY3QxRFE2VFhQYU1Ed0F6ZG9QdWFOYyt0bktpOTFwa0NvbjNqS3c1KzM0ck5zMjA3cGpNNVdzMGpMQkRtLy9JZUJjWERWUXJIeDY3dnlOaEpuLytQZUM1ejVqd1ovY0NVTFk5SlJTMWMrdWpHbjNMeEY0MDlua2pheEx4NHNpNGV4bjJlak1iN2VXMGZhL01MbjJRWlpxK2tnbnNUOTlOVHBNOVdPZEpobDNnaXMrL2RIVWNtb1RONXd5eWE5YzZpOVBIUTIzcVBsMU4xditCTlhYWDBEdDdqcWk1WVdpVDNEZFRxWGFML2EzdkJpb2hXKzVJRk93eHZKT0hSSVhjTExRdUUrMnJaNEU5ZWR4NHY3bUczY2gzZUhSNlJ2dnZMa3VYOTdCamVZMFF0ZHhadTYrUDdjQ2VmYm03Zis5YldyMXhmcmI3KzlPSlNqZ0F4dEQyZm9sQW5EYU1FYjVSWm5ZVUFOSGRMekQ3RTBraFlRTFJnUS8yQjY3dlg0VEh1MnI4YWplSHpRYVBabnlJZ1pDTmlaTUVOTWhFRXNTTVlnelVEUTNNVEdXSWEwQ0ZMNTUxNGI4cWNSbHFranZXdWxEWkc1M2JSbzd2VCtJbmdrZHQySCtFMzRGbmplcVlQTE14ZzFkTUxKMEhJN2pRbU1KanJaM1FtRXJVY3RZREcxNWJDMEhrTFowRTJISkxDejFobUlpY3Q5VGgwSnFhb2ZZUjJZdkJPSVpVdWNEMlFvQURaaHZ2bnR1ZXJ4cGZkZmpsc0psM0VtalhwTlhsVjI4bk9mNy9LZGZEeHI0T2psSGNHRjhiMkhnNEZGMnNvemNYNzlYUUFJTGFxc1BHcTgxVkhsSFh5ZGpFL3g2NjllV2J6OTFsdUx5MWRleWFSZ2hzN2hBMFlTb29NOUh3enkxUUR2THhzZ3Vzakx1N0dWRW42R3grQkw5NXpVK3ZzMk9WbTZMWTJKeEl6UE1uU1BQMzk2RHZVQVc5RXV2SVMvS2w1NHozMHpxem9wSEpTSTlUV2VGZTI3Zm5URHFUZTl4V2dML1BZZWVoeTN2c1pGZUN3MGxiOVJ4NE1JT1Q3TkZwQ3NaREdManVEa3lTZ3cwWElJNXRYQWRaQjVZc1ZrWmVZejhuc3I3YTM0UGVhRWd6RXgzYitYZVphWUNHUHppRXZyemZKbUl1QUw1dkNaZWl1YndwS242Z3p1M1duaGFyNEFMUEFGbDNBblB1M1k3OEVCL3ZCT20rYnZUWXNuL0IxR0RMOXdJbkN0MVFaM29uZ0k4aERrNmZMYlJUbWFkL01lako0Ri9id2RLSTJ5dTcyM2NPNjhFeWNtTWUvN1d5VkozRzQzNnFNZTZrOHdUenp2WE9yeTNBbm56ZDB2ZmxZcnBiS1B3c0dzQU5GTVNqTk5nMW8vbXA0MU05amNJTmo2TURVOFF3YkNlVVlVbmdrbGJDTjRFQjRpSWR4b0h1R2RvQUtaN0hSTUZobzlnY1k4WWpKZ0l4TjlMN3dZd3F6L3FuYUdVUTVuS2JpWmNydThIVm1Ma0k4UXJCT3JEWmRDUDhmWmcwR1pUNTRNazdUUUJaT2g4VENJWmRmQ0NJOWhKT25CdTdyU1poR0hpTjdMelA5bUxoT2g5WjJBVHAySEVUQisxV25KZlBKU250SEF3VEFQdTZpOVFweFJsMXlMUVprdzJ1N0wvdDBDVzROd1Fua3dWN0NOUUFYendQMzB1V3JjV3F3NmVDOG91K0xrK2RmUzVCdjRPMjdqeVROWTBRSGVmRmVYelRUS045NTRvOTQ3cldQQ3MvUmRsdmVkWCs2QmZNck1ZenFaN21RTngrVlBPSE9USS9SZnlCbUFGclNjeXNwU2VXNUZFRi9OVnB1RXNyZ0VCZUhNbEVSZ29RbWVjNVpqNHpmYVdyeUZ3RXFJUnEyc2ZJZ0t2OUZHbU1ZT0x2aFVGajVVWnhmYUVaZzBWRFFkSVdSUEZQYnUwMmZQRkU5Kyt1bkhTV3MzdEp6Q0hoaHZaSDhabXIvMFcvRm9ZdC9sd1dKQ2tkYVpWbEtta0ZQYnA2b2V6dEprRTZZeFZuc0kvVGN5c2dUL3d3ZTAvNHhTb256c3h1ekhQSGYzWVh5ZW8zVlREcHAzb3QzR05NTDdpV0IybGVZYy9GUmRxOE1KMzZTdFRpQzg4QVo4dThESzFOTXVocjB0Z3ZkZ2VJcnY0QVFmSE0wV0NkNnpDeGVPbzgwUFh6Y1A5RWpac3pMbWtyYmFYK29qU09QeVhkd0ozcUhIVHVRQTJ1Ui9mWmZXYng0dVZYN3VTVm9CL24yWFY1M0lGQnFySTNyT0pjOXFlMVBRODNKLzd6MGpLTHRnWlF2RVRNZ1JLcnVHMzBzQ3JHWkNJek1LR2VMRkxoY2s2VDFwaURSQ2dSMUx6MTFDSnRxMEhyY0VjdElqREtTUktaRFBpQzk0TmlSRENNL3RHUkFILy9oTWU1ZUlSWkJwYkhySzdlbjFJd0YwSWV4dUJEUHhwRGQyU3ZmdWtxTERCSWdXNlZ4bDFIT1YzbitVTzBSMUJ5c21ZR2VtTldMbzZrUXliRFhrbENkQmsxdmRUWGJ3NS9YYjVUZWIvTDVzRE1WUGVDV2poUU1ITXVsVDJnUTRDREVkaFU2cEY3M29jQ0plMG9lbEZrbDNJRENCUzFsekRjamU5M0Q2bVlDZE9PNzFIUjZXZWJoUEk1bzg1dTY5Ny9DTFBrK1pQRFFtQUN4VGh3T0NVVno1dTd1RXVYdWU4anhYdk1UbEgrOVovdlpuR1Y5MUFnck5iTHRxNHlzVGNsZHpNczd0bTQ0dGEzZEZndkp1Rmh3UnpqWThJbHpReFlVZU9reUN0ZmdxQXMxNzVoT0N4cnVCUjJNR1E5RXdkYTNHWGZDMEdRSzg0Q0hzZEFqei9WWmNJay9melQ0eGNlYzdGUE9lVllrNnpvQmRjZkhLazhBdFh5TkNrN0RLTVJweWgwdVRrd1JnQ2Yzd0NEeGN1L2JGNGtoTUprZnovdEFocm1EWHk5WnFNeWM4YjBTNG1ZNUhHdk1yWUhOczJhSFV3NEVQTnpJeGUrSGNxVEp2Y0VVMVVXMmhqaEhCakM3VGVBc0hhQWNQNk9mU0podkc1cS81UGUxTG5YUStPcGdSanZoZ094cHoxU0U4ak9iNEdwNkdkK1RwRW55dmVpemZlVDk4TW1uY0I0NjZMODJReWJEeXpHMTU5N3V5VFI1ejcvejlBamU0NEpwc0FBK0IvZHhwenI5MTZkelhYMzdwY3BndFE0UHNTTGNheC9yVnc5aFJBNDQybTBtNjNUQ0FVNmN0dXk2aEdOdmh2aXdJQ0Vtb29iR2RFakM1eDBhb2dTQ0NkUHlpL2ViOGpnRU83TVlNRUVRYTRwY0FUMGV3VTc2Ylpselg0M2JYKzFuUTNqVTZrNDZJT0kyekpvbUlzMUFzTElJamFtajdPTU5aWVloZkRTamxJZHIwMjlJZzVEVGd2VXd5Nyt5c0pzM2pER2ZsQWNidFJ6MzB3d3pEYkZXbmZKY0hSbkgzelhPU1YrZDEwQTVuT3BGOE15UjJyeXNRTVFsNUZxcTg0TmxjeXpDeGI5N3Z2Y1FkbS91a0V3K2M0bFVJREh2VGdNazEzOTBudnVlQlFWckM0RmdXQWhGVzZqcXdUSU5EQS9HOXIyOUowL2wydzYxeVFodHhIcWNUbXAzdEJzYkdtUU03ZThuK2F1eXJ2dDJKcDQ2R1JYTVVSM0RuTnJjdmNjQTdRZ1E5d0RhL3VUbWlhUUNwOXpSVW1oWTdjSHVZeUd1MHVlNFE1VWVRNzhVRm1OUnZPMmFIcTlsdjQ4RHFoOW5NSzZhSURQVzN2b2lGTytqMU85MURDV3VlUkR3eTBGaTlMWUt5Wjhxak9nbWx0VTU3WHl1cjVtMWlEaU13elRPc0VYRDVaOEdVL1RyMmx4ZUQ3VmNqYUNMVWRRSmc4N3dkTXdzY2NVbVVmdnRrZXcwUi9QZHQrQjg4d1lkT0cwM1VTM3lYemdOc3RyMDF5YTZUc3pwUzN1b3JyanA3RDA3NVc0WHI5NUZNaXVJSHRKZEhHbjNScGVCTk9lSXJZKzdpdU1RZkd2byt2RktKODhma29DQ09ieXBiYlR0cGk2ZnllK0FIWjVXZCtQMnRmdy9kOEF3WWRUN0ZBNG4zM0Fubjh5OWUraE1iRHlFNEZ3aDI0YU1oamdrWmhPZEpZekVKVnhaSWFHMng3Vzg4T2lDVGlZS2JVajZXSUliQUltd0VVYnM4OWJEdXlhTVdDTE9oRVVLTmNKT0dHV1J2OEs3eXozMkVnKytJTmdRYnM0VzRRMHpQbFYvaVRqenB4dGFMT2NSMWpmRHh6Z3BBNVR6T0JJM09pVy9yYmhxNmI0OGplQ2NObUlZeDNaV2xISFdCazdXSE9YazZKcUs5Y1V3TTZaUUVXNGNHc2x4K2p5RDJyaHRtUFN6LzdLM0wzdm9ORE1vUWZKdTQ3Z09yKytEUSs0ay9jZHdGOEd2SUgzMzBVY1VuQ01XZERzM3YwaFlUcjNDYU5QSnRxTHQ4OWFxeTBpMjVUNUFQWHVLRndXLzZrMDgvV3V5UHo3Qjg3c1dsalNZZGRpc05EN3hvWURjMjVkSHlYSGFvTzVrZEZLK3RYRXU2MmV3bzIyQWVERy9FWEdCa2dwWXVvZmd2ZVFrRmIrcXByaTc1b3RYd2dZWXV6djY0c3hGU2RxKzdmUGx5N0x6bnloeUFSaWV6dmVqdTQ3YkRHeVVlaW90ZDU5ZENTSG1iTVhXQTMzRmt0UHRhZ0VRZzdXdmJ2VDFFNFBOQTdNMTFxTVFLSC82TVduZXlTbllwYUpnSTRZcmdrUmZ0V0pyQkJUb1FTTDQ3bkFDZXhRZC9sWjMzNnFhVGRRZmp4WXNYeTJhdER1cktaQVZlYWVTanp2SW41S1VKeHV2T0hiRHdGeXJMTzFrdDY5dzg0eDFhZ1VrK1VmVUxudUlCa1pkaFlHUERwOXpwUkF2ZklZLzBMcUVVdnlvSC8wNWJhQm9xeTRqVEhUK0JWNWt1NmV1K0xPKzV1ZjNvblcvK0gvLzluLzEzRWFwWkdSWWhwSGVFMWpveUo5cEJPS3MybnpFcFp2OER0a1NYN1FjMUdtRTFaZzhUYUNiTjJGU1pRV2pPeEVZZFRSU05kQ1ZwQlEycG1DdWF1R091Z3VvYTZ2WlFXRms2Z1AzeDZieFZCTlRyMDVqNVMvUEpUUE5DdFJBeVFqSHBtVFB5dDh3UllZM1V3eVJjNEVCSTVhVWgyenludHFnTWMvQU9lSng4VENhdGhEbkJnd1hkaTJtU1NGMHNnSEFtSGliR05OendEcElnS1pOemYvdGh4aTgxOGJieUx0RFVudFhKS1hqS3Zyb1pJdDZMME5rS3J1Nm4zRWRocUFkR0o1QVFtT0pnRWxOUUx2WEpjeTlPVVJOMWl3YVJxK3FxRXJrOEoyYncyUjBEd2VLNUJFVGV1KytFNmVGZm5wVnZHcHQrUU45Wi9TZVRWVEpUSDc2aTR4L0tDNGViMkdaOGJPK21VVnYwVTVzWUpSM1RpK2Z5T2doZGRkTEU3dVNwRlRtaFJqa1BNOG93ekYrSjhPRW1TQkRVZnM5SlFhUGR0Uzl6Vk1ZenAwL0Z4ejBIQmtkUTM4OEV0TDJXYlh4MS9iT1BTcE5tMXVBbVoxTHUrdFZzb25VZnZyTjRLUzZOUmxoY3g3YUNTejc1M0xGcVFWTzBWN3ZlVWZJc21Da0JuaCtwYXZBZjIzbzAxcldNREkzK0hEUkxHdzRIQkI0SFJVU1R0bTlEWUxUVVhnZHkrUXJoZkw3dzZIRFdjM2xta3FwREZGTHVXczdZWlBJTDI2VE9LVHMwMzd6VFpna3JDZUhVSXBsNzBWQ0Z0WGhud0FtemllK1hMbDVZYkVRN3ZuY25SNXZGVExGL0o2TzFDUHhlc1p1T0kveEdZNTZKNUhLWHkyLzdZSFBYTTNsWkk3SXcxR3I4bSszd1o1RU1JWDg0K2JxTVdIV0lOUHBhdFJnY29ZbEp5OHVYTDVmUVo4NGdrSFVtOWhteGNSUGV4bCtQc2gyRGRyQ2RlUk0yZHUxd09qUUNXYWVoZmJnSVI2TUN3ck40TVh6bzJRakdkd0tVY29SZWVWMi9kVkJrd2F4QzlIN3k0bmJYZ3J1VkFYblpzbFc1aEQ4QjdkazFaVDVYbXZNN2IxejVyLy9neHo5ZWJHZjVLZjllcm0rcDg5UEtxdlQwZWhnTVlTREdWY2dLMGhIQ2UvZEJVaEVIQXA4U3FOMjg1QkhxOUlTRElhakdzeFBoRnh1ZVBKbFVwQjF6aG9rUnd5ejVZcXBFS1EzTHNMVzBndW84MHNqS2JOSjJLRVNUVjZhNVVsZ0VWdUtZUkNTQUIwNUVINGFoZGN4bDhuSHE3SHVrWHpOSVd1RHVhb1J5aE8yRXAzVk1lZkl0WnNrS0xRMUtZTHFnUllPVFlPUFZJVWduTHVISjQ4UnYwaGZNNEJYNjNhL2ZEZVBuMjhEcFB1RnhoSXU2eVd2SzhXM2lnTVd6YjJBV1YrTndoOTlIRVJJMEV1blJmWUw0TG5pYW9PdVlRRkFMR3F0MFZUOTFEUDVVeXp2ZmRMUW0xQWcvc0xCck91U1Vsb2ZPNG5nV1gyZHA2RDE3WlJBZWYvTTNmMU13RUM1czE0WjFSbnd1ZGJnWDd3YlA2cURqUVVPZUUxTi93bFhIaEM5M0l0enR1cmk3azNTT0Q4dTh5K25zNlJHUW93UmtMNWtvQjB3U1V5ZkM1L3JTSElBMWh1YnFBUTRDZW5pSzMzNHNXVFdYY2piNC9qU2JaTUdmNzd3ejFGRzlDSFR3eXN2aERQdFN1THByaTR0TWZ2UDZpUTRiWElYSFVnNWxDRTdFMFRhR0p0SjdMZyttNVh5TjN3SmF3Z2Z0R00rQmwxbkRKS044ZUduWTNFcjRKSWRoZ090MnZFTzJzbWdvZlVYNEk4clNNaDl3cXdPY0VJcktHRDVxbm41bThxQnN5Rjk4dVBPOHhWUlZKWUcxelZqb3RySnNNK0tnVlYvTnR6cDFRVm1xTlBWeWw0ZHlKenhYd3ZuNzMzdm5mL3NuUC9sSjltdk9rbVFNbThvT0l4TnFrS1VYblhjSU8wanhEb0UwV0wyOHVQTnRrS1lSaUlNNFQ4eG1SMk1VanlhckI5MDFMQXR5ZC9JK3JhVEttWVl0ZitrUUZ3TmdUdHBCMksxb2dXWTFERW9EWTFjRW0zSUZ2WFVST25ISGxtbHhEZmprVzk5eUYxL2UwcnFjRnY3a1lNckt1eWZScnQycFl0S0JxK3JxV3dtZTVBWDJmUGRiWFA2d3RIbjdnR2dRTHBPdHZqVm9tRGZ4MCtESy9hNEVIR0c1RkhXNDcwdEIyUk1LbnVVUFRPM2FpM2ZDaDZCWHh6Ymh0SkJHUS9IWS9Od0ZlUTErL2Rid2pDakF5WFJGTUV5OUczYjVQck03cFFUSktpeGxjK0dCQUJrK3NkVDQ3Tm5qaTlkZmYzM3g2cXV2THI3MmpiZXEzTC80aTcrb2Q3Lzd1NytieFJqM0ZxZHpkaVVCdGhHdE9DQkdVNHZHRjYwTlh1MGpyUU5aaTgveDJYaDZmSlo0NnVDYmNreUNnWE1FUjhoUkd1cEdoRDM4TXkwNFZhVlh3NFhXRVlBUFkwb3d4eEpSbUpGOHpEZEp6MFBuUHQvcDBPTCtvNTNGdS9ZdnYzSWxIVXBXczlMSWd3UUxuMGh2RzRFeHhaaTA5SHRmdklUMng0ejEvN0YzYnpGK0g5bWQyUDk5YnpidnVsSFhFU21OcExsNmZJa3ZPekU4amdNYmdRSGJheUFHc2pDU2w4VUd5RU9BUE9SeDM1eTNmZlJiOXMzN1luaUNCTEVSWkczRFNIYU1kZXhaZTJ4NTFqT2pzVWFpN2lJcFNpU2JUWGF6MmQzNWZrNzlUL2VmTFVxanNSM0hIS3ZJZi85K3Y3cWVPblhxMUtsVHA2b3dUTXpUSUtFZXpncDUxTXd2K1Y5ODUxS2s2SEZrS0RveUtKMDhrUVhDMkM2ajhmbjVISWtRQnIyVFhZYlphakNaVDU2WWxyNnltNEhkYkcwek9ISGVqWFp6MDcxdi9aVDFnMzZCRmdOUTVkZjBBVzU0d3BEUnA3UkY2eG1NbFF1UDRzQ1ZBZExpL09xenp4UU4zYXJ5Y25OUmptb3dlSnRkTjAyZ0gyblZSUi9YUmk3RDVhZnNQa3BBUEdtYVR2T1IvNE9wZ3FQNlkrZ0VMRGkzNy9FYmcvb3NjeDUwUFpoeXcxRTBrRnBYZmZQOHZuQS8vdWxQL3RmLzFhLzhsNy84b3ovNW4wNDJzMXJ1ZGx1MHhybUthU0IwNkpUWUgrcllKQTBPd2lFS1FqVXNCcWpSRVhnaFBKMm5tRUU2c0ZIV2o1b0JjN1pEaUsxek1XZGxKZDlTVDZSbE5LeHk2YjVJejNZSG1yTHlyMFhIYWI2a0t0dGxxN09FS0lWVFp6QkpRNmI4aGFlWmszZUlJWXk1OGtnb2VDdCswb0FWVVZaWTZ1T3BianBlU2VxUnlNVkhnSmlPSFlMUzJOMWxtb21hbktwbjZrNVg2SXdGVXM1ZUpDa3IzeHNZbFR5RmgvQU1IUmczcWRwVFZRMHdmdXBkZU9qM1BHY2RmS2UvbHZvZ3lBOVB5dHdnZzVCMzZnM1NlZVdWOTJxVHBOY0dpTGJkYU5NeGlIcWY3Y0R3MEV5Mi9aWFplWG5uNzFtL2FWdDRCNE9uOHVCSDNtaERoOFY4bkRqb1o0cnM5TDVQUGZ0Y1dXbDg2NXZmaktvaVpwTEI3d081SlBqbEYxK3NNblQyTjNOSFpWMGRGaHFRQnpnZWZmVFJ5YVZZZVRqb1I5dWlxZnZ2dXk4cW1waUZoWkVjalRsb1hRMFcxSjNJcGNHMjRiOGJDVGlBbFJySHJNMGx1OWV5dWVoNjJyaE1Mek5WdGhrb25DdjRES1BQQUxTWkFjTkFaemZqbzQrY0NVM2txRk42NG9pU2RPRWt3REtQeStGTmhhdWtWOSsxbEdtbks4ZXlDYU0rR3RqZE5rUWlkWmtzdFFHVWthNnBXRTdrOW5GbmZNRFo3Y0NwTDRHYnFxZlVWdnBjd2tJbHlYWFFTVEd5Zk1tZkhoY00vTWFBclBUQjJFanoyZ1RSeU45T1RjNTd0Mk5MOFVNaUg4emJvS292YkZ4Zkw3cFBkNnlCeDdWYTJ0UXNScHRvSjJYcjMvd3NKUElEaTUyUkhMNmg3ZnpnY2REWXFJZDZnYzhXZldrR0tUVXREZjR5S3h6aUFSelk1RmU0VDFyUEtyZEN2dy8rL0JjLys1Ly94ai81MGY4a0l0UDE2UFpXWXVPYWxkb1FHd1FGWjNHRE9kQ0JlUjBNZVVncDFiQ0pBU21ZTXZXRVp6dU43MGV2S1U0MVFKQnZqLzc0VHN3cG95ZU56YzFIekFpeW5lSld4TFRmc0VPeTFSaWtab1E3VnNyVDJIUnlHVVRxMEJTTUtuZG5nSkdsZ0pzeXhLMHlJbG53cDhQc3hjeHUzSW8vSlZqRUlSZk1SWGlsbjFhbzlOaVllT2FxSkYvcEFtdzZqOFdsb1U3aFI4ckRkQzJNNlhnWWRUSGlTQXFwWHVvZlprY3lERk1wSEVmOEwrYVdRU01sMXBxcUlvZGZ2ZmlzYi9IYnY1L0M0TG1KUHdqZmY0ZEhQM0c3bm9YSDFGTmI2VkNjc1AzMHFiLzQ4aFIzMW5VKzdUZVY5ZXRUMVRqbE5VM29MUExHWUExc2I3enhSZ2FYMjZYVytKbWYrWmt3dUszSmYvZ1BYMDE1enBzNG12QXdtK2lmTWJIUmtYY1M5OUdpTFl4RFhndXhLUmErdUJnNzVKenhyTTJZa2RsaFNOcDJwa1JaRndWK2xnY082SGRtaURQRHFWT1dzcE4xd2NhUDRDa1RtaUEwQWtQYTAxR2VDMm5iK1J6WGFGQmZYanNlVmRoT1hWb2Nxc2tBOEVBRzJGczVZK1ZZWnBscjBZSG5YSTYwYjlHVTQweFNIbm9wZUF3bXNkUzQ4dDYxeWZuY1BtOXdQbnYyYk8wOGhGUDFpQ0JhK0czR1NHS1Y5bmpzd2VWam9FVGZWQzEwOUdhSkpFaHFGcmpVZGtXdjFiL0dZQXYvZ3haRzM5TmV6cXJRSnJvYW5NSWpHTHFONUtPZHhLbCtITHpRUWIveCttc2xhVnR3eEtoUGhDbExZeUNRcnpTWXREVHkwMmVxamJMd3VVOC8zZS95NVBnclIzLzFEcDVPZXl0TWx4K2I4WTdyZTZRWjlEajhSeDA3anZvMi9SYnRWZXA3L0EvenVmLzJuLy96Lys0TDJSVjQ1WjJjRkJlSjgwWjBVaXVybUxQUmFkckFRelNkZGw2U2FhOVFENllDSWVJUEpiK2JpTE5vRUlTUktvdFFwNk5vNVFuWmFmeVNtQkZMTGVpaHVwUVc2c0hvSENaVUJKd0dkeTR0dmVIUkVJYUdGQytVVzQxaDU5NVd6aUtnRWpHeUZyRmhUQ2s3UGFiaWpMTnJ3d1F4OU9SckJDOW1tVFR0bWdsNXFndmorMklNbWQ0M2s4YVlkUmFTZEVpcndtOUU2aUtGeU05T3lOTFhoa2xiSEt3ZGc0RjFNM200eU5SV2RmSEtRaVU0SUEyWmZoYXNCY2hnekY1MXdyczU4SEhiN0tTTmxOcW84QmtpVDFqL3cxd3lEdFRQb3VvNDZCOERUdmxnU0dmamRDeFRjSFV1ZktjdWhRdDY4UnBBdEFXV3EyTklBY2RtU2VnaW40bkRyOFBUNHZVK1RuTWJlY1dqY0NYL3h2Tk80TmY1Ly9pUC83akMzT2F0VTV1WjhMT2dCTmNZMFBVd2F2cFEwaGg5S1Q4THd1OWxRZTFVbU4reEhFYWxXSENSTkYyNHlpenQ0WWNmcVhqdjVwd1lkMXV1UjBwKzdmVzM2NTdNbzlGeDN3b3p2aG4xeGMxSTBIa05iTkc3WjBjZ2ZHNUhQY0RQQ1hObWVXdWhQN2ZFbjQ1cXc0RmVXb29xd1MrMUM1TWNLanU0MWl6YitabnRjVmRqajIwZ2NjYUtQUUptRHNGbXBHYzM3R1NHRlgvNFQ1S1NrcDFqeldSVi8xQjJOWEhDNXJTSFdHbFlzMGs0VnE0RnN5R1ZqbllkVXJPQldodU5YeUVvZWFBSjdVRE51TjludzJ3eFYzMUhmRzFnRnNoaHlEVUFCQjdwdGxKM2FoRlBBd3A2RjE5YmFUOVAzOVJpKy8xbUtqRTNYUEl0azhPVTEyYU8rMkdCUzc4Yng4R09RYjRYQkZ0eUhuQnJKclIySUFqNEZsYndWc2c5L3VlWGZ1R1hubi8ycWFmSGpSTkJiQ2FpTldXRHJDSTA5WXNxdzlSdU5QVG9ZS2Jka0ZnSUNWS0VhVnhwTkE2R3pHRkFFS2J4eFJkV0VrNklaQkJhaUNnOGNuVHBudjRvYjBpQkxBNms0NVRWdjRJUFl3c0RGbzRwVmVQeFM4ZGgvcmVqc1pKemNraGhpWkdDaWpBenV0OUs3d0VYbUxsbUhNcjFYanNqazRhVHY4SEd5RXovbkVxRnVDT0Zoc21wajkxS2VKUXR0amJrU0U5Nks2azRNSkNvaHpTWDBUMWhReCtzVHFNKzhTaS95Tm5wUFFNSDZzZUJoMVB2V2NkdW5GL2pScnpHbVdlcGN0US9kZlFOOW5ZbGFUR3VqWlBIYkRwK1ZYK1ltK1l2ZkxSdDA4RDRGbGVZdXJjajlYT20rc0lLRjhHMzlEcE5TMmdQUFh6ZnVOdzNnK3hpNGxwc3FuTWtzdEhqaDNMZVJpektKai8xVXo5VjZYL25mLy90TEJ5K214dmlIdzJ6eUNseG1aWEkyNklpVTdUQkJFWWQrZE9SMTFrbHBSOE9MTEhZTUNpK2x3MGNIUHhySnpzekNRbGpzMVhhTWdPWEdZZmpORy9rWkVVRCtaVllYZHgvS2pmSFp5QTVmLzdWbkxVeURoNjZHUXNKRmo0MWlPU1VPZW92Vmt4ejBUY3ZMTnNza29FajhHRldhTjl1eUhjeVNOQ25QNWdqVWFrQ21MRUpNMENhaFdGMHQyOW45aHJwZVM4V0Z1T0dsUnppTktXbld5bG5YdjJDNG00M2RkZWVmbkNMSHNYM25lWXJQS0VSZmtVcm9TOVBabm55YVBxWERxMmdFNE9mUVpaNnd1QW4zOTNvbURGak91ZGl3QkdJV0lwc2JBejFwVGp5VWgvNTFCMlJlZklidDhXanp5bnZTQjJhdnNYbFFpMEZGemk1N1Z4ZVduU2E5TnFVQTIvL2RFM3YwcmNmMk9GRFhRYjNxV1QzNWgrNjVsLytwNzhZcWVSMGlERkhlR1pLNllBWmpiSnhhNzBxZldmTkJzT0FqQ0gxSFl5K0doeWlxSUs4RCtMSVJ4REdYeU5CbmpETUdSUENSb1A1S2tLZWFhSFN4Mm9nRGVKWC9vbmhYVnJmbFhjYUlSeTRpQ0hKRWpZWTZ2YmUyUHdpVXcxbGdiQVlFNFlhYVFOaE1hR2JpOGxSTjdxNDNHeVpwT3d1Qy96eWtGYkg4TzFjalNhRU9qTWpRUENyMWYvQXFRN0NWVXJhcWxQZTVXa0FVKzBxVHd6NEJNRFVZWFpsTDk0ZWVZcC9oenRRSHhkZUdqOWRoNzJTdUVaNThLYjhybzhPWk5kaTRTV1pxaGRZcGVVOHgxR3ZCdHN4QUtneko0MXcvaDIvQWc3OVVWNjNlOU1DUDVJdktmTGRxeGRySVZBWVNSSkRvTzdReVZrUG5EcDZYeDNzVHhyRHRNVHhqcUdoejZXMWNSQVBPTXhTcUtGMmRnOE9zSC9vekNOMVByaExndGxzdjVkZGRVejA3RkNrWGxnUGMxVW1KbVVoa1E3VERBR2RobVZWUHlnVHdMUnB0V0ZtRWdZUGVISjA2NjJiNjBXSHB2V2JXems3SmpoVUZ3dUdZR3FjbXMwVXMwMytiMSs4Vk16NWRNd0huM3pzc2JKUU1aTnhUZ3R6dURyRkxuVmN6V0xvaWVXSGFrMUducGcrQVlucXBCYk5BN00yaEUvdFVjd284UnJQbWdMdS9iVFJiRHYxTnp4N1J4c05xenpOb2l3RW1wbFVXK1ZvVXFxbUIzSVJOTHlueTVXL21hdnlXemhTWittYkx1VEwrUjVyTXZXNUR3K3BIMFcxWVFDY2k0c3JjT3JWTkZjZTB6OFZSNzJTZjlOWDExUGJTT2Q1enpQblgveUZYL2lOSjU3OFJCSFArVGRlblR3Y0prMTFjTzN5cGVqVXh0MXhGanhVbmwzaFhGYXlJTjJVYmo2Tlc2ZUFSVUxkRFVJZ1pUSFNHTjN5ZkxZZjcrUmMyb1hZc3JKaExRS0szc3pUd1RQT1YzQldMbW1CMnczSGN6TUQzV09OL0dtZ05IMDZ6bGpCcGUrNlJXV1FiZFJnT1JvaTJDMW1Qd2pQOUhFdng3MDUrOEpJWGhKSXBOaktPd1J0WlJraHpZV29MVGlOampUMGJYTko1M2hGOXlQU09aS0tVMFJJWlZoWmJFZlh0NU9wc3BQeVdGdlVXYlFoSWx1c2IxZ1FDbXczRTA3Q0owRmpCbkJrdW13THVTa3JwczJmcEdiMElsWHVCSmRxWHlxTlpPZXJPazdLZFV3akxIT0ljZGJ0ZndlL2xUYVpkSWRMNW5LUm1Rb2tmTXc2ZHRLUnZKTUkwMVZxZXJ5OG1DTll3NVNLb05NMkdKTjh1UGt3SDh6QUFKd2ttVjZEYmd3Znp1Sk96ckhOVGtCZU84M2g1MVpHbUZxRVNwWnU3WkNxN0p1OXhCMkpEVDJWUU91ajdZSTdsa1cwcTFsNGt0Zmo5eTlPWGovL1V0SER3dy9sSUo0TXJKZkNLT0FXSGExdFI5b09EV0NZSk0vamtXZ3RySm1PTTh0YmlGcnVlcGptYTdHWC91bFAvZlRrNnkvOFZXN3MyWnM4ZkY5T1RNenV1a3RYTXhoY3VKejhtTG1kbml6Rkt1TzlkM1BuNE43WXJSaGxXZlM2c1dJZ1NHUWdaN2R0OGRmbWtZY2V6QTNkMFZqUVk1OWNPUlU3OWx3N2xoa2NlcVpPb2pGQ3MxWnRGOU5PcTFsZFg3K1dBV1RLZlA3aXo3K2F4Yitmcmh2dDZjQWZTSDdib2FIWFhuazFSN1hHMWpybWhaR2hzMEE2N0kzWFlvMXgzS2w0UnpJbzVtUzZIVFNaY0FmL3d3V1R6YldvZ2VqUDUwb2RCTjhRalJyU2NnYWdwRER3K0daaHNoSVZqcjQwaEluRUNYM2N6aUJuRG1vd1NaWVpKTEpXTUZWbnZIc2xGKzhtUGZ6dlJMQmk5ZUw4WkU0K2xYZmFUZC9TaDZsMStKVktZZ2RQT0tEVFdoK0s2SXYyMEpMamFSZVNWdzArZ1kxenBHcDZiSDR5Q3FzTlFJd1E1bE8rNDBvdGdCczhsYkUwaFdzcGhXaUh6YXlkM2RQTStjYys4OGxmK2RLWHZwU09tbk52MTYrVWZlTkNLblk5MHhiRy9iWm96eTJrNFhPdm9JWUxsb0tVTVFwYVRLc3A0ZFNjaXRTYTBDTE92UkNMaFMrbVA0dEJLdVNGNHRQaE1Na2czbndrUHdjZ2FkVGQzRDFJSjl3N25JYTY1R0FLcmdGTnB6QlhVMEdqY3hGa2lBZWgrT25NZnQ2VlYxSkJPbk81bERXMmlhZU0rRm04a1Y1Y2trYXh3TlNQMnVKbXBySkllcFFSZldjNkkwSnJ2VnJaS29jQmw4UVFuU2xKem9yLy9vQVNOTldHa2NDeU9TMi9GZ1NuakZtWk9CckdpOGtlWm1nRDRJTy8rNHg0NmpYNzNXa1BZdC81TnNvYWZ0SlZPK1JUT3ZDRHZYSFdlV2tQdnlvbk1QOXRuUExsWTBDb2ZMMURkdHBEcDROaksvUG9ocTB6bXROdVMyRVFidDFtYjZ5ZGFsQk5IdDQzTW8wRzYyb2FhU0YyNUcvbG9DVG5ubnorODAvV1pReXZ2djVXRFpMSE11aGN6V1dxVkF0dTY3NzBqa3NDb2xLSnZmRGFrUk5aMURzemVlZnFhd1hmemRoenJ5dzd4M2xjZktvOFRwdTNkRlpsMzl4T1diazZLakNZK2RWcGc2SHZVSE5KbG1nVWsyeGNzci9HcUJ3U3RrMzRDRDR3dmJyUkplL1BQLy8xdXNuK3pFTVBaNDBuWm5DVEMxR0QzRmRsMzh3aFdkdXBsOE9RYkk0NW11TjNxVWgydzFDUlVORnZSbC82ZGZrdHhYTTM4SS96a1MzVUQ3VVB2SE4zb3h2d2RsOHB2S2M5MUYxLzgxeUxKUWw0ZS9BMHk0QVRhZmd0aHhFMnZhZ3ptUFFEVGh4bjhneGNoR2NVSGFTdHcxVDVzV0JLaEhxSGw4SzVSWmEwYStkSi9RZDYrUXEzTVkxTDhrb2ZOWHM1M3AxSDRXWEszTzlwNXZ5NVQzL3F0Nzc0RXo4MnVYVHhyU0I5YTNJcVprSmJtZnFSaGxlY1l3QTFDemtMZGd5T2hUZzJvS2l4NUtqUXNFYUNtRkJ4T2xxbU5FbGp1dUlZUU55OEdrV0hEeUp2UlFkTE11WTBFR1FUdnZEMW5UUXF4Sm9xRlJOUFk4eWw4Y0t4OHo5aGtiYTNFcllaMWNzY1l0OGlsY2NnUHJCWThSMEh1R080MG1VaEpnVWlPTEQ1M3I1bHlqb0doeUtFd0lDQS9CQkR3U0E4UDRzd25KUEFoaFFRSFZ4MHhxYWZCcW02R3k0RWpGQjdhcndWL1NXSncwNnprbWFUbm81VFBVbWZtRkVSWlNwTW92RmVXSXgwV1NqTkoxeFZIRUhCNDJ5SDRuUFlVYSswNnp6Rzl6Ui83Ukpuc0tFYmJhY01NNTJkdEVlWHNkOU9PbEZCR0h3VmpKM3EvYy9Pc2FNZGZsSU8yUElMeDBVemxYYzZaZ0N2ZW1ibXNMcXlsaFBmam9jWmh5R0hXYUJEdWx4bW1OLzV6a3RWS0JwemJyaTIxUG1sc1Zzd3lvWEo1U3M1RXlKTWVqRU05MHFZK2NXckd5VTF6NjhjeTJKaHpxOElZenQzN3R6a3BaZGV6d0NmTnJzWjA3UmJlNU5ISHo4MythdS9maVYrRGdIS1pjR1p0cE9lMzN6ejdkRERKS29UcG01aFh2bFlwSitPaEJiUmZmSmVCSmNMRjkrSi9waUZ5TW5nTHpCRlJGdzdHc3NOekRuUnpLQnNMd2Z6dXpldTVKa1pTczZlY2FPSzQwYXZaRk9IaFdKM01kcDQ4dlRacDB0ZFlQTUhHQzVIdDc1eEk3ZTVweTd6aTltb2tRNTQ1RWd1cVFpZUloWVhqYkhQM283T2R5RVdKbkJKWWgrMG0wVTluWXBqcjVrMk1EZ0cwSW9YSWsxL1NIOU1TS2dlc1lhZVMxU0llV0Q2Y281ZHdKeUwyV1cyczVVd1o4c29JNTRVRDZYV0srdVJxQSsxTGRwcHhpeWRRWGNJUjJOd2J4cVRCK3FhbnhJdTAwY2tMQTJycGhCYzVWVVg2NUthMDkrNVh1c0s0UVFYOGhpdThwdjJnWHBQWFRodFZ1MDJvdDE3ZjgrZE8zZm1SMy9raDlQV2FhWWd4c0xEVHBnTlJ1VklSQXptdHNiTjl0dmFxcDFHZ0FEYk5xdngwbWh1ZWxnTTh3N0xxcTNDT3BFNDJ6bTNlVGtOZldQejNjb1BRdm16RHRDSWtJOEJGeU5OdzRhcUlvVVBpVmJIcUtsdnduc0huTWJWMko0WW9xZk9OQmRDQWk4QzZkSGVGbG1OcmJ4bVNMUEV3ZDkzU1cyUm1yMFBwajFnN0xoYUZHTUdieTlJRm1NdWdnLzhJZmdiWVNUVUhMY3ltRlZuQ1I1cmtKaVdqNWhJMFJpejk1cDE1TDJ5Q0J3Tko1aTRmdmI3TEN6OERuL3o0enFkOER2ZVIvQytIMXgxZlBGR0h4NzRTTklVWUhneG1Cd3c3V2tXZjZNSEhHc2J6S0lHTEl3Zy93cW53ZXQyRGdmQ0lvNGZQUkZtTys0bnZIVHgzV0tNQklURjhBNTB5ZDU0TG9PNkJkVnhYWld0NzdjbVY2Tm11cDFCK0psblA1WDdDSGNuZi8yZDg1Tm9KcUp1aSsxd0J1NWpSK2NuVkhhZis5em5KbC83OC84NTdaVUZyNmhyVHB5OGIvTDBKNStiL0srLzgzL0VpdUpHWm1OWjlJcGQ5WWxjajNVaXV0YUhjeHNMVEx6MnpodUJOU0xLVklkc0d6NWwwNFhMNzA1T3YzMWg4dU5mK0lIVUlWWWpWOElrVTU3WjJRSWFDTk5aeWJzRndnejlSVWY2Q2NiTHFzaHBidHJLWlFPWDNyNlVRK3h6Mi95amoyWEErRVJtRUpkejJOS1ZuT0djODZ0dEs0OThrc3N2b2xLOFhPZDVyRVlkZUg5b1NQdHRYaDRTNWVwMkRpc0tuZDJPNml3YmJBZDlwOS9PQ2lFbGdFenBVdG5heFJuUzJnSWQ2ai84eFd1OU5VYXNEL2p4MXdlN2p4c2tsekx6eFRpdG41aEpPeDVYUENvbVA0ZVlqYlllS2tYd0NGOUkzRktOcGYveDAwTThMUkFXWTZYVXpnd2tFQVo3QXlhekZHbkJhRUQwVHNEd3pZSFY0bi9kWEJSK1UvMjdRdTdCUHovNDdGTy85WU5mK096azJxV0xOUnF0aHZCTWM0OUc3emNYcEpWcFdsQVRMTlRDa1Fhank3RjRzcGVPUUtweXBLVkc1bTRYMG9ZK0dxTDV6eG41U0w3WjVXUjdMUVNHTDBlL0ZOT2ZRdTZ3azhTWWgwb2p5S1kyU1Z5ak9nSkVPQnJBUW9TR1JpaGQ1bmJlRVV1eXFyeFpWL2daMVdzQXljQURGcm84MzBXSStkYmc4bWptbTBJaThZVFE4aXpUbzlRSDhUbmVFeE1tZWV4RVN1QkhsWU5RNUdYYWJXc3ZQVml3VXZvdlo1Qmcxb1A1NVh3R2ZEZS91cWN2NVZxa1MyQjFjbVFsbmgvWGhIYjQvWU8rVzBJWGZqZFhCSnc2dFN1WXB1MmtyR3FqUEdkZHd3THYreExZYklUdjRiMDZWdXJNbWIyQXQxYm80VHZ0Y0R1emthdVJVT21sajRWQmp4MmZhQ1dMclp1N2s3VVQ3R2VqYnNnQ0ZiaWNOcmlidG9CdjU1UnNSdnBra2ZIRXVhZEtDcjBZU3dnTWtONmEzdlZxYkl1M0l0VnVSQjN4VG5USkJzNWp4M0t6U1ZRWWYvcTF2NHlhNElHY0pUMnVzVnJQZlpkVWNWUWtGNklxTWNNN0V0VUZLeHVtWGxvSUpuY2p1VjRQazErUCttczVFcnpOUC9OUkNTN0dKbmN4REJHTU53Z1FvYS9GNktndEhHNGs3eE9ud3RoeWxvbkI2RlRPSzkvSW9pajlydnpmZUNPN0hIUG8wV09QUFo2Qk1iSks2cmdhMDhEZE1IUTBkejBIN1Y5YlAxODNzNXc3OS9UazVPa1R5VDlxbDlULytueU9vYzBNemN3RFBXZnpmWmgrSk9DWXJXL0dUQS9lL0lvcEppeGZSV2ZhbjcvK29vOXNaaERhdjB3aWZVcS9Xb29lZUNubmoxQnZvSGMvUjdtaW02cExwUGIyOTVTZk1Qa1ZMRTZaVEZ1VDZqM2JGWjBUVm9LNzhQYjBPLzBoejZRVHIvcHo4bkhuWkxoQi9nMGVNeXljdEFTYUduMjdHSGJLbGE1bTBVbU1kNmpYUGF2VytQem5QL1ZUVCtYMmlSdFpjU1laazJKVkZNS2NWK3l3bXVwUVlhNDFDMEUxRUJmY01GR3orNDUwb3lFZ3hxK1lsd1lNUVJVeEJNRWNpVm1qNFV1WXZGR041SXhoYWxETTA1bTRkWE1GVFVibEYzalNCa04vbTNNYVltdHBVY3BVYzl1aVlRamJoWmppTG1XeHhWT2pWOE9uVE4rbXJFVThHY0czcVVWQ3ZMYUkxNldTaVF0T3Z4cUJRd0RVSTVpMHB1LzhDcjVJUWlSMkI2K3JzN3BSWTdCcExsTzZoSmZrRWlKMGhuT0sxZ1ZTOFVnekdXamtVZDhaUkRELytOU3ptRitJTkJHZ0tVN0pJMjgzZkFBQVFBQkpSRUZVY2I3OTREa3d6YnJaYisxejJBM29oKzlJbVRyNWxGMDlxWk5JSTRiSytFenoyTThYRHFyc084c2RPZDc1ZDcvOGh1UFFFMjF3cENINGxHOXFXd01WSEdxZnlTUVhCZWZKdGhnTXB0Z1k5Y0o4d2hMWmRKY2xqTENnTHN3NFVsY1lyMEh6K0hISFc5SURYNmtmK2pweDhsaHU4bjR3NlhMMVU5UUEydnd2bm44K3RCZUdrc1c3cDU3NVpJNyt2Ry95dTcvL2V6RVJ1ejhNMVMwalY0c3BvMDFDQUlzT1VpSVl3ZTFwaDZjRndaMm8rNjZIUWQwSVRXSDZhN21nMVExQml6a043MmdrY0RydXVyRWtOVHVSVytoM28yTkZzNjV1bzQ4MllORWR2NXRGd0N2dnhUOHFDMVlhYjd6eFpuVG0yU29kOWNpamp6MVJGaWtMUzFHYmhZbGZpejZhQ2FCTktFZXpnL0N4REJwbFBSRUxGTEJoekJzNVhuYzM1MS9zTFErcGNUbkljdkpMMHpIODdiZHgvTDAzUTIxLzM5cXM2QlVOSkE4Nlo5WWIraXJiWnYxRmZQM1p6VEx5SHdKU2FoWi9hYXZQSmEvMUd5T3VkZ0ZuSFNTV0owb3N2SWFIRkk0MWROS1pVVHI4VEp2UHAwK3h5NWVudUhVV1RYaUUvRE5XanZUSlNXNzh3T3JwVzN5L3dYM2ljUys1VHo5eTZzbGYrc1ZmL0I5KzlBYy9td1d3M0l1WFh1Ymt0ZVdzbm1NWTl1MjdoUUNpSE1HWm1pWUtCSVFSR3lINWhla3c5RzhWaFN0NmRCUy9jWDBOSGJUR0dreGJtNVJrbXNhdmxmL2tTWkpoUllGNVYwZE9tR2ZsRlQrTXpEZEUxMGdlcHQ0TUZiRzQwYmNhTjNBaENQSFNscFZHdUVzeUszNDZLSVpleEJmL0FGWE4xY1RrTzJDbWVzcjJHem8zK1pHTXpTZ2NjSDQ5R3hoWU5KQ00rVjNQQWdsTERTb05xOGIwa3FiQkpFVFR2Sks4NlpReHdYUk1XNEZKQ2tpcUxpK1lJUnF3OUsrOTB4VHZjK0swQXpNMzZ6ZDgrdTlnN3UvTGQxcFdhcHlJY0hId2svM0JiM1M0VG4vNG1aaGQwRjJmcHZrR0FnNGQxTXdtbnhnVVh4WXBGb2lEOXB3KzUyYjM2NFZmYVk3YVZCS2lzUXR0Yk5peE1xK2RoM1RHU3VDK0hFemtGTUtMa1hTZFhGZk1OZFArWjU5N3RuYTFQZnJZbzJIV3h5ZGYrY3EvcTkxME5uWjg4dGxQaGptZW5Iejk2MzhaK25CUzN0YmtzU2NlaTJyazJRd0NPUmNpakcvVHpkakIvVVp1aDdkT1F0ZnJOTU94TlRxRFRRU1l4WnhBZC9hUng3TWhKWGJXK1Y2S1pZZ0Q3NjlZc3duOXNCNDZGajI0V1FEckliUmMwbWJxaE42ZERyZVRvd2hoSHMxWTN5QXAzbmYvZ3pWNHJPY2JRd0tmMlJobWFGQW4wUTkxSUV1SzJEK25DZlVSRmtGb3NCYmdrdysvbmRBeXFWUWhNRjVZbnpiMTlHcy9yTFpNVXgrTldKVk9Ieks0K2VsSHhmd0NQenFvdmhGL1hZbWFaaTI3S3YyOHE2czZHZjZMS1pkS0lqa1hRUU9BOHowbDRBQW9UNWtSY21CRnVvekVSU3ZxTGx4ZDRBN1p5aXRvcjNpRUxYR2NPMUxwa2g2czk2VGtmT3praVIrd2txeENHckh0ZVNHY0RwWHVxRXlDd3JDcEpRcVZSckZneFpRaGdUVUYyWjZlSzZCVGpJbDlrQnlja21RclRYd3hSSTA4OU1pK1NkVkRiY0RPVnZtRHNTSWtERHRNUG1vSnNNeE9oelJPNjRsSklwamo4VXhSalppbDEwMDVHa1Q1T3I0ZngyLzJWL21HUHRSOVNQQkprempNM0JBZ2N6bHdDRGQ3QUx2RGNtNUdjZ1pyN1lvc0loa3dKbXJCajNGZzByWnAxN1p3K3R1c3JJTzdDS3NBeXpzeG9sektoVWN3STh3WlYvSGpmOWdkanRmaGQ4dERXUHNQZ2cycUFpeS9kclBselBvTC82Q3lPdTFIZVpLWXUreVpZdmVUV2h3ampYR205eTVOWFYyTmFpdFV0cEtwdEFGNVBUc0RkWFRIZmxJYjdFVjZRcC91OWJQd3pDNy8rVWpHcEZZN0RFTU4wUjBmSytaOGZ4amRZMDg4TVhuMTlZczVoK09CWW5xMVVCVjBud2lEZnYzVlN3WGY1ejc3QTJIb241eDgrY3UvVmUydHpmM1E5Zkx5VGxRbHVZTXZNRkZ2dUxyTmVSMlhzbWlITHVqRFNaZVlwUGpGRk1OZ3ZIUHFEdy9vbGNSOExIM2o4cnNYeWgrOEZ5L0ZTaVgxdEZXZGpmZUpxR1hPUFBiNHdGc1llK1NPcWlzcmppdlhjaXU5TXpqUWFRYVNSeDVZcTB0WG1RM0MzNjN0M0tZU1FKaWphVTgwM0czdWUvWUhObVRYZmcycjUraDdacTV6dGF2MWV1aFVYNkZIQnF2K2djNnBjakJ1czBycUlMZ1ZSOXpDV2JHS01VTXUxV1hSSHdGcTlBbXpDalB4L3E1WjY3UXZnQ0ZkZVJybWJjREZ2OWgzNnRQcDRMamFhb3J6Mjdra3dlN0VlNUk1UDNYdXFYOTFKSXp4NXZXc2QyZGF0UlI3M2NqTGs3M042UDh5OHMzWk9XZFNFQnZsdE84Z2hpdzJhR3c2TmJiSEZvMmlVWnJjZG0xUEdnTUJRaGJrNFl3YTNWa0Z0M2VpOTRxOXFPM1h3a25wR3FvSU9UYW8vTW9ZS1dacHpzR2dieDdXR2lTcUhKdVk4T1V3eWF2WExtUWFlektkNmtqMGgyL0Z0dlc5eWFOUG5rayt4Nm9qYldXZ1FCakt2YlVYMDZLMU1JYU1LMHNSVllHMGtBNXRXdVhjWkpLYkJwMFBreDMyeTA1T0czb3kwallpUVdCMXkzSWtGZWYzT2hpSFNvT1pvR2ZvUHpoSTUwbDVPcVl5T0JzM2hrczlVOGErSXhFRUplckdJWnlheG9VNnU0TVV5bEpmZGJaZ2dpRjhtTHZ0UW9OOWQ4QjAyMnVCeWlST3VkeFl0WisyRFZneVlLU29jdjBjWCtOdmFTZ0JGVGlxUGZObTRPR3FMZWxpRTk2L0N1aXdQSTFEbUtVQk5IL3EzWUZRMWk3NDNkcU9qWFBkRTdrWFBYSFVBM0NaY05QYXkrOWVEQzV6S2xvZEJEUUd5VHFyTytoelhkWEc5U3V4bXRpWVBQUE1NNU9uUHZuSnlYZGVmaVhtYlp1VEwvN1FqMFJTL3VQUXl2MmxvLzNUUC8xYXp0RjRNQnMvTGlYdWM0WDA4eTltNFpBMEczcWpaNzd2L2xNMXdIN2pHeTlNdnZqRm41aHN2cFlMV1dPVnNSYTF4Q01QUFZKYndOY3ppRndPYzl4TlAxaU9MbmlGUkp5Wm8xdXhqOFE4YnoyM2lpekhhZ1NUck52RGowWVB2TWplT2xaUEljVDFHK3ZaS0hNNmNKMUl2aWNuMStaVC9sTE1Ob05EVEI5dFhuenJ6WnhuRTdyTG9ITXE2aEpTNkU2dWFudjl0VGVEbHh5S2xOa0VQZm83RjYvazdzSGprNXZIMklQSDRpV0xwcWRqdHkzTzVkaUJiMFpmVCsyaGoyR2F6Z0VKVlFYL1liZ3BpNVVVSVFuajExKzFwWmxOTDZhMzRFSWl4WUMxcjBGbk0rYzRsOTEzOHRVL09LYXRCb2NhOUJLdlpxckJpY0h0Um40MU9ET2ZDN0hiK09QUU1lWHhYMEovcWJjMUIvU3dsM2c5Q0lLaDRTaWRQeGdDTTFqUTgyRDJ3MHkzOVA3NFQ5S3NCSzdkcklyZVhvNlFXUkRlWTM4eXFqMVhvMzJRVlNOUkRoclNkSWkxQk9VZzB2UWI0WFRERk5OTlBYZUNjSkx1WVNlZU9CclJlNlhML3RzaEZXTzQwNmxLRW5vdnlTVDIwNlFpM3h6aWdYVEhlUWFnZlFMUTRDUVAyM1ladmlPNmtoNHlZcXNIcDF4K0dsN2V2bWZod1lNMHRvRUVJWWkzR1lacjVCZFhXREgzMUYwKzBucXk3U1NwZSs3dVlNYWtLbkFQdlpaNDRQZVRaN3VxMGFoV2U3M3YyZlh1Z05uMC9EcjhzSC9IL3lqUFR0dlBoclB6L201NVNLZDVPcjM0cys4ZmxoNXVLbjdTVjduVHlOVmgwOXJhQ1kxUmpjRi94UTBLalYvS0VLL2JRdWYzYS9yeXZwSEZiRktidHNFZ2JJbkdqRjU2NmFYSnIvN3FyMDVlZWYyMXlSLys0UjlXdnJMSFNNQWtIRjFpWUtUWDgrZlBGMzI1d0lGMCs5cHJyMVc1RCtib1V1WnR5bm9yOXlpQ0YzMHljS0tidmg1ZE1EOW5iYURKbGhxdG9ZQTdHcGFpTDdCZGpWbmZtMisrT1RsN2RxV2tTcFluNTE4L1h6ZHJnOS9HSnJBUU9xNXRmSDN5cVU5OWFySjYvSFNrWnZiWHF3VXZuQ2hYM3V6Q0hkekU0b0kwMitWWDNLaEQxQlArK0ZPRHdEKzEzY0Ryd0swd2VJRFQwVjhHd2JhcG16WVovcU1kdTQza3JkOUk2MG1hNStjbmYvSDh3TzY3TExQU3orV1ZTRk8vcUIxS2NCcDhnWlFPbmxyZkNtMXduYWQzZFdHb3dLK0VqR200ZXZWUFBLN2h2RmVaY3lFT3NxeVF3Z2lwaFA2UG5wUkl0eENwYkNIVEE4aXdNNHVFcUlub21SRmtTWmJwUlJtSE01Smg3akZsU2ZyVzEwS1NtNlloTHEyaWQ5WjBDT0lRU1RYNi9ORHRpcXNScTZ4cEdMK0NLK2tRSXlkY1o5UlFPZ3lpUUl4KzBpTVVyZ21PZmFhMDRLSzZvWmd4NnRKMUo3TUtxOGFPVGt4OWpPNzBmT3FIQVpNVTFxTUhMYWs1L2hnSlNZdnFaMHRIRFViTUlJcndwM3k1aURFdytLeTZBeWh1a052QmMvaTE3d0hEay82d2s4OWhmOS8rZlpqcjBObTAzdmZ6dTB0WmQrU243ZjRXYnIvK005a01XQUo1ZFBBNkl5R2dHUUQ2WWduRFh6d01UQjdDMFEzRzVGbDBHMzhISVdGc1ZDTW5NdTFIRXkrKytHTEZ3OXd1eDU3NDdVdnZUUjY4TDV0T0V0ZFUyOVp2UDR6d3hPbGprNS84eVorc05BNWFvdXF6bSsxNmRpalNUNk1ydExBUlJ1aVNXd3ZDYTdINVg4dXVQSERZZ3U2TWo4R29jenhtWmp2S3NLQnVCdEFMYUU4K2VTNUhucjVkZzhMcDAvZlZJRUpxZmUzaUc1bXRPakRmQW54VUFhbmZLNisvTWJtUThnd2NaeDZQNUJwY05OeG9HYU9IRzRPUUxlNXNxZms1VEFtOEdLS05WTlhHd2FmMDFEL3FZY0VkM0toVEh2cVI3OGF4cHRiaytvUStSRWZlZlZMOGJoZGhsVi9palRTamdUdFArWFZmSFg1cDEybVpLYmpDeEZuTTdrbjZhVTVaOGkvbGFaQWp2VGlkbDN6YUNZc2NGeGpIQUZTTU8zR0xMd1NQOHFsZko3aVhuaXBSMDVJMG1pbm1icGpTZkZRUWlENGYrWms2T0VKeU5KSUZRazQ0d3RNNFpiczZUVHVNeElXVHFvZE5vL2lrREVqRjF0dDJsczJ6ZDNuT1JUM0NkYU5pMnBqbzJNS1pOSm5tSUlMTXVQWkg0UjZsU1VsV3hoR3h1dmlCRDJ5YzcxcUF5anYxQW1rR1l5N0xnY1N4V0lYSklnN3Qza3haWjJjOW9GelhUZGtOcGlNdFpRT0JUVFk1L255eWwxWDd1ams3QktmdURrREMyTG0rK2FRK3ZzdWZJU1VjUkNvQ0RJejd6MEczKzk5aVZwaVhoQjFPejN2V2RkeCt6b1o1aDQ4UGM5THBISGVtSC9Xc3NBOUxuTEJPTDFybGN5aCt0VmthdDljV21HZkNaNml4T3BvMndIQzBxWmtUeG9OMmRVNk16MEtkOWlMZFBwaHpOTkNEUTRWKytrcy9NL216UC91emJHTDVUdklhYXJrbm4zeXkwckorUURzWThiV1ltdFd1dStSbnEvMC9DVU4vL1BISHEyT2JrWG0zNFdROVpZOEJ3ZURoZ0taaDRxWXNXOGYzZHM5Vk9MTTVsN3dhMk1ISHlnTGovanlkZFN4RjNvamE0c25FUHhucDNGWjFUUFZpOHJkZWNUVHhDRVlHbUxVdzNMY3ZYSXA2YnFIT0JBR3JlcUo5T3dVTk5IQjM2UjBTNjBEcVdsNE1iTklUSU9BTzNyU0JYekc3YVR2TU1qM3ZjTXBab0d1bUtQMVcxQTdGQ0JNbVR1Zmw2WHNza0U3MXZaSGVCK01mZkVMWjB2S3pCc1hBb01xSktyQmhHMzExS3VXbnBXcUJ2d2FQUVpqTVQ4RTNjQisvREM1RlIza2xMTm9Lenlsblp6cklXQlJVM2ozTG5EVjBWVkxsUWhCT2FuUENHYlhHSGdreCtyUmFsZ2tTaXVGbHhDNGs2VWpSN1E0bWFvdW9qb1VBQ2tmMWJnclYweWhwS3QyVWFXcFUzNUNwZ1dMUFVOSXJSQ0o0aTRiTzhTQUJhMVJUSGU5TWFqUXN5WUdLQVdIcVZGZXZYeTFUSXdUWk9qWjUreW5IQ2pUR1RIZG1FYWZPamtoWjhyUmcwSkoyeUNKaFEzVXlEcDhaaTM5UnVBMm1tL1IxM0dhZTZrd09vRkNGbTJuZktBU0VyK0JDcFV0V2ZzV3JrQS8vMDBRdmx2ZDlseno2KzI3UGxqcjI0eDk2bWMxM05vai9nRy9XOTI3dlhmNUIvSWJqYnJFUCszWDVCbHp1b0V3ZGJSeEtGY1NtYmNjMDJHbHJhYnJDYTlGSGRKR203SnkyMHY0Nk5GcUFlMzdhL2RsWVd0akIrY29ycnhUVFJVdC84QWQvTUhudHpUZXlZRGhvZzZRc3ZyVGVQVy9FR3VQLytlTi9YNlp6cDA2dFRVN2ZkektiVTg1Tm5ucjZiUG1CVjE4eE1LREg1U3dHY3VoTEdUZWp0N1pSUkR4cUNiUE5odmRHYkpQTnJ0QTJldldVRjNVRTVucGZ6b1JlQzZOMUlCQThoWjlHRDU0MW1EQlk1ejlqN2hpLy9CNTg0RXpSdTRIRnpGRitHUHRHSkdUU296NUJuMHVLTmhxQnRmRlRBRS8vSUMyd0NodHRjVUM5WUlBVFQyRisyb0NmL1BoM3Z4TEdiekc3aERxZVBQbUp6L0ZYNTg2UG4zREhnSHJLYS91MnErWUdQTlhldGM0Q2pnRUxpeWF1eXcwRWxkL0lSNXlEOGgxa3BzeTZWU2w2YkdudVNiWEdsZmZldTVyR1B6a2ZPMG1WZ0ZpTGQzVmd2WTRFc1RWcVl0eGhkZ2tYeHpiazZtaEJhQ0dNNUp4L0Zna2hwdktLUkN5dTl5R1ZEK25iTjdlVHh2T3VrMWtIY0p1SVVjL0dGQ3FXelhRRW5aQ1VsRlljNVlZaG1zYkpRam1WVCtLU1NuUTRFZ1VpbUNVR1JPd09Ob3N6bk1iSGtDMFk3RXYveVQraTdqN3NuVDh6SFRTV2NhcW0zZUIxc1BsZTdGcmRwWFlyZVZyWUFrdi9ncG4waXhERnRBUHdCOVA3M0t4WDhDak8vci9EOGFkeEs0NTQwL0IrZnJkTklnYUxqdnMrT0hpay9BOTE2U1FjbE0vbTArL2ZKWFdsNmZZNlhJNDhpaVlxN3hIS1Q4ZkVZWFJBTnNpY0RvOUppYTlkMFFhbXpIYlpJSTJXWG43NTVaS2NQL081ejA1ZWVPR0ZZcTV1cERsN05qdnZIblhNNkxoQ3paTmFRNXBuY3YwUy9UTXBHYk1qYlo4OWU3YWtUL1R5K3V1MmZPZUl6UHpRSkNGZ0sweVhPa01hQytkZ3RraGE5SnBMV1RGSUM0TTMxdDhMdzh6MFB6OFg1SktjSGZ4dndlNmQyRGlmeUFXNjZOZW1tWXZaY2JnZHFiL09zMGxkelNRc1lLTnQ2aFRDZy9wU2Ixek53aVBZbGUvYkxBL1RoeGYwcTV5YWZRU3VXVmVNZDlxZTBvTjdtTUZPKzIzNkV6ZmJoL1NkWnM3Q3VsK1BkaHB0SWkrNEtoNlNPTnJONENHZG4vWW5ySWxUWldieEV1ekNybS9nRVlPWjB5TnIzNUhQblZLNnNnY2RqVUZCL2k3VGpXRjMrWU5CNVJ1V3JhMGhuZCtUelBueWUrLzlYdlJWdi9MWmMrZEtXb2E0akY5UkowVE5FSWJHL0RCYTEzU09kQ0FpVHZ3d2J1K2syV0IyTU9scGcwRUs1UGw1OTRQazdkdGpFd2lrRHlJZUhkSzN1UE5oakMxcHU3Sm5wTlhRek5vaW9RY2NVb3ZwSXVhb0U2eW1ZZVdOSUJGU2Q1NG1DbjZjemxRWFpJYTAxNktTMkV5bk5JMG44U0E2RFZ3TGZOTkdKZmtzTGJsMjNybTZnMGpjeWx5TGY2Vi9Ebk1QUEhhbkRZc0RhRUY0d1Z4eHFkUWxaVUdYaHhkTTkzMXUxcXM2OW1DNmlKV0RKMjRRWTczdTQ2NXh5TmU3cWQySHVtbFpuV2ZIbFhmNXpjTFNnVFBQdE9qTTEvZitxcHpaWHhlbnJ0cWkyaUJscUViUlJPcEVpcWIzQlYvSVlMUmozclVyK3NDRUxPeVZiamMwNGZ2YjMvNTJObW1zbDcveU1HcnB6NXg1b09JOUVYTzZ2Lzdydnk2SkdUM1paQ0tQUzVjdVJEcGx4ZkZNNGgwdnlkdnNUVk93bm1nbUl5L2xZNURaMWhmNnlHbUV5Y2NaSytnUURhb1ROWm1uSDhhYVhsSGhtTGxCUVhxcUZ4THhRem5zeUdKZXpGb0xWcEoyYmZ3S2phY1hWUjdLSlpSUW1WSEZnQUZENTYrZUJndU0ySHRkNUZBMGI4NUxyMnpyK3hqUVdHSG9INlZTVE4vQmg2ZmRwUEtTSDlldysrNCtLKy91ci8wVVR4enRJZHgzcC9ma3grbW4zc3RDS2YwRURNeEx4VmVYR3REU2F5cmY5TG5pUWNVckJpd05WOE9EVjNCbXdwajZLSFgwQlFPMVBFY1pndy9kazh4NS9kcjZWME1ndjZLaUpRbEg4dDJKNVFRcE9iVU9WdE1nbWFLUkFpR20xUmYwcWRvUlVoSWpmekhad2NpNjRUUklieXBCb0JpL01JUXVMK0YrM0h3S2dGRGhwbXp0RDhFNm5adVNFYjc3MzJhbFFFU1JibHVxbUU0am52dzFPQWFNQUc2dUR4WElYR3htU1ptTzc1UzNNa21OTk43S2JwMm45Sno4ZGI3MTlhSGVzTXVQSHMrdXM3MFFSWFdJZE9KS203QW1Sc2lwUEtaNEt4UlZqaC8rcDh2MTlKUGY3TFBETzVlT2Q5aS93L3VKdVhhY2ZzN20zZkUrNkNuTjRmaWRUejJubmZDRDBzTlA0V1ltbm5UNVg0TzhzTkhScDlQbXlpaURYUHlGWVhiYUFwT1JEaTM1Umt1a3IrUmVzeVpXRUErRTJXRzQzL3JXdHlvWE5DQU51a0NIcEdDMGdWR2lBWHJxelV5ck1UaCs4bFFPZi9sZzZGdXhlWDhqQnlHaFJVS0I4TldvSkRLNkY3MGVXODZSQXBIT2E2WVhzenN6UUhIa2FaQnhJZXFnby9YS0gwd09OY0p3MGZ0cUpGOStwUFpiMis4VkkxK0tSUkkvenJSZTNsUWM4SVF4citUY0VMZ0JrOFBGd0MwKzJyUTRTYkJabUI4TGxtNE9hb20xOEp4RkN2aEwxSkYvWHZqNzZSUDlMbi85cXAvYWNiVGJtTkhBWDhjVjFyK0NPZCtqak1FWHBFdjJ5WDhNR1BMcytPRGUzLytRV2ExemUyck5xY3RMaHRMdjV6dHRmMzBYSTQ4UXZ1L0FCUGQrQmxabGpCTDNvOXdiTDNPcjczenRCNS83b1gvNXcxLzRYQlk4TG1YRXBsdlZHWFpDaERtd0pBd252Q3dIejJTa1N5T1ZwVWFRYWhHUERTcDd4UHpOTFgzcFNER1JJWEdMUnhweWMwU1oyNFd4cm9jNUpxdDRrb0tpWTBvRDJJSEhMMTIwRHZPdTg0MGpMVGlhMDFVK1lTZVpydWI4QXRPMWQwUFUwY0h0YkliaEI3YVFVRHExMWVlOVdGRzRlY0tpWW9ncm8vRldWcngxcGlQTWk5SXhyc2ZLWWp0U3pVb2FDM0VuNDlMdnNWbEdzS2FhdTJHNE9xNnJnalp5YkNRcGVUdkEyWDU3TFZ0cW5ZUEIyTjc1d0hXN0NjSkN1TUdCR3pOdVIvSVA5ZVFYTXZCcmx6aFZYc0lFbTZyYkZWblBlQmpjekRENVZYSzE5aDFya0tGdk8wam51K0lvWnZxcnpKTkdIb2QvWWFmNzhieERkdTN1aEhTL0VPMitYM3BOWWlSak9mcm5YU0g1bjR3WFlqcm8vTzU1MHBrMm0wcHA2Ylg1Tmp4WGl1ckVPcDNmSFM2ZFoyUTMvSlB0MUkzOGFoQVBMczArS24yRmhsWUNJK1pBc3RUSmRORGFGaDBkNitjLy85bVNRTFhwaVVpZEw3NzRZdHIzMXVTVHp6eGRlZnoxaXkrVmxDbS9XN0ZadisvMHFjbjVsMThxTy91SGNrSHJpWmk5WGM4c3pibmZKMDdrMnF0c0ZjZlVMTXlSYkQvOTZjL2svVUxSeUsyY25YTGhRc3oxWXR0c3pXRWpDM3dMd2NFanVkRmtNZCtQUGY1SVhWdTFuTm5XazU4NG0zeGlaM3pwM2NtTjNKcU5LYU1yWjRFLy9OakRPUlpoTHR2OWIwN2Vpb1hGamRnaEwrV1V1U09ycC9JN0hwUE83VksxYkdYeE9Yd2xOQnQ3M1hDZXEra0RNRmNibDRJRGVFR1A2TSt1UkxlM1dFU2p0N2F6VHJnMjBZZjA0Zmt3YnY0YVFUNW1lb2xjMzQ2eDVRdTN6V3pockpreTVpdFJNK0Zta3A3OFBKTXlQOVNzWmNldjFvZUNtNFgwVzJjc3kwTk14d2VMWVlkeEdpcjRURzlPUFpOTnVjcU5XV1g2SEVZT0puYkxEakpTSGpyWUNaOEJueVNvejlvWVo2RitYQXdSdVBqWDdDZGxWdWc5OWlkbW5ac1lwek1KRUVFeDFEVDRjcEFER1F2Wm54OHNGT01pUGRlQlIwRU01cXp4TVVObkNaQW9qZGkyTTlmRnI4R0R1RnVKWjF1ekVYUzI0WHRFUlFRYWw2a2JaOVF1cVNpZEFEUFlkaXRFbU90bXRwYlAzNHhrSFJqa3N4YXcwbExRWDVLRFc1WTEzRUpnc00zVmFPb01oRG9meEpRM25ZdTZvanA0MGlyZmdoK1NHc1JtbEUrakkrQ3BFNWRrTE4rOU1HK0Vua0lUUDhRZW1CRzFWZVM1bm1tSU1hV3dJdGg2QnlqWDVlUnRHbWY0SC94dC8wNDcrdzFQSCtZNjdtdzhmb2UvNWRGK25hYjgwbG5WcnR5MHFJTnZIdU9yMDA1ajN2RVExcjg3QXZJeGNKbDhwbkhrcG55L3dxV0c5WCtLRy9HNVlqQkpneWFhRVpDeVNNdWtYNHhQWE8zSlh4enZuaTU2SlpWaTN2ZkhUcG5rNlNlYzZabkZOaW9DMzZST25aMmtUTUptZlVGRllpQWczVHBMMllXd0M2RWxOR0o3ZDBpcUZ2b3dVRFJwSUZlV1FSNGVCbE1aekFUdDJiQmxUY1JOTEpnL0dCMk1STzk5K3RTRHBYYmhyMTZrWGc1TXhZU0NGekRLaDFOdmdvbTRwRzFodldhaUQvbG03cG11WE9tSGREM3dMYnpicWZIZDVjbWJuL0Iycys4ZDMzUDJaM2JRYmF4ZW5LZWZlRU93bVBhQnpNN2huSERuV2JQcVhYc1dodFJ1Wmx0NVY5b3BUZVFkSE1vUVJpcjJQZUlPbWdaeXc5cXcrWWEvZTVJNVErSXJyNzRlMjhzM0pnODk0SVlKcDZ1RnVDSVJiMFFLV1E3Um1XTHMzaDdTb01waXVBNzJaaXM1YmgzSnViSkIySzFJSUp1eHNJQU0zUW9pV1Z6b0VQeTY4YnpyYkkzb0l0Skl4aHlrYzl2cERHSHI5VTRTUm1TM28vUzNrbTJoWTU1T0x6dC93TE1keWRVT1AwVEg4ZE8zWGZjek4rZE1qYkVOZlN5T1lNZjBsemtnSnRLSUw1M2FRR1RCQnF6MHlBYWJPa1FtbllDMHZKbUN3VnoxQ0JPbTBzQlBoa09NQjB4OUVNWWd6cUNsWEVBcW9ocGZkLzRGTDljRTVkbXUvZURxbzdoT081dW5kUDN0L1hDYzh2TW5Ucno5MHIxUFllbjBEUVdtNmIvd2pGRjM1Ti81VkliVFAvdndUK3ZLVzlyNnBjUnFPNkovU1Y5NUpGNE5qTk00SkVvTzAybm1oa0Zob3RyUEZteU1qUnJCd2xuVEc2bk1mWDBQNXZZVSttWE04MVFzTkxRbGZTL1ROQXp1M0ZQUDF0WnYrdWdib1p0bm4zbHk4dk0vLy9PVHYvcXJyMDkrOHpkL3N4aG9SdnJjdmgxVlFtQmNpbHFBYW8vOSs5elVVZ0FUeDh3eFF2aWFuekpKaTM4Ukg0dEVMbHk0RUxPL2t6VUlMRVV0Y1RQcURsWWI5OTEvcHJhZHV4WG9lSmp0NkVlRW9MRmdOM1RLNkdRc2NDbkQ3STdUWi9CeVI1VXFGeTBidkRpelBIRlpmOEJ4Q1VqYU5Nd3V5Qi90bDNnaCtVcmI3U3l0OS82UlE5dnR0MXZTN3pOZjdBRWQ1R0gyVXk1Q1RISVlBZWxwMms2eE9RRXE3WlAyakZRdEwzeUV2cjZPaE0wM0s0N0tOMm56V2U4QnZOYTZEQ0xDUmw2QkN0d1J4TFN6dUZ6WHdkT2FFVGN6bDYzdmUrYlA4c0xlUzArZXVlK1h6K2E4V3llK3NjallEZkpZUzdoTlFRV2pTVWduRE5OTGhabnFXS1J6RTBpYnl2Rm42K2dtQmd5dWJnbUpkT0hNWGI4WWdJVEJKNS9Fc1J0dk13eDNPeVpQL0V5THIyWTNsTnRIeGdFNHlUOE0wUm5PTm8zd013V3JHMHpDSk9zMjdwU0hDRWpyT2o3ZVpZZGhVVWorSmpod0c1V0gxT3pnSnZFUXAyblBhRGk2cXFYcTFJNUUxR0dwV2pCZCtXMmsvam96NXU2OFppTTg2NHhVdnlSMkRReUdzc25OKzZ4MDBPL2lJTUNHeTNlN0pxTCtSblJON08zbk9kc1ordjJ3LzJ6OEQzcWZUVHViM2p0MVJVRVp2RFcwbmpxbHB4bUtic1lWWTg0VFUrNGVvZjA1ZGVxZjcxSDNwR2xEN0drbUkra0JjNFlpNmhNU0dEZWk1VHZ0QlNjMU5VNjdZVVQwcmNyQUNFbWRHTmZwKzA1WFd5bnYwanVYSSszbWNQd3kxVnJNOFp1UGhURXRGQk1rcWQwWFhYRXhyNVJaMG0zU1VKMWg5R2ozV0Jqa1RtWjlHUGNMTDN4cmNqN1RTL2JOeHlKVnowY3dRRmRVQ1NkUFpITklEdHFuSW5uNGdRY0xROVFyVHp6eGVON2RwdU9tOEd1QjVXb09RWEtsV3RRaFVabFp3SFEwd3RzNXYzbHpNelNhem5Va040bXJGN3F4YU9mblZtL3JPSmdxUnE3T3Q5Sm45Sk44cEc5R09zNC9mY3FONGZvUmYyM2gwQ09DVThBSVRhY1B4YS9iUWo2RjQrblRlN3BYNGZrd2pZeStsVXltN1ZaeGd5L3h0RXU3L203NmxVNDVuUi9xY2NOMjRSczFKVDBiWkg3U1VMMk1yZXMxbDAzYXhFbVppVGJnd3B5cFRaT3Z0SXNaN0FaZG1Mbm5sM0J4aFZFUlZsNTV5a2VhZTFaeS9wUC8rT0svK2N3Zi92dmZlUExzVTVOUFBQRlliV3ZlRGFPNkVjSlp5bUV2RUx1Wjc0SFlvUkl3cFVMb1ZrcEptb3RSaVdCdWRuTFI0WFdqR2lGSk1YUFQrSWpmU080bmZUY2duUjdtNXpCeEhSQkJkdU5MdnhscDNkUEFRS3FOMkpzeVY2cVQyUkhGZWtONk1LNWsxNWE0dmZHRjMxckM1WGZ5Wk1KelhxNkRjMndTQ0tDaHI2eW9SMUtuK25BNUtDL1NNclhIZW5TRHhaUUR2enNCYThFdytDaExGU04vZUFtYjNJV0ZjR3ltTFhFSXBGaFlFZitnYWt4OCtIZDRSYTM2ajdjN3Y3c0Q4ZlVPOWxrL2VjMSszeTJQV2IrUDh0NzU5YlBMYUxqNUYwTk9sZW81aFcyY1R6M2dyRGhWNzFIaWJGN2xFOVMwMy82ejh0SHBkUFlETHFCY1AzVS9FaFdGZGtSWGFLY3RkS2doeE5GR0pHbHhNV3MvVXVnVjUwOUVNcVZxRTBiS3B1b2dMVDhZSFRScHR5d216b3h6aXNHb0hQVGpPV2pjWXRtUVVFT1ZTWjhiZUZMSDFkeXgrZENaQnlmUFBmMzA1RVNZSjF0cEVoMFlDUUNsdWlobUhxWVNoSzFsRGNjVmNGZWpSanlhdy8rWnl5MHVad1ozZlhQeXpuUkRpbU5PelFMTVF0YzNjdTUwWnJJTE9SOWljWXJUb3V2MEcvMkRxWjQrUjRDZ1ZVVzMrbzU2a3FLWGMxYU9lSERoWURGeGEyYVlhU2dLWllGVjZFN2V3YjZxNzdlTnVuTndxejV0aHFyOGJqZmh5dklOUDg3L2FOeXh5aURVMGZtV21WN2V4YXY5RThrUDB5VFB5bDlmV1kydVhoNmNNdURYT1J2Zzl5TjJLY3NtdVk0alB3T3djQ3hkL2RzVnpCSWxiL0h1V2Vhc0NzOS84OFZmL1B3M3YvWGJpMWtoZHQzN2Jyak9YdlJicHZPUVRJMEJlUVFnald6MFJyZ09UcWtHdVQxbHpwRXdFUUNtRENubHdyUnU1MGhHMGpRbXVNOEkwNWwwdEpKV1FtZzZpazZIbUVnWFEvYzJwbVYxSVdxSXFvZ3pqVUJmeFVoLzdmaDJwb2hHNVp6RkcybGNtWmd6NTVJQURTby8wME53TW85YmpqbWVNa25WYnFnQXozcDAyanB0NVpHMHBvd09zeW5HVElVU1JvNWVxVlhtWFFLYkR3TUMyc0tvbUZKTjZmdWczc2tIUE9NSG9rSHN2aEhsSU16aC8yRi94WjkxL2QxUFliUHZIK1g3Y0p6c250MW5pMTFhOVp0RXJEb3F3MDk5UnYrUVJVZy9icitPWGRmT1FlQkhjNWhhaUNsbGpRNkxOWGpueDZFMWJWOGROd0Q1SnYyQ0J3MnhzdkRPWDE0NkxFWUZ4NWlYZ1JNdEhEQ1RXUENFMWpCbWJuVG1zYlpDNTJ3VHloZS8rTVcwK1Z3ZDNqOS9NUWN5UmVmc2NQNXJLUXRkTEFlMkk2Rzd4eDhlT3hLVlNUVjI3ZnA2cE9xY0VoZG1EQ2FXUnNwRm8yNWZVVzdZV2NHWW9TZEN4SmdGZ01VaFZ5ZE9zSGsrT1RueWpqc0d4dzdWM1oxeFdKaUZ0WjJVVTNVSm1qRWwreEFzU3QvTW9pTmNnT1BJNnVpWHJyNWFEZjFUdndoVFR6QjV3azNqWTVpeGpqRDlSSmhueCszVDdYejd6VHB4T3krNGw0N1RGdnpCazU2Zk9wTjhoMlE3SHlzU3MzTDRuY3VsQld2SGppYmZ3ZmhKelBDd0dtYS9HcHpMMDh3bG8xVGlEQTRzcnZ5SGZmOWd2UTJISnpmZ0hQRGUwOHo1eXZyT1Y1Ny8rZ3ViUzh0cnErZWkzcmcvdHA1TFIwNUFaeFkrY3BCOEVLR3lUb055UzhKV2RHV0YvQ0J5S1FpR0pCMW5NTE5oTnFkRGFDZy9FalhpUVBpSTA0K2swK1pOTzZmU2ljSW9uWk84WUZ0NGlPNVdwRTFsanRHZS9qcGxoeWtiNVcxejNkMk5QamtEaDRVOHgwb0sxM2pidHpPQ3AzSEhRVXJSSTBmcTNvdDBVa3ovUks0SFdzcXNJQkt4cVNEZHRoRVhiUExwNlovcHE4R0Izck1ZZWN5a3lCc0xaZ3FEUHRMOFZzYkJ1TzlSUlBIZC9od21vbzQvUy9RNnphenJzTmxudjNlODcvYjlRZkg0MzY0NTVKU2c5NWx2Uy92cDZMTWNPZkdWcGRaM2RnUTVEVGNMaXppWVFibWthN2VQQnd3bUhWVVJ6WnhyWmhMOHBqdFdXZHBISjVVUGVwSzJtYlgyc2RCMjVzeVpHbUJKcHZ3TTRQTGw0Rk5hM3hnZngrek9nRXdualI3Uklwb21YVk5wMkxMOUozOHlEa2xhQ3R3WUt5WnlNa2VVM2dpc3EyenV3eEMzV0h4RVlPa3pMWlM5dlQwRUJQUTAyakxxQ2dKRjRCWjNmbUdjU2RNTDBNclZIOEJEdUZCSGNJQlhQYWtadXk4WmRNU0hFNjYrczloSWlHSUJVWXczYkp1UWlYN1JQWEtpMDkzTFVReWtXVERLMS9DS1FkYjU0dG8wT09yZkxBMDIvclRyN0UvNVJRdEpwMTRjbUpXcHZRcjJLZDZiSnRSREhHcDQrZnFwQTRHdVlBK0o5T0lnZkVrblhGL1gxOG92NURUYi91Tit5akhZeUYrZVNScFhmKzV0eWZtbDdCUmMrOXBmL0hoMHFyOFZFN1Bubm4zNnFja2ptYklGVzVtdWhaRFNnSmhkNlYrak45c0tjOXV4Y0JqRVFVeE9iaXhrbFZTZHhiWnVxS0ZYWXNZenJDcElNVU9QTzFiT3hmTWp1Wkk2RUJSOTI3VVF2SGNOckF3bWVSaS94Y2hRZGpIbnJjRGozTit0RUpvemZqV0lodEZvbFM3c2RIU1VuQllXQ1FKQmFHUk9YanFEZ1FhaFUxY29SOE03bDREKzA4bDMvSmtuYmVVS2VodFpPQXpEQ2txR0JlaXA4aEtsbkR4bW5memFlUi81STV6eDNtR2Uwblo2ZFRuczEyR3o4ZHF2SXMvOHVadi9ZYi9aN3o0SDVFN29rK0VVL0k3YlBIckthcXZFOWhPbjQ4MkFzbDh2WVRVR1RPdmV1S0RYUmdNam44SEEwZ2hKRjVvekdGZm5YaW1yQk8zV0E3eTJiSWJsUWxXV0Z4elRSelFncmhrUTY1M2xsWEZZa2dFWDA4UFkvRWpmYUlWNjVKRkhIZ25EZmlOcWg5QjMwdkovK2VXWGN4ai8xeWRQM1A5QW12eEcwcTdWVlUwWisyc1IrdFh2dkR4WlNhVSsveU0va3ZMdno3VlR4MHFkQVE1d2MrQ2tqa3VCaFlzZWNLamx1R0lrMFdGVDEyMWtrRmdPN1pjdUZnUExHcEFMajYwSnlFOWNkSXhtd2VoYmZZNGV5WmJ3NktQNXd6RzY5eU9BWUpRbklza3pUWnRMbWV5SHFTbWMrS2g1cS95b1BiU1BNdnJaNzNBcFRyZHRvdTIvZzE4N2puTjBEQkRqREJSbGFoc1dXL3lPQkVhd3RTQkR2WEU3NTlJb3cyQmhsaUZlbFJXb2R0TDU5OUsvdDdaR1B6bVdBZFh4QzAwelpzMEZaK3BTdkNaMVMwMEtOMkF0QnAxOEcrWWh5NFAySG5VWHIyMWMyTmpaK1BMMXE1dW5nb1VmUnNnV0NERkRWekZkZVMrM083eDNkYkliMjh5SXRaTmIxeUs1WGcyRHk3a0N0cUpldnZ4T1NUQWIwUnV2WndGa0k3OWJJYlpnT25RWkEvcllMbCs5a3F0N1RMOUNXSWdIZ2RueEY2MVR2a25CSWVyYUxjZ2tLb3c2ZW9TMFVWUU1hYWhza2QxeWVsWE05ekxlQjh0dUdCa3IwamNpT2R4SVBtWE9GOEpqaWNFZWVqZHBISnBQRWwvTzdRekhzbFYySmVjWXVBTEk5MXlrbjhWMHVPVjh6NGR3NVlmcHUwbkNncUN6ZTRkOU03V05hVE1DSGdRWjhrbXU1SGpTUnV5cU10VnFQN054MHA5ZkhUUmYzNFBYNlJDaG1tbGM4ZUt2NDh3d3JYNXZVa0xFSEg4TzBUWGgrWjcxNy9CK0ZoR1RRRWZFWW9JWVJFeVhNM3lsUHJMY2h6M3Y0Q245cjRGSWU2U0dBVkw4ZWliTUpwNndpcXA5WVNGcGhoeEc5Uk84S3k4enB6SS9UYnBnSVQ4ZFRTZFBjWG52WDhhNUpFNTd1cVU5Q2N4Z1RQVUhFMGpaZVc4bWRET0NnWlBpMmhUTlFHK0I3bVQwdEhCQTRyMTJmV3pzc0FzT0F6cDFLb2Z2WjlIT3RVNVVEZ1p6Vmd4bVQxZXZYQTlqUGptNWNPbXQ2SDB2WlpGNksvYktKeWJQNVl5T0IwN2ZQL2wzLzllL0MxTmJuSHptTTU4UGJXVVRUSmhZMkdpT0dBaE5ybCtlUFA3RXc1Tkg4enR4T2tkaWh1RnN4N0xwb2V4R1hNek1hNWpXM1ppOEhidnByY0J0OGJzdnI2RFdjR2E1RzFZMmIyY3d5ZGtVTzNzNWdqVDVPd3FYS3VMNFdzNWxqanJ3OHNVc2VzWm0zNktveFQzSGsxb2tQNXFidkoxdnpzOU0wa0tZaGJLc0RLYWhvb3BMSzdBcVdVdzdhRTVCekdXUEJQZ2xGaEZoWG00OWNwc1JIQk9BTUc2NFR1TUVyNEV5cWlXcXdQbFNDMm0vQkdrWXJaZjBGakQ5M0NHYXovcVpSZnNaZFBrNWxFaVBaZDg4enIzSS9ZMnhyREVBM2NxbHVCZzJXTVlpZXZKSjhTUm5WaHh1M1Y1Y3pnQzBjcno2Skx5cDgwTFdqQUpxWUVlOEdjU3lLTWgwc0N3OU1uaFIwemhmR3orb0hZT0pkYys3bDErK2VDRy9mN0YxL2VvcjYxZXYvTnB6T2Z6RkFlU1lyUE1vWEhmRDFHNDNVc0FPOVVZWTJFNzgxME5nQ0p1Sm10SFBOQXhEY1FXOCs4N21nMUNTS3RVRlNhWnVDd2t4a0Y3bzVJN09zZTBjZWlTTlgza2tmWTJrSVJZYlU3eGpKa1U4YVhENSs5WXBhd3RuQ0dGM1NVT240NmZsNnFid3BDM3BPVVJJNmpGSUxDOW5DeXZta0lZMWpWYmVSdFFwSlVHSCtmS3YzVjZ4dGNiWWxXUEFFSzkvelN4OWUyL21pQUM4OS9maFp4Tkl4K253OXUrbmZMa3VyLzBQUDRWL1VCNkg0MzdRZDVkMXQvQVJwZ01NMTkvOTVPdDlmSTg0NEpuOUhyNEhmKzhHYjhXZnFYT3Jsd1lXMHE3Qk1Za1pEWEU5UXlxcEtkK2tTWXdhYlF6cE9Pc0hhYnZGaUxpMXkrOFRuNmkycDhwQUQ4ZU9uUmp0SFpxaTBuZ25nZ1c0cUFaSTA2VHc4N0hTWUE5TjdlSGNqcmN2dkJrbS9aa0lLTzlPL3UyLy9kM0pnL2NmbS96RVQveEVMZ080VkhCWmorbVpHYmdhTm5WanFjRSt2cVRIakhLNzd2a0xGeUtkcTh0bUpKR2JVZE90aCtrY09iSVJDVHczcGJEVExpdVBvV09HQTdEckI5S3BNei9mOEFSKzllZGZmdE4yS2JvTzNraXo0a2dMUitLUnVvVmZ6NmFlenQ5c1EzN0pLbmJkb3g3aG8zZTRGSmsyeHNpSG1xbjY1QlFHK2NoVFdlcm01OVlhVC9qQjFMMkxWMkdCczJGUGtuS3orWW5UZVFuc05QWEVvZVBrSlExY2U1OHpRTVYxdm9mQXI3Qjc5cy8vL2Z3My82ZjNycjMzZTIrL2ZlSFhuM2o4a1IrN1B5dmJUbmx5bnZPTlNMK2JrVURtMHdCN0diVzNzMml4bVlQbmF4b1phd2NOVXpzRmd5aFhEWkZFU2FYQ01lWmJhVmtJM0U0NExSWFpreVROcjRscVBuRXdjRklyQkx0VlFyanBkelZXR3FMaU4zT09sSzFkbWQ2Rjhpc2Z6Rm1ET1ZkNmUyZHBjalhFZWZHZDBaRVFwczVFeHdldVp2S20wY3FnYzE3TUhYTExka21DNndhbUg2SUt3UTc2UWI2S01ueXpzeHkrWU9YQ251dUp5dm1SSkwrYlExakZwS1NmNXROKzdUK2J4MkcvL2o3OFBKem1neUNScnN1ZFRkUHZuVzkvZTk3TmovL0k1ODZTK00yV2NiZXloRmM3QjMyVjl4UVAybEU3b2EzdWhNMm9TbTJRTnJhZ2hvR2ZqRmxkYlNhNWNUbnh4NWtXRGFlOG16a1JETkxjVlI1NjRHOVE5NVQrMVZkZnJmelFDRE03OE5KWE00OTcrT0g3SjQ4LytuQXhZREJaekw0ZVJpcXR2TFErT05HcXA3Uitkc2Z1cEsrZzk4VUlMcVZXeWFDeUVhYWJjeE5xb0dBaWlEbWZqajMwaVR6TkVzRGY5VmVHbjNMOTVOdTNEM1U5dFFIWDN3WTFjZlV2WmNLWkgxajVNK1c3dlJmVlFhYU92c2ZOT0lOdTRRaHpWZzc4bFVDVkFjM2dvMjVWdnhsbUtFN0QxYnJueWlNd1Y5OU5Qd0kvV0R6RmwvZklhK0Fwbi90NVMxTUx1aWJMNGhWdGpNRWp4VmNkNVJHZnlrZWQ2L2lKK0VqcjkzM0ZuRk92eWZNdnYvM1ZxM3R2ZituVjE4LzlRaFlKZiszbzBiWG5sb0taVy9URG1hWmw4YlNtTTZVL0NuSnNCcm1kcVg5d0hvVERZSjd4YzUxUGxMYlZZTXpSNEpIVWtDYXFhZTljcGxvVzFtb3FuUHp6V3N6UzFLU1pKdjBqNUp1VG15U2xsYXBSUnZkUGc4MThrMzdveCswd0pEa1pYRW5BMTY3R1RHOHBIWGp0WmxiVFR4VFIyM0UxeHdnN3hGWGxaaXJIN0UzK1pTMlFuQkdSS1ZlVm43TDNacVRvcXVTVUtCSmgzeUcyV1hmNGV6Yk1lM2VpdTcwWHNRRnV4czNHUDV4bUp0citxL2lIWVRpY3gzN2t2QndPbS8zdTk4UFBnL3k3N3YwOHlMbmplQjUrOXkzUEVYWm5HcDE5ZE1EUjRieUxpOEZnTnFSZlc2WTNjNzNhYWt6b1NMb3NkRWpUNzcxM1pmS05iM3dqa3VNNEFVMytHSHZEaittUklPWForV0VVcEd4dC85SkxMOVVHaUtYc0JPU0hFZjlJZE15dVdiSnA1Y216VCtRMHVZdVQ5UWd0bUJGR2VEU1NxYlRLS09haU9xWGpTZWVJczNhVEd5eWlZckJUTVBTZlFZUmVYTGtiMFptVDJFOWtPemw0SEd0cUF3Mm1DUFpqV1pUazNLaWlERkx3d3BUSk5aNzREendPUEdQZUJCZVh5ZDRNZlBMRkdNRW56UU1QUGxUOXdhREVESzlnanJRdmJBd0tZd2JwM1dCbEFHbkJCcE0rRXU0dERmZzU1WHVIVTNBb3p3OStXRnJVQUJiL1p0SU5xenpBcE85ejh2QXR2MjcvQ3BqK0dYRWpPSVVsaU52eGt5andqRm1Fc3I3dm1MUDZaMmEzZVg3eThwZS8rc0xMWC83Q3VjZC83UFNwa3o5M2RHWGxCOUtOZm9WMEcvUVB4aGcybXM4dzNVZ05FQnhUR1c0blRHMHI1M0xjaXNSc1pibzcxVmlBQ3VOTS9KcmVoZFBUNWtGMi82VGZiN1F3MnZKUGcxYWpoN1hYdHhFZ2JqSDV4Q2Q1ak1iRW1KVWhWeXZSdDNLQzJIeE01MnhWdDBqaTdJMVRweXhReU1mWkhrTUthUWtEMFNBNi9renVWaG44WjhTbkQ4TzgvZXR6UjR6Wk5XZ0V0Zzl5VE5VK2lnTVBOL3NjTUE1LytPaXd1K1hYWVllZkdXc3FuZlN6cnVPMW4rOXBTZnZsOEx1ejNHbGJqSWlkZFA5NVo5eDk3M3JwOHUvMjVMZmZ1UUttOXhSY05LTXRHbzVPcTQzRXdVQjAzdVBIYmRjZUZnKzJORnZnWTJKSG9uN25uYXRoNGpkTElwWVg2NDZ1ZXpHZlNMUHk3ZDExd2tqTHplUXcvMDg4K1V4dEZMbWFXMVdFbmNrQ0lEWEhYMzNqNjVPbm5ua3F6UFJZcVVDS1BzT1UwTHIwM05DTmpvRmxqaWxtN2hJa1pIUmRVb1hKWE80ZmREWUUrTmhuWHpsOUpmY21uZ3J6alc1NWVkd28za3dLZk4yWEtuL3RsaDhueng0UU9oNWN0YXQ2NXR1Z0JsWjVtZzA0RGJJSG43R29tdnhLS0prazdsQ0pTRnZ0TXMwTTQ1TWV6Snd3UCtYeTF6YkNsbklZbExpRCtSNE1IQTJYZkJ2dWJrOTV5TXNhUks2SnFUeDk3Nllmam5xRllZZlIxd2FXOVBGaXdsTjRrdG4rdHpUZmw4eDUyZ2IxZVA3bDE3ODZtYnorMWMrZmUrS25ZcjN4Ynl5TXBOcW5jcmJBbWZtRjVaTkJ3TDhrYlRMTnFjV0E2QTB3WG12Q1czdXVqVXBuMDNEVFRFbkZGcGJzUEp4RHJFRm9FMU5lNmgyUy9UektUZU00OEtVYU1YbEEvbElXbEVUWnl3VzFiSTVyQzNiS3A3cElCdFU1VE5tdXh4YmFvc1NsdmN1VEkyOWZMR0l4b3R1d2dKZ3NFbm11ckRTVXBrb3NRQVp6MENHNlU0QzFjZ2MvcnYwaGJoLyt4RGxJMTVVYUNkdS9uM3k5SzYvZGJGajcvVTJlbGM5TThiN2gvN0FiNWQwNUlQQnJmL0hyZlpwMHRPRmdFUERlNGJJVzFtWDBzeUxNL09HdlBWTkN4WVZoK2V2RTJvVnJ4dU1kRFZCbDJDSk41WURST3VmNDJMR3JkY3NJU1ZENmphMExsWjZFTEIrU3MzeVVKODNSV0ROUUg3Z2x4d0JOTXVSdjE1N3Q0bFJrSkZmdVMxLzZVcloxUDU4RnJzbmtaMy8yWjNOcjlyaDI2dEV6RDVjVWEwQllDK1BqdXA1ZzBJeDF3MGY4TFF5cVoxa0RoYjQ0VEd3bm03NElDOTVkTWJXNlBPNjFCQWRIV2dXZmZGdmFGOWRsdy9MelE4L0theVlubkFrbzVzWFpBWHdyMWtmV2l0Q1djQmNZazJydEtvUXorR1lFQUZmeU1uR3RaOTQ1NVhkYVoyVkg2TjhQRjY5ZHg5bk5tY3Y4d2RjNDhiNjdOMkR0TUcwaWpaOTRmblRiMmt0OGp0QjF1QXdMaE5KMmVoWlczYjdpZnQ4ejUwYjQxMTkrN1N2OTNzL25IbjBnS28vNUx5L05MWnpLU3ZDWjdCWTZHWDcxcnlHMEdHVFVETUZ1RVVnaE9RaUdhZ3c2bU03L1NMSDlMNFRnVkMxTzk2YlByVk9uRXM5Q1VSSWszTWljbis4UUJ2MjBoaXlUSXhLODVQbDVsclZCUHQxR0lVZEU2OXFxdEhubFRRV3ltRTZMd1RyZEs5bEdSejBJaEhHLzk5RHUrMXdUVHdWTVZSM3ZpelQxQ0dnald1QWRCS2Nldy9rZTlSb0V6cmVKYi9ZNW00Ni9INzkyczNGbjgranc5anNvZVlUTXBwdk5ielpkdjQrNDd5K3p3ejA3RDAxek55ZjhJTTZJcERPTzFmcVI5Mnk0TW5XMGZnckRPRGtNQitOaUdZSEpWSWZQd0UzMXNMK29tUFJNT3RHQ1RxNzlsZWQ5WE9PME0vbkUvZmVQZkxJd2pObWZ6NVJST1JpenVHKy84V1lxSnMyNVlvNzhqOFFlbWFScEN6bEovSm1ubmk0R1Q1Vmlnd1VHNTRkWlVsM3NXaFNyMmVHb3YwRWZETXBaWFhWc2d2d0hrMFhicEhWV0c4Nkl3WWhIM1hZekc4aTV6cW5UU3RKNGlsZldHc0ZSOWJkbVlnbkRYTUhmVzZQaHNSbXU5K3FMd1NPR3g1OWozVkRxaC9sWXRRVE4vUHQ2dW9haHl4RnZ5U0o4Y0s0ZXlxbzhBb052RG96cTJaSnRDVy80QWppRFUvbHJFOTlna29lMHZxVkpMYXJ2T2haVkgyV0ZrMHlucW94aUsvdHB1MHpsOWp1NitFZkRuRlg4c0h2aHpYZGVtUFU3R3h2OUk2ZE8vZjd1NGs0ZFNMdTJ0SEFtQjRpZnpNMFFUeTZ2TFAxNlVGcklLL1Z1R0tZR2drd05xWEg4dkZjREp1TTA1WDcySGNlem5ZV2NVcFcwK2lOaHdqdUdSa2NnNG5sSDlEb05vcUNiSkpFZ05LNGJ0Y3ZYd1JaekxiM2lrQytTNjZJeEZEQm1uWFEvblR5NFdmaTZiaVBrL1hIYmZ6WmRwNTk5Tm15ejhXZlRIUGIvc08vTzk4UGl6SVoxL01QUDJUaC8wL2Zxa0tXVFBjaEJPVTBMell5MUJkZU1tRDZXeFB5TmIzMnpHTGJPYkdzMFBBMHp1OEZ3bU5oaGZKMmZ2Ry9lekc3Q2lMOTk0RTVKME5QRk4yYytzd3RtcVdIN041ckJ0TkhJaXkrK21CdFZIcXJ6bnYvb2ovNm9hQWp6cFB0Rnh5Um54OU82d1ZzNTBxQVI3MzdXUk5wMVBhVGRuRnBNQ0JNSDB6Mnlrb1c2ME9leXhlbmtTYnBYajZMbDVNVlYzaWxYM29YSDFMM3B4Rk00RlFZNHVoK0lWM1NOK1NYZHpadlpJWnRaSXh5STc1UkhjWnd5S1p6RlZWQlE2WVVMa3hkOGUrNnk0SnIyV1RqZytDdmZUejM5eGtBMS9JV1RhZVVoalh3cnIrVFQ3NE01eDJBZ1pvWmN3Wlo0WUtxNHlrNzhXU2NzRWNwTG1MenZJbHZOSnZuSDlYNGx3dXc3bTV0WEw5KzRkZG52N2V1YnI3eDVkZVBiWWRDdlJHZjA1WnM3ay84bFpubGYzcG1iK3o4ai8vM3l0bDJJd1hIR3pKcDJrV2JMQm5PSzVDeEI1cExKNklYVG5LWTVXR1RHL2JwU25SVE1USGFvU1BMRXlwa3V4UjQ2ZXBWSTAxSEFSQzFCbjJlL3ZqQ1N0ME9NL0VqVURuTFNHWnJvTlhBVE5pSllLcldMd1FLeEl6Z01WcHVPQWNXbWxlRkp1a2ZRRlJndjBrRUduNEw1ZzJtQUtpYmFrWU9mbktmZlpRa3lIUVNxeE9UWFJBL09obFZZRWFhWE9ISGFIUXhUOERQY0ZNUnB2UGJ0OEduYUttc3dPM21QampBdHY0YXBVZVpNVWNsODVNV3Y0UXpTSXZFa1hVSUxyNktrRGFxTzZoNDh6Y0pJNmxYVzdJeWlPbXI4TVJVLzAzdUhHdG5KOS9MNWw0dXg2SWdQeEF3T0k3b1MxWVE4TUFTMncreU1uU1B1NEhtSGNhRTJkT0N3b3FzNU10Y0FmZXJrcVdJV2RNbzJUbUR3eWpHWXM4czlFdXVkYytmT1p1cC90T3lLZmF2bnpWZ3NyV1dYS3VaNUpUcHBkd05tQWIxcyt1bThMOFZVVDV5YnpFZ0RrMFUzdHZUV014YXkyU2xHZUJFU01rUExPOHNrQjIyeEwxN0s5dVdWbklSM08rZmNXQ09yM2JCbGQ1d2pTbWZVR3lIKzREYUF3Q3ZjQlEvT1BMWVFDSFlISVJrd2pnUkc1MWhZUDlrT3plOWtMY2I3Wm1CamlVU3RzUndWRVJ6QjRXcG1CMk1idW0zeEpGZDdENmlGaHJUTHFvT2tiYVk3bHpMcXNLa3dXNkpVMDBSNmRNRU51R3E3Rk1UeXljQVlzKzRJVEJiazdUUmVLSnl2Wk51Mjg4TDlGdEpYRjdOK0pRN2pnaVJMUFNKWUpVNGRrcFo2Y2tkekZUcTRNZSt4TnBSbm1WWkZkWlEwLzZnbDU4TFFSL2p6c3RQTEp4Ty9jcDkrNU5TVHk2dkhmdnpFOHZLZk5EUFp5N1NsTENiUzRFeVA2aEQrRUUweG5oQ2UzWVpHUW5xbGVWdkhRNVJiYWJ4T3I5TWxXcHdwWFJWVGFYWFVmV1lSNzJaazQ0bHRETmZ4ZkhXZWQ4YWRSZ3dKSWtCaDQzZVFaOGZvZE1XVjJuUG11UjgrNDNlMzE0YWpueDNIZCtmUnp3NDcvTjMrZDN2T3hpM1VWUyt2UHBQb1U1K0IxUDN5QnF1OVcyN3Y5MnU0K3lsR3d6NmU3MDh6NjBPeUJLUEJrd1Jtd1BRajFWSXJjTDR4WjB4V0c3TFhKUlY3cCthZ3doQnVVT0pYMGxuU3laYyt1YTArNU05UGZ1THdkMm5EVHRRU3luSVA0ZTNjblBLTmIvekgyRU0vVUNvSEVyYTRwR2I2YXVWZ1JBMFBSa2Z5WnFtQWNjN2xGd0pPNlVNS2xMWUhIN0J4WUdnNGx3T0Rlc21EbEM0dStEb05ITXBqdUpHZVgrUFlhWkhhVVJwcW9HTlpQRlhuSzFmZXJYeXR1U2lMcEZ5enllQkFXdm12S0N2V0wzQlBnQ2tWWkVnQ21QekVYOHNnTW1BWVpiWnBxVHFFcDlZZ1VlK0pteVRKWTV4SVZ3dzZlQW9uTFh5QlR6d09QTnBDL2wzUHhvbHcrT1g0VVpWSU85S1BXUVI4TkU0K1pzNkZxdS90enpmZnV2TEtVNmZucnV3Y25YeGhhVzd2MU5MSzBwbU04ci9sR01DOUxKb1VvWWFnSTJwRVJ4d21hRXFZUnJQVmRkSG9tZ1pnQ1VISGgwMXJxR3JBWXRBa01vU2F1SWtUV290THcwOGJ2eUVsc2FWdGt4N0YwWUpQLzVGR3BnUmY5c3hTVjNMRW95TjRTbWVvR0IyaXZsUFFvU0pxeEJjMjY4QlpJTVZ6NURRYit0SGZ1d04rOUJUZmUweXdjdU01b0c2L2o1SWJHTGxtNkYzdjRUZndXaEh5cC9LZGpURDE0Nitqb2drTWswUk1lc3pKQXpuWFl0Z1h5d01Ed1JUYlNiT1J6VWZPL0szelU0SnQ0Y1hncG9zSjdLRjFaUGxKeituOHl2VGp2eDBwMDJBZ2ZIVTFPd0RqUnlvK3NyYXlyOUxBdlAzRWtWNFp5aDg2WTlQMzJGWnI5ZmhSSFhEQ01TdjFBUmNHQTEvZWxlSDlSSGF6T2lQR3JUMGx5U1lMZzh4UzFCM2cyNHE1cW5RY2xRZy85WkcyK2xEOHFTeThNMzJsQ3FKMldWek16ZDhaK05qM0M3ODl2ZXNUMDdWRnVuQ1VmQTBPN1FZVEhGK2tVdkRmdWpXWTQxN3FDNld1MVJvM3FBK0J5SkdlbkRyWmFhdS83TzVTOXd6ZHZOdkt3VnQzbGFhZlk5cjZGVDkxSWF5QmZieVBQSVYxdUZNeExRb1hjMDZmRjY5dWlJR0RwQnVsRndnZi8vbGVNUEJlZHFaY3ZMWjU0ZTFybTY4c0w4NWRYbHBZK2txbWQvL01GTXNDblMzV3dlK1k2cVRKc0xUNkYrS3N6aDVDY1B5bmhySllRQ0NoZXJBSUVvR25wT3Y1TlBaOHZzZVp3VU0xMFNvSy91MDA2dDErZGR0SkloWGJUcThRWjdpa0RSeGNMVllFbG40ZnowQVlQeDNKODROYzUvWkI0UWFKMmZSZC9xemZiTm9PYjcrNzVRK21kdDJCZlkrNEk3RGZaM0hTRlM3Y1R6TzRzMnBkV2orVFlncS9YTUdjMmxUS2dyK2k1UnVlcG5oTjk2cHdmOFhoNzZsejkzZkh0WDFiZG9OcFpJRE91N0RSdnFOdHFaV290QndSa0c0ZWhzSkdHdk1aMHBmRk90SXRxREFtN2xRWW1QSklxODRYZDBMYVNwZ2hxZkFUbjNnOFp6ay9HQnZvNzBTaWptb3NLZ0tDQTBuUCtjMFA1eENteHg1N05JdDVtM1g0UDd0L1VqWFRUQ292eDZ4aVRPSnZSbzNCRHl6ajBIaTBHNGsvK2RtMEpZNE5ZSmdnZURCeGpOU1BaUVVHeWpZYS9YTnNoRWY5QjgxMDJ4YmVNcHNjMHVpd2ZzQ2dUMGF0d3diYXhnMXFwTDJrcDNLaFZ2UzhtVjI5OEtkOHp0R2dZRkJlZUdiQkpGNHQ0aWZlYU1Ma280NlZJbXFGTU9lMk8rNHIyZUNTcXFRR2pKUU52bTVEN3dZMzVYZzZuVTg3YTFPcUpHa1RwZXFxdnNOdkhMYlVpNTk5T1RCY2ZDdzVUeHZpYi9ONCtlTEdoYjJ6Rzc5Lzh1YkRQNTVGa0RQUk9mMDJIWEV4NUNpY1dCMHRaTXNvUFpaTk1KNGNJdEFJT2xjOXRWeEdVSTFjbzNSaThOZWk5WnlObDNkRXozVWNuUWx4MFdQTFkzNXhHaDcveEtxNFNxM3M4elhLR1l4WUlMdldVYzU0QnVTcEc5L0NHdFlLNkl3NjJnYzhHL2JaWUdYUCtzKytpMWZmQ3Z0YnV0bDhsZWtmdjFIM3hzbmRDeGx4R2s4alRzTTlubmRQMTc0NnJYZ1lrU2NHaXNsZ0VQd3dEMjBvSGovUFlqU0J6emU3WjVMWTF0WjdpWmYyVG51QXZSaE1HQU1HZ1BrNEV3S1Q3anlVVHlWeTh0anh5ZG16WjhNc2IwemV5SzFCeDQ3OVo1TW5QLzNjNU0vLy9Hc0Z5ODBjeVhrcVozZUFUVDRrWHZtRFRkN3NtdEdFZkoxWGdab3dKVllaMUF2elU4bFJtbVpRbSs0ZFRCM2xkeXlxRFBtUXdIMnJ2N3pFVjI5NWVWZityT1BIdWMySVB0eU1vNC9iWEYrL21yeWM1ekVHcUdhRVE4cS9tbk0vaGhrZmtsZWV1dmk1MTdQTFBWeW1HK2xMWlJOY2grMm12NDUyNjNoVmZ6Z0lrK1hYakxsbXhDZ3E0R29EaTdIQ3hSZm5JSjIwbzMwOXhhazJUemtMZ1kydWZLZHVXb0hocVRraFhYNWg0ZU0vZjJzTTJQZ3ltYno5MVhTRzFXTnoyMS9JRVlvUEgxbGUvVjBXTkJZU1F1WGh1L1IyQ1A1Z3VxT2h4bUpoNG1ETXhXRzJFblVBQUVBQVNVUkJWRVRKdWxRVmFaNHAzYUpmY1RXZXZ4eWk1dGZQNFRzNmtQZjUzQk5vMFVVYWpoblV5S2NaY2c4RUZTeEN2U2hHbnQxcFJyblRPTi9qbzlQMjgzRHl3LzZIdncvSC81dCtkMTJrYjN6TitzVjNtblUvRDBvQ1U4ZWRoYS95bWVLMi9LZHROQnUzT3pJR0lZNGY2VkhuTktYRnREaXRYY3dxNzU3Q3k5NDVYSVkrR0NPbzV0UTQ0b2U1ZFY0Mm9aUnBYcGhyNVpFNGJWMWhrZS84K2F2SjY2RktSeEttYTE2L2ZqVkhFa3pQWUNtR08xUUVQWURVd0QrMVJIR21zME91V0QrVUJKMzg2Y2Fab2kxR0FBQUg1dVNack9LOFoxdDNKSFBIQ1RoV2dDU1BZVHBhWURObVFsUW9HRlc3ZnBkSHUySmd4Y3lHN1RLN2ZjdGs4T3R5RERpaFpzSEF4VFc0TEdkZzJBMnVGN0tUOFViQk8zQ3VQajBnOU9DVDFFSDJ3SDh5SFhUUkFsRkthbHcyUEdBYmRSeUR5cGpoaGpGSC8yajJxOC9XWG9ZTVh0VSsxYW9rZWtjNjVQallYSnVubnRKaHlrVURlUnBvSEcrTEZramF5cEQrWStiY21QODdlcDQvZjk0cXhsK2VQWHYyMjJmbTV2NmJuSXoxRzJUb0RMcGx6NXcyS0lmQXJFWVBBb2hYZWw2ODBzZ2Fub2lFREErSWR5UTZJQmdOMkxybEpwcVI4d0dieWVBYlYzL3lOQ2xIam1QMUdoaHVibERXQVROSnNlVTNubElmZHNLNWVnTDRROXhzM0g3djZNbzg3TmRoZjVmUHJwczh2ZnQzNEE0WXdZSGZ3UnY0T3IzM2FkVXJ3b0I5TnEvMzQ0d0VLWjVPMS9YVkViVzVieDIxbjIyVHE4UHFtTko0TnhNU3AyN21tTGFWUE1XaG1tZ21USElteldKUTB2YlVteCtHKy9UVFQwOWVlKzIxeWRmZmZTZm1kR2ZDTUhLTFRoZ0dTeEJ4cERGb1NPK0pnVkdMZ2JFTzQ0cjZZbnNuQng4RmYyNlE1OVFESEp6cHVHOC9hY0RJYW9Sa3F4NERwaUZGSzBNOFllMXFPM2pWZStCTW5WZHpFaDJKZVNNblNGSVJnTWxzWXUxb2JtUEorOVZzY1ZmK3JlQzBjSlJPMW5sdVdmT0pFNjZzbXI3bUcyejZIWmkydzBUcG1URm82ZnRzanJSNnRmVStucFBIZHZLemdEZnFPN1d3eU9CUVJ3K0gyOHB2TnpNTjA1c3greGtIU3NtREU4NzU5aHR0T3VBb2ZCbTVac0xCL0RGekxwVDgzZi9CcEZjZWZmU3IyZVR5aFpXbHVZZXphSEJtYVhIaE41YUxPQVpSeHJpbUNHY25sOEJpcVhQemc2QktPc21veTQvVGtPM1FtWWFidG5sNWovY0RaamNrOFJGUEJCSnp5R0lRNFBzU0hqQW9RWU40eHRPQThyZDFUWXllN1dicjAzNmVzM0ZtL2YrL2VLL09hQVQ4TGc1TWR6TDBBZWRIUVUybFRkc3BTNmYyYTJhbFEzS1lqRjlkWStZN2pBWlRaL1pWakNEU3Ezd3NGS0dMeGwzbEZ6cEFHdkxTK2NVamtYcTJPc0UzeHYzRUUwL0VVdU12SjYrZWZ5bU0rcDhXRFNuM1pqYXdORVBIeE1XWHR3VzM2K3ZVRUJFUlVqWUpWZG4rS1cvZ2IrQkMyY3BUYmp0MWNGc1BsWVM4dUs1ck0rWVlGNDQ2SnF6eVMzcDVDQzltVi9VYnVPTW5qa1YzWmNtTHhBemUyNUhFd1FlM3pwc0d2L0liSi9MVUp4cm52ZzBXNDRqWE1lZ3VaTllxZkxZT2lWYXdpRXRPQ2dqMVhYalFwdGxsS0w1MDRBRlhPekNrM3hkTXdzdDZKdUZWcnZ3NDYwYjUxWkVOOG82WEdWVE5vdEt1ZzUxWHpJLy8vRjFqNFBMNit1V0wxNjVkZU92S3RlOGNXMTNhT3I2eThNcmF5dExQMVMwc1dYM2V1WVZocHVPbDhlWnpUZ0lDV2M2OWZzdXhqVjV3VHU1OHpzTU5VT2thQTdTeXhFaG5TWWVaaXc1dE1Zc2NRd29nWTVPTTg4c0l2SkNmS2ZBMnBsem5keVI1VFR2VG1VSUNaZE9NRlBJZmNTRWtVMFNMS25VUEdzTEFtVXVDVHlScW1lUmVYVTgrK1hKR01wL0VpbE9QOGZSZTMvdWYrVWJsK2NtbXN2SWQxVTV0d0pGdStvdnYvanUvK3VZMzQyYWlKd3RmY0pQbkFLRHFNOUlsZjM3MUcxR3FuT25pNnhpdkJ0d2pXdXFUbDdGQWl2bUU0U1dqS0lJaUtjWS83M0RsVi9GUy96SzlBa0lnMWZuemQvcjBIcWt5VXhkeHU5TktxM1BxckJoSDVadlV6bXJXZnV4NTB4UjFJYXJEdUpiWjkrWjM0Y0s3azFNNVlaSGJqS3BBZVd6Z1hlZmtHaldYTnJTOXJGdC9ic2RDZ2huYWtXTXJrMDgvOTF6c2wrK2JYTGtXdlhYOFYzTGV4RllXeTA3R052ckNHNi9uZk9mclkrRXI5WEdIWUFTSVlucE00SzdGZ29QQTUxNUtDMmN1ZUYxZnY1bExKV0xmSHppM1VqYTZvdklveTRUQ1RUWk94ZDhWY1Z6WlJVYzZQNW9UNUN3Y09vU2ZiYldEODIyL0RpcVNSMmd3dEJma2xZckErYzdvanhraG5UY2I0V001QThTaTJZMlU3WGM3OXhRNk4za3BDNlRaSUZaUDc5amI3VmlvNEh1bFMwNDdnRTg3c05VdUNUcUZicU8vd0tEWE9HaE11RVAyU2IxbXBNeGQ2NGFXcEdkR3FDOGN5U0MzRnZ0dHRzMGtabFlmNmwvOU1HVmJRN0E1ak1wbEsvQ3hacUhDdEZCcVFUSlJxeHl6b0ZvTVhNek42NW1ScktZZFdXNjVQUG9tOVUrUWV5UjEvbGh5RG43L1BwemRpTnMzVDc5OWNuWHZxMnVyU3o4UWlmclV5YVAzL1ZwdEN3MVRybGxZR0hURWxCQ0NWaHdqYXNpMEdqUzBPa2J1RUErR3BLTmJvQmdtU0ppQTc2THZrRlBpRkY4cXp2Rys2aUZFemxNK2gxMzdlYllhNWlDT3FlREJsN2ZEK1J6K3ZqUDIrNys2dkE3cDcvZEQxakcrdDJmWDkzdEw5ZDFqaythS0pjL2dzTXFhNHQ2VTNNQW5YdUd5Mm13d1pzeTUxUjdDMDNMMVRab2Izdzd1R2RQM3RXeFd3T0RsdFJnR08vSWE0VlFRTnpjM29wbzRXSHdUajJWSGJYU0tEcE9FU1crOUZJNkZnVjI0OEhaMDBBNG1HdFlMYWdwdThJaFhGaUQ1bGsrSDBadldUZko1ZGwzY2xESVhaZ3Rla3FPTkdBdlJMMXQ5a2RkYUxFYzJibHl2K0F2WjdYZzdBd3ZkODRsY0owZWZmaVVYV1RqVW5qTmdJZHFoRWdoZWt5Y2NlUnJReGlhTkRKYng4MTdoRVR5VUEwN1NPYmlGTi8zZzFlSlp3R3lUMXNqVXVrWlplcXpRcGFmODhPNUtJNjYwOHRPa0R0b0hWOEVHUHAwUWxHQXVlT3V6d3RXZkcrZlpERFdPYytMbEp6NTVlRDZYMXhvQXFzeWtwN1pwZUcrbm5ScmZZL0RPakdway8vSGZ2dzhNdUZZcjVYekY3N2tIamorM083KzJ1YnkwZUdabGVmNS9yR05Ba1Eycmpsd2VpVnVIVnFvaHEzSDEzN0FDSkZ4MFFsckpDTXQwaUM3WnJRcUlXNmNrQlpQNGJodTVReHhOckhKb1Z3U1drWDcwalZBaWFvd2JEMHc3NzRNVzg1N3ZFaDFURXIrS05LU053M2tYckFrZno4cnlBLzhjVG52NE96WDl3TFFqb0pEeWdYR0FmTmdCdjM5M0NUNGMvVU8vcXpNbnMxbTRDNjhLaUd2L2Z1cDB3djJhRVJ4OEQ2WlFqQ1NBYVdQTVZUajdYcFlBMHFqVE1MRWJGaHFPQkNYOTZkaVlyODd1L0lxVm5POVBncWFxc0huandsdHZSMTk3TElmdG41Njg4c29ydFNtbFZTelN5cHZ1bWIwenl3ZmxrdWpCN3VlTThsdWhMZmxoMUNNTjZka1pFcG5DNTFZVXQ4TVhnNDRaYVVpdzZPZEdkZ202NWQwc3hua3ZiSjZQM002QlRSbHdpdEZPODI5OE5hNlVQOHdJWFI5blBTYkw0OW1hTjNBNG1MTjZqMTJUT1hjaGt1WnFaZ3B6ZGhJR1IzNjNja0VBVytpZEhWSzJlZ3lneXZ3T0xsT0dYNnNCdlRjY2hCNE1seCsxanZlQ2Q1ckdlK05QR3dqSGVQbjN1NVBvaXVGbXRsYTdHRE40VE5LM2haZWFJL2phTHpNOTFnQnM4UlVPV0h0OXpKeXJPZjcrLzd6d3p2b0xmaytkUG4zeTZMSEYzMWxiV1g1eVpYWCt6T3JTd3I5YWlmU3hHS2xtTjdvMFJLYXhHT0duOVdzcW5DWk5vMkl5NmJ4K2VTLzdhRDE2K20yVVg4anFzTFQ1WDUxdjFIS1dXUS9tSm4zMEtpUFlkRys4NWU4MFBTRENBbllqNFhzV1FVc1Q3M3BQQWZ0RXByQVoxLzY4dXVQTkJOZnIzZndMN2hsSURxY1pDZS9DdkpVUHRydTRqd0xMWFpKOVY2L0dnWWdEN3BIRUtuN1hUYWZGV0h5VEJIVmF6SXhmelhUOFRaaGZ0eWZWZ25STTRxNDRIak1xQ0V4R1c1c0d1N25IclQwNityRk10NHNSaEVHWUtsczRzeWhZWlliUmtPSnkzMHI1cFpCSWp1T0VPd3dCWXlhQmtzSkp0blRRR0k5dmc3RjdNa3NmSFNiSjBxTDBwbUY2Qm0vVU1oaDFCSUpiZy9HUW5tMDYyWENhWWtnbVBMMjJkcGVhSWVvNHpIdzlxaFdEd0Y3d29HenFtVklmaE5hb2U1b0p3eTNHYktmalhNNDdxRUdyOUFPUmlQbXhra2g5TEhENkprSEgrSzc2eTYwSUorQ1d2MDBkWnByK0VYTGt5NStUaC9MazdjbkpreXVLajErM1h6WE9WS0plTzdwYS91cGhCZ3lQY0NNVnZGNkoyWitGekpzM2g2V09qVC9LWlh1dURWZU9EcnRuZ3BuNHdqaUhSaW1mdVBXeCsvOFJBMk16eTQxWDNuaDMvUytqeGZwT2VzUHZaNmorOW1SKzVXZlNoYVBiVFlkT205VTVEbWt3b3o2QzFybm9sVU9GbVpiUmtZM09yNk1qcTlMblpzRmxOUGdndEZITlFjd2EzN1N0blhqMWkwY1RTVmxTVlJRU3M0RUE5WW93bFFDUitwU2dadlB4em45SzN4MTB4MVA0WWZYSUhSSHE0d0MrOTRkaEREUGhNNjh0OFpma21hcVRzRnEvMjg5UnJXbWR1KzZIbjBrTHpydlZzZnlnTmVIdGZNS3JxYm1PU2tMaStJay9HTUJCNTllbS9MU1krSnh6TTZwdHBFMkdtS1RmbFhmZkMwT2ptODZHaXRLdHB1bVRScWQrTURwbGh5VE5aYlkxR0U0NmR0cFdQcWRQbmFoRk0vY0IwcGM2ZThQVW0rbWQ1aGNIYzNVdXNuZE1BN1BoM3M3aCtjckFaRzlnY3BtcGpUUEVvK0pJbXR4MVduVWRGMWJZQlZrSUs1elEyMTR2cTR6VVRmMlNuek1ubkIxQktvV2pWU3FRUEpYTHdTUUcyc3laZjZrejREajBWM3I5U0wvSlp1QTIrU3huSUtwWlJXRFR6aVJvcG9YNmljR0E3dHVDSVdRcWswTTMxbGRLcDEzbGo0RlJ5Q2dUSk5OK2xiS1p2YmxkZk1uNUhYblBiTGNXYU4xVkNsZk9MTkhXRmljZHhnU2Y4akZBdFNSTjZ1ZFVoZnJGZ0txZUhFdVgzbGcwYm5XaGlqSDcvZGo5ZzhIQWxZM3RqYmV1Ykh3bjV3SmN5Q1d4djVmdThMK0Y1cjRTaXY1NVU3d0ZxMWdoT1BjZU9uZy9SNTJtZ1VPUzRVWUl6NkpOUFVPRGd4QUhjNWpTUURFSVJOZk9CWmdsaEtEOWVJbzMrTFU0SWRScHdsS0JWMFJ4VWw3aWxWOXp3VW9yaCtFT21ObUJueEQrL2ZQZHpIbldqejlYZWZSeGkxV21jdS84alFWQlplUlhzSTczQVhmS21uYkd6ci95ck53RHY3QnAvYVplNzN1RUh4UWNzK2xFNnZ5U1NUN0dOMzlNcUo3eGwzOWQrQmttUUwyQXNTaXVtRStRakFuV3pTSkpZREdzR0pzOHBtWHExQTRSNGd5ODdKUG5rNGN0djB0aFNLNHhvL3BTWTFMeXlUQUlqSFF6eDVBS0srazJBempHZmlPWHg0SUZ3emIxNXNmMlhqMlV3NjFITWgrTWFUQVBnOFo2U2VwdXNuZC9acGhkWU1PY2IwVTZkTWpYRGRKdVlLcHp5TU9vK1ZPenFTaVlMYnJadmszVjVuWjZVM3VMYzQ2MGRhRFhYaGJOU012S2dnK0wyeTNkZ29YT0hveVlNZHlCUFZSZU1KZWttdkxzdXBNV2p0a0lZM1MrNWJNWmE0cGJVYU1ZUEREa09ySTNPTUs0VTUzZ0QvYmlpdkViSUFkVEhXVVBTVnVZUVFVanhwUXg1em9vQ2N3cHc0NU5BeDJjbXAxZzBGdDVPcFJzTlRNZTNjYUlpakpjdHV2SjRzUmx1aFkrVTd1cVk3d3pXTmc0TXc3NkQ0Z2ZNMmRJK1lmbUxxL2Z1UHpXdTFlLy9jYkY5VzhzSERuOWx6bXc1dmN6OC9wR1NPN25NR0s5QkZFdjd5SDJTQWxwWUpmSjNzeXF1R2trcHFWak9FOGFvU0VOSFdBd2xjRk02ajJFanVqSCsrZ0F2b3ZoaFBEa1N3THZkQ2hOK1A0T3hDbHhDei9zK0ZYUmh3Tm12anZ2OWhybHpPWTFwSTBPUC96RXlQYmRUTEx1YytsdFU5aTdEak9SSkx3TDNQdjVDVTcrNzRmcHdLOW1NVE1KbEZ2NG5oWWpld3h6dEFIR1BPcmptLyt0bkMwaC96NERwYWJPQnVFd05wM2RnRXdQVE1LaVlpQnhHUUNFY1JpUWFUdm1SYzNobG0rV0RLUm4rUitOVkZkbkx1Zjl0RzNkMDRGaUxSWWJuTFFrUGpDUW5FbDhHQnlwemlLaW02RGxjeU9TYytFNkJkbTJUYzk3Szl3dDZ1UXd1bVNrdm43QkZ4MnZXcXFETjVZYlEyQUlOU1VPcXdWMFVTY2loamxYMHBRUE4wT1NERk5PWWNxTjk2QmJ6RzFLeDVnZGFicGM0aW1uY0pqNDRPZjREWFdOOGpNd0pwNDQ4aGdMNkZPNFV6cC81WXcyR1lNcVB3eCsxQ2x3eXkvTUdZTm0wbGhNTlpWWm1LcERTTThHUHdNaXhxek5NR25DeDRCYm54eDZmU1NnSGNGSGZRbldFcnpTMWlSNUovNWgwQ3g5eHJCWlZmcjR6ejlFREVSaXVuM3gzZXV2bkZwZXZMMDB0L2hxckR4K3htbGpOVVVNTGVaTWo1cStPZFpSWnlJaG9EWlNRc2l1cWxUU1NQd0dneFk4aURKWFVleS82eGp0NzhtTmNYNjhZenlsV2lsbVBXWDA2WmdkdHhMa3oreDM5YWRwd0t4L3gyMG1LbXcyZlA4N000Tit2OXN6VlR4d0E4ejYzczlYQjUvK3F4bEdRaXRhQVBNY3FwK0RMQTYvZlRmbXZGTVMyUUVRWGU0b0JHTWV6QUxzT2lIODY2eVlweU0yNGFjWWRzSXRBT213YmgzQk1Fc1NpOFM2RWRVQWY1R1h3cFNkZTdFY25TVS96WFRqaHAxeTQvQjdqSm5PbUtNeW9IOHRLUzlsSDg4ZGZodTVSM01yVElNZk9EQVJaWUhoUnNLR3REMVVIczZjTHBWQUdBNjFSbTNXQ0dkMFhacUxYcU0ycnAreTBJNThBbVRWS1JsV1Bjd0dNRXhxQVFNRFRLM2xKRGxxQ0RybTNIQlZhUXNIUWdPVEdZYnpPY0NIUWJaTzJiZjZsaVNhdUpnM2N6WU9maHUzNGhtb1NqVVRobGZNT1htV3VWL0NXbTBrWGJLb3RBUHVBYnN5MUVYWjhTbVk1TDBhQ1gwbE9DL0pQSDJBSCthcTdKcVZCTWZ3UjJJMmtQcGR5eVljY0k2eWhsUXVYOHhaR1U3Rm84NVl6VDJSQmkzVFVRTWZCbTFtOGpGekx0VDl3Lzl6NGRyTk4rWjM1NS9QQ1dWL3RMUzA5czlXMWs1T0Z0TElXNkVmNStpU2NsZVdjd1pCRmsxMjQ1bEpXTlFnSWE4UXVuVzh1bW9vQkpUSkduazVNem9xa2RUYk0vOXNWQmtiRFhSY1VqTzJOc0tFVTZra1Zuejh4cFNyR0hyRlRPeWtxZXc4OWNMOFNFejhaaDFwZ3ZSWFVYSXZIWUxjLzZXRWROZjlYK1dYTDgrU3FwS284a3UrdzM1MFRDMTVncmc2ZHoxVDV5bzdzS1R6K0hHZU9tKzdZcjc1dFBXNHprYklzK3NZb1NnRG9LOVJwdHA1YnppcUFzSUtpVHA2SkxjU0l4TW5IUkF6eHB3eFl0TmVsN2ZxdkNTcVpqVE9lNUFwZjM1K3k3RjBjSmF4UzAxdnBJTVBDZElpVXM2bklBVW1UbG5wcFBPdTJVRlg5czdPTUY0dFcyQ2RHNlNZME9MaVhwM1JyT3liT1YrRGhNYlc5L3BHN2lYTURkazNyc2R5WXBYOWNVNnJpMStwS0JKKzZ0VEpnaGVUdXo1ZElHU3phNnpaeU9INk40bk1hVWltZGZsZlA5SmtNVWo2Z3VUUm1BUEw3VERpWVQ4ZlJwWTJHSFFEZDFRaFVmdVFzWU12QjMwVlk4YlBrRVdrMUVHdktVVGt0RWZaK0llNW8xdGhURS9yREdSaHlkdEFRTis5UjRVUTB6VjI0bW5JcWg4cEhuNjErMllVNXRCdm9DSzhwTFNxQnhxWmowWEZRdEx1N09wWFppWE9iRjZKaGNtd082ZHVJa1VmalU1NVNNMkRNV3RyOUdCR3dpUnhPK2RsZ0pjRnhyQkZkL2dSazBjTGd4a3dsOWNtYTJITVlGeGF5dm5YYWJOcjE3SWdtM1ozZHZaUVNnYUFqOTAvZkF3d3hUdDM2K2hYanl3dC9mZVJySDU5emk2SnVMTHNTSWZRQVJ4R2c2S3NYdGZpUy94MWNGS2lBL3pMcENpMDJBeHJ0dGJpSWZCOUtVUW4rUkRYRE9YT0tBT21Jbkw5Rk4zSERmSlBYMHJ3a0Nmak42S09DSGY1MjVMbzNXQnRQekNraSs3bmVaZHNpcUdKTCs1aDEvbTBmOGM3N0MvOGNCZzhZY2o4TWVPUyt1QTcwbUxINVU4S0x1WmFrdFd3SGlqSktFeWo4KzN5dElGTzd0ZlRkT1Z3L0RhanZuSjlsZno0azQ1TDRrNDVKREw2Wjh3QncyZUNwM3pwZXN1MFBNRnBrQ0E1azlJYVZtSGlrdXFsSjkzSkU0TnhIakxHWHNlWHFtTVlTYU16MWMvN0dGeW16VjAwQjJ6bGcyODd6RkNkbGN2SiszYW0rdHg4Qm1qMWRuQ1grUGxUdEhHN0NJUk9PZ3czY2NGblhVVyswa3ZUZU92eStZSDlWcldKdEdPZ1ZBK21mQmJjTU9QVjdONnJlV2JpZFI2ejlWQ1d3UXdnOGpZd0VWckFSKzJ6RmlaNzhzUXdPZVRuTUNiUzhucjArM0N0M09VTWVyYStrL0RSL1Y3cXY1UDg1Z0xMYW1nQ3JIQTR6cndabUtzWkNuVmtQajltemtVZTk4NmZsemMyTGl3Zm1ZOUZ4K1JmSEY5ZC9kY0l5NVpWdHk0Z0tBMGFrazBuYzF0RUNEMnRYd3VGL3k5N2QvYmpXWExkaWYzbXZsWldaZTNkMVRzbGt1TFNwRWhaMURJV29KbXhiSTh0dldtQWVSaS8yWUFmL0JjWUJnYXcvd00vK2syR0RRTUNiR000Z21XTjRCbVJva3kydUhXejJjMG1lKy9xcm4zTHlxemNNLzM5blBoRjFvL05KaWsvc2l1ajZ1YjkzWHRqajNPK2NlTEVpWWpNSDlsNHFlTXQ0TGIvTEZlRU0yS3VOcEhZZ0tpRFFnZTFmaGVtQ0JiRmxqTUVSR2lkTllGZyt5MXVCTWQvQndIU045QkdtUDkvWEE5L0ZDWUFJUmx4SzRuYzRPZC9TTFFWSmd3a1R0ZTQ2OC84Zk5qMWIvMTkxNCtPMTVWUW52bnRkLzdIbnlVcC9uNEJqSEcvTGUyV3ZvbXdnMGhoSnNnNGsyR3NCL2dSWndja0lBRzB2ZGNoMkpMV3FBVGdPc0dkbFliRkg4Q09tZDVPZ0ptS2dvMjhwbU9CNFdRVHRzaUFiSG01SFNBTENBOWozc1hlR0FCWnZXaHlrRXN4ai9JZzNSU2puZ0VrVlExckN1RE16QzJuQ0NYdVNOMURXMUora08wS1dGYllrVzA3RTNyS1lkS3QxQldKcU9Lb09teDFnN0xsb2ZmNHZTM3FsSENFRmlxUUIzeXdrL3ZVVk51OWptbWgwWXZ2OTFtbEdHNkdTa3F2N0ZmOGR1ZDN2OVJuMHhXM2psR25KMjdwcXQvWnJPd0R5cHc2NWVpS09kOWpjVlYraFpGMzdWdWowcVJ4UkF0SnczdE9PZmhsdXFnT2pGQ1AzYTlZRFRoQ0s1WWFiMFJ3ZmlPRS95ZUdnMm51RE0xREQwR25rdHpTM29hV3RWUWJNYVNNaU4rRUR5YmtaejVEc3pMbkttZ0RvRHdoa25ZWmFuS2RDZnE5RTdQNG1oTlFDdTNlL0RXQzl4dGdKcExtZFhSdnZodFJ0ZzgvKzllaEE4WHNWVHBsRUJIQzVuZjBPM2YvNnIxZkpKTjg3MzdxUG5wWEdaR1owWE1OWjhlK2RiLzFQVm5UNGZTNFB1cE9lclJjdDljRGdGTTNocllZbTRSYXp3bnNUbW9FYmtmK3E5NWJ1d0JBVEFyUTNBR0J4US9DdWJyRHgzM0NqajVXZTFLam5GZzVFYW41Uk1CMnEvWm1ydVhjeVU4QmE0TGZ2bk9yOUptV2NnUHdzc1FJa0xDRlp2MGhQWG1qTS9XT3pubDE5WFJvNVhDNGZmZGVMRFoyU2gxeVoyMjlkTTJ5QkhJQW5QdzJQVEg2VS9jNmpIaFFubnd2VlVQZXR5WGFyYnpva2ovMXBMNU4xUGxPRGFMKytsSm9nc1ZFQ0p2YUpCOUNtM1RYNnFOOGp1N1NOUThqdnBIRlIrS3VnNVRqVHhwQVgyUHVaRlR3SURiV1cxdVpjSnNsc2JNN0o1V250Zk1iU2N1WE1zbWF6dGZFTDlwemliK094RXFIRTRrb25ZVjVtelpDS0Y1S0hyU2gzQkVaZEREcUZTMVVoeG5yRG0zaVdscGNycEZKalh6ajkwSE9RN3dUZFlpNytqMEc1MDcxdjJKMzl0R25wcWIzNWhjV1BnZ2gvV05BZ29EWlFPdk55OVFJd2VXNWlEa1VoS1JMTXRieUNEQk1BU2hDVytVUUpLTHFEbVA5SWtlaUEyRVk1ZWllT050emJnZzlOMm0xMXkxdXhGOFVIVFR6NXVkZEkrd1N3NUdyc0VkUDdVZGpCRkdPY3U4dWpaR3I5Nk4zSDM3UHk0ZmY5ZWR4VU94eGpiOHJwc2JOY1FDZ2RKMnAyL3FYdXl6d0x6NzFEQUJKc2YwZG5iTnZuakdyMzJtVmlvc0VaVXZSSHRhek9MUVJjR1ZOc1JDckMzRUNhOGRRVVhIMFUwMm9OMVpxcjJaMnhUa01PS0RxdnJLUzFZWUIvZHJzS0lCb29rd0R5SmZ6QWxrYndGVm5GRDcyMkdPSmZ6ZWd2SldKeHMyQTlQMzhUdWN5YW1JbFA1SSs2K1VZT01lUDBWR1ZDTkFsemVxd0F1a0FEK2hQUjdWUTVZK3ZObmthSU9XdjhoUndWWlBKWXdGLzRnTDhhS0tiU0FMTmNxRWpIYTFPcHBuU1pVSXZZRTBuWHVaeFNhL01NSk1PazBEbWRUYnFGNzhUVGxLMVJ5NUJDb3k5cVAwMWRBYWpzbFh5U2FlQmM5UVNVUjIyOXJETXZrRnBBWE04YXRONzkrNVhPbVgyR0dZbzlaTzZTUG5zWTdLVTlwcU9Ebnd5NXczSzEwYm1qdTRteklPb3J1alVqOVVhUjgzeXEvZmo1VHQzWHZvUFRpdzhQVFY3b21hT1N5OVlROTh3Y2Y2MUphc05MTUNzL3J5a2p6d2dxczFNN3JqYi94YmgxSXF5U0Nra1ZrQ0F3TGdQM3p1Z3VEZVhOSWlOMERqcGh0eHhaVEZFZlJkUC9OWVJRQ013NHZ0aCtQTDFNMy9rbk92K2VqNk8zdlg4NVlWdXBiS1EzOWdFTUhRbmZJK2p2eHUvOTNpN0g4L2pZZnAzOS81YitBNlcvS3JIY0YyRk15d2xNYkdCTGRET2Q0NGZWNCtmVkRnZW4zajRCNzd1MjluQVJ4eDB3OHpaRW1XWVdSaEQ2OE1NMVpleUtkRmE0bFJIckMreVFWRlVGL1pzdUhneEoyMmZ1MWdubXJEZ0tHQThuQzNwSFJDck1hQUhwRnRaMDJyUlZaQWdiZFIvOTI3c25yVmxLdlZFZ0hydVRyTThVTWZtNW95dXVQSDh0emZ0blJJVEJOVEZ4RzVUdzdCemx2ZXRMS2VtRWJObDUwUTIrUktIZXFsRlVWUng2akhQTXdGQ09iVlowbjdVS25UdDFDU1RKZkdHUmxtOHBOejFMeGxyZVdsdG9GTm9ldXFFejFhbk9qY2QwWHpxazJwSGZkektqbnhKdWx5clE2cVVCdFo0cWVadjh0V0lWTnphMUtXZXRQM0pGUWZpTG1YVXNsU2QyNE1IMTJvaTBGYXAya1U5YWt2MUs1eDJ4Q002WW83cWFDcnFuT3pibXZwc2s0cmk1VmU5SDROelZkT3Y3cDhia3gvODI2V0RYLy92WnVlWC92djliSUNEeUdiQ25JWmNrNndoNGhEbXVHdk0yS1E1eEZDV0RTTmdhRDEvQXhQZmZwNFRSd2VhNWdlVll4QmhXbmpTY2pGei9CWVhDQk1pcjBrUHZuNSs5QlZsNEtQdUdLMDdUTktZOENFQSsxcnA1QjdvS3E4QTJ1UUxKL240S0NieHkrL20ycjNIMS9MZGdkeGR0dmxwYWZhMHUzL2xKODUxaG1MMVVFUFhpWnhLSFFBRW1OMXZ2d01GL2l1c1lYcmk3M1U1eWxReEwzOFRldzJzK1hIc2t1VG9tanR6WS93K0lTZzlRQ3ZjMmJOblMrbzlkL3BjZ2JQM3dKaC93T0tnVjA0ZVRKQ1J2Z0c2ZUlXL2YvOUI2YVNCaEZQZVR5eXZCSVN5TFV6S3lvOUZIVmFNcXNhaW4xYkJGYWZxOHRpdVZqY0FlaklZSkc1bEtYWFNxRTV0NEQrVHZUZnN5WEVZZXBXbStyQnpJMXFrUGVBS29BUG1FTXQzemoyKzZpNGYrM3QrRzgyVnAzcFBvTlhKbElzRUxBK3NYQWdxbXlVUjI3dERlL0NoemJXSHVrSEw3Vm5kS1pjT3hZUm9HOFV3WTJ6MVRaK3RidWRqK1RJeGNYZFVKMWxzRTNXR0Zabnl5WFo1YjhwQkFHbi8xRitOQ0pKbmNaWktKWlNyczNaWWJabFpUdXdlZzNOcnRWL2R2MDVndWZUcHZidG1veC9zTkdKWnRKVmtocWVUOW03WW1hejlFT2p3YW1Jd3BGb3JDbE5raElxb2k3Qkh3MlpLRHMvRkpCQnU1RHBEOUdkM09rOGlhZ2VlOFcvRmhLZzhWQTA0eDkwb1dCSHQrUHNQLzA3c3Y5VFBoOE93TmhHdVhOTHUrZTUzNy90dmVSelBlLy9kdjNlLy9iM244VERWT2FWc21KVmVNY3NLQ2l3dDIxV0hHeHZ0UkczZkcwTTNTVms0SUxjUVV5cnZteVRiOW5wd09nbXc1T1lUajd6UVZhdktoWVdaa3ZvQUFhZk5MZHYyTEQ3K2dMWGY3V3I3WnNpYmVQZzNRdHJPOFZUU25Rd2c3aVV0WGFEVFN0SzFSSkpqTjU4RkpuMFBqWURsNHRKS3BXR0NHYzBZZ3ZjNkFWcmdULzdxbCtkY0JXNTVXYXZ4bERIZ1Y3UldVcjl0VkZrT3BWNUtDZ1hZQWZDQUsxVVoydHRMUHVXM05sSkttdHZpWng2WHU3VEZWYWFPbFhDalFXVTY2dkVEN0JOUm16UlZRaVlra3llVGRmVEs2bDk5a0hvVFRlckM1djl5MzRRQktrSGhhZ1RvZFZ6bmljcWIvT1dTSG1uWTc2V3NCaFNmZlRLMFgyc3o0TjZrWm0yczQ1WTJKMHpQUjcyb1AxUlFpVE42ZjkvSDJPK2hsK05mdjFvMU1MVjg5NlZQUFBXcC8rYVpKeDZmMzk1YWkzN3hkaUEyaEp4Ti9ET3dqUG9xek1QRVR1K2NvYkxGSi9FUUlpZWxrQ3R3VkJpT0R0a2tYT2luZGdBTHU1Sk02ak9HekRXUks1SEVHMExQYkhza2dacXNDZml6R0NHeDB4YTJJU1VtWmlGQ3U1ZHcvQ1Qra2s1RW1qam92V3NwY1UrL3dyZjNoclpjOGYwSVNERUpoaS9tTFBLTmRCblFNR1NsVjVUNXZtQ0NaYlovWllPTnExV0JvdVlxUFdMeTAyMmNhMC90cEVRZ2xKNHJBK2hJK3FwRWdGeEp0Kzc1WGY0eS9BWXd5a1kvYVNLclJnNzVTQmM3TzdNWXZXLzJZWTdGUkJ2U1l0WkVMTzR3djlXZG1CZllrSXhMc2t3U2ZUaHNsTEdaTS9uMm92ZDlzRzRmNUpuaHFTY2ZUOTRPaHJ1WjREdFp5N1pYa2k5MW1GcG54NXQ0bHdNU1d5YVg3dDZJampnYkpvMDZDV0JIQ21TT3Q1dk4vRzNNSko4QTRlVEs2YlRqYkliajBUa2ZUR2RQamd2RFNpVEM3MzMzcFpqa25SbE9abktRYXVXRER6Nm9DYjRDdXBMdFNKWEFMbldWeVRJVnA1cXAxTXEwTS9sU1pQN2I1a2JKUVFBTWlKbmNTK1ZVdWVsaFN3MlNNckQzQmFac2dxdkp4QldmSGtpZDJtTTZkY2MwdERyaitMWGxwdmtXblFKNnBsL1htZGdXbFBSYXk2NFRDYnAwcGRUTkJKV1ZTT3BYMDFKZmFCOXBWZDdrZmFURFFlZGwvcGFNYWJ1em1WZzljL3FFQ0ZNZnlWZktzcEc2ZnZmZFNFdFpRdTlZcW9tTW9OQ2xmWnFyczB4K0xNQlpQYm1hemFsaTdaRzZyOTMwa3IvZEhPSjdLNXRXM3JvVC9rMGIzTHVmQlVMS2ZPeCt0V3VBOVB4N245NjllK25KSjA5T0JuQmZ1WHVuQ0V6akluVE9odUF6MGRWTlpwTEpNQk80MFdxNWd4ZUxGbXFvR2lZeUdkR3B0RUtINEl0azg5QXNFTVRZNHUwU2xEZUFodlBPQllTNUl2YjJxUUNzaHcxWGp0SnBET3lnZ1BKZlRCR3dDYk54UFEyeEFleFJWR0ZHR2NLeitWY2ZBM1Q1Nkh1YmpCSzZ1UjVIZjViWEFoVHhqZExyK2VhbmcyWXJSeGdlazhicEdMcS9PdjA1aVpHQVhJQ0V4TE1UTXpYdTNObkhTdnJ6N3Y1NkEwRVo5cXhzdTNzUGpxUmNETytDVjlxRUkyMlJlamx2SG1TT2dQN1lvaExPeU1WWmdJRGYwTnBXb2I0QmVZc2czbi8zYXNVbDNzTWdUMHUzMlUvem80eWtQTUNoVE5LU3RHZHB2L0hHVzhQYjc3NDdMR1ZqL3VkKzdWTmxOejBaVUVuQ0NadE8vNmVHUkE5SEllTjExK3V2TWl6UG83cDJsd2RwK2QzVUNCcVI5TnhzdmJ2YXdGYW8xWUdqcTN3TGpnMVRxYitaZENha3l4WStlUnJSWGFjYmg3YUtTeDU2RzdtUHUxN3YyNWxFVi9iV3pHZ1AvUklrMHNBSlgzeVMrRHozT0ptK2FhL05CK3FVenQ4aUk2c0RVemZoTFVsMVdrbk1GVlo0N3pqeGVFNU41RjJUeG9VbGRXdlRZOGw1dktWK2hYK3Z6TTNzZmU3VG4veG5UMTY2bE9PRjdvY1JjL3BFZEtCbWlqZlRrOWZHNkVTRE1JUlRUSXF2OGgwMVlud3ZTajRwb0FuRGtHU2dIS2dMQ0xSOU1ITG50ZjZGS3ZQUWlSMmhjZjBaQVU0bkxtWlFKYzBremZxZDZOQzdLNlJlMGJ1MU9CUGg2TGQ3cGU5NTdGMEYwVm1JTDJtSXAwS25JK2htZEo1NTZkLzYzWHVYWjNrQ0RQTGJnYW9ZSlIrOUt5WWFsVWtLQW5uSEhUR1g3STdDaTRNZndHREpzTVVkbHVXU1Z0VU5hY3FkcE9wZUFKSk84Q2l0RWNOR21LLzQ1YzBtUXNEWWNKaGxBTHRqazRDQVdCenpzZGJBeVBKandRbjFoZ05kQWM2ZE8zZUdLMWV1SE1WbG1UQndKcUZYMlBnbDlRRkFOcnJDc3NnQUN1TGJqWTcwenUwYnc4MWJKczBPc3NQYVFpWW9ENGIzTHI5ZjZqRjd0NFNZcWo3YUg4OVZCZTF4OUxmWGFhKzcvdXd6RTd1eXpFaWJOUFBPU0x0cEYrOVVkWk9LRTIvVmpRYjFYeHVnbHZqVFNmQmJJS2lMOXJaOUszcEtVUFhZMjFuYXl0NDdSeUF2YWxKOVcrYmQ2RUtuclE0VUVaM3d4RXdQUFhPMi9Ed1pzOFZaUzY3VG1mQnZKS0FEdjNIOTFyQVZzOFBaTFBjV3Z0bzYwcjdOam94cVdIcW9hNnN2V1hnc0xFWVZrblVLUmlYWGI5d2RydCs4RlgxLzFFNEpQRjY3bGZEeG4xL05Hbmp2eHAwWG5qeXo4cSsrK1B6encyTVhIeHNlWk5IQmNvQ1IzZXA2WnFXM3d0d28vcEJOZElqRzZxdnBNcEp2Qk40b240U1NxNENHTkJpUGFETlZRZ3BHL0lDeUpPTEVOUmxDeDBEWXhVVTFNSjJ3cFNMSWV3UnJHQ2MrNE5YaVprclVybndvNG85WFdhdXJwU1pGYVRlUUhHZG92enM0empIOEQ5TjRWL2tZUlFJd0MvUVN5M2orNU5GN1YwbHR5ZE40ZnZrZHY2ZytldHB5MUYxLzE1YkVQOHlqQWxUOEFlQm1ydFltM2dvUVlrVWhUZUFzZlAyT0ZPcnVXWnZ3UnlmcXVmS2ZEQU54MWdWMmRUUFJ0N0RZOU5rVkxsZ2h6TGx6NStxTXdCNHZ3TDJlN1Q1THRaQ3l5bGNpTEFBMHdjZCtlaTRBWVFTMXdhWTIvNWh6a1phcll5bnp1ZGd6cDRPM3pTaGd2eGQ2c3JUNHhxMWJpU2NockdJcllGS3JjYUVQcmswSTE4OVdGNlA2YnQrRWE1ZDhkL016Sm9tMUtqSHhXaGhsa3lIQW5Vd1h3TlZvTFNLcU8zaHNuWDNxc1hwdjhVbTMvcUFhSkpFaU40QlZUOEJaM1hEOHFWUFhWa0M1dGk5Tm5iZU9QZmNSTlZlYmVFb3dIU1k5TkxXR2RtSFZaRG4zU25UeGpncVR6NWFucWFoOXJxU1RlMUJiS1ZqQW9rNVp4UlFvMjg0MFlYVzJMcVBadVlDek5PK2ticS9kdWgyMXh0MllORWJ5VGpwcTROaDlUR3JnYTkvNDFxZS84Sm5QL2VpM3YveWxuRXk4TnV6ZWZEK2l3OVN3R1dCSTF3dzlVOUpJRHhtdVRZY2d1UUtUdk11V0hEaTltSjJPMCtxdDZXd0dqcGdOS2RGK2dRWTVPNFJmTGtSWDRVTkluTitZZ2NOOGtMeVl4ak1pRjBrY2dPZW1Jcmw3MTBDcERUL0hmOWVpaGZncnhoSm1GQWNXS3Bld1V0djNmdlN1TWFITTF2OFJVN1o4OVBSN25qc3dGaU9POGlGZS9xcXNLVS9Qbi9qSHcxZVlkQzRtV3F1c0NlZGRTV25KRmI5M291dTFFbytrMU5OaTZ0YnJ5UjRWL1RkcHQ2UnBUQmt3RVI0Z3MxYzIwWFRseW5WWnEzaEl5eGFKN095Unh0dThnUldoZDZLSEpoV1N0cHVKWGVzVXhRWDhBSVc4a09hbDI5UVlrUnF6YWs4WTd5MnlPTXo1bGZ6T1pyK0h4WnpkdDNUaVpFbDB0MktEYXdXaGZWbUNveXFxOHVSUHJ4c3QwWjAwMUVsM1ZXY0p3Mi9sS2ZwbDBpOTlMWExra3hwdU9zQlo4WTBBRnZEWHYrckkwalowM1BrSGhIVVVvZDZFcEtaRGovNjJFVWtpcnJaUkZrNStlajdscGVkSDI2aGpvNTM3T1MrUlJZWk8xTVUvVXVhMGtUaTBFM001ZGVsU2o5ckVOeDFqSCszUURrcGJicVhSSlhqaHBTMHNSMm9XVG5VU2FQYjJOa3BuZlF6T1ZUMGZqejlPVnZuTzkzNHdmUDZ6encrZmYvNDNoMXZ2Wi9ub1FteGJLUkN1WGF0dFJXc3ZpSkFMTlFYSkNFRVJSK3dWYkwvWlVCNzREUU9HZVBjejdCOUpSSmdCazRUTXdpZ05TUHNPYWdpUEUxY0hvUTVZaUx1RE1kMDJWKzl5VDFJaC9NU1dxT3ZDQ0MzMk1DdG1hL0ZLR3pHWEc5MzhQc2hNdnhnSitQSGdmNU8wK0VtOEphbUh3YXVNWG9YTHBPM1pWZkdPL29vQ2MxU0VvNGVqTlBPNnU2T3dTZXlnZ0tVQmVYMGY1VkU2R0JERGQ2bXRxek42SHZqSDdKdzhTUmdqMTFGUEFVa2creURnenZyQ2UzVWxMcytZM3pXLzJBQWRNRkJqdUF1blEzQmZqMmtsRUxjNFl5MmpwNTJBL1prQXJUZ0tST0tmOUpzcXlIYXpzVFlKV0RoMDFhWTdCRUxTRytCWVBYTWgwcXlUVFc2bWpnRnVwSDFaSHJWRmdWeGlxbmIxZnVRNkRZelhZMjhMWHVUUllSSzE2VlEyYVJKZXZUM0k2ajF1T1lmQ1VpZE1wTU1nVjdDREpzSFc2Q2JoTXZhdk50VkJ0WGZ4bS9SYlBwby9lWkFPcC82NDlyM1JnYnlSNEZtcmFJYUpDWllzQ2hFQkpqYlJ2YjJFNmVXUVIzVnQwcy9wSmpXWGcxZVNKVllvUnBZMlRVck1yWk5ML1hkdzFzNjlYcHJVbkRyZVhJKzBuRDFPMUVWNHlmRmdkN09YOWpFNFYzTjlmUDY4K3Rwci8rWExMNy95UC8zeGYvYWZoMkJ6NG5KbTVIZERMQXZacXZGV2hxUnJXZVdGc0ZoZVdQYU5vQkEwMldNeUVrT3RtMEtJK1hjWThPNEVZMEZBZk5Rc3RnMXFnR3FkRGhHQVFWQ0lseXZRQzhFM0c5SEd2Y1VNK2VuZUFacmZyRVVJQ3dUSVdEeklTUDZYbnhCL0VYQWRpTmtac0FGclp4RDMvYkpBcVVSckNLOFQ2UEdiK2Nja0VXN0RmSWs0amdRa1hoZ3FPY1BWN25yK0s2K2pzdlJ2MGxLU1N0dnZqN2g2ZVBGalhvQ3dldXBjK2ZYTlJsUytqWGRlSkNmK0d2aEdWeDJtek1xTG96cFVsNEJXZTUwOWU2TE01bnBkQStNTDgyZHF1S3c4YmZWZk5uZlBnNDN6cWJQR094SmxrUS9oWGZKQ21pWXQ2eVJZVWtpSGFaczRETHVkTW4wM0N5azJzazgwSkZhTEJ3Rm1iZHM3bTk3ZUNWUnhvZ3ZwaUtQWFNiL0xnL2ZkZFQvRWdUcElJcTNYZ0JGd05xbnpZRVJiNWl2aUxUU2Q5RWMwUjJyZTA0ajVUMHF0K0FKKzZsK2Fjd0ZLOTk0bThzcjE1NE95TXRHZTdiM3ZBSHg2dXBreTh0dnFzTkdlZHBJR2dVVWFkKzdjVFAyTnpnTWNMVGhheWptRzgvY0JQVFBCVmdZTFo5UjVTNy9SUjY4SGQzV203ZW43cVRURVhlMGtBOGZ1NDFNRGwrK3VmWGQxYXZLLy9yM2YrWjNsRE5LaTE1b3B2YUdqNVd1VG1VejBiRWQvdUJXOTJId0F1MHlNUXBRRlBpSGtVRlhrMVRiNWdSMUpOUllFME0zT2tKcnkzWXg1S0NxU1cweVVNSEhTNklTUDJQclZwVWJmVFBSNFQ5OGM2aTcvQzVsdEJ3Q3pkS0NKdzJXL2ovNTdKanBaTS9YU2xGNi8wa1hvSmpLUjBuUzJsdnlXWG50MGwwN3B6WlVsOGJ1ODY2N3lrK2Z4RHNRM1RJdVp4OEhFN3lyUEtQOTVPSXFMNlpoTzRDamNLSUhFVUhHc3JwNHBadmQ2SjJvSGNkRTlkb2taT0FyTFVTYzBwbXpNamxrQm9QbUNOTXJ3OU5OUGxlNTVQZEswWVRTL0RoYVZOMUkwOHp2eGkvdm16WnYxYnZYTTJVcGZHcFpoYzh6VGhBRUU5M0w2TlIyb2QrSUVQdHN4cyt2dHRwaEpRSnZyMHk5dkFvN1FUbkNrSmdSbkkxM0xsN3BzOVZ2UjE3dXFyNlRSNjdsL2NaZkhmckd6cnIweTFMdHZWZi9xd3NaQnNSZk9xc0RlZWUybVBodzNCY2hJMDVNQjBSSXFJbVFJcDY2OGw2ZHFrNEEyMnBZWCtlaVhQSWhUL1c3YVJLbFJmcVd2bnBUUE8rRzBvM0RpRnpQSlhiM25VK21jbHdQRVMvYW5qajExNmNWamNYSDkrclcwMmYyRTFFSGtjSUxVMjF6bzFFU3VlOWZKbjJCZGsvcWx6MGNIOWkreFBONWRXeTFrMU5YR2pmSno3RDQyTlRDNXNQalM2U2VmK0plZmVPNVNKSjBNdHdLQ1M1bFVBczZreUZPcko5UDRVWG1FR1hkalJiQWZZbUMzdkIvYjEyWkRHcklJa2M1a3FEa2Z5V0EyMHR4Y3dpMHNCRGl5UXMzeFZnZXhvVjV3eXJPVGgrT2ROWUZGQWczSU1WcDBsaUZzMG91TDVEMmJxemFCRHlETWh3TVhzbExMMWVMSTkvanpMRTBUUXlhamxqSnNGRDlwWlQ1cCsrWUVDdGVpRDh3Q1U0N0lnbzNOU2gwU0NTanhaOUNmRGlYTm1oSEFRU1JKdS9MSlF3WVQ5UnNmUm02cHVOMWR6VTdiUFJjdXhLTGxVY2VTc3FjT1RaNGxSd1VHRnZaSUswOEJPcDJKL1M3WWUwOE9wMWRQQkFoc0tCVGRjUExaSnh0RldIYldlMWJzeVVPQU9YczhUTmxGTGpHUm5rNEYyRy9kaUVsa09zVFBmLzd6MFU5bTcrNHNIcG0xZFBsd04zc3czTXlwMmt2cDlCSWluZWQ2SnZia2hXckNwQjN3bWx0WUhtN2R2bGY3TmVqSVRwODVYMVk3bDY5ZXl6NE9XOE5TOXY5bURnY2NEck16WERPN0pQV2xKaEp4Y2xTTEsraFgrVWx0QjhCeklrdktPNXMwcVVCWUJRRkdnQTd3MUJYQU1kR203amhnUEg2dmgveWhIMjRnbUllUkg0Mm9KU292a0RKNUVkcFBNUW96bFhyVytVNG1uWW1rdTFzNjYzUk1zWkFBcHVxaHRaeE9PdWFKaVdNblFNd0NnbldIcnQxQ210MnN3SFRFMWtGR2pOb0x4ZmhlYVdZaVF6MUxQRUp3SnI4RDhDbG5rZzg5NTVxZkdzNW4zMnZMd2RPUGhBWXlFc241Z1dzNVR1eCtkUFAwNHRKMklFTnRNYnEwa0h3bnJ5YUdjejhSNjVyRmJEbTZFejY2SGJQSEd3bDNJNU9CZDIwc0ZWQlB3WTdWR21udmo1MTc4VWMvK3F0Ly96ZC84OUp2Zis1ZlBHOWJ3NFZ6V1VFR1JGTFNGUXdkWW56LzhydkQyMis4V1JKWExVb0l3TmxyZy9SRWdqRE1SZWlZeC9CN0tmby9rcHAzZEtrN085bUNNWlJLVWp1U2hQSU5rL0xqV29ncFdaZGF1NFRZNDFUcGM2UHZ3dmVodmZmUzVLWXlJVlVTSW9rNmVSQVh2Nlh2STBrRkJHdURKN0NSdk5UWmdmbE9hc0ZnekpXa0o0NlNpbEl1ditXeDRnb0xlMll0ME10UUNTY0dFczVVckVFZWJuY2FGR1QzR3NheGtDYlJGdkFlcGk0QlJWaGMzNVMvRnVpQXRXWlhURXFUUm5lOUhqeXpVNjRoY3NDbFRXUmxOQklRWG9pVVpZdE5wbk1YTHA3THBPQnk3SmJ2MWh4QmJVUVVzR1QrUmlwVC80R3JveklxeDhNNmYzZ1VsUkVPNlJpQXlzL2EydVp3OGZUSkFqeGdESVhFSTd4NWliUmsvWlpmMjh0cUV5cUV3RjNWS1ZuWE84QWpqUFp6NThUdm00bSs3ank3eGwzMzczMEwrZkRyK0RmQjFKUDdmdklxTFc1cW9lVkZlUzN2OXA0ZzREbW9XMzU2Zll0UHZ2b3pHcGhOZVd4QjZtaXQwbHRyNGlSUytVeDZUVVZEMWVLOTU0QjQ2b0lUSDkxd2hSVjM0ckt5enhhc2RWUlg0dEdKOWJibzZZc2JUWHJ2WWoxajVFTjl0WjdKeU0zbytIZDFGRm5TZnF4enJxcisrUDM1ODMvOWI3N3dUMzczczRkZmZQN3p3M0sySnB5SWlIYnhzY2VIdzlObncyRFp0T1ZrVzI1YW03UmtMd1dBaHpnYWtlUVVqa2hpTXlQOTUxSnNPcytjV2cyb1JjVXhBanlXQklpeGc5L3NhS2hkakpIcXhBaUwyV3RnL0ZrdGV4YW1ma2NDeFNRSUZtaDBCdTkrcGpMY0JtNndkeTRTTlAwb0o4K0FpYVMvazNUNHFkT2d3endZSnR3UmNFdTRTRUhqakNCUG1BU1R1V00wcXlMclVOTEV5NityNlNBaml3Y0luTndoZjBDQkEwb2tZTTYrRk1KUEdoa0V0SGRJOFlVSmJRZXlPaVVkYUNWZDZoenhTTnZWNnNCd3ZKQ25ucFZEMVZnNTVrRFhzK2RPWjdlNWkxVld3R29qbmlwckFJVmRzNzBuV25vQWhBNlozckl0cGtocHFqN1ZwVWxCazdmVUhjQ29nR2syZFo3MGtwVnl6T3RxMDN2bEc2czM1VFZKdVo5UjFFUTY3UFFGdFZ1ZUZZYVRHWUt3dWRZVzZFZThuSHJXYWVSMkJOaFYzL2syZmxjdnFaU3FGM1hqNHJvZmltVFowL1g1UjJwVmQwWVc2RVVhQzNNWnVVWEZJazJXSk5YZThYZFlrbi91Q1UvTlVYRW1MRHBSSjB6MVVnVng2Z0M5TkQvSWdtdjVrWmYyM1A5Vy9LUE9TbDFLVjEyTEEvMnk5SkJXTzFXb0FiRzR2R3Z0UGxwU25qd2tsZW93N1NTb3ZhbW1OamZUbWNlL1B1QVluSHV0Znd6dmYvRVhmL25uVHo3eDFKOHVaM2k3bCswSVY3UCtmMi9xd2JDVENaNVRXWDZLU0Jzb05vQ3p1Z21SWU9KNzJaVnNOeHZrK0g0cVFNN0dGamc3MlVHNGRzSndtemdCR1B3MVFtME01SjBqZ1JvSU5ZWlZ4Y1VZUlpqeEY3cnUzenRJSStJalA2T093RHNFM2syUE1DVkdZRFVnVFNjOHN6YllTdjdYY3hhZTA2THJPeWdGMGtYczlPWk5HaFNtd3VVdWZWSWwxOU5wakVtT0ZMU0JLcHZ1L09lckpFeCt2SEN6dEplVWhWbmp1MVF5VkRTWTBUVWVyK2RlVDRtZzZuUXF3QS83OHltU0Uvdml0aGZHeFVqTkp2cmVmLyt5ZnFZa2FUbFFWL1lDTm93SDJzQVJXRzZzTit1THRReU41Vy8xVEk1QmltVUdkVXZwakZNdjBxY1dXTTVtUnR0WmRLTHNnTm13ZmlMdE81OXY2ai9kV080QjVkU1JaL3JoV2FvS0k1Uk1DRy90cjZkUnFiVVdLbTIxdFRDZlVWblNCZFNPelRJSnF1eTlIc2J2Z0ttUU0rQlgrS2NpYzJtUDlyTjlGNTVVcWkxU3hmV0hPZUpPZnMrbjNPcUMvVEdCWXpmUDZrTitaMU9XYXFNRTZUU1duMVVlNzcyamIrZWs0UWdyd0lwdXk1NDYzOFZkRTVTcE0rMHFuSGQ5dDhIS1crME5Vb1JSOVZKcHp4amx0VGtFZm9SelYzNzE3ZUt2MGczZjVJQ2phcnZ0bURRcVlxbVY0dmNZbkt0NVBwNS92dnEzTC83elAvcWo5dzR2WHJnUVlNdndFNUdFdVF4VDJSaWJFRnc4c1J4Q2FSS3NvVExHMHBPdlJXOTI1KzdOa3FRWG9sU3pMSmdlR0hGeUpqMEFjaEZvR0JnWWR1YnoyN2ZwZ0dkbkRFek9iekY2Q0wrNUpuRUlaeW51YlBMWEdhY0lHaEFrakgwK3VBNmludXY3U0dJaHNTNEhHSUhVOG1hMjBjeGtKeVlWci9KNDM5T1dmcy9EZmdDOUx3cndYWjdsSFlld1VtbEFRVElDbzNHVWova1JHNEVDa3RxaklSaEN5cW4zNlcyQWVRN2hMV2xQRUU0OHZSNmswNjhvWE5va1UySlVQekRTZ2E0UmdJZm5ubnN1TnNienRaZkY5UnNmakpac042RFhPUUVSU2dhbWJzcW92TFh6V1FCbU1aMnh1anFSL1p4OUk1R3gzOVYyT2pRZG1EeFl4VFlmUUpVM295QjVuODFtUzA1UVVROHNldG9KSlFBajBtQXlTTzl1VXlUZ2JlOFArWGFKUStmSm43d1VuVVQ5MDh2S1Q2Y1BkNDV1MlBkeXVmdnRpN1p0am42OWZYZERlVG94WDBXeGtjNUdPZ3NweDBJNksvRSt1SjkzdVU5UEx5UXU4Wkg4Vy8xWC9QbG04VTFLVWgxTnAyZnBLSFBWYStJdWZYZzZJVmxSdG1nMUtuNXg5UHloTzNWQk1DQzQwSDJYS1dMNEJjQnVSeUJTN3U1ZldMU24vWXArRTM5Yjl0MVdiU2FyNWVyYnFMenR6ZkhmajJVTmZQT0Y3MXg3N3Rsbkwzem1rNThZZGg1a1JqL2l4MEtrcWZYNzk0NElCVGdqR0ZzZTBpZlRJNTQ1dlQyY2ZYQzZWQWdUa1Z3d1h0dkdNWk1wQVFhZ3hsWVc4VFdDYmxLaTU4NmNnZVlpYkJYTEQrSXNRaDh4SHdMMm52TWU0U0pNdjEyV21SY2pqL3lYYmxjYzhZZXBHa0RFYnlaclptWlNyaXhuTnR5WHZndXpVZFBZWjJLOEkrbjVOWkhWbHRNMmRVbk4rT2RkejZkTmRqaDVxS1hpd0RsTTR6cytvb2VrOWpEWkdibXJwUFNaU0UxQXJCWldKRHltSm5VMXNXLzBtelF1Z3VpY0QydytWV25RbjBmNkROQ1lNTHB3NGR4dzQ4YVZ1cWdzZHJMTG9QSm9HeDJsZXZaTVlpYjFhanQ2eW1XcjFpSzFhaTlnd1E5SlY3MHVMR1ExV3ZMT05NNm94YVpNNGlPWkFzV3F6M1RhQlE3SlZPbFFiZnd1ZnlteGVQWnFNdGdTNWxqNlJNMGtmblVyaktzRHJ6di9vTlRmdG1vMGhTYWtKdzljZ1dmOEtRdi9MVXpTRVNEcHNSUnF2dXBGOGxuQjh5V2RkdjZWL2oyZGt6SXNMNXJzYnBkOGNFZHhKajExSzkzZTlyNmxuNnIzYUUxWWZpYXorS3J0bDkwRmlOWlpPTFRDeHZ3dFBLbDRDUGphQnlQYmd1b2tNbEl5YVdvcE9McG1rcWh1cE5QelVqL3lwMmc3NzNzOTdFV3dLTnZ4WkxzVjNXUnNhS3NIT0w1L1BHdmdHeS8vMjJjKzgrbFBiVDczMUtYU2ZSb20yeE1BZ0doOHBuWWd3eVNHSTVlS3lVS3Noc3duWjArVitWWmJoZGIwWUw3dlJiUWpXU0N5QWdnQUVNSjNZVFNFRHV6eldBU3ZacjEzVmZ3akpxWUdBQ3c5TGl6cnFxT05FcDZWU0lGTFlFTzR1ZVJKR3Q1Skc3Q0tVenhUQWJCS041S2Rkd0REeVJJa1NMcHFZTzJkZSs4UTZMRTdVOHJqN2k1MVNSdktlMVpPNmFtYjRGN3Nxc1BFWVNwZzJZNUFhaDJLUFJQRTdkdzNtdzloOHZISjFWNHY0bFFPZWVkU2hZbUxiandBSDkyemxac3JKNWVyemxsNHZQL0I1ZW9BbDVlWlhEWFFWQmJMdVpVeDNWU2t3dldVSi9uSkUxVlVtOXdFNUJaenRPMHNBYlZ6SnRXYjlGZFBOUk0vUyt1ZHRqS2JPOVdIdllTQmlUTUVBWTBqbmRRVldxbXRQZE9qVE1TS1FmbE9wb05ZaW5tbWpvOUtoNFdHOXBZK2lQRnUzUFYySDMrbi9PcEdmU2pQT0poMmYwQ3JSaXdOdHFvajBkbEpTeHBHUmVZZ21MbEpZejdDQmNzajZpd3JUTVV2ditpUkcyOEw2b3Y5V2p5U0dOTWtOWXJLdTkyZE5sRXNYL3dyVDdVNXUrclVSOHRuNjd3c2QwY2Zod0ZqazRIYlJoWFNUMTc0YStGL3VxT1FEL0dnR2ZNVzJrVWFRQjBvZDNjTXpyMG1QcWIzdDdOajNhdXYvdWphemQvL25Rdm5UMFgzbkQyZkRYWG53K1FiV1NiYWRJZ2pvZzFob2cyU0ZPbUZ6Sk5qc1BJWEVXZm9HdVpFYklnT3c3dFBoaUNwU2NhSnNJQWZjQUxOTUFhSEdNV0JnWG9jQ1Y2TTZSM1hHVlFZb0RvYm9PdEFCcHhJOVJ5QTVhWmpaNzFiazJBQm9VaVEvTmdpVXZ5QVp6dEFBY3prczhjcERuSExQNzZYcHJ4aEVOYzRnSlBFZlo4T0ExZWRKRjRMSDNvK0MxY2o1ZEpCem13M00wV25NdE56VkR6RmRLMXU1VWs1bGFmWEFjbGJoWHNuZjRiSUMxRXJPQXZ3NnJVckFlWm1sVkVtY3dIaTF0RTAyL0xVWEhUclRyTFd1WW1sQVFlZ0tpWlBldXNaMlNqYnhZc1hZMm1UOW81VkFKWEY2ZFBac2pMMVltNEJ3TmxvbjNyTE11NTdXY0N5dGRFV1JKUzBIOUJ6aU1CQk5ySFhUTW94ay9xendaSWpyNENqOHFqNzNxNmVYU2lvTzkrNGZxL2Y5ZVloRGZUdzdxNjJlVDY5UHBpaXhQRSt2OUJwbkJpaktxNE9EUGd1eHRLRmpqME5WSUJkMWlJQnpzbTAzMHpDeUJPTEU1YzZTbytXV0VmcFIwY3NEdFk1QjFrZHBZMjFTUlhEQ0VDSEhEcnFaWFBuaCt2KzFMVkwzdnRjUlhuSUgzNnJUS003bWpSNWkwNWNVZXhWVy9CZmFUVEZTdzkrZlArNDFzRGM0ZDVyRnk2ZS94ZGYrTUx6QWJHZFNIZHNjVU5Zb2JudDJEZ2pjaHZoV0ZTeUdEMjAwNWczYytTUllUMGdOT2kxaU1UeWJybzUrbGpiaTRiRVMyS3IwV3Zpb0c2d2NBR2pDbWQzTWNEaklsV3lCN2F6MTFRSW0reG9nbzRVeERpZkZZajlpTmxpcjJUaVV1ZGhZeGdyd213dXM1UTlKdXp6TUozM003NGx6UFJpUURiTWFPbXR4U3dMMGF1TFg2ZlFHSHh2dUhuald2STFVZFlwSjJKR2VPR3g4MldlZHU3OG1ZRFVtUWJTR0Q1TVk2L3FhQnJDRnBGa2srNXMxRDMyM1MzNzhPVGZPK1pSb0lMZnhXeGFzNS9KU0tCZ1VrcmFLekYvSTBudkI1aE5ydFVDR2t3Y0ZDZ3BrSWdXM1Q1VjBoU1FTRHgxU0d4K0wwVEhiQlJ4TzdyK3RXd0ZhcjlpZW1QRGQvcmtwZVhZMVVhZmZDOFRmK3lhNzBXUDdMNmRldE9PTEE1SXJnQ2k5bXFZeUZ4Q1dUTG9WSXdzMHRtbDA5VFdTN0d5V000eFN5d2ZIQmMxVCtXUmN0Mjd0MWJBVmdDVE5tSFZZRWZEWkw3eXJ3UFR4aGZPWDB4N0xKVStXNGNBVUxTemNPNDZraGJzWVllVTZNc2ZFOEtwNkdnajNsWjV0WEhaRUtPWDVGRkhNaHN6UytJc2UyM1dNYUc2QXJnR3k2MytabXF1Skx1L1ViY2tYeGJHb0FHbWp2YUhRYWViQVVEcUVUU2tibldlOHQvM2E1YVB2VXd3Tml1T3BCRXczOTYyendYSk83dnhNV3FlTUtva2hBRGkxSkwybTQ2SmF2SnBWN21GaFJ3VE43dVVQYmJYUWtja1pxTUFZWFpTenhFb3dtZEdNblBKMjFJbVltZGlJbXAxSWxYY2VpeWwzbno3L1hTTU9zR013TkpPdXAwa2NheldRREFmZC9mM3I3LzcxWC95ZmdnZ0JEc1ZzTm5Ka0JtQTdvVUE5ZnFZaVd1QWhrV2JOSkVQOWE1TEMvVWhmL2pUODJQVUF0NWk0TVkyNHVzTTZrNWljTTJFOFRDc2RPMkRETHlYd29CMHd1SndrZVpjVHZjZ3hXd0YrTHlYbG5CK0k5eWVINElucGw3Q2tHSE13SDZHbHlhbkFpaVJxTisvY3JrbXVCeCsrc3d6endUSVkxbVFQSk9DNVlXMERjUklXNHRaQUFCa3RnTjJKSm1TaWdKMjBoS0dQMUtpdk1pYjhIZml2MjNrUGhNVlFpd2w4azE1aEUySm9pYUlMbFpuRnVaa0k0MUxBYlE5UDlTeURvRmZVbS9yQU5veFRhWHVDZUFBS1hrRDVNekVabExHa2g4VEp6OVVKOEtyYzlZQjZhTVNOeldQU2MySGRVZDNUSEtjU1NleUVtQ21seis1ZW1yNHd2Ty9WWFg5K3V1dkQxLy8rdGRySnp2dDB0dTFPbEVva1M3WU8vblFCbFlSWHIxNmRSaXVXeXFlQlJjcFlKTUVZOTZvN1BIalhiSlpaZFptNDdTbFBqdzNpZFA0TE8yOHhjM2NBQUJBQUVsRVFWU21qcUJZd3ZaMDZNakZkNURPeCtLWHZWSTd0VEpYaDZFYmpjQlFJa0xBVGh1d3hhK3pDRU1YczVsazFwWVBvdDZhbkx4ZmgrQSsvZVNsR2ptKzl0cHJNYzhNU0tiTlN0cE5XMHZMN3liTlpzUkVrczUzVitVdTJWT3U5anRuSzBhOUJQVFZXYitVaXhPbTA2eDN6QlBweHRHTlo5LzNNMWVpWGdsS1cyblB5ZXdTbWY2alRPbmtRODBmdTBlZ0J0NTQ4KzJYYnQ2NS9meHFDSEl6b0RkalV4azJuaUZ0cmtaNVllQjZEb1ZRVFlSNmlvZzZRWGJDYzNjVkFRVTBnUldwRjhIeGl6a0w5R3VTcEptRkdRcFROV0FBS1FLZDJVZ2RBTVB3R3FpZU9YK3U0dDBJazUyTWZybkgxWWxaL1BMWDA4Zld3dkVudlh3dTFRQnpRSHRQVEVRSys0MVBmSG80bTNpcE1Wd21zZmlWRDJ5R3FlejhkaThTS3FzR0lBd01PSk9tbUljYUtGbXZUVzZrMVpsNHpzS2NsSjBhZ3o4VFNac0JkMENLRVZuRURMRk5aZ01OZUV6MHNUZW0yOTFLbkV2elVjTWtUeFZubFF1TXBUT0s5RVZTcGtiYXkrL3BoSnNJNkpLU3A2ZWpUdzhqVTFHUXN1UmxLbWxNanpZT0ltRmEzWmVFVXJaSWpRazdIMUNuem1HZG93NmNBY2dhNXkvLzhpK3JNOVRwc05DaFA5YW04cU04Ykx2VGJQV09WY0Y4MUV5a1UybnF5RXdzYXV2cWNQTk8rNmlQRHJycVVGeE5mUU93MVBqRHpyWDc0NmMyMnVJM0hVQ1BnelFxTFZLclZhenk1UGkxYnAxQ09nMFpWanZ5bHdQcEsrM0ZxS05tcmJaTW5TMHRub2owdkJGMVRWUkU2VkRZWlMrRUJ0Q2Z4VDdLUzIzRGdvT3F3LzR5clhOcG95L3hLaGVYb2xaNWZIZUpDOWhhbW85dXFzM2loM2UvMmJBcm0vQTJWeUo0b0YzNTkzditNT0N2RzFmK2RBNDdFWlphUFNoVU14K3NoSS8vZkx4cllEVkk4QnZaalAvODJXekdnMEh3TDJ1QkVFNWpvQVp3R00wem9nUjh2bE5ndU5ma1ZSRnBBdWN0WUd1RWpMZ2FVSkJtTzVnZUVXWUFnb1JwbU9qNEpHbXNabUZFTGFmRmtMbUFCa0RETEppUW54NlBlenkxdE5KeDlQeldBcEFVaEhwRS91NkhBVy9mQVRJWm1nZThQdlVibng2KzlPVXZsNlM0TnBMd1RtVEo3U0tteEhTR2tJbVhvN1loMGNySGNuUytxem45d3pDWVV4ZnladDlrbGhMU0FrNWIyYmlldlRkVHJWckNUVnFqeWtnd3crYUZnTGQ2MW5GeHM1R0U3Y1dneml6cnhieDl0R0RSaEFVMHpLOXFVaTNQYy9QTUhJbkQ5dkFJa3hzS3g2N1k4MmI4QmJkTDVXQWlhak9YUlNYcUdKUmdjZ2VYV3VWb3NzL3liZEliZTk2cXA5dDNzZzNvbmVHTk45OUtuZDFONXlNTi9YRzZCMmttL1ZycGxqTFpXNE42d3psNUxIM1VGWDhXSW1rTDdlTU9WTldmZXdPd1pyYW9ESDNTRnlENzV0NS9sMzYyNnIrcFViUzl5M0wyc3N4UkJpcUVkT1RLa3BZcW1xd0p2NnBadE5Ib0xoV2ZjTnF4cVM3VUJaclVVZW5jZElyQ2xjb3M5U0h0NmlUeVd6bk1LZEREeXlNYTRiUi9ZaStBMWRhOW5HZENTOXB2TngzSGZmdHBKTHc2ZHJDQ0RrK1pPeDNMZHo4a29YY2lSZ2Fic2ZpNGN1Tld3RHdXT2FHSnZjU0JnSXltamlYbnF2NlAvNStzL252aEo2Ky9PWHp1MDUrSy92Wms3RUhYUXZnaGdoQUNoNGhaSUxpS3NjSWNuZkdBTXNKai9GOU1NMktzVWcwRUVEZ0V6Zytwd0cvKzdOL0FuR3NxZ0xHVGs0Y0IyUExKNkk1SHBsNzMxcDM2Y0g5NDZxbW5TcEw1OFk5L1hNRDN4Qk5QRkVBREduRUJiRUpYeXhjcHRBMGJuVGd4bDhrc3dFSHFKZmxKZnpVTGJKNzl4SFBETTg5K29uU3VwTXpsZ0MwSm1SN1NJaFZNdUVsS1RocE42czB3TzUySU5PVGQ5WGhXbjlGVFd6NnRiSUJIWGxoUzNMc1hBQW9mVFVmQ0I5enl3dFoxN3N6Q3NMYXhYb3Q1TUJrVnk4UlNnREpEVjV2STl4M0tJT0hHZWpxUnZmVU1qUmRxcExLM3ZaOTRjNEo2OG5FNmUyc3dZdHNPd0xMaXNBeWZ0UXA3WHBMNWxOTXlJcW16bmhET1VOemhDTk4xTGlEZ3MrRlZwTHEwM1Zyc3Z1OWxBeVhsSytCTTJUaCtxSHlNTktncE91ajQ1cmNPb1lBckc1UUFXTCtwVTBpRjZzRnpBNjdXL3A3Vmt6cDFEMXpuMHBrQzc5Ylpkak0xdE9VNmN1a0E0clhDdFFuTmRBQ3hnQkRuVkt4MjZJMTVWdytoaE5Cck9vZmtnVXFETlFmNmRURHRBd0tEY21abnVlbWthK043aTJHQU5lc2VhajBUY2VMZFM5MjN0cWEzRG8xbVFoUXR5RmRacjZRajg1NmxSakM1NVNVL2lnNURKeVZwcDMxYjJIR0JBcjQyT3RVdXZnTmlkYXErUEt1ZmJiU1VOSmdjNGtOZGdQcWlNK2VPd2JtcTRlUC81OFczTHIvd202LzlaT3YyUC9yOSthZXlKUGd3UGZ6a1pCdkNGU09GT054ZEhBSkVwSjRSVkNPcU51UkYwTDY1ZCtia24wUGNIT0QydlFnM0JCcEVHeFlpZFo2TStvRGJDSWlTVEVoR2lTd1NYWWFzSTRZSG9OUWdpYXo4aW9PMFUybEZHcEYyRVh5a3FYeklLUkszSS8zZEtZQmFpdFhCNDVjdURVODkrMHlBOWVSd0xmdFlBKzV6NTgrWDVjbTlTRGlrWHN4cHdZQWx5NHlzZW5uRXF5d0ZCZ0U2REdVSURPQU5YVjM4a3FEUG56bGIwcEF5di9YdWU5VXgyRlZ2ZXp1bVc4a25PMjM2OEpNQlFjYzZGZk1ITEVsVk82a1BlZURVTWRPMVducWRUc01FS1ZDbjIrVW1rbytGMkUvYlUva2dLcElLSDV2YkE3dlNSU0tibkExSWE3Ymt5OUxmSkpYZlJNbkc1T0p2NWw0Qm1KVEg1S20weGJVUk8yRXpYU3M1ZEpRLzc1WGZieXNmdVNiWlJvY2VZTjdOSHNZQUJ6RFYwVTFwWSsyc25vVHBZQ1FleitXQWo2bmplZ2JJby9jVnQrZEdPL1hkQ0VGN2h6WXNtTEtRcVhZeUxMK2h6M2lWbG4xWnB1ZXl1Q2dxQlJzWHBWcWxVQks5MDEyUzYwemdrdTZqVmt0eUJ3SDR0aXc5SFVwVlN5YmpNcUZLOGwxY1ZNNDJ0NUVmS1U4cmkzclFDY20yMzQzdTJ5aWhmNU5QYlVjbzBQbnppejRhL2JlOVRmanhycmUzZVB6ZTNxSmVzamQzVkdIT3pJb3JzOFdvTjdoamNLNXFlRFQrdlByakgvOVhyNy81MXA4dHh5cGpPWUF6ZVhDL2lBUlR1RENGQ3lIMWQvM2VHUVpSRmtpT0dNeHorWS9zNG43MG5QZ1FhQ2RLQk9rNXVvT2FTY2ZFbUF4QkF6eUFZNktLSTAzM0lXRFBVeWR3Wm52UzRPWUNUUGNEbXJkdjNLeFZXbWZQWFNpcGVlWFU2WkptTVI3cG01NVorZzlpdjF2eEpBN3h5SS95NVVkSndlS2tudWxsM2QydzJLWkpPNzcxUEpnSWtyLzV4QWtBV1pxY3pRVGIvVEMxa1FKZE1RbDVJV1ZqaVVES3E3Mnl3K2k3VVVkc2g1RXRwejZabVh0U0hta1VVT3hISWwzTWlqMldDcnViR1hFa1gwQkl2WmpsVDlhaXJ0bU01RStkQUN4MWxxbVBnUDlVZE01Y3RaZDd3RWFuQVFSbXM1TWYrMnhnQi9URlUxSjMvTDJmaVdLUy80V3NJdFVtVkZYQ0tHdHJlN0cyaWJLUzhGSmY0dkNOV3FiaVYzOXBFMERXMjd2aTJOTk9JekNHcWlVYmlzL3ZMZ2cwaVZpNFpzMFMvL3ptS2xwS0I2R01kdmN6NUs4TmtDTEZ6MlQwWlJReGxZNXdjek54SmI5SUVzUlZmWVl1Sm9QQ2k3RmxOMkxRdWFLcnBlaWpkYXphVC96Vi9nblR5OUUzdXVvU2RLOERmdmtoczNPZWdiSzlueHY5N3NUNnB3a2pFWDFiM2tNSHdxTWg5S2R1MFhtVHVGdG5wME0yaXF1VnV5MXF4YWhxT3dabkZmR0l1Rys5K3RiLy9KKysrZWFmUFhieDdIRG1VNS9LWnZlWjBERUppSEZkcVFlV0RJaXI3aCtxRjRUV2dhc1o4TGVaZVlUS1ZBdURkYW1nL0NhOGJ3VmtVUWxRQTVCYWlYWUFZVG9Tanp2aTVxZ05oQmNXSTNEaUZBY0oxeDJoKzFieDAza21UdThCMkRQUFBET3N4SVlYODF0Y2NTdDZWZnJiMWRYVHNlUE54RkJBMFdSWWJSTkoxQnBqTlBHNkVuR0JHdVpjbWM5UlVBRXNLd2VUalhRa0p4cURKajNwWDM3ejdlRksxQUVrYS92emNqVmtqZzJ3TWsvTkxaYXE1WjV6NGFKS29TYVFKTHZveWNuRmlnUEQra1lQeVUzYmp5UXFBSHBQUTNqeG5GZzVWU0J0Q2JaaE9nYW5kOTVOWjZNdStIV3BxMzRIYVBiRzBBa0JUZm1pNGlpZ0dOV2h6dW14eHg0cklOWXU2dDQ3d0t5ZCs5RGNiNHNsT0JZajZsdWMxQ2grZDVyb25aZDhxQi9mL0Q2YUVNdzdycjh6eWFoZVBmdFI3eE5HdUFyTEdpTVhzMDErcWRYYXhsdnlHUm82aUExK3dwR085M2VsbWZSQ3hmeGJtSVBlNUluYmlwUWFMVW5xcEtrcXhta01XSXFINm1aNjFQN0tLdy9kVmQ3azBiL2N1VVliVmdhMnJRTFVIYm9SdDVFZW5iUDI2WHA0SFlSUm5BNlhSWkxxVUt2QytiRVRHamhJdmVxN0pySXJVK09BU3VyNHo2TlFBN3ZyOTI1OTViZS85TTlPNTJTTlNjd1JTcWk5aFVNb2h1TDJpNWpJZHBWK0UzU1FPNXRkazFwNmN1eGl5MUYydm9lUmF0Z3lJMnFUVXBpYkRmSjJKc3BDWHZHVC9aUHpqajJvY0lieTdGRUI4bW9rVGFaOW1OeXVhVURvTGd1TGhDVFpJUGkxREUvbk02bG1nb3BmZ09QSXBWb2lHekJ5Nk9qOWdOWEoyQ3MvOGVUVFpRZDlNcXFNbFFDeC9Od0tJMWpwYU9OeVpsSGlkQUVvVW5YdEM1ejQ1TmxxdCtsSW1GUXJUTEsyQXNyMlRDZzFRWEtWNUxJb3h2N1N5NVcrU2NmdGdLUzh5eGZya0xYb3ZCOWszd3FtWEt2UnJlL0dkdlYrTmlHNmZ1Tm1PcnN3Vy9KeUdQM3RiTW9mTzYrWXJtWHZra2pDMFUxa0htQTErY2s1ZGxzQnRhbkZUSmllSHhhako3ZjNSY1RyNUdWL3VKOUpyWTNvbHg4RU9OWWpiUWZDQWo3aGE1SVhVQW9nbFBnWUt3Vzc4dTNtY3RxTnlVYldDT3F4NlY2YmJiRHV1Q1lRQzB5aWMwM2JORDF1c2hSZ3FzTjVnVlorejZXek15Rm5ReWNTczMxV09uZ0JJODR6R2loZ1RUaDJ1dzNJdENvZ0ZpYlNaOEszMzBJSjY1a2Z0dlRwR0VLREJBUitnQzBWRTVBVFZ1ZURhdW5MSjZLYmxSYVR4TzJNT2pTU3NrNFlIWVRpN1BmZDl0NG1mVXVLNUozZnFjL29pa3FnTUFyWkRTMHZaTDlsdExJWkM1VHRkSG82MEZTdlFBbVcrWUowbWpyaG1ha0lFT24wekJNd2szUVlBdUhDWksvT0RDZ1RBRXlZN2tjOVlmK1NrNmV5NFZpT3JkcktBckFTRGdMRUsybmJyZXduL2NZYmJ3WFE0eS9IeWRrZGtSU3RTbExpWTdXRzZuK1UzTzNidDc1NjU5N2QveEZ4NzJlbUdFR01lS3VxQVhCRjJDclFSTkUxdVJJQ3c5d3NDU3hUeFNpMUR3WElqUi9NU2ZJbVNaQld2Q010V0dBQkJFbFdhemwxZzcreXNZMlVLeDJNUmRJZ1VXQnFBTTBQeVpERVE3b0Ezc0pqRFA0OVl3WjNsK08zZ0RuMWlJVVYwclhTemlUWGc4VEx3b0lPMStRZk1MVzRoYVFpYkpkbzVwSzJOR3FDTGhLa1BBVjdDbEM3Vk1nL1lOODZqTjQ1OFpwOEZLL3l0UEt0RlVBeldWUCtHemR1cEQ2ejJpOFRpazlkZW56WVR2eTdHWlZzaGhFdDhkMVl1NWVLSW5YbDkrYmFjQ3FiOUo4N2UzRzQ5T1NwZ0FkMVVNcHFneWZnRTZEQ3dIVFczV0pHRzRTVGZ5SHB5bGRKZHdHamFvKzBUWHZYZEpxQTZBaElrNDU4OTJlLytXMmdXQ2hWYmFKOStISDVQZTZFK1ljNDRjYjkrdDJlYzA4RS9abS9ub2IwdVBGMzZraitBT1hDUWpyVHpYUTNrYTU3R0NNRnJ1b3FIYVk0TEtMU2xqWDZzQ05LZm51dmJVdUNIYVZSOVJad1I2ZjhvRWZ2NXVuK1I1MzdaRG8vbzdGdU5zZWZCVFk5emRvM1pWUW4wckE2RTI5TjFhbjNVMjAzdXRBU05ZeDl2R3ZVbEVON3d6YTZuMk53cnBwOGhQNjhldVh1TzFjK3VCcWdpajR5ekZkbnhvMkdwK2kvSkorUWhoTWFEb05Rem02TGRqWjcrV1pZbklNM3JUQXM0b3owWU5pRkVVZ3VIQ2FvazFRQ2R1TFppd1NPMFJBMndBUFVBQmhRSUhSKzNJRXRhUm9BSTNiUDRscUk5R0xESC9ucVlUWnlUQk1tOE4za3lmbE05TkdYbWtERUFLUmRZQzhlOFl2WGU4eFlESmR3d3J1WVBCMzZuZTlzYVVuOEJVZ2pYZUdwVTIxWHQrMkFtTU04ZmJPWXhuTG42ZW5WNGNhVnE5VUpmUERCQi9YdDJXZWZyWHpwR0p6WGVQSDhZOE9acytlSDU1NTVNaEx2enZEMjVjdkRyWGZleldrWDkyTFdsVkhFUVNTd2pBem1Jc1ZOUjRXeEZHbnFxYWRqWVJLd01TSzRIV3NPOWJzZDV0M1BpZGpTOTZ4T1dTTHNScUtqWG9xTVZ2WGYvZ1RlNkd6VGhvQ3UxQkd4amJZWlVzVVZQYW5WYjlyUUpra2RDTldSaTZzMlRWcEdPZXh6VFpCSlcvMVYvYUNKa2QvNEZxTGlrV1p6N2QzbzRhZHVMZjhQMC9BUmZzbEhoVS81T1A1Q2ZUOTFBV042ckZxKzNieFZHTFNBUHFnOWRqT3lhSG5Va1ZNYVpNU1hxRU9aRVVkYkdrWUlRSG91cDhwSXB3T3ZlTlNMTzNySjE4b1hPanFNUkN0ZTVRYmkzdTJuczFRbmFOc0NrcXEzQ0MvaXE5K1NUeXhVTXRKWFJsWWdUalhuaDRxRE9nc1lUeVVPenE1L3ZUMlBkYzVWSlkvV244dVhydzQzWXVQNjlQblZESkdiWkZwRHh2QzRYdHl3dkhZVUN6Z0RYcE1WR2MrVnlacGhMN08ydksxSzYvYk5pSnFKSEtJcmtJdFVoM0NMeVVMUUpGdEFpZkFCSjBtRkNSeFFQY2h2ek9JeXpIWlJReGppMGgwajZnaVBReVQrMnZ0QlhDYmw1TFZVSXZrTmJFMzRZUlJNWkFXY0JRM0FoVDB1U2QrK0ZVMVhIb2s3djUzdUxHNm5qcEJvVERCUzYyQk1IY1E3Nzd4VFpRUVN5dWM5aWZqbTlSdkZXQWNwbjNKZ011Wi9qei8rV1BrL2QrN3M4T3UvL212RGt4Y3ZEUysvK3Nydzhrc3ZEdmNEL1B1cEJ4c2NXUTA0RjhBMGtXWEhQNlp5RTRtTEd1ZDYxQ1dUVTV2cFlMTHdKV1VIUkxWeGZLVHNJd0ROdXpwTWdNblZ5T3hxbklJTHhQSkNubHQ5TkdrUlVQVDJBQzZ1Y1pjcWJxQ1NOdFNPdmt0VEhZMWZ3b2puNTdscXI0LzRMc3o0TiszRTBVbTNidzlCMjhSZjd3RDQ2K24zUFBNZkNqdHFiOTlKbmhhclpQWTEva0dyMFUvaGVmMmhkZ2lWaGE1U2Y2RVRFOFYwOHJvM2RMMlFPS3dpUlhkR04raFVIVmFhb1ErMDY3ZTdQRG5GWkl0cUx1MnhrRWxIRmxETUxDMkpsNytaTFBVbUFhdkxkaWh5SnFmano3RnNmV01zMVNTUGFJdEtBMUFMbFFpT0plZWlqa2ZzejF2dnZQdm5WNjVjKzlQZmlFUzNIWjNiRnZVR0JzZ1ZySzVEVmhFaDIwdWdCeXd4aXRWOEhNSWpoV0JtcG5BdGJHT212dUFDS0RRd0FHeFpRQkJnSm5FSTJuVE5HVElIL0tVamJuRWlVSGNTTkNsN2duMXJ3S3hMMDZSbWpMd1UvU0NkNE5QUFpNL2orQzFHeWFwSHJrekdFc2VDVlhGWkhTWk9BRXJ2TFU0ZGh2U29JN0MzWmQ0bVlvQng2ZHRUWmhOdExDb2NNQ0Q4L1FEbW5heWdJdzF2UnNjSXJIVUtGekx4Ui9VQ0dLZzUyQXBMcXk5V3VYSHplcVZGc3AvTXBLREZCcmR2eFI0N05zcUpKRGJhcDBxNm84cytjLzdTY0RxUzluUTZ1SjMwZmdmSmJ5MHFDV09yUy9sdVRONG1jR3M3MHdKbXdKVktEY1QwQ1R6NTZhNmJoYVVKVTdjV3ZxU1RqWFFHTk5oZVYxdkdzenB4RlFqbUd6MHovYjduWUJVZnBXdlZrWERlNmRCMWRwV2FMT1FYLytJczZoakxSMTdWTjc2NjYya1gvU1E5Y2RYdmhFdjNVT1d0dVBJczM0RFMxZk01dlpXeFcwWUo5dEZRUjk3elYzTWtxVGRsTE9ETmI2ZTdtOEIwUnFBSlE1TjEwdUtrZ2M0NU5JcE8wS1U0bGFlbktlNU9yOXFpZUtQU2FmWEd2NG5YSGs1blQxSnU4YmRPL3pEbmNDNHZUWVhlMnM1L2xXaitHT0d3UmdtbmhTNnBDWTlONlhyZFBGTDNkOTU1NjM5NDcvTFZQMFZjeFh3aDBwcGR4a0doVVJNd0xBVzhvemNtUGR1NGlHU2MrYW93ZFNSaTcvT1BIUzgxRzFBaU1RTVJxZzN2YkZLRW1GMGNJc1ZBbmRnM0k1M2c3S2xJaUloOW40UnI0aW1BSzB3VURva3ZFM3RaOVllUnJPd3pmRDBWaXd6UGRsc2p0ZDdOZ2hxTVEvL01iQXFZMjN1QkgvbkJMSml1cHkwZjNwR1dPK0E1ZTg1c1AyQm11VUExY1JnbWxsZFN0NVY5S1lIWnl0cVlxWFROeVp0eVV4bXM1dEJjVmdNYzFRM2Q4SzBBc2wzZTdrYmZmdVhxamVIZVJzNzhtMXNhbGc1alZwV1J4Vm9ZK2VMamtiZ3ptVG1mQ2NHSlNINTdrZll6a3hjeng5eUswZWsxclVTazIyejdYbGdaR1dncEp1NzRweDJyTXV0dm13dHdDRzhEazJhUHJ0d0Z6UEdyM0RabzRyd1hYdjI0L0s3NGNsZUhMcTUvcjdaSytPNVgrSTl5TFUvOVN3UHQvdVR1ZXcvclhpcWFVVnllcWREazN5R3VUbVJmdGdROTdkL3BhVDVtY2tWTGFhZEVsZm9JRGUya1RPaFRwMkVFbUpxeVduTTM4YVhMU1o0amtXYkNrQzYvQTdKOEhBRnRmb3NUUUtNWlRubnQ0Y0lmT25QM3ppRzBOUUdaYnliNlRFTHJ6TlVMMVplNkpwanNXWDRlZFVlcG1ITHVJUWwvYy9OZTBTN05TOGl3T2crVDdEbzFlVTRCamlYbnF2MUg3TS9MbCsrODlQcnJid3dmdkg4MU0vRDBaOHluN09yVnBCZUVWeEptVkFJSVo1cE9JUVJaUzJsRE9HYTMyMFJpeUQzRVdreWI5d1FzT3RucFNMV0kvZENxc0VpQnBkY09tQUJEUzYybnJHSUwrbXdId0Rwek5vSnUrMHgwNHQrS25wZitHTUdUVUYwY0tad2ZraXhnQnBBQVVSd1lDcFQ0dmdjc0l5MldoUUVnanExc01YM3lkaWZiY2ZKYmpKY1F0Y2xOcE8rTk1QWkd2bTNHNnNKSW9UUHFpVmh6bEc0NzVhT1drTmFOS3g4TWIyZFBWdkhRZmVzc3hHK2ZDcEw0ellEelcrKzhsdzJZcnViM2VoYWxoT21YVG1SUGtaUERxY1QzcVVqTGoyWEJ6T0tKMWVGV0xFOXV4YkxEQUNEclM0YU5rdHJTYVdVREk4TmVkWmlvcVZ5cmJNcW5CNlJXOHJPZWk2bUJTQU1ReTlIWkpNdXI3OXJDN3dZSHdvMUFPRy9rMjZVKytuc0E1dDI0Njg4dHZmRXZQUThQMy8yMG4yU3lPeG1PUXpzdHZyRnZJei9DK2lhL2dGTDc2aERWdGZmVmJ1bkl0WTlPcHNkbFh4UTIwVHF5eW5uOE5yQUxWWVJBOXlKc0V4WEVhNVFsSGZXa3E2dHRZWk1WSGZ4YzFGN29ETzFKVC96UzZ1bmdEMWZMWSt2OG5MdEpoV1pTMkNSbEdxMit0NUVpVlVmU1RrZmplcENPMm1HdThvZ245cE1Id053c1VwTFJQUCswMG1sVU1jZTNqMzhOdlBmdWUzOSsrZkxsUDMweXVsSnFBa3VQRjdJOUluT3NCMUVmQUJkNlhXQmdkekpFYkNoZEVuUHUvQjBFWUJGbkkxQTYzZWlVaThDeVJEcmhOek01ZzRrNllYZUpwMHRpR0kwRXk0OXZpTDlMdSs3Yk9jTlFPcGJkbmoxN3BwZ1Q4SkZLTWV1dHUzY3FiZEtVeVVFU0x6Mmd2R0pvVENkdDZmQWp6bUxxTUtZN1VEZTdMdzkrYjQyT2J6b2IwN3hQUFB0Y1dhcVViV3BVRnFSeGNlMGx6anRoUWdzYTV0TGJzQk5tTFNKdWZxZzJmdktUbjFRZTNybDhZM2p2L1V3V3BsWk94dFo2THhJemxjV1pzeGVHTDM3cHQ0WlBmdVp6dzlYcjE0YlgzN2s4WExzZWxVa2s5NW5ZUnU5SGVyYk1lRi9uRW5DVkxzQmdDY0I4aXhXQUF4QXd0ckxtZjEzNTY4M29IUjFzVTBPaDV2S1hjdmZmNmxwYkN0akF1d0YwZmRlR0tTZDFWb3V2Z1hTM3AyN3ZUQWVMVHk2U0w1bW85SE1iZTRjMmZwNVRMdlZXOGZUdzhkN0sxUElsbitnSzRGRmhDZE5IUTBaWlMrbnNiQXNBa0UzdzdtVUMyVy94dG8zL2Uvb05nSFZRK1Y5WFA3eTNwOWZ2YUJITlNMc0RjSDhuL1U0NzQ5K29sYnpQLzhvL2YzdnBLS2lPaXM1RzlVQ2FCc0JBWHg2cjFsSjJ2LzJqcGltUVR2aGpjUDU1bFBNeGYvL1ZiL3o5UC8vdHozL3U4SGQvNXcrRzl5Ni9VNU1VVGxpMkpCZXoxZzVyMGE4dUJ0UTJBNFlGVHVIRjJxczRQYjJoNW1KVUdzQ2JKQmt5TENhYkN3T1I4a3pLYkdjRll1M1RHK0RmQmlaaEhFU1BjREdDQXkyZFBtSFNyNWc0a1puQUN6SVZRYy9Idk15T1hjemZUa1ZxQXZqckFVVjJ6RVhVR1ZhZXNZRlNSTXZibVN6RUhIU0tHS24wMVZGRkhHWlBENEQ5SUtvRmswVWxDVkVMSkY2VGMwQitPWHN3MDF2dVJHMWlSTURQbFN0WFlwK3EwOG8rRnl0WktBT0hBbVlBWWkvNW1ZaUl1eDhWeUZOUFhJckV0VGZjamdYR1poYjF2QkZKK2NWWDNreWFCOUZEcndkczdTZXlPaXhFT3I3dzJGUERGNy95dThNenovNWE3ZS94Ny83bUc3R0J6cVkzWWN6RnFEVm1Bc1RzbVZYbFRHeUVKNmNDTXNualBrWk51WXhZQU9CaHRwcTBFVDB6eHdhTXBPQXVRUVBLSmhIRzNLYnFGVHcxNEdsM2JXdGtveDFVcEwwY3FwTU5xRlk3Sk1DRTBkSkh1cEdmZkJPSGVCdTlVSDg4N0tpOTErbDFKODFLUTJjZUViYWwxNlJuYXFQQzgzaWVDWGpKbDh2eWNVS0RlUWRMMk5QSEJic1NPdm5OVEVoV1BiWnRPT25jTGRTeFMxNmRLSjU2WE4rNGtxS0ZqdlBYY25XZFdYVnFBVzZ3WjJwdzRpQ2ppc1JwLys4ZEk1U0FxUTVMZXZibzNzcXVpUStpVWlxQlk5Umhtb2Zac3JkSW1tSXJlNTZqRDNtMG1WUStaWUs3N1Y1bzY5TE43THQ5YjYzTmNiQlZuMHA1N0F5NGs3enM1ZkFDY3JQek1HUHVYS01qYWhqOW5mMVM3Qk4rRE02ZGVoN0JPeE13TzJFQm5OaVVsWlJBQWlCbFlxeURBRllCWHFpT0h0bzMrbVNNaDVzd0dNQWtRV0JVZXVyNkhXQnlKM2xnWEl6V0dEaFNYNENvRVhUQVBkS1FkSmpjY2FVYnpPU2tSUURTcGN0bHJDKzlyVXpjM1F2QTJyQjhlYlM5cHpEODZRc2EwSVNvdzF6U3BrT1pIZTNYSzd3eUxweHFxOXZDZ1lKR1VtNnI0cFFMVXlwUEI1eXlWdzdqS2g5UVo4dHFSejBuVzUvS3hsR1hNdUtZVERycm0rdkRsV3NmREsrLzllYncrcHZ2RHUvR0VzYit2QXVaalB6aWwzNnpRR00ydjJjWFZvWUxqejg5bkx2MFpBN092VCs4OXBNM2FuYStUdDRJbzRzL21GdjV0MGlDQ2trSDJDVEFRRkdlZTF1b1MzVjRHQkRtbE04bC8rT3VKTE84NTc5ZnZvdm53MzdIdy9YZjNVKy85L2Y5M3RQMTdQY3ZjdDF2eFJXdjd0UW0zc3NiNXgycEV0MFVqZWljQTdRaG1iWXZ5WnhSRk1BMkVub1lSbGlkdm81VzJkRENnN1RSNWxxMm9rMmNha1VhR1lRRm9OUDNCWXk5bnd0Tm16UmtXbmhVendsdjRRci84aUF1QW9oOG9nMFJrSVRyZCtKRmF6MXN0WW5lTHM1M2wzaXEzWUs2UmdBcDRSSFBxTExLWC9UanljNlJxN3JNOHpFNEgxWEpvL2ZqOHRYclgzM3YvZmYvZVBWa1ZndUdVT25BRHFKS09MRjh0blRIRzVFa0VGNE50RUpKdFhvc1ZJUmdxUnNRcGtVVUFMWVRJUW5iMEF5aHptY2ZneUswVkMwaTlOdlZDUitBZGlJWFovZ2lsd2tWZTkvYWZhd3huYmlFbzZyUWNiaW9Od3hiNzVjcW9nMEwrVFBoRTlZckJ1Y1AxY3VuOEw1WE9rRno3OFRuYmhqTUgxQWdzV0Mra3ZvaXdXTjZhb2I5L1kwYVFwL010cG5xNC9idHU4UEU5a2JGUzkxRG5mSG1HMjhOSzlsTjdrdGZmajdTL2VwdzR0eGp3eWQrL1pObHQzd2xwb3ZyVzN2RGoxNTdmWGp2eXZXb003SnFNSXplaE9HVVBiL2J5cmowQ0hFa1BVNSs1WHN2OSs1NkhSNFdjSkdZVzcybUVDTXZBS0tCZGZjckhwZjIxQmJ1djh3MTRHaWRjUGZiMDNMbitqTy9IM2JkVDNzLzVwK0V5STN5WFdadkNjOS96MmUxWlFrRW93NDRRTmZwakZBdlBjOHU0T2V5N0YwNFZ3a1lXekhIVE1mS3J4RVZJSTd5b2RyOElGTHpUTlI0cWFWMGNnRlQ5S3p0NDUrS3JFN3BDYkNpVmVETVNXc25SMWpwU0h0ZTBRb2FNZ0VKZkpuRGVWYS94VHNKNzZRWlFEdVhRM0hseFdUemV2aUV4UWpYMnFTMW9YaDdUUjZEYzFYUG8vbm4zdnJhMTc3MTNlLys4VmQrNjh2RHVkWHNGcGVKSkR6ck5PRDVtSEpsSjR6U00zZW03L3M3RzJKamJjdWM3U3hYbXdnWjZnZTJQRk5Wbk1qdWNOTUJaMHpUR2FnSU90OUtmeHBnUGt3NmlEK3JRTVlZcmFrMmdDSjc1bUtJRUx2ZnpOY3dBN1dENzdVME9jUnVzUUdiYWN3UjdpNEdKeWwzY01ZUXJzWkVrWHd5SEJYSGZDWXV4ZDkzTHBPWEx1M3JOQ2F5aVQxL3pNcE9uejRiblh5YnNIeVFvNFV3MUwwQTlOMzdXWEJ5NTJiOHpBeGYrT0x6dzY5LzZuUERKei8xMlN6MVhocldjM2JkY3BhVFh3MHd2LzcyNVV3TVhvOHRjL2IrelFJVXMvdzIzVGQ1TjV0NHAxTGZnWUlNWUdMT21EcWo3N1dNbnBPdjhVczljdTdqbHpLT3UvNnQrKzNmUHV5dnYvOUZkMkUrbks1My9SSzJ4OXZmMmJPaU8xbnUrZW1yNkxxSkprRHVUc2M4bm81eWQ4RGx6emRXUk5ySEtsZnRZSnZVMW5heGhvbWVmWDUrditZbjl0TjVydTg3QUxkWjBhQzdnM1RNdXdtakU1NFBDQXRIbUVoSlFnY051R2NEMnVONWtxWjBxaE9Jd0lMZWl2NFNWbG1ML2xJRWNSMWsxSWhtcW5PaENtR3RrYVhiZUtzNityVHQ3Y3hoYkdWQlY2MytUTHo1WDREY3k5M3I0aGljZTAwOGd2Y2JkMjc5K2RmLzd1Lys1Uk5QUHZuODZ1bVRSZXdUSVc2Mm12UjBwSTRpc3RBdkt3eERhOE02Q3lNNnNTSk9mZ3JVN0ZjUXBrR0VnTkdXbWNEUE8vNzZjQlVSSTBUYmFEcTF3d1ROZnY3TVo5K0swOWt4anovK0RWTk52RDBJTVZzbFo0aTd0Wk5EYWJNQjBHTDhtZ3h5QkpQVmp1S2N6UXc3S1l4S29OSVAxY3Nib0NicGs1MjR5WW1tUzk3ZTNCaE5ObVZXUGlvTHdFK1k2U0N3dVp1MDRpeWZ0dGVHTXM5a2FiWHltTm5mQ3FPLy92Wjd3ODNiTjRiUGZQYXp3MWQrL3c5aXpuY3FHeTdkQzJnL0dFNWZlbTU0NVVjL0hyNzFuZThObHorNE1Vek1MY2NDWkhuWWl2N2lUbXluU2U0TDJWUEJpUzBtQUtWekdQTTNXMkRXNHA2azArdXNNemFWakh6VUZWQXByZzRtdC8xUjhseU8xS3djL2JsSlp6NnBWOWMveEdtakRrd2RPSHJidWFzSHJzZlgvZlRuSU5KUk12MWRqN1BpVFQ3VXRUSzZOeitOTmdUVTRmV0xLc05sSHhjZEcwQVRCbUJxWXl0SnZSTUhDWGt4WnkzdVptNmkwWjlWZVB4RmdNamVKb2NzT2VLM2RoQ01URnNUaEtGRno1WjhVL1ZOVGpmYmZta1V6U2R5Y1JrbFNhZUFPdVhYRHVOT25TaGI0NXRXLzNZTjlDeXVuZVFYZUhkWGVSNDlDTmZxSVBXZWY4ZmczR3ZwRWJ4YnlqME1yLy9KVDk1NDQrMm5uNHJWUmdob01sTGNib2pYd1pNa1RmYk5WQjRtUW15RHVRTlFhK0lreEo0OU42Z1dyQ0NzN1NnVDNnb29JSXJJU1NJbG1YYUNWY2VKeHdVZUVHc3hhU2gwT3N6Z1JHY21hZUdHc2dHOWZ2MzZrU29ERXdDRXpzanVKSFp4ekdZSEwzc3pZd0NzS2M0Q1VJeWI3OTduWjZUU3BtdnN6TE12ditsSVRDanRUYmZoTWE2VlowQTluV09rNWpNVU5heXQ0WEc0ZURmV0hWZXVYUjllZStYVnFESnVEcDk5L3ZQRFA4NWludVZNU00xRUgzNzExcjNoWnE2cDdNSHdnLy8zVzhQcmI3d3p2UFB1QjlsVEkvbVBKRDJ4bThuUmt0N2FIczBtUC9lenI3SU45SUdFK2xSV2VhYUxWejdscGpDdE9raG1NTERmT296KzI3MHh0a3BXeGEwZTJ0TlBnM0xGMXovOGdqdC80aHozMytNZFQ4OXY3N2wrOXp1dmY4cjFzTHo2cll5dTNxWXR6Z1pRdml0akgzbHBEMjNGZFlIY2Z0ZWxDc3E3dnFkeTdiNFhvT1lXb29KYUNDMVR0UjJrTGl1ZmV0OWNWRk8xQ3JaOFNpdUFtM1l4dVN4ZGVaY3ZhV3A3N1ZLZFVlaWZIN3pCSmw2NFVkRXJKbjk2MllDNlBiREZvU00yUTRDMnFMSWk2NlJKSCtxYWhlRmFIWXppcURmSGZ4N1pHbmoxeXBWM3Z2bkNDMS83ektjLy9RZWZldTdwNFhDNzZUQnRZMW5BUEpLUTdMTUFJMGlmQnR1WWFpcHFBVVRjbWRPOUF5NUNEdWtWWXpjQWJFUFBSbnlOYSswNFYyRVNGNFl3N0xUQkVzbmk1dTFiV2NDeFBweE5aN0VZSnBNZWtMQ1RISmRjdHNtNm9DNnQrQlRLeDNRakcxK1NiWnZFTE8vRldIdlJqMlAyZ3dDczlHWXp5ODVVenBKYkt3V2xNWjhPcHpQbDFFSU9ibzE1bnVmVEFWOHJCZDk3KzkzaFd2VExPcWJmLzhQL2FIamlxVXVsbzF6akw2TE8zUExxY08rOUc4UExyN3c4WEw1MksrVko3cUt5WUhsdzcwRjA5Tmt2WXk1N1dxeWNPbFBwNFZMU1ZCMVBsS3hpWG5VaUw0ZjdyV1BCdU9yVmRUQUM2dzVlL0RZd2FlRGNtVnlwZmVPOGMzV1E3Yy9DL1NJM0hyNzc2Kzg4aTZjLzkvamR1ZmErZ1h1OXlKK2VMaTkrOTQ2SFgrM2kzdmM2cnZqU2x2R1pkeVRWWmhvM09abjJHL212OHFRSVBaNDJVZGc2TWZHMW82RldpcDRlcE43UmhJVWVJWlIwN0trVHFyWDh0aFNlenJrdTlBSDkwUko2UzMzdng3S2lkL1lzazNwKzFSK2U0T1NSRTZhWFU5dktSNEZ6Um0vYTFtbmd4UnZKaHVvWFRJMzF5VkVqSUhHSjQxaHlWcU9QdUh2eGU2Lzh5ZlgvNVByZHozN3lFMW5LSEdCd2F2RUJuV3piNE1WU1U5S0hKZFB0TkdtVGMxbEJHSERyeTFOSk5uVFZISE80SXE0Um9DRFljWUpHMUlnZUFCVWd4bXdKd2ZJSG1CdGdicGY5TUdBa2RiaTY2MkJVVEFDc1JxSVVSc0J3ZGNXeitIcmEvUHJOUlU2cS9QUnYzc21IWjNHNGU3NlgxWWRNQ1JlaVA3WWw2R3V2L21pNGUrdk84UGpGeDRZdmYvbkx3OExKUzVGMnc2REpRM1FxdzAvZWZHdDQ2ZVhYaHN2dlg0dFVHeVpQU3BzQi9mVWNNTG9YczY4aEI1YmFtbkl5Y2NNSXBuTWtmU3FYenFUUzcwNmVPWFduekwzY0Q1OGJLQUEwRE8xU3VyYTNScE04ZXh6S3BNNDlpNmZmaGZpSE91bHl3bzg3Y2JtazRjNDF2NjNkMisvbXAvbDlDR0srYVh2M2xxK0hIZEo4MUZUeVRFVmxQZ0hJZWJibk1iL2FpSE5Pb3Zkb2hCbWMrTkNSZDhKUmErMWtuc0VDa2Jab2g5REFJcVBscWFldDdsdGVHemhLWS94YnBaVTRGUkhRS2kvSEh6TkNycGZmdTlyZU5uRmFLU3R2ZUFpZkNKdkJaN1Y1QlJvTEp6MHhHYTBlZzNPdm5VZjQvdWFkTy9mKzl0dmZHejd6dWM4T3AwOHN4aWJZc0R5N2JBVVB6U3J2WjhuYTNGUW0yMEp3emhoMGNyZE5lZVlqUldBQUc3N01UQzlrcUJjSkE3amxuVDBkSXBRY09RUnRBdWNoQTVPY01MUGhZeHYySVV5RVMyZTRjdUowUnZ6dHVCL3ZMVEJCOElnZm9kZkdSd0ZBVEdnbk91OU4ySFdiNlM2ZFVNZlFTOUJWT2dsYlhDWndNTWxoamdZU3orR29jMUFXWndINnRwREp6TG5vS05rVTM3bXpGcDN4MVp4YVBneFAvTnFuaHllZmVLcFdGQjVPNUtEWUFPdEc3Rm12M1ZvZnZ2dURkNGJ2ZlArMWRHeVIyaW92SjdNMVQvSWVhWWtrZG1MSmptU1d4Wk1FTTFUT2FTZE05Z0MwYlVpVnI0UG9Yc3ExbjdQdnJLSlVGaVo5SGNTRUovR3BCNERpZlFkMTRYdEhRMTB6RGpqSzdsazZYQWNTNzEzZTk4dHp0ZTNvVy9mdlhXL0RIczY5eCtYdW1kdUw1UTNuWFgxM0wwQWNkWksxaUNsa2xUeHhYYS9jUnovVVBOWFJwN1B2b3huNTMwOTU2OFRxcEtQc0R0bVY3N2JIU0pPa1o3SWMzNlNmY09keVFvNVI0TldZUEthVVZULzhIMDVrRjhUYXBDaDFGck05cDU0VFJKWVdIZUt3bkxpSEFHckdpYUVCRTdkVUdlbmlIcFluc1hIS2E5UmtSYXBKUnMrNlhTdFNkUXprZjNybjdiMEh3NDNRMG5iaWl4WThGZFBxRXMra3NpcGY2cmZhTXAyK2NNZnV1QVp5NnNmTXhxVkxGLy9vZlBhdHNJMW1tZFp0MnA2ekRiTlpMTkFuMjBWdWV0NHNkS1RvU0F0MjVPcDZVdVpLbUFGQU5vQWU2VXRIOVl0Qk8zZ0FFTHVEZGNuWSt3NHl2cEdXYk1ydU4wYkNHQjFZT3ZQYmRMK1lNaUJmNmNhdjRTSEhUN0lXMS95SXUwdjlwQ3RNY0NLTFQxaDVpSU9aNEU2WXlUSDNsa1ZQaDdrdlhYcHErQ0I3WW56L3haZWo3amd4L0tQLzhKOE9aODljeWxMczdEODlreE82ejUzUEFwN0x3OWUvK2EzaC8vcnJ2eDYrLzRPWGgrV3NGcnh3NmNrNjA5Q2tvSTNmYld4a3BPRTBhUktXK2dwTUpZOXQxbCs5eUYrVlpRUms2Z09BKzZZc3l1N3V2VHUveXNaNTV2anRkZXplUnpEQ2VCYUh6cS9IcFE2NjYzRjQ1cituNDduSDJlUHhidHdKMjhQMzMzVWY1VS80SHNmNGZTOGREMzhrWHpieUxubXFTZDBhVlRRZ2xLNzJkWEhDb0F1bFZnK3NnN3dqR1N1YnVsUzNlM21PNzFhV3ZBZmk5TWM2YXk3VUdMLzB5VkZ6SlMvSlp1ZzdFOGlSMk5IZmJvRGIzaTIxTTJQaTV4d3UwZXZSSGllY01oRTA1Q2w5VDZWWHFyejRCYzRyc2JtMk5heVJHQk5LKzZxUTJ2dlNlbkhJZjYvejFyWkp5NGRqZDF3RDcxeTU5bmNYVmsvOHErZWV5Y0dvV2J4aGFldHVOdjRHYUtHY29tZXIvUXA0bzg2ZzkwUE5tTjJxTEtUck5JalpTS0dOd2NLUThVZmpVRnFIK0FYWXdOMkpFN1pyQkl3SW1pT3RHdllCNFU2b0Q2SUxMbDBjc01DMHVRUFIybUFtL2l2UmhOVlJZRnpweXFPN1N6d2NZc2VzZE5CV2JyRmhMV2FQK3FhV1oyZWtZRDhOOXM0V09XVDVYMWIzM1J4KytPcGJTV3MzdTk5OVlqaDcvb25zc1p4VFhCWlhoMmVlL1kyWXlKMGUvdkp2L3Qzdy8zenQ2OE1iNzcwZlVGNGRKZ1BDZDdOSHhvMlkyRjBKRTA3R3NvT1pISW1RaFVFS2tOd3dCUU91YlJWZkI1emVNZlU4eTNlS1d3eUwrYmxlcm5ySUg2dnUrcmYrcmdPbzkzM1k3dDA0NC90ZFFKSTdmOUpzZGRRazRPNWZuQzJlRnQ1N3o2N3VoUDN3NVp0MzdjUVQrWGdZdnY4V1I1L01hd3RQVE15R3JqTFp4bmwzRUd1VVhtYjFWSUE4eXF0NDBGTDVUWnVqUTRjSHFFYzBwSDVOYklzUGNOTDVlK2ZBaGVvY1U0U1VKRUNiVHRHaXBDU2JLTk5lbG92cktISktkMVlIQXVkZHRzK2pNaWk1dE5BcklCYTNienJDRHM3eWJGUkRXSEhPb1NQUy9MNSs2MjVXaEdiN2dhVFZ3alZWbXJxcWNpU2VYcGVlajlVYVZTM0hmOVRBU3krKytGOTg1VXRmL0xObmYvZDNocTBNczVtbUhZWVE5ekk1Q0JRdHhadWdkNDdBWmpnZlZxMUpsaUl1VEJ0Q2pXaFJCRmJIeWVmN0VWSG5PNkx0VE9ZM3NNVk1DSjAwd3EvM25manBjeEc4ZDF3bllvemQzL3NtbkhmdStWRitQV013VW85WDl0TU42eC9GQTlqV3NqemR4R2VkOGhLR0Jzb25Ua2JTeVZMeDVaVllhY3kyWTdCV3pxeEVram9SdSs3RDRkVDVzOFAxYkdqMHYveXYvOXZ3clplK0Y0NE91Q1htOSsvRTVDOXhUVWFkTXh1VnlMbkhiSHlUdkNYLzl2eTF3SUh1ZWk0ZDAyR1dDbHU4azRKVldXVkttUUdrOGlnbmdERTA1L0J1Mzh4SUo1TkU2NWs2eUFSWndVeUFyVXZFeXU0NmtzQVNwM2pWbVRyaFBLdjM3dFJkcjkrcXgzemcveGU1RHVnOW5IdFAyOTJ5Wm5ldXZ4K1BUMTdzMUdZUW9MeWhxZ0pUblJtcGtzNjU2NXZkeTMvb1JUbTVuay9Qd3J1YTFOenlvVjVJMDl4aU52ZzZzWnd0QU5MbTZwckZSYWNISUkxME8wMHBGM1ZacDB0cUZQV2xEUGJMYVBWYzBWWWVmS3NsNXNwYUlOOGsvY09vU1h6akhtUmJXc0pIZHhhck9EQ2gxMDkvUC83OGkydS9oemkrUHhJMTRBRFkzM3ZsbFQvN2ovL3dEMnNQaStuUmNQRnd4a3gybUNpMFo4WTdva1pKeXlWVnAyWkl0Zlo1WUU1WEVuWGVGVkNIV0RGUUk5NEdvZ1VDK1U3UFZxZVFoUEE3S0dGQXYrbFhFVExteERBWXJ1dGNFVzhiS3VZVWoyUUlJTFRwdEFiZUdNMDc4V0JtMEJrb3lwWDhSdzNDSHRiUXRqRTBWVWIwa2psd2M4WG0vSHFkWE5lemFNUUU0RksyQWIxNDZueEdBSWtoV3owdVpVVHg5UmYrZHZqcmYvKzE0U2MvZm12WW5WN0tuaCt4NHNpcEpUZXUzRkxvNGN5NVNOQUJGdnJHdVZyTUVCVlBoZzdPYTJ6NWFrUDVaS2llQVlDODlqclFlU21qOTdzQnJnWUVEeVZieityRFJjcFRuL3k3cW01SEFDbit0TlpSZU4vRUxROGR3UHptZk91dXZ4dC9samZ2WGRMaDNQdnplTHJqYlczZmlBKzdIci83ZEVZV2gzWGdxczR6UGlzL1hjcHU5dW5hdW05NkpQOEFXTnJTQWJMS1FrTG41S1BuUlo3UlRnZHRDNDVNRHBwakFMeDJyVk9YMEZRWUhRbi80aGJHdC8zTWFmVHllaGFuL1RlOG8wcVpTc2Y0c0x5dFRncm9remR4MlVQYWVaRnMyRGZ1M3FwUldvWnZHWVcyamxOOG5Mcm9kZG5ycC9KVVg0Ly9ITmZBcUFiZWZPZTl2d29yL2hId1hGak1DcXdBYmgzd3lZUXR3SVdkZHpKUlJkcWtKa0NjTTFGblVIZlFIUkpCRUs4SkdKQ0l5UGh4OXg1QjlrdVNSMFNQR1hMeHd5OUcyczJlQjVFankxU3QxQ1d4RXk1Q0RpOUtmemFiQXhVeDU3bUgwMUZ3M3ZkMExJVVc5MjZBR2Vnem13UHAwNW4wbkhOWVo0YWdPZ2FUanUrOGM3bVcxd0tDdVpVencxT1BQeDJKZURlV0dPL2xtS21ydzk5LzkrWGhqWmpUblRwN2VwaGRmbnk0OHNHMURIM3Y1NURaYzVHTUY4UDRPYjh3QzJjY0drdHFYMWxaR3BZRC9ydHpBWU5JY1JpZnhZQURVdVd2eXBPOHluL1Y1UWljQVUrcTRjajV6dlg2bEQrYlVCMWtrbk1xbTB4WnJLR000dXQrWTFUZDBzdTc3cVI1QkdxakJLVGJ3L1I2Yys5dDArdlJPNDVmbDNEanozNzMvTGtEdmg2dmJ6MXY3ajErSXdJci9CS3k2TWYreDY2ZUovSDA5TWJqOEI0QXloczlzV2Z0WEh1aHBCNm9PQll6Z2hFUG5USkoyUjdMeThzcjVVZjZiZjl0ZVJGeksxZDczOVFXa1ljclBGTTZkVkgxa1R0YXFmSmw1Wis3eTJTa2ZKcXJrYWIyY1hBdnYvS0o3dGJUaVl1L1ZEWmtuT1NkNjNmZmVsbmRqeVhucXA3alA3MEdOdGJ2djVUVmVIOWtPZkYwRm5lWXdhWXZDNGFGdXdKd2tWUU9jdnhPbGhBR0hBM2JNVmN6dWN0REVTb2RjOGkwU2EwaE1oSjNXQUIzMXQzM1dyU1NWNGdRY1NKOHdOV0ozWDAvRXlmZSt3MUFHNk0xTlFoZDhXSE9Zdk9PelRFRzhKdWFRWnljK0Rvd2k0ZVVKYTBVSjM2emlqRVRncGpJa1ZEdnhmenQxcTNiT2ZGa0k5dUFQak44NWJkL3QwNjczc3ZtN2UrKysvYnc5Vys4UFB3Z3BuU1VPUXZMWjRhYjl4TG1sZTlXT1VsalRwcWV5b3ovaWV4c2Q1aDlHeXJmQVEySkFTRHFqV0srNUNNdktyOTdxVnRPM3NlWjBqdCtiZjdmZmdzQ0FEeFJmU2lqeFRjaiszQjFrRGlVYlp6QmQyTWR3UFU2N1BYc25mVFVsM3NEbDVZWDMzbzg0M0h4MS9JMFFqSWU0ejRjbHIvdXBPdDUvSjF2NG1sM2VWQ3VORWlJQWloYitXbkVZNEZJdFdjOHlvK1JoUGJyVXI5MEhjcmdQWEJXZmhPby9LS05Ibi9wZmtkNXJ6RHA5RW5pOG1ZU01EV1IvRFNwV0w3NFNXWmFXWFB2ZVJoUFYxck55ZnVvWHRCM0hQOW95alVaZWhCdWR5OEhBbWN1WWljam9Yakk2TExWMFVmVlozL24zbE5wYVIzL1BhNkJFQ2ZKU284ZlE3V1M4aVpES0V6UjlQaE02R1luc2c5RWhuVldDbktHOGZuVG1Jd09OdjVwUHpxaDhkT1oxTDJEd25hV1RIT0lIVEg3MWdFRVVRTTlkOUtRdUVqVC9HSzRja2xEdUxua1ZaekZDTWs3Snk1QTFoMUptY043TTdFS0tHazU0THdSYWVidHQ5OGU3cTl0RFpjaUpULzc5R2NpY2EzazFJMHp3NC9mZUhQNHpuZS9NWHpqaFJleTh1OTJ0dlZjaVhvalE5UXNIOS9ZeUhGYUM3RmJ6Z1ZRREpYWDEzS0VWWUJtT2xLc3cxMDNJbG1weTNXYk13VUkySTFYdmFaTVJnUXBUT1ZiWHBTUFg2RGh0N0o4VlAwcFF3ZFBaZmNib0xqNDcwNzU5L2JiSHRSK3UzeDNyenBMbXNKeXducmZYUU9vaCtsNDM5TjA3Nzk3dk4xL1Q3L25XeG40NmZHUHA5SHpvdDNZYVp1ajhLN1RndFY2VkJxQW1wL3hQSWhQR2ZqdGFmRFQ2N0YxOHBsa1Rwc0FmQzYxVTNscDlNTm1PdWROSm02ZE45TktydWZWcU1idmZ0SzhmQ216ZEUwbTkzU0Y4YTFjcXErSGx4ZCtUQUp2eERUUG5JTlJHU2NPcHBBZjVjVFY0M00vQnVlUHFxVkgrRjAyNDdsMjE4cThiSVFFaEFNWEFlSVF6VXlZTW9qTHZ0UXhQeVNiblV4K0ZiTkcrcURpcUdPQlFuaEFmQ3BXRHlZTjYzc2s0RkFkb1RhTUJrVGlKOWQraHQzQUtHSjBFYk5keFVyS2prZUxCTmdZazBqWm9ESnhzeHg4TGlxQzZldzdYUkpUNXR4aU5weDBIYlRKcGpaTUc5QmhZZ2NzRDdMeFRRRjBFclEwZlR2Uy9sUVNjUHBMT0crNGVmVks3WEZCSlhEMndxbGhLYXFKTXhlZkd1NnVidzMvUi9US2YvZWRIdzV2dmZWMjdSTjg2dExGNUdOMmVPdmRkNUwvNUMvMU1KL1RUR1QvZmlRMVRKYy9VVHRuSWpMRDZXaERoK1dvZ3Jham41L015R0tmOUp5cjl1eE5tWTVBSmZteUFWQUg0MVJZeFdVNzFlNUhIVlU5cFRRTnpKcktZU3EyNWJNQkFwTmVwTVd0N0NldFhyalNkK2Y3WG5aUm00ZzlNVENqbTYxODVydTlpQ2NDVEEzZ20zVGRUZGtLaUVpekU5a3VWZHJ4MTgwUSswaEUzdWpZSjVMK3VDcUpmNnNpTFpYdkl5cnZuQVlDYU8yWEFuaDB1T2JxV0VJb2s0N1hOL2x1K2wrVGVDVFExbkVMSTErenFTLytwNkppMjhsMnJlcHJMMEN1UFJaWkM0WDI1Z0tndTVrTHVIUG5WbE56Ukw4Y0VoMnBlR0tEbm55c25EbzVUR1J2RlRib29iUmhPWHMzTDZXakRhV0hmdEp2eHE1L1B3dXhXUEJNUnUyU1VsSVhSOCt2VzAzR3MxMXJGRW5aZHp2dms4Y0M3Z2d1eWlIK2pTenRuc2srTWJ1cC8xdVp2M0JnTEV4bWU1MW9rR3JwbnB2RmpSZUswb1NkRkNYdUdKelZ3ckVicTRGWUVWeXpwU0Z3N3BKT1k0eElIc0E1QU9RNS93T2UvdVFLSVlWRzh6MVhLQXVqRklpVEhzS280WjFpTE1sZ3NMRDAwWEpsNzFwOEQ2VUdjUmpHMDgzNlpuK005QTY1Wi9ndmpZU3hNeDUvNHF1SnZGRThwVThOaUJmWUJSVDRrVVdMYWZnRjdtSGwwdjl0WmJOL3U4ZVo4RnM5ZTZuMlczNDM2bzMvKzYvK1p2akJEMytZRlpBUDl3ZGV5OGI1clI2WURMYUpLY0NXakZTZHRIcDVLUGtYU0tiOEJXTEptKzh1K2VHNmRPV2RmTFc0SDBwdy9KQytmSmZPZUIySjA2V3NQVnozQndqN2Q1S2tkS29qRzBtYTdMZTk2MkdyUGxKQkZoQ0p3N3lCazYvRkt6eC8xdXMvTkh0TFE4ZTF1di9wY2lsSGE0OG1wWXRER2FxZUVrYSs2RjY5cS9JSFRDdk41S2VYVWY1OWQrbHdwR08wMGFWb3o4SUNlZ0F2bkdkTy9Kdzg5L3JvVmhSQVYzNjhud3Zvejg1RkVMQUFLTzhJRWRKd3NzcGU1bFBrb1hZRnJOaGF1MGtET0FzdkQyaXU1bGxHWmRGSlZia0FkVlI5L0toM2wveUlzMXhvc2FGem80UDI4cVAvSGt2T0gxMHZqK3piclkwSHI3My8vdnZESjdLWkQwZENkbEtHQlNkUjBoVXhoNVhhdHhEMk9EUFd5N0UvQURUek1FWFFDVmhoUS9VRnpNVW80aTlpRGJIblI2WGhudmV1Y1IwMDVrSHdMYjNHWkpKcXcrR0FXMzZMeXlvdHcxUmdRbjJCT1pwOXMwTmpHNk01S2Z0Mk5zMmZpTmo5eEpOUHBYd3p3NTJjaVAzU0QxNGQvdmFiM3g2KythMXZSNktMbEw1aVZWZ0FKWEhRUzF1SktOOW56NXdmbHBZakZVV0NybDNUTUc0dWswNGQ5TnlkWnQ0QlFWNHhOdGNCQmpNM1J1L2xhZ3dyREFkc3hNc1AxLzI2aTh2b3dHLzJ1L3lSUEVsdUFMQWt2dmp4dnNmVHdicnJhTk9nQlc1MHZvZUhHWGtvVC93bnB4VkdkcG5xVmZxR05BSHR0bkNpZFNKR012ejNjbWdiVG5yamVlWEg1YnVyMTRuOGRMRHpUbm1FVlhmQVYxck9EUVRNUUxqNzlaMmFvS3U3eE5uRGljT0ZkdmF5TjduM29kSkt2OUZLT3IxWWtaUzZKR2RTbW1qV0NiQjNyblJaMktSZDJueEZvNnVnYlFTSzFuNVZGNm56V25BVkVGWXVtMjVWR1ROU1VwY1JZVUsvN2RSNHBwcnlJMjFPVTViZ1FlOVhWRjZ2UC9MUE1UaC9aTFU4dWkvWE5uYmV5ZG1DeFVBR2MxenhYSHIrRHA2T0NrS0VmWWE2Q0RiK09xaTR1em96NXFIRkY0RHYzK3I4dWtUZkFLdEpJNTF4V3p3WnRtWW9pT2d4TVFEb1RDamRCZ2dBRWNNenB3SXc4b3JvbVZFNUxYeXB3SFhLb3Bmb0huMER0QSt5SEgxMjZlUnc1c0lUdzI3S3NadGwzQy8rNExYaHEzL3hWOFBObTJ2RHFUTm5ZOFkzTmR3cUFLQXVpYlFjc3o1TTZpaWs5VWhzUUhBaXpOakxRektpN3BCZlRLZE9qQjU2M1lpamw4L3YvdDVkR1BYZ3UwdGMzVytMdDlVYlAwQ3FTNHQ5cHpTZzRwczhGVWdrdnMwTTJWVUZ1MmhwMUtUYktBODdXVmpUNDVCbnU2TlJ1VXhtWkZKYmNxWWlBYU40ZlQ5eStkMldYN2RPUmZ6UzB4YlNWeGZ1THZubjVGODhucVVKRlB2N2UvZnVITDE3Q1BBbWZJSHRUaTI3dm5EaFhIVTZ0VUY5Tmk5U0Z0dklPa2FNdWVNNEdFdkRCWkJkNkVDYVM1bGJZS2xCaFVBeWxvZkZtRVdlU1p0YUVDWGYxMjlkSDZZRDBJdVo3QlhHdSswY2p0RHJMN3FMR2xHa2t0SzZiYUp3RWhncmIrb0FvS09QVWwrblF3ZnJXOW5LVnY1MFl1ay95eVg3RlhkNytzVi9qOEg1RjlmUEkvZjFyZXZYcjhVVlUyVm5ucFMvTVYzeFdoaU5RN2o1RzRsMEJENTVwRU1HM3I3MW5iWENJc1VzeGFnQkFLR29KZUlwZjlwdnBrYzlqUloyQkU2UlFzMm1pemZtc0tVS0VRRmRwcGVHa1hUVmdBWEJseTQzTE5HQXUrbXc4eklndTF3NndZMUlNUFpOTUJROWNlcmlNQmZtdkx1MlBkeTRkWE40NFlWdkQzLy83ZS9IdGp1YitHZS81ZlYxTzlRNXZwN1VrdzRpek1ya2JuSXhrMVA1VGFvMjBUTy9sTHlYQkZURktVRHJBRlFnMlY1WG5YU1FyYnBRNGpBMW9GRm05M0ZRNitCbXRPQzdzTUNHdjNFZ3R5UWM4RzF0dGZCKzg4ZC9pN3V0dk95ZEc2RHRFdUpDbGhQelI4b204UU1zWlc0dWJSc1FtczQycXVKeGRVc0kzMG1pOHRXQkdiRDZQVjRXdjVXMTUrbkRlZmVObno3c2wwZVN2NnVyTUtoY1NMVTNidHdZak9hY2ZpTSs0T3kzOEpYT1dCdU1DcUI3VEQ2am5raEhaTDZDTHJ1RHM5Vjg2bmIrN0ptaWc0VlkyQ3c4aUxsajZJM0VuTUtYTkV3OWdmSXlERXNkZEhwdjVWYmVtWkhaS1Arc2NZTGVwU0twemlGb3ZKMERqcHNFciszcWMvS0UzZ3VoUjh6UWMveXo5Mk53L3RrNmVlVGZoUEJmQ3RNOG53MGxSZ3lRS2dramhLVGlnTFZmcEtoNmNmU25NVXQ3OU5zRzV4Mll2UVhNRFpiRjRrVURsUVlhSnIwYVF3TU55MjR4TktEaXhNZlZjOVFzSEdtd2ZlN1B6WCtkVWgwQVA4aE9jUE9aNU5rSmdKc3NPNHowczdKNnZoakV5ZDNmeW9UZjE3LzJ0M1hrRkJYSWZpWjVGcklodmsxcVhuLzl6V0g1ekdyQUhEZ2VETGVqaHplU3NPZDBWS1VGS2xYZWdJd3l1cVppWW9ocFc5NUdERmhQTGYrdGZoNHlONzhZV2RnT2dyeDNTVlJaR3pBK2xEN0ZnZUdCMUZJbUpJRXF4dmZPTUY5Yy9OUitFeWsvcXdkQUpFNlM1RTVHQ2RRK3dOQWV5QWNIZFBFazRHYjl3RDlwMGRKdmUxbUxqeFM3dTB0LzN2YzNnVmZqQ3pDYXRDemRYbjYvZTdtVXcrV2RmSFBLdFpMajBUenpaMEhOWEtUYmhVeWlPZDVNUE8vR2hOR2Uzc0M1VkJWbUVFY1VOQi9nZHVxNXNoa3hpTDlBc1NUbVJpZVc1Sk91TnpOeHFLTnQ5TnJLcHk2dTNtZ25wckFLT25maGZJSCtSaVpLcWE5MHNqUHByRXJYbmlaRnV4MmdtVEJXWjVaNlI2c2FnTmFQRHM4cE5pWS92ZC9leXUvTWE0enZXTmNPd1ZVRHY5d2RnL012cjZOSHprZWtsUmZERE04UEozTjBWWGVSVWpFdEJuTUJoS0xJb3NwUVpyMERTS0hWZkdyRURNNUN1UEVzREZkaDg5dUVpOVhKb0xjSWxrMXpobitjZDVpWGxBcFVhdkl2N3l5R21jZzdqRVd5bzd0ckV6NENpUjlJZDdDTXpqbnZuTFppdzNPbmdrL0U2dU4rZHAxNzk3M0x3L2RmZW5sNDRkcy9ISzVkdXhHVHVPWHNKcmFRNHV3TWE5RTl6MlJGSk9Dak5wRHRBcGQwU0lERUtSbkZrRW1wZ0NoNTZzOTVWVURUd1JOTWQ5QUZRSnd3WGRMMHppVzhOTWFCVFRqcGRWQ3J3UG1qL25vWVlBUkUrT1ZQWitpNzM5S0kwVng5YzNTVEhmNjhGMWFZVnN2OFJlVXptMG15YkhuS0hhU0RBc3ppNmZscGVtYnZtMnFwMmlhenFIMWZDYzg5WCtMM2Uvd1NMeitjN3hWKzFJbnBKQUNkdS9UTUIxQ3I2V2h1Wkg4U2QvbW1lMmFmeks4ankzU1MzdmRMbkwxZWV0bzNibDdQOXlIMjY2MkR5ZEF1ZFpvT0pwM01RU3lCMXZwa1hlajZaRG9LSjJOdjdUWjlOZm5ENFJMSTIwUjR1YlRUUVNKTWpWVmVqZG9zd3pZYUlUVnoyN0hHNkIzdVp2Ym1RQXM2OTFSSkx2VlUzaElwNm1nVG1LTTNQM003QnVlZnFaTGpGMW5hZWcxUk5kZWt0Mkt1RVlONTN4aWdNV0tlQ0E0a3F3QUFRQUJKUkVGVVJuN2JqVi9YVEFnd3JGZ3Y2M1RyK0RQeGg0bGNEU0Fhd3lKb1JEek9iQmdSdzdva0xVN2ZTVEE5UCswNU9Ramp0VGliTkFQd1lnbVk0NmZDSUdHdUV6YkxEekQvOEpWWGgrOSsvK1hvbUYrS0NkekVjUHJzK1RCOFFEczJ5bHVreWdENVRxVEgyVWlOR3p0TTB6STVGZUE0a2ExVTdjVmhTRTBhT2hGVHJBYUFMWC95MzVpdlNiYWVtYm4xOHJSOE5yV0U4Z2dMZVBqamVwMnBWK1VBekIyY2ZmZWVIK0hFMWV0bC9KdjY2blhMUC9Ba1dYSzk3b1FEenRMbDEyL0E3RTdpNi9rd2lpRXA4Nk11ZTd4OXROTGlhKzNjODlEOThOL0wwZFBodjNVS0QvUENUdzlMTXFiaUlPbmV2SGt6a201QU9SM0F4WXNYaHllZmZISll6ZVNkc2dCeGQzRXBpNGxCYlNMdER2VGlsQWVXS1hUTkpHeW1nK3NiYTRuL2RpVGF0amhIbVBzYnNjSUpiUUZ4OHdxa2NNL0M3NmZ6ZHplSm5WWXBnY01FNlU3U25qa0ljZVdiTm1JbXg1a3pWZDRxZjU1OU0wcEpWYVplV3h2bVY3NFFQMzY1T3diblgxNUhqNXlQaGRuNXArbGFnYUROZHpZelBKdUtiYkhuSXRZSVhzWEU5a2FJWHE4WU1RUklzbVVUV29BVXhvbWNVSFZuMXpyNlBHSklBVk8ra1pFeDMwNldVaU5pamhUY0oyRG9CZWNDN3NzNUJZVmUxSkZFeTVHWXNNbG1iSnFYSXVYWTNhMUFKVHBGQ3c3a2cxVEV6WWVKVGVYdHhXU0tkY2xXTmlINnUyKytPSHoxMy94VllzaDJvSTkvWm5nakV0cjEyOWxRUDVMelJDU3ArOW1YMlFJU0tvRmJOKzhPSytmc0tkMkFhV01qbGhySk5HQll6ckoyUUxLZXREQXpkeGhHQlE3Szd0dGhKcDRPMGp0MGliQjNkc0JWSFhTd1ZvL0Z6QVdtN1QyLzR1aGd4NzkwZ1MvL0QwR3RBVUFmS3M5bkFsUmRzZU1HL0JaVDhDdE1kRHFwRzlBUTNYTGlZNFZqRTUrMlZGcWU3RDNSVFA4cS83RURCeUowdDlRMVRxc0dZTTB1dCtXVEh0cEVZbTJqbVVsWjVXaG4rVFZKc3pxMjVGa2J5WWQyVnFiZTZRSk4rYVUvcHI2NGYzK3Q2bkl4TnNjWExsd2Nubjc2NlFKV2V1Z3FnM29PQmRBaDIvNlRVemVuc2dkS3J4ZnhTOHZrNWx6S2VPSGltVmprWEt6NnBMZm0xdGFhTllhRFY0Mis3c2NTWjJ2bmFuVUFLeWVqODA2NTdVWjNmLzErNmIvRlJ3cVdkblV3azdFQUNvM3NaTmZFelJ6VzI5dFd4OFd2V3RhK20rWkVVbWZGTXlPQXhoT0g2amJQalRzcVN4LzU1eGljUDdKYUhzMlh6enp6elB4enF5Zi8yd3NYTC81cEE0d21HU0ZnWjdCWktkaFVDU1MvbU9BSEhERUQxOEhHYndUcU1vUWtTZXhtUnk3eE9lSUhNL1ZqaGg2c3RVVU93aUQ2RGo0WXJlS0w1SWR4YmFLMEZMMmdvZU5tUUJpUTJNOWpMZ3dnWGdCaDhrZ1l6MENEMHdFODgvUnprWlovUFB5Zi8vcC9INzczL1I4bVg3TVp3cTVrdWZhVmdBcTlva20xU0pGWldtdjRQMk9kZW9Cc1B0dC9BamhBSmQ0dXNWWjZlVmFPSkZ2ZmxMWG51UU9SWndmUEF1ZGV0ditQdlR1TDl2dTY3c1ArQjNBdmNESFBBRWxSSWlETHBtblJWQ3pKVkdJbmROSkljdXFZcnBNc3JTU3QxYjVJWFdtcnZLbHY5bFB5cHF5dXRzbGpuOUoyZFMwN0swN3NlSWdreTVZc0s5WXNVN1FwU0JRSGlRTkl6UE85dUJqNi9aejkzL2ovQ1FFTUtZcXk3TndEL083di96dkRQdnZzYy9ZKysrd3p3UWtjRGwya0czQVMxemZ0RVh6K0hIcDQ1Z1Y4Q3dJd3oyV3pVS2NYbi9DVFZoNU1BTjdnY2Z3OTZxdHgxYkg0emJYZ0ZONXg1S1hzam1HRmg5K3pqUkxTbFZZdEh0dHNweE92OFFCZjJialdmSVh6TzNMa3lLQnZqeURRM0EzcisvZnZINmFMTm1PQUsvN0FKV2s1OEJ2MytkOGpjUHBIK3FZWE9qR0h1S1BTYjZzL2xnZk1Hcm10Wk5SQVk2ZUptN09RMzhhME0yK1BQSXl3TnFURFE2dmNUNUhiVlJ4eFN6dW1yS2hibzdveXRUUnU4L2pjRHMvNU9QTy8xNFR6UERYK0MvLzlwcjM3UDNUWHdiMi9yUEVhWGc2R1NLc3JnUkpCVFhXTTAvQUdBNmJ2RnhmeitPYXZBWHBheUFoenF6SE5VcHlGRHAvNjIzVW9uUVgrWXludGtCVVJJdkcvRm1GRklEdERRUnd6OTI1bzJSNG04MjNoaHBzcWFEUWJJanhNeHF4bURPa2NaVXViZG0rL1kvS0ozLy8wNUQvODlrY256K2ZRZkdmclhyNnlMa3ZoSWdRai82NW0vTHF3WVdrSVJReTJaVXZPM1kxV2ZTV3JNZmhQc2xvQmM4dUxnT1F3cG9kd3RMNVllRE52MDBBOGFWb1E5M2ZUeGh0ZFBPam5BWk1XS1l6UXRHS0JNR3NuSCtIU0NLTk5ubytaaFpPdnAyRVJwT0xCaS9PYlV5ZWRaK1BXZFNXc3c4VnBQTHlOampocGFNN0N4VFhTZ2ZlQW1Ua0FOTkV4NnRBODdObjhPaTh3ZEVBRVl5K0RBMThjUXBuZzNMZHYzOWkyejA4NWhDdTcvTkRVTSsrRWMvMmVEM2ZyekZqUkUzeU4wbmJ1aUdrbEhmRFNwaTNEbEhPTi9Ua2FQMXkxclRKOUdISFVKaGY0eTFlNHR6d1djdmlXOHVxTVZtTGVrdjFBQVJveGZ4aHBXcEZSZHViaUJUZzFmZ1BaVi9oblRUaS9Ra0w5Wlk1MktCcnpvZjEzZlhqL3ZsM3ZNeXk5Y1A1VTJWYkRGRTcyd2lUMDBPaE5ZZml5RmRzaWJXalhqYTRGaEViY3pMMFFCdXVHdVpvdDFvYklmZVFvZXJZUUFjT0RDVG5NUFBKTWcxL01FQjJqTW1jNDJuTXBRMTRxcTdPVFQrV1FmRVBqYlZ2MmpQTXJ6bDVZempyVm5IVkJZNHF0K04vK3U5K0t0dnpJNUlrbm5zcmgrTHVUTEthT01LRWRZUmpLUVRUd1d6YzA2QWhUYTZIamR5VU02MUNpZFprb1U0WlJ0Z2hRYmwzS3A0d2hSRFRLV2lWQlFNRy9hU0NlT0phcmdlODNRZW10WElRdWY2NEYzZWdJSTJDVjFlb0J3aGM4V21VSmp0S3FTMEJXNTlkeENHWHBXeGczUHVqWjlkTjUrWlkzMlAxYldQdkJjUWlmQ0NCNEVreldtM053azA2NCtFNTFtNGZmTUxxVDhDMHV2T0NrTE96RHRGTWQyNTdkKzBhblI2TWxsRTN5NlhqQWxNWThuSG95TXRxWVpaM0tiZ2VqZG1UM2FGNFFIL0hHMFFFaWo5REVHUGpwUUppcFNsT1h4QloxNTZGczNacnJ5VkxQWmV1dVN4N2dkejZtREg3d3JpdXNRdXQwNHByOWFrWkM2M0xrUUVDSERxbTc1S1lOUUFOczE3VmRpK2JNYUcyaWNQZ3hZSThZY0pzSzh2SHRDNFRidXpYaGZIdmEvQmNSY3Q5OTk5MXo1Lzc5SDlpN1kvY3ZyMmFZOXVJenowU3dXWHBFaXl1R3BBVmN2UllOTXY5b1Mxd3o5anhEWXR3TzA3akZvY0gyNmxrTVo5ZmNTQlB0eE16MitEMFZmTkp3aEw2ZFc1dWNUWkVGL1NadE5vZVpuSWZnWnBJenA4OFBJYkYzVDRhb2lYc3VndnA4bnUwNzk0ME5KTjk0L1BISjcvM2VKeVovK0o4ZUdReTlhOStkRWUwYkppZlA1SEQ5M0lDOVFMTWNEQlJjOG9hM2RkTUVpRFhNN0xFY3U2TXdqN0xNYTRES3NtVzZ6bmlrRDhjcUMrZnRBYytiVVBOV1BzTFBBMTcvN20vYWVYV0VSZ1JXalpTdGxwK24weE82SHNOc2NhUUR3MG9IK2NCTmZIbDRHais0TlkzNzNmaDJuQzRyLzNtTjBUZTQweXErVVQ1bEhKMUFCSTIwaHZadzhxaE93dGhEOEMybmZYR3ViU0tJNzNuVG9SRlBKMkMwSUEwSFp1TkgwTGUvc25XWnhQTmJ2S2F0OTd3enFWbmxZZ3VtL1JkdUJEU3QrQUliZCt6Q05HemJ1VGthL1hQUFBUUGVLemtmbzlzOElXOVVVUGxQaFhHeTA0R00vTkU2K1JuRmlXT2xEOWM0ZWZOL05XNU5PTDhhYXYwbGkvdlRELzIxRDIvWnRPMmVIQmp6SVF4MDZ2aXh5ZkZzUUZuSUdjRWNZV1FZZURXSHQyRE04QjN4UExRWHk2cTZzV2w0bUFBamNRUUZ0eHlOaTkxT21GMVV0RTZRWFlIRjcxcFdSMGd6TktLOE1ScVl3amliQURabjA0aXQwMmRwTkxFTjIyb05oalc0dE9FWGdqTUJ2bWZmd1hIeDdLTkh2am41cmQvK2o1UGYvLzNmbit6YzlZYVlLTUl1bVhSMEJPcm1tQzFXcjdJWnh2NmRuV0hyeHptL0dTNUhRTlBrTGtaanNxckVBVWR3V3MwbWdxWGtqNlYwSkdRMmZDTmFjd3hrYmpiSkRiZ3RST0FNZDJYMzIvdkNWTUFTTGdSbzAwc1llcllRUWovaEJCVDQvSWNKWjBvYndxc0ZNS0ZOYUxaUUVwY0RqeE8zOCsvT3hMYzhwQkZQL3YwTnAzNzRlVG8rZUFPdjZkR1hOTXJsekI5d1hkZmlLaC96QURpTmh6aW5UNThkSFVaM05DWjM0Y2Q4Y2RkZGQwVnozbitqL3NWdm1uZ0gxT2hnR3BkdUcwWnVjTlFTT1N0a2RBSzEvSytFWWFkWk1NR2NNSlBSNDJaNEhYRzA4RkhHdkJlelNtVTFLM05XTTdHN0xxWXdIY3UyN2VrNDlxV3RaeFIxNXZUSmRKS3plWkhrbkxRNjYrb1lhTzlqcWQxQXhSOXRRSjVEcEtlVm9DMU1DOWVrR2pqUC9takp0M2Ryd3ZuMnRQbExHL0xXdDczdHdWMDdkejYwZStlMmh5S1RIcjU0NGVLL09uSDgrRWRQSFR2L3VldW56cHpaZHZmZUJ6SmsvaXl0b2hpaGJHZ0xzZHVaSE5MNFBWY3o2NHdoeFJrTlBuNitoUTJHSndqU0lCMy9MTHlGeFlpZlZqM09PQTZWM2VodEJVRUxNR25aajlkbHplbldDTlJ0TzdaUFZrNmV5U0gyNTJOdjNwMWgvMDU2MnVSYnp6NDNHSGgzdExETE1VUDg4V2MrbDBPTGZtL3krTk5QVC9iZGNmZmsxSW5sRVJlSG5NeXR4OGx4bUVZMlpNTUQrRmFndUZUZ01vMG8vWW5icnRlbHpOWUVFempicmprbHJjN2twUjNDZTE3QUVUcUVZd3NERGNhM2VQM201NXNqRk9mcHd4OU5QUEpwRFZGY1liVE5JZmpnbVB4YnFBdWpHZHNoS0E1L09EQnowRWdKYjZhRFVRY3B1emRoMnQvSzBFSzk4NW92UThlREYzL0Q3L2FUMXRNQ1hyaHZPUEZieVFvR09NSEJKUVRjenB3UTk0WTN2R0dzaGxBZXVKdXNFNi9MUHkvczBRSThUK2M3QUUzL3lJK2JEeGV2bmQrZG5xQVh2LzNFYVpqTUc1UU10bWI0dGpsajE2NDlnNDRuVDd3d0pnblp5R25SaEM4QlM0c0dNMVFFRGlMRHB1Mm5FUm1oYkJMYlBFdTd4clcvWDhsN1RUaS9FaXI5Sllsei8vMzNQN0JuMzc1ZjJMWjF5d014Tjd6UDJRYVhMaXovd3FXelo1OSs5TWlSUjdxWTkyY3FEck4wdythdmNmSHpkRVByUnQ2TWdGSDVOY00yYzJNYjZmZ1RVeG8ydXk0L1FzS0RhY1huSjd3RnpvbXNTOTJSTmNwMzNubG50T2N3U0RxSVNQV3hmcG45Y2MvZWZaTlQwZEIrNzVPZnptV3JuOHB0SmM5bnUzZE1JbHQyWk5mWG5tRWVZSmFwUTVEa0ZVRVdqVHpzbEk0RDg4akxNRG80R2hxRXVmaVJTWEFhT0U4RlJRSnU0S2FjNk5ONE5rM2czdVYzWjUxNHdwU1JNUGViY0ZKV1RseS8rYmNBQmhNY1dxYTN0TUw4NXFTWHp0TU8zVGlDVFh6NVN0UDVkMzVnZ0M4LzhQbjNJNzB3NmIwSkpEQldyOVNFMkh4K3dwa0tDRFVQN1JNOUNHY2RnNVU2bTdORWtUMzU3cnZ2SGc5Yk90amlTOS9uZVBEendBa3U2SzQ4VFY5bGtEYy92OXUvdi9sMU9aV2gzVGpUSWtwQXI2QVFCd2tMVmduWU5xZGN1M1pxNEcwRUFHZVAwL21xbk5jVHRpR2pHUjFlZGNCZ2phRWtVMForWHFXQmFEdlJkcndKNk5mcTFvVHphNlhnWDREMGh3OGZQaGozY05hT3ZpODNDNytYaWVERm95Lzg5OUVJUGhlbU9QckVFMCtjbVM5R3pvWi9lblBPbUZqY1pLWEZjb1JaaHQxMmtKbjhzS3d1RFc5eE1WcGtscVc1RkpYbUd4MDZBaStOUDh1UXJ1Ykp6dUZzUWlrYjRqaWdKMXpCSklJeEhKeGs0bVJ4WTVqU3hHSVljaW1IMkxjd05EUmNuMHRRcitkVXNXMFJST3N5TEwwZW9ibzVRdmQ0Tk9pTk1WWGNkZWh3bU9KYXRsbC9jL0p2L3QyL24zenVpNDlNTm0zZE1ibmpEWWZHTHIvVksyR21zMDVuSzgzSkd0VEY1TzEyRlVzQzViV2NXMDd3MERpYUZINFJEa1lHcTlrcGVObDIzMnhzdVpBYkxBaUJ6VEdERkN5SDVwY3d0VW5EbVEzRjdDVlloakJqTmdsOEQ2RkRLR055cnN2bzkrRHZMRWtra0RvZTRVbkFidCsrWTlqY3diTU4yZHUyWWNJRUhtZlBuSWdtdW4reU8zWjQ4Sm1sQ08zangxNGNjWFV4eXBNL3lTZUNPb0lXRHVERFY5anFTa3hUNmJnODdsVk1yWXp3c3M5Rzl1UU1iMExHYnM2eEN5NGRXZ3RFazRGbno1MGFlYldBcG5tcUU4c3M0VzlKbklrK0hldldyWlltMWtseXlrdkwxOFk2TGZzdy9BaFVKd0dPRG1Nc2Ewd1pnaitaTitSZTZzdnVQdVlLbzdJcUQ0SGJRcGVDVUtZT2I3WmxaUVViT1VLUXBFR1duRGdZT3BycEEyTmg0NWJKcmoxVlgraDcvTVM1bU8rdVQzWm5YbU5kbEFDUFRuMU1ab0psUjJCR2pndXBrMW96VG92V1dSYk40WnhobUF3SERmdlg4SGlGZjlhRTh5c2sxRi9FYUlleUNtUFBqdjN2MmJObjEzc1hOeTEraUwzd3pKblR2NUtKbzAvbCtaT2JoYkw0VHozMTFQS21wZXU3Q0JGT3cyMVh3clUwNkxIT09VeU4wYmwrdHdZekJKYXA3T0ZLUUdqRXBiMFlaa2FBaFhHMmJhdVZHWVIvQ1ExcHdxaDVuQ1NYSzdQU3lHbTVXVGRNQTg0S2lJWEVOVm4zeERlZm1uenkwMzgwK2Z6bnZoSjc4WlhjNDVlekpxSXhYMW8rSGlGMVlySnBZZnZBWDU0Rk84STMrQ3JUME43QzdiN2JUb3VKeGNXY1F4RG5OMkdFRmdTbTM4M29nNkduV2g2L1RndWVoNkFrY0FrRmdrYjZlVHlrYjlxS0Q3WjMrNGxMSUpkUWVlbW9SVjZkQm5rN1RjT0V1M0R4NEE0Mk9NcmNjWVRuL3cyOENSSnhyR01XWitBYXMwK25WeGI0ZUhRR0hvS3EvY1JYVHZHdHVOQ0pSQ0VZUXBpL2NIaTB0dTQzUFBsTFkwV0YvRXZiTGUyZWNCVHU0WlNuWGYyZWlyeTVPQjFQK2JoKys5MndsRS9lOG0yWThoYlhXNWh5YmRsY2RHYisyTFdyT2sxbDBmYkUwNTUxR05xckZVVEpJTzg1bWdxYWQvQ2ZsbVhlKzNhLzE0VHo3U2p6bDhEL0RRZmU4SUZNd3Z4TGpmRDhwWFAvL01TcE14KzdjT0U3aGZMTlJjMUZwUThZZ3RKb05kN0JITkVVUmtPbVFVeC8rOWFndlR0ZU0xSXpCZis2L2FRVzlKZjJNeDNxWjJYRUNMZVVMWUxZVGRpWG9sMk5wVk9HN2x1alZTYk9tWE01MENlN0ZPKzg2NTdKM20yN0pvLys2ZGNtbjg2azMyZi82QXM1TitIVVpDR2JGL1lmMkRFNStzTEpuRFQzN1dqaDIyT3IzcDIxMHpVTXhveGM0NFR4aHFDSzFzOFB3L1VxRkZyKzFXeTRNYnhGTitVaGFOdVUwTXhMV0VVc0RvRURCb2JtbEtmZzJaRlhLek44ejZjSEEwN2lkanBwNWRkcDVYc21Rb0RyeVRZZG1yU3RaZE5FVjFiS05HVDNadENZd2lVSWFZaktMUjkxUkpEVmQ1WFp5S1habjJBdW9Tdy9jS1JaaWMwZlBuQ1JKMkZNUXpkWk9UVGViRytIZjlPb2hUTEJyRE5pVTFaRytiWDVvRHNwNlpmZFpCSkhVTFBqY21EMTA5OWRmL1BmNHVqN3h4dkNVeWUvK1lmM2ZQcitodmUyZENKZG45NGVhZFVEbkdQQXlGTm1xUFhyZDZaanlkN0IrR3ZEeXJhYStpMWNwNTNHdEt6eU1PSUFTL2gzNjdwMnZ0djBhK2wrQUNud1Z4Lzg2UTlrS1BuQlMrZk9QMEpBbkR4ek5tY1RuL2gvc2lQcnlPM1FQUlN0dWNNMmI5bDh6N1lkT1dvekRCTVdTUHVrSWFlcDVLZkdkbVZvRElUUlREQkxpd2s4elRDck9kMEw0eGxDcHAyT3h1cDZIdzNjYys3czZXRXVNZndjeHpWbW1kemxyTWd3ZkY4ZjVyNXNXQnJCbTd1ZTBsRmtKVU5zbUU4Kzg5emtQMzdpazVNLy9NeG5KZ2QyM3AzekVLSjVaV25VeHFWTUhHNk5lZURLeGdIajFNWFRZMk1ESmdtWWtiZmpRakhlV0ttUkllcWw1VnFTQjNlTUNYZE02N2N5aU12QjFYZkg4UmF2aFFvQlZveGNLMXdJWWhxaXJiM2k5UU9lM3dSZHdTL3RtamtBTEduRTZid0l0TUhnRWFyOGdzYUlKdzdoMi9qQUd3N3dCRnZuSXg5NGRON2U0cmZ3QWNNM2dkLzFSbmlQTW8wdCtJR2ZUUmFyMlRZUFA0TFpVcjBXekoxV3ZnUXVYT0V2VHpEQTFIN1V2UlVXamdOZ3JsQU84QWczZHpCeWNOSyt2RWNqbS9xWmtCYmZ3eWxmeGFrME9oUitIUDhPRTEvK1hWNi8rWFdjanRkMFFqUDBFVTk1MElhN0VMUE42R0F0eVVoYkYrYSt5TDQxNXZ5RkV1aDFVV3lpRFB5bkkwMmRZWjdobGFBdUE4MTZPR1dxWWswOXZ2TzFKcHkva3laL29YM2U4VmNlZk4rZTNYdmVtd2IyNFBtVjFRY3h3WVhUWjkrMWNuM2w2ZHNWN1BEaEF3ZlhuVDZ6L0lROXFYR3hNUzZ6cjdraHV4czRiVG10YlFnNkRTMThZVjV1T04vYW1zYnRhZWMzUmlqK29VVVVrN0FXWXFxbG1DZTJ4VGE1SVRiSzVkaDRYWWk1Tld0Z0hkbnBKTGt6NTdOMmVmdkNaTytCTjBSc0xFeSsvTWlqazkvNWo1K1lIUG42NDdsVzZvN0pONzcrVEFUeTlzbkM1b3dNY2diemhld1d2QkxUQjZHd2MrZVdHN2hoUEs2WkUxNXd4b1R0NXozRDk2WG1oV1pjekl3ZWNHOWhXQUs2aEZIbjRRMitPRTBQYjQvMGhBSG5EQW0vUGZ6RkIyL1FWN3dzQVJ6Q1p6QjUwUkVNNFkxdncvZk5nU084M2J6Z2FidzczbW8wWXdLWkcrblRDUnMxWE04U1J6QWM2S1A5MEpZSlowSVZQSG1LYjdVSWdVeGo3cEVCZjJuRnVmbnAvQW55UWJkcEE2cjQxWDRhOStFWERiVy94VWVmcHBGOGJMbHUzTUVldElwSDAwUllwL2VXcGg5eGxZM3pXd2ZqTGEzNjl1Z3dkQ3lPcitYY2ZtS050TlZDOEVIcnk2SGhjb1QzOVRFa1JQdFNadEtVWCtLYUxqYzhnMHNpMy9pODFZODE0WHdycXZ3RjlMdnZ2aDkvNkUxdmV0T0h0aXh0dmljMnNRZWYrL3B6ay9XWFYzL2g4c3JLMCtldnIzejlxZGlTYjFlc3BlVU5TNWQyYmptVGxmY2p5cVhsbFcrTjNWL1JrTzEwY3BtbUMxZjErdVB5MWlGQWhyRnR4QitNcElIT05UYU4wWkkwMmdGL2dwbXpuaGdnakxCbjk5N0JMSmVpVVkxRGpMSWJjU0ViVDNMSmJOWVZPMnQzVDNiN09WTmo0K1NScjN4MTh1OS80M2NtWDN2OHlXeEl5U3FJSE1Tek9VeXlPUk5MZHZwZHVKQ1R5UUszbWN4Wkc5Y3lnejZFMWVYcVpLNEVoNnZSNXZsWnA1eUYxZ01QRE4vbG9wR1M1WWt5NGpXamUwdW5YUElnakh3ckI5Zk14Ni9UV0NNdW5tL2g0blo4YWRCRjN1TDRUU0I0Tnl6ZkkxMXdJZ3g2MVlHMHRxaXorM1lhdG1KeFVxakE2MVV2dE1GNndGRTI1bzArbDFuOGdWT1NDVGNwUndDN1JZWFpnWm1KcHV3aGxPRldlWmVRc3h5T2NFYVB4bGw0dzYyZVBLT2ZkSmJPWDFaTzhkRERmQU40SGRmb3liYzNHbnBvenVJMlBZWDNiM0RtbjRGWS9oU01hb3V0QVV2VCtBbm5sQnMrbkxDaVhkVjUwN1MyYjg4TDBQQkJ0bWVMTHowY0wxNnN6dFRxRkxST2k0TkV3cXM4STRQcG55UVQ5SXJkbW5CK3hhVDZ3WTM0am5mODFROWtVZi83dDIzZDl0QktUczg2bnhVR3AwNmVubXk0Y1AxVFQ1eDY2VXFNVzVWaStlclY1WmNLNzVYVDdrWFR1QWVqcEVIVm1SZ2xpRFRNWWlhQ3RoaEN3eHVOZHRnM3EvRU9ob2l3R05wRTRwVmR0SWFtNHl6Z01KOXJvNjVFRFdlK3dDQVhNL3hOaWdqZ0xURkxIQncyNVVlKyt1WEp4My8vRHlkZlAvSjQ0dVJJeHdqdloyTGVPSHo0dm5FdzBza2NuRTk0c0Z0anVMRWtMbEFzb2NPWUxRRGg2aHYreW5ZK3F6bWFXWVUxZy9yTm44Q1dkcFFqMzgza3pmU0VoM0J4bmNjQUxzYm1iR1FwR0VVemFUdHZhYmdXZUoxSDU0UG0wbm9YRFVzUUJjVHdsM1ltak9mOUtnLzVnQzB0MXdMUW0xK1hvK1pycFNHVTZveUo4N2tLeW9RWHdVODRFOUsxVW1ObVM0ZXZod2JjWlFHVDg5MzV3QjhlM2NrSVU2N09YM3cwNDErbUwrMW1kaDJaQ1Rjd3BHLzQ4Tzl5U1NlOTc1ZlFLM2x3MGdpZmQrSjJ1bkdyVGZBekl2SzBrMFlkUzlrdzBOc3QzNkgyNkZoeVpPTGs2cllaalpmWDY4Q3krQ050RGk3aU5WNE45OVcrMTRUenE2WFlEMUQ4ZStNT0hIempCdzRlUFBDK0tFVDNQSC8wK1g5MTZ2akozeng3NGVTZnJGdTRmdWJhemlCYnl2QnRzVDRVVy9QU3lzcXdOeDg2Tk1scWpaeTB1V0hUTG95M0tlZmJZaTROTkh3U0Uxb1lhOXJ3TmJ5eHJDNWhmbXVNR3JWbTZYdjhGbjh3YlpqRUJwYUUyNFZWNzRYSm1WaFI3TnlqWVpwOEpQREZYNHlnM2htdCt1aXpSM1BNNTJjbkgvdjRIMlNpNzBMTzlyMHJONUpFazh2Um5vZmVlQ2pMNms1TWpoNDlPdkxidFh2UFNHdEpHQ2JDMU91bm1ocGhnU0hCTG1GVFFvOGdML3lLQ2FzY00veXR3MjNCSnA0SDQ4M0tWaE5sL1BsMWVzVDJtNzkzQ3luK1hYYitUc05yZVBBakVId1ByVFhDUXQ2K3hmWDREU1o0MW1hUE1pWmY4VHppQ0NmTTFGdm4xMlZvT0oyWElmbVZDR0NDcVRWbTVvc0xGK3Q4aVEzUmJ1V1IwZ3pjNE9laEtkT1kyOGtUYnVCNkdnOWJvcVVuNktXYngxTzh4ckhUUzVmaURGZmxMcG8yYmIwYmh0L3VBMndIUnBmUG01TTNPRnpCcTNZSmh1OHJVMXFpbHdmTXptdlFMSjN2YXM1dkx2eHE4aFpzWlZuSVNoYWpzMHFiOWVUV0Y1bXd6VEdrc3ZSQVEvekdBUjc4cGlqNWZGbTNKcHhmbGp3L3VJSHZldGRESHo1NFlOL0RhVGdQWFFwRHNaK2RlUEdGWC92cVkxLzkxS3ZCbXNiODV0MjdUMHRETUIrS2dONjllZk9EV2NZOFZqdGdJbzE4WTliL1JvUmw3YWVZSlZTdTUyak5tc2pCQUtVNUpSazVIYk9EZGM3UkRxZDJacWZNTVN2UUtLMmJ2cHlORFdjekc3NDdTOSsyUmJDZU9uTSttdXp5NU5EaHQrUndvKzJUYjM3emljbS8rWTEvTjNuMHEzK1cvSE9HYjdaZEgzdnhkTmFpM3BGMXVSY21MenlYWG1kRDdNcXJ0ZzVUL1RKWmswT1N6aWVNSnI0bDkvMFIwaGdyRVRLbjZYZTBNTVAxQ0NVTTQweUZjVVBJZEZpUGtjb01VSXlPUWR0aFdzTjR0TUNRQTI3S041ZzFXak4zelRtOTZTVzVsY3VYaGhCRGw4MWJhdmVmdUVPVE5OR21FOGxGcy96QWJ1ZWI4NjU3RVN1RTNaTW1tWkRZUU1Qd01ldmtVb1FockVZUmd4ZW5YSTBISVFLMlVVckJMWE9CYzV6WmxuVUNoREtCclAzNGh0OFFhcW5FSzFmS0pyc3BkdGF0VzAxVzFzbDhpNWtqY0V1STIyZkU5V2dIVlE1NWxSRHR6dFlFbXNjeU9YNXdLU0ZyQkJZS3BWeUYzNnhEQTB0OU9iNXpJYitySE5VQlZUbHI4bktVZHlway9RWkhYRy9sNThmNTlveDZtMzZ2cHJ6anRNUjh5ME01ZEZUU2o3U3B1OFdObVU5SU8yY0txdlJHR0gyZm95dkFUSUJtVFhyV3pBdFh6c2t3YjZSNXhnVENYYzhrdUh6SFlVM0Q1NVg5V1JQT3I0eE9QekN4N3IzMy9nZjI3OTMzdnQxNzk3dzNtdCtET2FqbC96cHo2dlNuY2dEOWtRdVh6dDNZNWZkcUVMNjJjNmNyS0VhU3pTdTdEaDc4NFR2K21jYnBvSm94M0l2TitkbzFqRjVRTmZodTlIdzBTa0tqWEdrS3dyTzJPaHRVYUtsaEZtZHNSS2dScERRTUd2VHVYWHV6WmprSDE0ZHBhYys3ZDllSlpILzJaNDlOUHY3eGowKys4UGt2QjRmTE9ldmdRUExPVVorNWdKVzV4akdoNGw5YXZqQ0cxaGhkNDRjcnJlNzY5VExIREVZSlVteXQ4TUhzQTYrVVRSb3dmTk42cENkMDRjYVZjS2dPcDVtOW1Wc2FqQ3d2WWR5QUUvLzUzK0swZ1BUYlEvakJjMmhxMmFUVGsyUDhDRWVkWVRzd2k3YWxCUTRHajU4OFBkMTVnT3ZBL2VHWGptOHhaMkg0TFQyNjlXL0xCR214TkdONU1WODBQdDdnTi80UlpTbGZYVENybkVZWjFyWVh6S253UzkxVjN0SVZQbzF2d3hrQTgwZDU1VkZDZWJhbUcyNEQ3OVJILy9ibXVyempZKzVQKzh0N251N3libGhORytHY3QvQ083N2NIdlp2bThFTVhjT0hMSHh6dnErbjhwZFhoTjB5andVMHhiNGpEYjJIQmR2c2FqZmx1ZXM1NFkxcUlzRXF5VHNjdy9iN05hOVlTYmhOaHpmc0hod0lQUFBDVER4ODhzUDk5WVpiM3B6di8xTkhuai83S3FUT25QdnFuZi9vbm4zc3RXRDQxTjFsNGJkM0NrczBEaHEwYUtWZE1rd1lWTFVhajB0alM5S0xCbFhtZ21LSzFIK0hGRExUUVM5RWdhWHpnWFU5aWdwQUc3WXFJcGUyMUxPbDhsdnJ0MnJVdkYzN3VtVHlhZy9IL3cyLzl6b1NBZHMrVUZRM3IxN2s2S0V5UlR1SmlCTE1yNTY5RXVMdTRkZnYydWxmT1Vqek00QllUblFGR0kxVEt6Y3dSaE9YQzlQaEpKOUJ4eXRrQ000amRZTWdXQWhpMWhZbzNHTW84N3pBak9uVVltSjRXTk9CNytJRTNZRVlHTFM1dUgybHNsYWJGd2hsc1duRTRmdVFMeGhoNXBJeERDRVFvdUhVR0x1V1lWU0xjOGxsMVJYaldiL2tST0k2Q0paZ3ZabTJ4Q1Q1NThSdjRCQzVISUJORUJBell0VUlIanJWN2s1a0hUY1FyWVZUYXNvbEUzd1IwQzZTSXliSDl1ZkdSai9JUCtpY1A1Vy9OV3RvQk4wZ3JlOU8yL2NCby84b251Q3JnMUluWGNUdmNlLzYzcUw0N1hjTURXNW43Vzd1QkczemhLcnpySEl5YVVLMTZxTzNuTFpqcmdnUHhoMmxvYlBXdXpxNWhhLzlCSWc5QW9MMjhXeFBPTDArZkg0alFldy9mZSsvQnU5LzRnVDI3ZGoyVXh2UGc2Vk9uZnVYU3hZdEh2dmlWei8zYTl4ckJ4U3RYTiszT1FUVkxzUVZ2WkIrZU1yeUZGMk80bkpZVjJSZUpWcHNtdXJFVGFoby9KdEd3L1Y2SVhVTjR2cUpCR3lJR1pvNENqU2dad3ZOOHpsKzJzSC9QM2wxRTR1UkxmL0tuazkvNTZNY21qK1J0eDlVZGI3Z244YTVtcTNLT25CeW5vUkZLWWZzZ1E2eTJ6VmhlZnJQREVnQjRBTU9aaUJ6Q1o4cHMvREZhKzdrSkJYNzh4T2N3WDJ1S05SeWZDZFdPSjAzQkwrR3B6SERnbXBtOU1icEhHR0VvWG1tZ0paek9aM01Od2NuQnlWUDRaNWxZL0RlbFROSksxM240RnE5Y2RTU0xNYzhZZmc5YUR4aGxuaENIUURiSk53UnliaUNmQ1orYXpKckJJak9xUEhBa21KaERPQm96UDBzVTRSR0tqWElTeWlWbENFSUNPM1NJUElKSGRYTFRFY3BVeUhXbmhEWitFK2J6NVl2SGNOTDNnK2I5Q09RdmZlV1JYT1pvMzdDVVVYalhVVUZ0dlBwcjlpMWRwd1d2SGRyMHR6d0xYdmtKNCtlTkR2SnpsZ3JURjMvMVp3Vkh1WFRjWTYzL1hJY3h5NmF6KzQ3M21uRCtEcEw4WUhtODlVZmU5dUFkZDkzeHdkd1U4UUdNZS9MVXFmLzE1SXN2L09hUkoyKy9vZVMxbEdETDFpMzN1bENUSTVqREdtbHNhY2lFYjRiRmFXVWpyRFdJR2JOVUEyM0cwZGd2cjE2S1RUZWFZQ1pQcmtWUU1sOHNaY2h0OGk5S2Iyek1LNU9sTk9oZGV3OU12dlNsUnliLzcvLzNxNU5ubno4NjJYL0hHNFlRT1g3aTdHRE1TOW1hZlRrYlVhNW5SNTlKSEd1d0NkWk5XVEpHKzBPWHpZdTFlOHZWUWNRTVBBejFNVThMeUkwWmhoTXlPcG1oT1VaanhQZzFJaWdocmF3dGhNOWwxWXUwSHZCYVNQak5LU05IMEtDRHZPQWlYak84dFB3OEJGNExQbWtJVEtZWkJ3dFoyZ2NQSXd0Z2g2MDFuU1BoMEt0T2l0YUVVd3UvNmxTTUJPUXBMZzNjdW1SQzJXbHI4dldiRFZ5ZVJqT2NuTWFkajRGbHBLRk1jTk14R2VYQXRSM2hYTUo2NnBlNmhJdExDOHI1RHRMc3lVV2FlRmZuTkUrenBnazgwU1d2Z1RPODBFNTQwOW1iTUJTWHYzQjVGZzIrVTVNVzN5Tzg4L0htdlBsekRjTWJiRS9ScGN4aTh1SGdqWFkzdytnOHhORWhLU2RZYk81R2JldlhaMFBPVXRyMTBybkFUY2M4OEIvUndqcHA5NU1XMkxQT0FheGJ1VFhoZkN1cS9BRDRaWm5ZUFhmRmhMRjkrN1lIdG03Wit2NEw1ODcvMmd2SFh2aTFrMmVPZmVySko1OTg0ZlZDOGU0M3ZmSERPYjF1ck13b3JhNldvbzJaYUF5U3hzaUd5Mm5ZM2VqREY4TjE0OWVvTDJmQ2F6RkNjekZNcHFFdjUxbVgyZStsbUN1dXI5czR1Zk9OZHc0TjQ3TmYrUExrRHo3NWg1UG5Ybmd4R3VDV29WbGZqT25pOUtrTDQ3cDZ1ZEsrYVNJMGFWcjF4bzF3cU9Hb2pERVlIT1ZMZ3l2R0tzMU1PTHdJSHpaZXMveUVnMk5LQjdORktFb3ZqZlhkaHFYOE1aNHkrdDFDQml4KzhtbEdubWRnY1BsTFE4ajU3bkJwaGZtV0gwRUlWbXZQOG1qNlNWOENyUEx5VFVCNkNDM3g0alVtOXNRem9XZU9nR0ErZCs3TStDYVVSN3lwOWFQV09kZklnWGkrR3VGcWNnK2VIdmlVRUM2Nk5GNXdCcWNuOC9KRFVVS2VBanp5b0JsTzJ3VzZLYVA4bFVrWis4Mi9hV2tPUUJqNFRUZXdoRGZOKzkxcCtzMWZ1b0ZHZnFPSlI3ZzhQRjFQWU43S2lRTkd0WjFaZlk3eUJDWi96amNROHV5SG43VHlNL3FqSkZBR2RINW91R1A3cmxFbU5MUkJCZTJTUE0vVWJoL1NYYVBzdkl4YkU4NHZRNXcvcjZDM3Z2WHREKy9kcy9lOXU3ZHYrNUFHWU9MbXhNbVQvL2VYSHZuOGI3N2VPUDNvdmZjK2VOK1AzSnNiUnk1bSszRk81c0lvUTRPbWF4bUxGZU5wMkFUZGpCRksrOUU0bXlrV04yMGJER1BpelFsbkM0dlJNQU52UTJ5WU1SL0gxTEZ1OGxnT3gvL1l4ejh4K2RhM244dkJSZnV6VS9EeTVNbW52aDI3ZEhiUUxlMGVzS0xmREMzTk1hTUVnTXRtVnpER2lobjUyVEk1bWdybXdTUWwyR3BvVzM2em96Y0paNExZT21XTVpNa1h3YTJzVjYrV0thRVlzZ1NMT21naEloMm01UWV1ZUMwWTBFSTR2eFp5L01EbCtHUFdoaVY5Ky9zdG5qakNQZUtDMDJZVytYUWE2Vlp5dG9VUkFBM2NjWmF0TFk5UlFUb3lOUmFSbXNzTlNwaDNYZEc4MThWUEh2SnNvUVptbHhVZTRyZWYzNGxlK1lkdXZqY3V6Y1RIRFAraUdkajh1aXplWUh2QVJtK1hPQlROaTViaWdJdSs0clJ3QkFlTzBxQUhKNTQ2NW9TTEwwNS9nOFdQRTdmZm5ZZHY0Y0s4d2ZESXMrUDRidGNtSHZoMmZsZlRTRld0YnlZZkt6b0lZWGc2Y2pUaWZuU1c2a2RuS0V4K0E1K3NBQW0xRy93dDN6UHEzako0emZQN1RZR2ZlTnU3M20vZDh2WWRPeCsrbEd0MFRwMDQ4VS9QWGpqN3lQbmxLMCsvM3JpODZ5MXZlaitUeG81Y3RubjlaSFkvWGFpR094cGt0TkZxckNXZ0NXRkNnQ3NtS0diQUlNMFVLMW4rZGpuTGpnakRjUlZRbGgyWnVPTDQvZDRuUHpINTBsZStQUG5tNDA5RmNHZERRNWpOTVk0TFdTV2dZUTVCbGtZdGYvbUJxK0Zmbms1Z0NkKzRzVzZaTmlIWVRDaWUzNjBSUmtlWmFxZWxIYldRb0RtTDY1RUgxeU1FNmVNOTlhdDA4MHdyRGVIZzNjSU4zTllBeFoybkQvaml6c09nYlJFMm5tWjQ0WmhjMmVDM09ic21IVUtsM0FSSGFjaldKMStabkw5UW0wVUlabm5KdjFlYjBJZ0pCdzVNUytmS1JWaG5ZZzg4Uy96ZzFmZ1BBV0tNRWxrV3FxUlRxTTVYWndmM0VrS2gwMVE0ZzFlQ0p2UWVTd2hMU0lxckUrOXlpVlBscW9sUTZacmVUYjkrQzJ2WHRKSytZVFFjdUhTNGQrTW5yZC9pVjNzdGFCMjN3NzJWVzV3YjVZcWZ0RHBZOFJ0SGNWdE9tOGNReDhPNVM1UFNJbjdEdW41OXFzVm5iZ1FlMWFIWENLcVgwNDFPYWtDNC9aODE0WHg3Mm54ZlE5Nzg1amZ2M0xOei95OGNQSERnNGMxTFN3OWZpMVowNnZpSkQ1NDhlZkpqanozNTJPc3FtTys3YzljOWp6MS8rdWwzdnVQdC8vcDlmLy92VFk0ZGZYYWM4WHZIdnIxRDJCQVViZ3NaalRLYWF0cGhHbUlFYlphc1had09uUmR0T0lnNmJBWjdJYitIV3liQXN1UXNOMWxmWDFnYXF5dldaWDN1TTg4K1Avbk1aLzk0OHVWSEh5OGh0Q25ic2RQWXoyYWQ4NldzLzJYS0JPZFMxaVBMODFvT1JOTElMZTJ5Y29BTmRNVWhTZXNTUDNidDFaejlYTXhYR2l0TlhicjF1VzZMTFZSYTlrQUNpbjFYMkxadE1aK2tIUGs1eW9pQjJ2RXZocnA0ZytHa3djeGc5V05pcklYYkVGaldJWWQ1cnhLaU9ZdDZzbTRHazJZbHZTM0J6ZlJidCt3Y1F0Wm1sQTFUWEsyVDNwdzEyanQzNVJvdWw5bkdZZVFMT2NpSnVZWFpnb0NHbjlHTnprRDllQWV6MkRWbndtUDlobHA1b0R6eVpLY25RRW9UejJobXVnc1VYajNhYU0yUDhQYWc2M2hTSjJnd0dXdmJLNDh4VkpkZk5ISGxBNXRRNXB5RjdaQWd1RnNPdVcyYjQyRjNURjdJTldoNzkrNGZzRTI0TnZ5UktIL1F0djJxczZsdjRmeVZVMW5nTWdSYzN2TGxMMXduVlhqVWxWM1NpZXZoUDhyQU04NDNXTjRlZWZkdjhJb3VwZkdMWC9VdWIyVkYweWx0UnVkRnU2ZDhWUG5GWlhiYnRYTmRSb05Yc2xMMVJCQkpKeGZidEl0bEE2enFLL0hoQlBkS1UvajZ2U2FjVWYzUDBSM0tEcjNkdXcrK2IvZjJIUTl1MnJ6cFF5cnQ1TWxULytMQytYT1B2SGo2eFk4KytUcmFseFU3RzFCMlB2YjhxYWNQcFMyLzYxM3ZHaWU1dmZEaTgrUHl5eDFieTZ6UWpVWjhES0VCamdZZktlcDI3akVaRkFhMTNmZGk3dnRibjJNc3QyeHhQbk9Fek82ZDhUT1VuMlEyZTlma2k1bjQrL2UvK2R1VEo1OThldkxHTi85d2hFbUdmTmVqQ1k3bFdDVm9MbVlWQjJHeExVdnI1SDA5WjJRUTJHeVV6WHg0Z01BVlBnUlQzcllBKzRiYkVJQlR3UXpuMGZqRERnUHZoSnNFYTRZUTNvdyt6eWlFR0Rkd0NGengyeFdjQ3FQRit2WVdGMzBxLzlLY2hKWFF5ckE1NTREUTVNV3p5OHprWkF1RVlhSVpacG9heGc4QkhHSERyTlZDZVV6dVJSaVB2TEtKQjA1d3grb2N1R0h2dkd0MElsLzVFelRPc3hqdjZkSzRnZFpJVTRMS29UNWQxcFhZL01YdGIvUzZsUk1PdnZmTjlFUS8rUEpuQXV0eStwYW04V29CNmJ2TDQzM3pJLyttYmNkdC9Qb3RUc09YZDhlZnowTmFydXU4MC9MM20vTmJ1eElIdkhiQ2hUWGM5bStZRGF0eFIwTVhDeGdsNlV5dmhrZUdDNHp4enp0UE8zQTVjTmFFYzFQbHorRk5XOTYvOSs0UDNublh3WTlZdW5ZcHMrdG5UcHo4NThkUEhQKzFSNDg4K2wxdEtIbTF4ZWlUNkI3NnUrODUrdUNERDQ1R3NSaXRkVXljUmRnUUF0V0lxOEYyTzlLSXNraGdER2VyRVJzdVJ6dExPMXVKUUxIVmUydTB2NVZNc05rR2ZpbzNadi9CSDM1Kzh2a3ZmSFZ5N05pNUNOYWRPVGZqNUJCaWJrTnhIT1ZGcDdERkZ1cVVNMllLaHhsaEtoTXVkbUxCaFUxYVkyYXlpTzR5R0VkRHBta1BnUmhmS3hQRUlleUt1Y3JPU2I2SUMwNU4zTlN0MWVMd2t3WXpjY29uYmpOWnYvbDUyalhqOGdPbmFFVnJwNUhWd1RyV2VZOTBNeDVQWHRGVzNhUkJhRTRGY3A4SlFxaGc1b3V4VmRLVys2aE9zRHYvRXNiRjZQQmVuNmZ4c3NXZUg4SE1NUzhzYmVxVDQyWTIwK3JjU3BpVnNLbXk2MERzc3RRcDhPK3Q5NlVkZDlrclAvbklGeDNxWFpPelRRZnZwbDNUU3Flai9zUWY4Sk1IT2pRcytBcTcxVE1LTlAwRE5pZmU3ZDdDT2wvdnprTjg3Y1czQng0ZEpwNTAzZmFiN2gxSHZHcHJNdzErSUpBLzgrbjRNUTN0MkVIamQ0Wk0xcmtQNFV4VEo1cUxwOFRqR2c4dy9GNFR6a1dYNy90Zk8vM3V2T01OL3pUcklqK2dJakJDaGo3LzlGeHVLZmwrQ2VZdTlMdmYvc0JIL3Q1Lzg0czdEK3pkbHpYRnA5SndKcFBkT2JwemVmbjBhS0FhaXlFd0JrcFRIdzFINDd5Y3RjZkM3UHJiNEt4a2g3ZXZ6NUsyZGRHVUE5eGRmdGN6YWZMSW56MDIrZEtYSDVzOC9mU3h5Y2tUSmtjMjUwNjVPeWFQZit0ckF5WmhkT3BNTFZ0ejROSEdiUEhtbkk2R1VRMnZONHdib0dOdWlLa0RrMnhKUHB5T0FUTVY0MmpPTks1dTlDV2NyZkpBWTh2VE1Gb0xaK3RUcFMwVFJtbXc4Z0tMdjRtY2tVN2E2VE15elo5UjdxbmdtZmZqTHoxSDIvZmJaRkpybnIzTmVlQzd2dkFhOXZ2Y3ZiZWFJMUlKWlFKNTJKTXZsTm5pOG8zMXNoRW9zZGxqN0dRejZDNHJ1SEh5NXUvVHMyQWlOblhHM2srTFpRN3FlR2pFL3QvQ2s0a2lFRzhJWXVuVXkwTHNwckdHcEF4bHRsQU9lWXcxemRNOG16YVYvNnlUQUx2S1gvWjgzNlBkUkRnenhYRG9yRDQ4WE1jZjlFa2h2UHQzMDd5RnB2anlCbE1jVGh3dys5MjBHWUhUOFBuZjRuSFNpTnZwZklQWjlQRVdqaTd5OHhneDhnL1dJNTIwdnJVclI0M3FkTVdqWEREeG9HZUZLeXQ2VjI4dG5lZG1YTmVFYzBqMC9YWUU4ODdjZnAzNzFjYmE1V3pCenNUZnlaODlkL0hVWjUrNDZUNi8xeHUzdDkxeHg0Ti83eGQvOGNQdi9NbDNwSUhRekNMY0l2Qlc3Q2FJYStabzRYeHR1bHh0TUlBbEYybVk2Mk5lY0N2RWhSeGV2NWhOSmp0enQ1M05Kazg4ZjN6eXhTOStPYWFNUnlmSGpydUpPUnJ3MWwzUklOWlBubjdtaFF5emw4WncvV3dtdEFpS3BTMnhDNmR4NjZpc29WMGFKaE1NWS8yd0hYUWx2R2hkenNRZytNTU9FZEE5R1ZqTUE5ZG1JR1dBNjNpaXFSWnpZRFFUTlhWRGRUTTc1aEFQQTNMeUdlVU00M2hMTysvazBVS2gwd3B2SnIyZS9OWmRuZGZPN0M2RVk2MDY2UE10em1icDIrblRKMGRuMUN0SnJGYzJlVVMvb2hYUEdMZUVTYnhTUmd4ZWpoa29hQ1llL3pLckxHVzFEQnlWaDJBR2crbW55MVFDVWNjeG5ReU5objh0ZGFvRGtXYnIxbDYrMTl2Qnl4U0FEam9leWNCOHFXQXBZU2xmL3Q3aVNPTnRpQzkvZHZPbWMrTWpQamRyY3pOdHV2TVplU2Y5Zko1K2c5Rk9YRzcrN1RlNFhXZCtLMy9uMlhFN25lL1c0SXRPM2ZsTnRkclFSNmNxZmVmZnNPYjlUQmlDWlNRYW5oL3RWcWUva21XUDdQTGRmdVRiY1ByM21uQkdpZStUSTVSejdmcDdkMlR0Y3V4NzcyYy9aVXM4Y2ZMRm56MS8vc3lubnByYlJ2MzlRT25lZmZ2dWZlL1B2ZmV6NzMzMzM1NXN5OTE4VjdKbGVNdldqWk96MlJqaGFxU2xUY1djY0tHWWpBWWV6YW1GbVoxcG95RkdnTkR1VnNLd0c3S0dlVFdUUnBlaUJYNzZqNzQ0K2IxUGZDcnhyK2V5ejdzbngwNmN6M1ZUMFlZak5JNmZPcDN0MnE2bUlqenpFQ3pSSkRBZndWd05YY09XY1VUd1dLMWhKMkFKRG96QlliYkZqZEZXaDcxNW1uNnFoUWtEYjhTSkJuNGxCd2JSdEdsdEJENGgxTXc2Z00zOWFlWlVWcHAxYStpZEo2YXF5Y1ppUHZKZzJONkg1ZzcvRWhBYk43cWl5UTBoUzROK3RveGZ5aGJxYytkaXRybDBjdUJpQjUrbkQyU0tWRTQyQlplVzdPRmFpS0VVL01aaFNDWFBScmcvODVOOE5lTFFnWFFIVVowSjNKbGFqQ2hDb2lFa1RSYVdLdzNVN3hMYXJaRytWRENQK3BubVhiUW9uS1RwYjhJWC9UbngwWm9HajZicWdQRHJ1S01kVFlYc2FBT0pvNHpWRGdhSThZY2ZCNVpIM0g3RUZkNHdoYmZqMzJuN0RiK0czMzYrd2ZPTjN1SjB2SnZoSzJ1aFV3S2FvcEtTeG84L09EWGh1UkFObXZZTXJ4YjRUSCtkTjMrL1ovVmJXSzhKNTY2OTEvazl0T1h0T3grS1lQNUlUN3k4K09LTHNUTmYrdG1MRjg5OTl2c3RtQlgzWFEvKzVHZC8vdWQvZm5MZ3dJSEp5aVdhVERTY3JKWVlqWEUwckdJb2NWc1lhbWpDTmVDTEVYU09sZFFvRjNPRkZCdXpuWDlmKythM0pvODk5dGpra2E4K0ZlMTNWK3pFcTVOekY3S2NMcXN0bm4zKzJPVGMrZWZHelAyWjJLRWpaekpVejBXdWRzckZMdWY4RExaWERaWkExSmh0eXg2YVVlSVNPQVFYZTNRTDE3SS94enNySmNTalNST29mbU5Rd25IQWlVQWlHTUFsbkRkbXk3Tjhtc2xISHNCTW1aeXR0eGtJc3lvM09ON1MySUVuM09QYjAwdyt2c05kaEJFYnVnUG5DU1JDK05qeFkyTjBjUEhTdVZuWnBzTFl5RVg1T0xEQWhuUEQ3WGZsT3k5SVM5TkRIemcyUG16eERRZE01WTF1VzB2Zll2ZnViM0hRa3l2WVZxek1EZ0ZTVWVoRHFEZk40TnEvbVQwS041MVdDY0txcTJtZThlTzBHMHBKMjV4OXp6dDU5S01PQzYrQ09YQ2R3bTcvbTlQNkx2eG41cVhDcTJMS3IvTlVqMXpqV3pIcTIyOXdoSW5YTUJ1Vzc0N1R2MzBMYjVxSVlsa2t4K1NuTFlUOHcvYU1CcGN1bmhueDFWVzd6dFAzbW5CdXFyd083M2UrODEzdjM3Wmwrd01iRmhkMlhUeC9NYWZHblQ5eTd0bUxQM050ZWZWMExsWEtMcit0QjlldHUvajA5OXVVb2Fqdi9tdC83U1B2ZnM5L3RmTnRQLzVBTkxrSW1UVGF6VEZGbkQ5ek9ocHpidG5Jc0pyZzFOZzBHRnBBQ2FXeXlXcmdRMU1PUTY4d0t5VHlwaXlYV3M1S2kyOCs4ZlRranovL2xUVENER0V6ckYvS3lvM1ZhTThuSSt4b3hZVHZ5ZE1uSml0WjJjR3RId2NSWlZJb2RtdWRRTExFMGRtZVhVSzZCS3E0TlhFa3pXcFVicDBjQWVDRXU5R29SekxhQ1lFMGlRQzBoWmFHWFFLT1pvb3B4SlVPOHpmRDg2dTRKVXphSCtPME1QYTc2U0YrTXhVL2Nmb2hIRDNwaTRiOStOaXhGOGFsQUdmUDFrWVIrUnJ1T3Z1M1hMVGtNTzBvZHpvTlAyekpqdkkxY0pKWC9rK0Zmd2s0ZnV1enk1S0RxN3hiTURmdU5PYitIWmszY0NlWTRVc0FEck5Oc2xPWHZtbDdGYjg2T1RDcnZPTEVKSlE2OU8xUkZ6bzR2NXRHRlhlbTdhSUJlUENTQi9ycW9KUy96UnY4UGNyVHNBdCt6U2ZBQWZ6dWNKUzNoZmVnUWVCM1BmQnZlTjVzdlBKdkdINXowbkU2YVk1L1A4S2t2VGtQTVBoeDRqU01tNy9oRHBadzc4WW5KdzhFeitwQXQrWkkzQjA3WnNKWlBLN2grdzNPbW5CR2llK2hPNVNsY1R1MzdYMW9jV25oNE1MQzVudE9uejEvNU9MRlM0OTgvZXUzUERudWRkdUcvWEpGZXZBdGIzbmZ6LzJ0di8zaFgveTVuNTBzWHp5YmN5bWlCVVpyUFh2eVhPN2tjNmxvVG52TE9tQU55NFlGRGVWcUdpY2h5UHh3TWNLY09XYnoxdjFoOVd6Tnpwcmo5Vm1lZGZ6a3l1UWJUend6K2VhM3oweU9uYllqMEVhR3JkR1VhMTJ1b2JONzhVNGNQejYwaU5YckY2b1JyNUpNSmZTeFBjVXhMQjdoRkdITnJweUd2cENWRDROcGsvLzREc051bU9TUUdUdXRJbUFJOWF0WGJSY09jNHloZWhnaHRtZUNnT1orOVVxdEFGaEgyd3RzK3FQZjE4eWVPK0Fuak1lc0k0OTFLZXRxVml4WXozbzFkbU0zRFd5S3VXZGp5amcyaUV3MXlwQW1lZlNaRkRWeGFldGpiU0s1R0R2eWhiSFNJbXZWUTYvWTBTT2NyTkN3azdFWXNaaTltZk42aUp2c3c5VDVrOTlNT1NqUnJnNGFJbGhLMDBxTUlRQUljcXRaQ0Z0Q2pFTWpJeEt3Q1dTMlpQWFphNHRIcFBqVDZsdG9KdFBFbjltazBRN01FaktaTU0yU1J1ZVQxSGRvRmJxdFJqTTBEN0V4OUNzaFdjSVFIdEo3ZDZkSGN5U28yVnlQSFRzMjhwYUdIM3c3Zmd0ejhkVUhXdWxVeFNVa3dSTjM4OUxXRVM2dDQxQkwySmJwWUZQdXAxeS9NRDBGVU4xR0tWaWZDZUdtalRUeTRRWmRRNXZGMEhGakpySFhaNGtqV0VrMTBseEpYcGFKd21QUVUvVUVoOUdaNFl2Z0NCLzBCVmV0ZXE1Z0ZwT3cyWlRpUHM3cm9hMjlBT3V5NFdySDdqdGkxbHBKWjVXVEFyTU9YSldQMFVkU2FzdnlXaFBPYXVkNzZIYnRPdkR3dHExYmZqVWM4U3ZQUFBQVXYzanErMnhIL3M4VjVmNjc3MzdnNTMvdTcvN3EzODltRTR5cE1WMmYzcW9ocldWWXpBaUU2Rkp1UjdiTVRhT0xHVzBzb0Y5TjJFb0UxL3FzQkRpVmlidHRXM2RNRGh5OGM3SnQ3eDJUSTQ4OW5qT1l2elQ1K2hOUFpiMzB2c21aczdWTldzTXRZVlRhQ25oY3Z6WDQwYWpUSUwweFpQc04vS1orUTNBbXJPTU9NMGdhUHNXRGdJQTMrelltSnFBSkJ2a1NscTBsZ1NGOHhKbm1PeGh4bXJkOE8rOTZ3N1UyUDJDYWtYY0VyUHgwVENVd0NuL0hjZExXYXBQSWNwWUtucmp4UFd6bXhHUk1SN055RERJTW1QWHJwZDlsODUwSkZLRWpyYTRsNVNDb1BJU01oK21rVGo4ckdzRk52Tmd3cGtLRmY0VjFmc3JUWlc2aGh4Nzh0MjByNFllR3Z0V1h1cFFYMmhwZE5TMEpVbjV0YXZJYi9vMkRiM0drUng5NTlhUWdISVVwaTNnZWViWHdyRG9zMnZPSGl6UU9qYkxoU0x4Tm0wcHdWenNyemI5d3FIbUdybVBwNEtUTTNmN1F3bmM3Y1pvbVRSOStmb1BmdjluM082NjB5dFM0ZXB2UUhlK2s0MGJjb1RpVXdyTi8vLzdSU2EybTQzRXQzT2g0TExrTHozRnJ3bm1RNFh2emgxMlpUblBtNUptZk9iOTgrc2dQbW1CV3luZi96Wi81azMvNGovN0I1SjVEZDA5T0gzdG1OQ2p0VXNOZ0wwN1RTeXRLUThtWS9ISjZma3hqcDkzRnpDNmZ6VmtiTkFEbWhPMjdsaWFicjBUYlRib1hqNStaZk9tcjM1Zzg5clhISjgrem8wY2pPSDgrVzVNM2Jyc3hqTzBHclFFM2MzWER4Z2pkOERWbXVBanpHd041aTlQKzR2SmZqZFp4NVVvSkFEWUFRbGhjMnJPNG1JZVRKK1lFczFjNCtBWnpIZ2UvSzEzWjFNc0dXN2pWT3RVUy9PRFd4RnV0U0JnQ09ZTFpLaE8yY0VOM2VOQVFIUzRVNlRqd29GWFAzNmRZeTlLbVlZa2gvM1pkWnQvS3k0d3c4TS9vbzRWTEMwVENpUjhuWFpmSmIybXRVeFplNllxMjR0QTJoY01YUFRqZkk1OHB2TllJRzZZMzUwMzR5ZHN4bVc1QkgyMWxPc2txcjdHRFVPT0s2L3pCazFZNmViWkE2L29RcjRVcXVvcm40Y2RKMjdTUlg5ZnRLR2Q2WkhYS1ZibG1OdXZDcDJndHJPTjBlZm9iN0hiZExxVVZUN3JLWjFvWDhSZkdpZXQzdDIvdFU1cE9CKzdvREtaK3lwUFZXcU9Obk05cW5ZNnJuam5mYThKNWtPSzEvM0dLWEJoMjZkVFo0eC85ODdBaHY1SVMvTkovL1o2ai8rZ2Yvb1BKRDczNW5zbWxjeWN6NUs3YlR6UnlETENRWVh6WU9RMGpERUs0WldpSWNkZG42TDVyMi9ab1BUazhQNzM4WUlBTW1YY2ZPRGo1MHo5OWJQSnYvdTJ2VDM3N2R6NFd6WHJqNU1mdWYxdHVOTW45Znk4ZW95WVBUUWxEY2kwc21sRUlRcTRic01iYmpDT09iNDNkdXhuRjIzYzlFUURCbUdBdUdMVmt5N1ZIQk1PNlhBL0VnZGt3T2s5d2FiR09MM1VXOG5CTUdkTmpPOGNHa1F6Yk1aRTh4L0dQUTNCaFVOcDROTDljcGt1b0VNSk9ndk1laCtRSEdIeVVvYlJmSHNYMDdMUmR4aTYzYjcvYitmYk1CTVZNTU1PbkQ4Tm5ZdWpPUkZvNFNTTmZPSHNQR0pGRi9jMXN3VldaeWk0NzZqanhSeHNJUFlTQmUvNjhDY3ZDVjc1dE5vRWJmOHZEK0V2WFpRRzdjZGVKZ3lVdTNPUkQ0SXBMb0tQWlNrWm81ODQ1VFcvV01ZQ25UUnJaV1VMWk1NSGl4MTY5T2FNNmNoVDk3Ynd6VVFrWEU2RHk0cDl1ZmVBTUZsbzBQWnErNEhGTmU3U1NqaE5IdUREdi9pMnMvYno3bVkvRGo1T2YzOHJ2MkZmdmVOend0NlJTV1M1ZTNKazlBOWEwRjYwN3J6WGhQTWo0MnY2NGFEVU1jOCtGQzVlUFBQbmtmLzYyNjllVzIzZVgrdUdmZnZBMy91Zi82WDg4K0dOdnZYZnl3dk5QNXlxanJHUE5LZ2JIZUk2NzZHSjNYb3kyYkkxem1UYXU1c2pPczZOeGExQ25Zby9lbUl0WDczclRteWRuVHArYmZQNUxYNXo4K3EvLzc1TW5uMzRxbDZ5K09NbjVScE0zLzlEaHllNmN6WHp5TkVHVlN6MFhTb2dSemhxOXhxL1JZL3p4SFNISERRRXlmWGNqMTdERjdjYmZERlVOdlpnOXJKRndESVNSU3VpNG9rcGNkc1JtdEJiSTNwdHlkUmFZZzRGenpvYTRqVU5yZGVKVjNrWVVORG1hY29iSGlYL0o3ZWJUdyt0UG56NDlaVHphZlRFV2dhODg0emhNYTF6OVkrdjBQNEtacXpMSmR5YVFSOEJOZjNvNUhwcXcxNWNnZk9teG5zbzkwOEF4ZnBrR0NEaDMvZzJCbld6QmdCZGgxL1J1bW9rclhKblpkam4wSndpYmRzTDhGbGQ2Z2xZNS9DWndMMTJzZEVZYllBbmJ1WFAzUzlMejR6cGNIZ1FudU9wVmZYbmc3QnN1NFBlMzlEb0lKNzRSN2c2RUVnNVBzTkFJbnBjdlQvT0pjQzZCUGRObzVkOTRpTnVPSDFqeTlidnAxYmg2eTRQcnQ5OWdlS1QxTkV3d0VpTEtnRGUrcDNFN2p2THQyTEZyeERuMnd2T1RjMmZQSkYvMHFUWFVhOEo1a09hMS9WbTR2clN6QlBQcmUwRFJkNHZsenozNDRMLytYLzdKUDNuNEhlLzRpWnlaY1dvY0JicVNSckEzZC9oWktYRXhab2pWQ0pkckVhSW1UdFpaRmhVbTM3SmpLWGJGMVdqTnV5Y0g3am84ZWVhWlp5ZS85bTkvSyt1WC8xT3VrZnF6eWJNdm5NaWtsOVVkVzBxVGlSVjJYWGIzWlFBeGJOR0crWml0aGJPR3oybmMvTHRSZXpkRERDWkx1TzltQXI4NURNS0pMOHdoUDMyYmQ2MGNpUFlYZ1NRZkRFMW9pRWQ0ZTJOVVQrZmxNZ0Jhc0lmMHRIbERPSTFRSEdkUFg3bWFXZldjTTJIaUJqeDJVaHBsMlpYcldFNDRRWTJRS1UyNW1IVEFCbm4wUWRVUmlTc3Y4SnRKdTN3Vk5oTWVoSzR5dXhRWFhpYXJ2T1hURE54cHhTTTRXNENLMTdaTGNNVkRseForbGE1d0tMeG5wN0VSbUI1TExGc1kyN1dvSHJ1dXBGa05qVGxDeWVvWjhPZUZzdzZ5Y1NKVWFZbmdXcUlJM3BZdGRZNDBXT3JMeUVNWU9wcy9zTVhkNk1CVlpOTER1Y0tML2h3QUFFQUFTVVJCVklXZzNhTW1wWlhUa3hvWSthZlZqRHpsTTY0NEMxM2czZlhWOGNGQ0MyKzBtMjliZmhkOXFxMHBvL2JUZFBMTmRYdjJ1d1d6ZEI3eGJkVkdyL2w2VHRDTi9DNHZYNXRzM2JZNWNmZG1sVk9PNkZYdTRCUXhIM2hyTm1kMGZVM3U4T0hEQnkrdW5uMzY5VDZnNkx0Rjh0MS81ZTBmK2U5KzZSKzkvNmYvK2s5bDZCUUd5eEJ3LzU3ZE9ldkNaTldGeWRZZDI4Y1ZVc3Rocm1zYWFvWmFtN0loUldQYnNXZi81R3AyTDM3amlTZkhiZGhmeUtGRm4vLzhGeWRQNTd6bGxUU2liVHYzNXRrL05KY3p1UWZ3ZEs2VFdoL0J2cFRUMU5ibFd5UEZBQnB4TjNadmpSd0RMRWI0Q0pkWE4vNW1sRzdzeXQyTUk2MkczdC9EOXB2OHhHVS9UZkM0Mm9tQUlCakVMWUZSek9XYkVKQVhXQmdZck1hSElHbGhJcDBKSngyTUR1aml4ZHpxbmJSMjhIa0xwNWtPUERPQUx0aXpVK2gwQ0FSMWx6dFpqN2pLVTc5ZnlyVGxQOU8wNEdVSEpWd0xyNWNLNW9wZm1wdzh4QmZYUXlPbWRSTktnL1lSV01MaDJIVDFmZTdjK1lFZnpkTkRHL1hzMnJWcjBNWXVSZkc3RHYwRzB4c05uSC9TY05HZlB5SFo5U1FPWWRqNXp1TW96RW9ldStiRWFlSFphY0VTSC83eVZFZGRQMTFlWVV3bnlnemU4ckw2WnRxcFpXL1NjZDYwVkhpQUlUM24yOU41K2cxbTBiRG8yWG5CQlE2ZFRqdzRDdTlISEU1NnNEYk1qUXg5bDV2bExaMXpUS1JEYzBzOXo0VGYzSXJEclduT1JiSHY2cStEaXhEOUIxVXd2K3N0UC9MK0QzN3dBeDkrNzN2K1Zzd1ZXVm1kNFhnRysyTUZobmFrUVhkRDFOZ0lxNjIyMTRhNXo2YVJmTzJibjVzY1AzWnk4ckZQZkdMeThZOTlJbGRrblF2ejdoaGE4WjREMjZKbDI0aXhITTB1UzU0aUFFd0VuanAxWmpSd0o2Q1ZSbE5hbTk4YUlYbzFvNjNQRGtQRFkza0xnd3ZuRzI3Y3JGRy85TGVHUFhCUGtqWmhNRDJVUHlheE02L09JeTVCV1dIZ2VhUWxpQm9mMzUwWERXYWNBbmZwOUJETXAwK2ZLaHlUbHpnbGhDSzBZdWFBdDZlVzhzMjBZeE9QaVRyaXk1OGpFL2h4emFwK3c1bnIvSDE3MEt4cHBXNzgxdkhjN0tSclBJU2hIUnh2aGljTWJUMWNsOTg3MTZBTlFVbEkwRklKWkNNRWRQQ0FCUjl2ZGE3ZWtzTVVKL1ZhbmVpb2s5Q0RnL084eGt0SUVvNXdWUlo0d0JPK2hMTjhXb2lDSTc2NmdJdThkU0MwYitZTWRidDc5Kzd4ZG00RmVsMk1hV1VjaFpDMmUvYlkyWEdVZ0h6YXRYQ1hQNWplWE5NZkxuQnFla3JiWVIxWFdNZnh1OU1MRjlmREh5ejVLVVBIRjljMmUyR2NOTXJMRktac2FIOHhJd3JDV2Zsbm1JL29hMzllRFFXZXlEa1lodzRkNnAwRXJ5YnA2eDczSjM3NGh4LzYwQWYvaDMvOTRFL2NsL09VWTRmTFJoRU1nT0VPM3JGL3NtZmZYWlBWOWRtNWwrRTZqWGxyanZiY2tBbTljeGxlZlR2bkxYL3JXOStlL09aSFB6SDV3cGUrUEd6S2UzWWZtTng5NkMxakkwS1VwTW41aXd5WnVka2pWMUZkdWJZODJiWHZZQnJiaHNsajMvakc1RWZ2L2JGMCsyRzhhSTVidHVmSTBHaWQzSUtycGFZclFEUkl3K0xOdVUyakc2czRmcHZjd2JBQk54dy9qVjVqYmliaFoxMnFDYVhsQ0lyU25JT1BDYVJvalJGUlNWTm5GMk5zd2hPak1IOWdPc3lRZ3k4R1hNekRiQ0hjaVhZdGtNNmVPellZTGV5VXVCaDNYcVJpYW94R2k1NzVONE1tZE9UVkRGd2xxYi9pY09rbXhudSsvTmE2d204d1o1YUpFVUllMy9BY2RBa2RodUJJaHdpK2Y2SE82Q0FIU0g2aDgrcGwrQkdxc2lGQUsxLzVvd25odVhmdjNvbmIxZ2s5c0FpTG8wZGorb3BRSEFKNFNudjA4Y2czTlo3aVpkVk55TUowQWpjUGQrMjZTd0pxUW0vclZ1YVJxdDhTOXFkSC9TckhVdXI5ZXRhb20yUmVXVEdSV3JzZ1I4ZVNPcnFjSldYY3hzd1JiSTc1bzJuQy85anhPb2JVYWdmTDBiWmtiZjZXZERBYnM1eE8vdWN2bkpwY3ppanU5UEdUSTUzT3g3VlJ6Q2phQkhxM01KVUhlZ3c2b2x1ZXJrTzR0QkJYUG1GZEIrampLSUZ1bTExKzRRM0Q1aXlkNmJwMU5PSEtWeGpDNmJ3MzVYaUVTemt2eHJFQ1czZnVtT3pOU0hVbGN4cFhjdWExdk5lRXM5cDVEZTZwSDdCMXpJcnk5aDk5NjhNLzh6Y2UrbzM3ZnV5dDJTaXlMWUswYkhqTURYYnJMY1ZzY1Q0VGR1ZGk1c0NjaXhrYXJxUXh2SGo4eE9SVG4vNU1WbDc4N3VRYjMvam01SHJPd0ZoWnZqclp2V3QvMXRKbmFWMW0vYUp6cHJGcHFOV2c1YWZCRVd3T0ppSklPTXhFc3htYVFXeTUxOUpvQ1RMQ0dXT3dLVXFuY1h1NlFRdHJqWXR3MXRneFNETkJDMmZ2dHFuS2kwQXd4UFdidjgwUlpyOHh3ZXgwc0ZweXRyUzV6QmRrSkR1bmc5Q1pMOHo2SzRkT2pNbG5Rellqd010eks5ZitMV3puNDNUWXZOK3Q0blc0TUlLWjBCelhlcVVjYk16S0kwejUwY0tiRzkvcEpkR0JZUENXSjMvMHd0emd0VDgvNmNGWFI0UXhiYm1IK1Rva2NRaGtna2U5eWJkaGRYbkF2ellkcnNOdDRCRzRMWlRreHg5T1lQanRrYjd4OXhadjgrYWF2SlNIcFlyZTZ5MkRqSklnNzV2TEl3MjR3anpNVGVvTDdzcERDR3M3UC9SRFB6UjV5MXZlTW5udTZMR2hTWTlUL3FLUm9nbFRGSHpRb1dtRG51QzFnRzJjNGNuUGQrY3RManlGRWM3OGI4WVZUc0pYczBKREdjQ0FWOUd3Nmc4YzhYcGswV21zUWxFV0k0QTE0WXhLMzRVN0hGdnpENkk1NDFCMktQNk5uM3JvTi83YmYveExrME4zWm9uT1ZOalFGQzNuT1g4K3UvSWlYREhsRzk5MGVLeGJaa1ArOUI5OWR2S0huL25NNU5Fc2pUdWRiYytPbWJ5YU5jUTdkK3hMcDc5aENPazA0VFMwMkZtak5GOGxHS0tSYWVTV0JHbWc4dEpZTlY3NVhibGNWOFFQUmtoK1Eyc05MSTEwckh3STgySnU2VHljUmt4NGFMU1dzNGtMSnVmZHZ5dS91b091ejQrWTNRSml1RjBUWkhiT0tTczQxbkZMYjFtY1EzOW9nbmJ2SGMrT1JVZDBZcWloQ1NzZ2wyOU9Xcy9OcnYzZ011L2F2OTgzaDgvSDlWdG5oMGJ3UkhlL2h4Q2FSSUE0L3lMUGdKRk9MbUp3bElHbWJPTkYwMFJlYU9rdGJnc2F2ejNpRFEweUt4MElaYVlCZnVxcU9xTzZuVnQ2L2dRU2Y4SmFITERCSWVDNlhwUWF6VHBQdjhYcHQ3VHFFUzc4Q0d1d09QVXNyclE2YW5FOXZqbngreTNQemdOZWd6YlR0S05URFZ3Q21GQlRMblpzN1cvbnp1MGpQK2s3TCtlaDBHYlJ1bW5VTUJ1dThzdFBuRkhlbEIwKy9FZGJub1pidFFOdXcrNk9xdFBnRjJIU2VRdnZPZ0wvV2hva1BDa2hsNk14VytHajdXOGZvODJjZFRNb3NQYm5Md1VGZnZ5K0gzL29uVC8rRTUvOE8zL241eWJ2L09zL3BjWW5aMTQ4T3RtWVE0bjI3SWs5NjJJT0dncWpiTjIrYlRTS0k5ODRNdm5qeitZQS9DOTlhZksxeDc0K2VlTEpiNDlOSmJ1eXU0OW1mUFZxRGlTS3pLVFZPRmVCRms1RFhiR2xPU2FOeTRIZmpWemoxY2cxek9lZWUyNW9McjR4bzdERk1DTWh1bUU2ckxUbDJPMG5CRlBhN01oUDJySWZZM0xhWDAyK2FkQ0RjYUsxbDhsQ2RXbjROS25TWHVUaENNNzFNVFVRekF1WlRETVREZ2ZwQ1FZZFFHMnRMa0Z3NHVTeHdkVEx6aEdKNlNJUTh5WWNtQW1LbWZMeGloem00MXE0MVB1bGRzZ09td0dzTk1vMnpsd2VtdkxzMEtLNk5hVW1tQWdGNlpYVDI5T2FzYno1Ri9QUGhEM2hLcDBIMDdOcEVzeUV0RHlOR3RDRllDTVlDUkgrSEZqcURzMjgyMjQvQkUvcVg1N3FUN3hPQnlmZjRuaXNsZWNudmJ6Z0EwOENlOVkyVm0rWVVKaWtxcE11SVNhUExpdWM1R05VRk5BM25EaktSOEJycHpZQldiK3Z2SGF4R2pudDNldEdIK2VEWDhxOEN4T1lrWUdPclFROWZNU0hFM2p0bWdiS0ltLzU4Qk5INTNMdTNHeGtOWThuT0p3VlQ4b0xyMnA3MnZkc0hYWDYyaEdlR2g3d0hSZVE3Ym9EZGs2dlhCUE9YUkd2NW0waU1KVjA1dFdrZWIzaTNoZUJ2SDNMMWgvSkJOeXVBM3YyUG56bkhYZU5BMzgrKzhuUFpHOUdEZmxvckR0MmJvc2dwZVd1ejNHZDUzS1AzN2Ntbi9pRFA1aDg3bk5mbUR6N1hBUjRHdWlPUFFmR2xtMUR2ek94VFYvTXJTT0xFY3BoaTlpTExaR0xKaEZtMCtEY0c3YytwOEJoWmcwWEEySjZ6UDdNTTg5TURoOCtuSW5EcmFNVFlIUFdzREY0SDlCUFc5Q0lwZmZHSUppZ2hVeHBVVFZjQnQvRHlhY1poTjBhVTBqRERjMHpaY1E4NG93RG5SSnViZSt3b2FZendTUzBKL0JQNTVDbmRtNXg0Y1pGcUVtekx2bE5SKzhkNWJadk9IRHpqSDNieUhNQjBXOUhHbVlNOXlQQ0g2MERhYndWR2N4K21nYks1bW1CS2h3TlBIQnBJY09XVEloNDBMbUZDMkdNMXVLQ2dTWk5RN0RRdVAza1UrVXJ3U3VlcmV2aVJUVGR3SzF4VkR6eHhYTndsZDhORDh4MnltS1Vjajducm1nekJETmNqR2JrcVF6ZTdjUUhhLzVwM01DWG56cFdUdVVkQWplN0ZyZGw4NVJ2c0pYWm12UEtHdzFyNGxRYXRKZG5QMmlGVGswWE1QaDFHNVdHaGk1Yy91MFAzNmFGVythTHpyTUpidUd6Y2htSlZOdXRiZmZCS2Z3R0Y3RFhOR2ZVZW9YdWNFd1p1ZTM1NE9YTEYxNTQ2cW1uWG5maGZDZ21palNrVGRldmI3a25kL0xka3lINndienZUVU81SjVWNkpqYldOK1VTMExkRnNCeThtR1ZSZGxwOTVTdVBUdjdreTQrT0JyKzB0YTZiY3BucG1JQllXaHgyWU5xRkl6MmZmZmJaeVphY24zRDNHdzlsYjM4YVgyeTJsOU00ckh2ZXNtVlh0TkRZM05MQXVyRTVQTWNad3ZrN2htUkxhVVNZUmNQWFFPMWNFemQzSUE1VHdiWTMzVDJHbVgyaUhlMVV3eXhHS3diRXNOMjRwY1VjWEROaHg4Y01HanJORjBPQW9STVpod1dGNFRSb1owR3dMNWMyZURFVFJ5OE0yTDdicGlrdkpnMndra3ZLT0xWakJrWXpPenh2NWVBSHIxdTVXL3RIdW81SnVBamJrVzRxeENOOEMvK2lGOGJ2SldFc0tyUjJHeW8ycFV6S1RXQzNmVjArSnZtQVEyODRLNHR5Y1dBWjN0TUU3N3p6anBFUGV0RmEwVnBjTks0NktHR25YSng0RGM5dlQ3c1piVXI0OEllYnRCNXc1K1A3YnJ5NkxnazNUbno0OGorZnRqaUU4MVF3UzRQK3RGcXl1ZlAxaHJPbjhWV09wbnNKOXBwRWhKZXc3VHZWOVdwb2tuYWRzb1BCanI5dVUrWHZRS0oyOHUxMHJVbWpKYmpTZHA3aStWYVczdEFFcnJLTDAvaUF5NThmWE1BRWZ6V0hmSUVoak5MRXFVdDIvQkUvSCtwK3ZYUExSK2phbjFkRWdRaUFzWjNuOWJRMUg0cEEzcDdEazNidDJ2M2U3VnQyUExpOGZPa0JEVXpsYXhUTDJSQmhlekozTVNmS25UK2J0Y3FaNENNbzNWZVdZekFpY0VyenVwQ3pNRGJsNUs3MTBYaHpidlN3SlYvSWNpTU4zS0ZHYjh4dXYvMTNXR1dSSzRsYzZCbmhiT2I0ZE5Zb3k4dlNKSTFOQTR0T1ZnSWdRbXhiR2hxbmJXRjZncU8xaXVHZk5LSFJaSHRtMFFtS1ppTHJrZ2xSai9YQ2w1Yk4xR2ZGeUxtY1FaSHlZWVllWG9MVFoyWEkzOE4xWXhlM21ZTVdYc2VFMW1vRGE3aE5GcDA4ZWZ3RzR3ZmJVUmI1dG12Tk5YcGV6RGFZbzRicnpDVzFNYVZpZHQ2ZDduYnZac3pHRjlQZDdIUUdhSVVtaEFiQjJ6VEpCRUE2RzhKVFhiWW1YUkRBQkI4RGMzNkQ0eHZUZ3dFbUc2WWRkTjdkYnZvTmhycm4wSnRRQk1kdkFzTWJQUEhWdjI5T092TVYzQkNPR1RXSjU3ZTh3UkMvQlp3M0xkWk4zWTB2V09KSzQvZG9OeG5pbTh6elRXT1dMeVdDU2EzU3lkTlRuVkg1ellTejl0RXdoY0dqY0dYRHRvcW8yaWM2cFJTRFhsdTNsajFlbnJSVnptLzRTKzlCUjJuUUVWd2FOTE9NZUUxcjVVQS80Y3JiYWZzOUFNL1ZmOU5KZWVBb0hWTWhKNDFpZ2g4cEhScFZ4N2NtbkFkNVh0bWZ5NWZYeHpoNVlUWVdmbVhKWGxHcysrNzdpWWR5Zjk0RHFjU2xYQTc2RVEzMDVNa1Qwd1k3VzZxa0lYQXEyM01wS3pFc285MGNZZVhic1plRzZFTjRiYzhTb3pDcFJub3VRalNDUGdsck5ZU0RqVFp2eTYwbFdXNjFLYlBtMjNac3pkQXlXa0ZXWExCbHJzdEtoWDM3Nm1wN3ZmNzFDT1d4R1NNd1dyTll2bEE3ck5pSkRjTWNjajl3UzgrUDZVeTJhZUFhOHBVcDQybjQwbCs0V0ZwTk4yeTRsOEN0RzY4MVZHRWFzZlFlamRpYklDTDBwUmxicTJPL3BnMnpxWjg1ZXlxbndkVmg5Z1NFVGdsekU0cUVlRHZwZENwaHh5R1lTd2lVSUJvNys2YU1oWkU0Yi9uM3UrSGM3bDN4aGxnWm1yRHZvUkVQbk1zT3JEUGwwS1MzSHVzb2ZhT0Zza3JYYjNHNy91RkNPQkFpT2pRMGxRWnQrRWx6OU9nTEEyZCtWczZ3T1hQcTBZTis0bmx6NERYZG0vYnk1NFlBeVJ0dVl6djYxRytVUzlubTRrbnJpYzVZQWdlQU9EaUtOd1JUNnRmMVhJUTBIRG8vdU1PQnhqcnltb1BkZVVqZnp6dzhPQ3BMKzVtNHRERkZPeERmVlYxKzl5aGxNVzFjWFBsd2pWZi9GdGJLQWh3OXlnQy9lcXI5Ti8yazR3OU90WlUyeGN6d0ZRZmNBUzhqdjFaQUZ0SStPWjFFclRBS0R3NmZ0VDkvTGhRNG5ETTV0bTNiK2NEV1RWdnVqVTZ5YWNQQzRpOWpVZzNWR1E3T0FNWllIbXVJUzV1cGsrTFlkdzJMRnVOdjRzVlpHVXNScWh0UzhRNngxOVB2dWVldXNWVE9sbGgyWUEzcmpqdHFxSXNwYUdyZ1lJZ2V2bWxvM1ZpeFZ3OFhOVGl1dzcydmpvbTBXcjhwVFIvY2NpVkwyT1JubWQ2YjN2U20wY0VRMXRWZ1M0TnB1TFFTRG03ZHlNV2pSVjI3VmxvV0RkbXFpNzZxU2x5MmN6aGh0dFVyTkpnckVjd25NaG41YkRUL2srTzdjUjRaM09KUDRZTlppbUV3RGI5NkNLUmJKTHFGbDNRMFlFNm5PdjZCbFEwL3hZaTE0b0p3WUlwQmIvWjdHakltclh5THRzNGhWdC84Mk5UUlZYd09UZENOQUJpNFp6V0g1VndFaUhyY0ZMTVY1NndVY2RXeDlPZ2xIODV2c05FZERPR0VjbitqbWJhRHJzd200S1JVSTY3SnJNYlhDSVFaREN4cHFyNUtLd1FYanNyYStYcFRGT1N2ZmN1RGVVMWFqelNjTnVBUjMybUk0bnA4dzFWK1lIZCthTk4rNEhSNmZwTU5td2RzNllFSFEveGVFWk51ZnVBemFCTDdQeHdvSnVqcDJiaFVxeWVFbXhjQVd4NUdlK2dERDA0NitPQlA3eTVMZE9PQm0yODRTRHZ3U3BwUmhzeTJkMW5OZFVoYnVGYTZOYzE1a1BmbC81Z0F0T0hrNVdPOXN0RER3MjY5Y1ZlMnJ2N0lybjE3MzVzRzh5RkRhcnZybkhJMmhyYXBUTU5JalZrbFZtOWFrMmZPZjFEWkdHL0hqa3p5UlNnVHptSHg0YStKNSthVjBiZzBJRUpScFRkamRDUEM1SHQyVzVWUkdwaEdvZUdLaHdua2V5cDJiT0g5ME13MFdnNU92akdnQnNhNTZRTjhqZG01REJvanVEMDhoQTlZbUtRYkpSaUVneVZSZm9zcmpRN0Y5bDZDbVpZN21Jb3RMakxHWmdMcFQ1NDZYazlHR0NiOVZqTUxqK21sYjAxNElQWXlmNEpPR0tZaWREbjVlVjZKYTJhVHRsd0I0ODgyektFbmdVQTQwNHd0alJNZmZUajBZRW9aOGFhZHNmUjlXcDY2R013YzJ2WnY2Ylpsa3dlaGJQbVl1R2h2ZE9RTk5ucWlCUzFaZmN2SGlJTy9PTUxrNlhmWHk4ZzM3Y0MzRFQ2V0hmTHo4UFBVMGFlRlAzOTUzUWdMWHYyYk1POGpVc214VkhPK2EwVFVFMy9pTm54bDR2Z3A1NVdrQjl0dmZwd3l6Tk90YUZjNGdNTjEzR3ZUOUVFNGVham5LZ09OT2tXT0lxT01jQzlUa2paRnVYRkR6WEt1K2NtQWNLUVpiWFc2bkxIeFJiZk9Dejd3bVBjVEw2SjRwQmZ1dVlIWDlMdHhCd2R1dnZNL2Nhc2NhOEo1a1BqMmZ3am0yNGUrdWhDd1ZGQ1k0ZWpLeXNtbmw2OWVmU0dLejIrdVc3Y3AvcE5mSFR2Tm9zMVdSWlVHMjh6WXpGc2JRS3FoYmdxemF4RE1HTmNqeksrT0JrRGppb2xnWWZQa1VtYVhob1ljTkh1U0NEd05SYnJXWWdoYVQ0Y3BsVy9idURVWWdsR1lOUDBiak1zNXh3QSs0bUJ3SFFHRzM1TWpRKzNjT3BVYnBTOW1NOGVCZy90anhuQlF6Z3dlVzR3d083NW94TzRtMUp3dnhEUWhqMzM3OThZVWNuWGdiY1RuSnU3TjR6YnVDSWhvSkVZVnp6Ly8zTVE5aks2QldyMmFVOUpvZUl4MytZc1pYNmtydmkrYXZ0STA4L0ZLS0JUajh4OVloRDRjN1hoMExCRzZsdjJoRjFzM0oxMHpKY0d0UGp6b1hFS2dodHBvcWo2ODBWb0hDcWJyam5TV050VU1ZWkE4MVlPNHZ0V1p0MitPVUpaZUo4bFBQdUo3MUNmWDMzNlBxNmtDUTVyOEg0NWdXeGZoVWZCTGNFdmJwL0tsVkNPZWxUbmllTGpHUlJuRTExbk1iUHhGaDZJam9WL21NYXRDT24zRGFqemhOTythbHZ3NkRmemJvZms2dUNUdnF6Ry9YY3RrOTlWMWR1ZmxZS1RWTWlNeE16bnM2bnBvczVLVHdYWnRMSnN6bkNmWmVkaDBSQ3A0TkMvSUR6NkVPRHlhaitiYllPTTNYNDROWFlaTXRJY0NnOFpnaUlPZWE4SzVhKzgyNzFUQ3lsUGZvMTJBdmQwN2syVVcxbktmODRkNVkrdGlOZ1ZrU0R3YVF2eGNkSnJCMkdoTWk2bXdCWUl5bnliN0ZzUG9HZ1l0Yk4yWVJNSVEwU2k4UnB3U2d1dmpZYTJzeW5hWnFXM1JHaWt0enREWmxsbU55czNBaEVneFpqR0U0Ymw3QllXeloydHduQ3Q3TkV3TlhkZzhzMG5QanhCZzN5Um9DZXhtVE1KQXZocWdkQVFSUWNFSmE2RWtuQUFTWjA4T2FRb1JraWFGQzAzTzVsaEZtMGFlZWVaYnViWDgyTkM2Q1dhT1VCU1hnMGN6OHZCNG1UOHBTbHdKRmIvUTY1VTZjZVZGOE1vUGpjMjh3OFdaRDhwaVNGeVRqTWtqZExVTHp2QloyaEdldWx6S2NheGpkRE8xUXcrQkdkVnRUSTZGOUc3dHBva3ZiVjNLeHFCZG85TWF1S2FqUWtONXo3UmNncGxna3A1L2JRNHlBa0ZINXFlZ1BQQldOK2pzN1NFMDVRMHY1U0pVYWxXQnpqTnRZMHhZRVl6YVZkdFVpMTdpdHBNV1RTdDloWGRiRVVmWm04N3o2ZHF2MzhJYWo0Yk56elBvZlJzNDRyYVFIL0NSUHY5Q3BsbStFY1FwMG1SOUJMUnQzOWV1WjJSeUxhYW1xWmE4ZUtIYUticTBXYU02MnVwQStWYytwUm5Ecy9FZXVCRzZ3YlA5UnVUOGFmelJrN05rVTJlRzVoVmZHNDdKYVlTdS9ia3RCVjZyWUtZdHA2SnVDUGhid2F1YnpHWW9xRXovTkdhVnBkS2FXVFFBRFlUR1JHQ1B1SWxQYUJOdTNLamFOTVoxRVFUak95MFMwNGtyVHNQaTU3c0VmVFdzMWc3RVdabmVsU2VPUjk0YUpEakNGMk5pWVgvRHpOTHhJNWcxek1vUDR4UG1obzJZbGNaSXU2TUpMZzk3cWVNZ2hZdEhNMjRUaUxYUlpXSWhSR0lYemRacUU2UXY1TnhiUytSZWNQN0FWQ2k3NXpDa21BcVlVZVQ4VVo1cS9PM3pjbTlsdXRtaC9jczVhVHFPTW5PK0YwMm81cTJPekNGVUhNS0VRTUt3QkYrbGJab3A2N0FieCthTW5rMW5iYUNGbW5vU0QxeS8yU2t2UjJpalBVMUxQcGk4aFpsdlljeEdYTmMxZUJ5Nk5ueGxrYTdiVjlXanZBbXp3S1VacElob2VvTldFVDUrK3plZHp4cmZoVWMweUt6aGJicEk1emN5RlQya1FmTktIOStrSFdqVkgrMTNLdHpuZkdkNXg3UGdsVW1oWU03SDlMdnFwR0dMano0TjkzcUVzWFRtTnRBUnpTOWZMbjVBcS9QblovY2ZYcy95TzM3Y01FMkZWdjNkN2FETGlxYjhycVNEUk0rbVY5TUZEUFdPUHBWV3dkdXNVZnd1enBwd1JvVmJPRUwxZTJWblRxWHNETHhOVTgxNTZXWUJiUldJbWVNTm1EWW1pWElFUTdYV3RLY1N2cW5RRFd5V3FVaExia3pZaklxM0lTU05nR3VtVnRrYklqdzFJSEdHSmphWUN4TmcyaHBlMHJxWVBzUWhVRnNMQTAvYWxldDFQa0lMaGF3a0dYRTFSSUpHZm1CcmtBU0dOTFJsTm1SRFlOb3g1MDFRbUhpU2o2ZUZCa0VnTGFFalgzSHRaTnUyZlduQU9wMGRYeTltcCtOenp6OHp2cTNLSU5EZGRETEtuVU40ckx3bzVpZzZOS09NekcvN3ArTGVLcmlZdlpuN1ZqRksyS0ZiMGFLRXJZNml5ME13b3dldEdzMk5ZZ2duanFBMm1hZmM0aXU3eDBRaG1KaFh4NmRjekYxR050dTM3OGlxbU4xajlFSDdKWnpWZ1F0aEIveDBjT29EM1kweUxweXZNNmpSM1lnRm5sMVhjTEJxQWYwOHdwVFpiMjk0ZHhnTnIzNlhvSmEyMnlaY1BVV3ZhY2owVzV1UWpodDRkZUh6TGY2OFFHOFlEY2Q3bnE0RHlQU1B1TzNtODVkWGgwbS9FTHB3NVpmeSthZWptZjR6MHF6ODFLR25yaGRyMkpldTFhaE9IZFhvcDB3V2VBZDlqQTVIUHFPT1o4c0c1enU4ZVh6RXJmeXFZMm04NUExM0hTdzNOc3JrdlNhY0J6bSs5MzhPVDgvZUlKRHpleWtWZklkM0t1UVdFNHZMeTlldVplWjdhRlBGS0NyWXVtQVYyQlY2YytYNkxxWkpvMHhEdzNncldWTEdEYUdRMW8vSit3RVR2R2FVRXRKbHBoQ0h0amxzb3FNUmxaWmNqYWJPdnhDSElPRUtMMXBFYWZMODJPd0ltSXRaTFVMNHdzRTNJVHdhZUJwNUN3ZzRFQnJpbU5EUzBNRTNvY2ZQcXBMVkt4Y25qejkrZEFqbW95K3dMeDh0L0lkTk1qYS9ERGt3V3BXbkdiWTBVL2g5dDY3cC9XclNkMTNBWFZrSlE2NzkwWnBKSWFUTnUwWXZPcndXekczdWtRYnU2RlJ0b09nRFpzOGJDRWZmWHJNdHJwRkkrNmtUdENSVW5XRkNVRnY1TWV6RkdiM1lPdC81ZFB0QncvbW5jUmhwZ3ZTQU4xMjNyRU9vOURxYjB2N0E0ZURDS2FkODZjWEQ1ZmY0bnRhTEZ6TWVoMFpGODVtZ242OC92enRPdnp0Y2Z2ems3KzI3dzJqSkJiOXdZMXFxVGtVKzZaU2lERFY2d1dLS0EvNnIwL2FXVjJ0dDg2QlJUQjNxU0I0YmNzcWpQTFJWWVdqakdmSHkzVzl0d1c5T1hYTFM5U05JdStCYU1EZU54RmtUem9NMDMva25sVnlHek84TXVxM1BvV3dnMmIxNys0T3JxOWRQcDZFVHlnZFRtY3RockxIQU5BUS9jN1BXM01CRzVVWFR0Y1ZhQTBqZERPR2wwbFV5cDhLNk1SYXp6SWFpVjhNd3JtOGYybWhxUFZzTDB5QnEyS1pSU1Z0Q3JCb3plRFF5ZnQzQStNbWJBMStQVG5qSUgzNnQ2UXFUVHVNSGQ3NHhFamdhdlhSWGM1U29KWENXVEJteXc0TjVnNUJLOHF6bzJEY0VtVHpCWXRZUW41QjU3cmxuSm85LzgwaHVYSGwwNUVISWpHRmk0bXJVdEQ2bWpzWEZiQXdnZUlJcm1oVXM5Q3ZHSElWNUZYKzYvTjcvT1JCb0lsN1JyODdFb0RsWDJyWWhGbk0yUG1qWHdydUZNMXAxZldKU2NEM2c2cmpFRXc2dSt0Y0plNklHam5wQXI5NlNqcm5CbDFaOEQ3b2JqZml0M2pqd3IrYzhidkg0K1c1LzMvSWgvUDB1SVZNZGNVQU11b3p5aE1UZS9VZ3ZIU2N2T0hQQ0czL3dSdHFwdjNqdCtuZUgxNlVCTThFTUJuemJOUy80N3J3Ni80NERabVhSNmFadEkzUnkwd3JoS0wvQ2QwcTNkR0EyaUl6ZGhFbU1OdHErdDNnOXlTdXZyc3NXM0oydmR3dG44THRNalYvbktaN09ydVBvVU51dENlZW14RTN2MnduUm02Szk1UE10aDk3OHozSmQvSWUvZmZ6cG10elpiRUloQjcxa2s4ZnlwU3MvZWp1WUN3dmI3dDI0dUdWVWtDVjAxUWpMYktFeG1zbTMvbFZEb05sNmp3bTgyTFIwdkc2a1lDNWdTdURZYmJkbWs4bHlUQkpNRnBaU3FmeHVTQnFOUnNZMG9LMnpCN0s1VlJ5Q3RRVE4rdlUxN08yRzVFM2I1VFJVT0hoNzRMbTBWT1lUQ29xWjlxV2xIRmNhdkpoSzl1UXdKUUxhWko3eTJSUkJVejk3OXZSb3hIRGVubzB3aE03UkY1NmRIRGx5Wk5pVnJmZStuSFhNUnFnRW40WTh6cjBJTGh0aWFPNWRWcTBWd2RIU3FPL1dTZDlPSjBMV05FUDFxR0lxZnhLTklBcnpaNzB4YzRSZGZVMWJaWXRZSENmNDJmSmVkdWFhTE4yY0haMUdGTnR5Y1FHbk14dkw2ekxPUnQraEFZZW1KbW9KYm94ZmR2bVlNY0s4NWdLV25hMjhXUE1TekJzMFhPOFdJTktwN3lGQU1pRUp2ckRJeHZFZWRJcitBVjgwMSs3OE5qR3BmdVRwa2dFVG5LUGVzK1RNSWZES3J1M3djNnFhOG5QU3o5Tk91eWVJeGRVMlJ2d2tudEV5TUdMclRZUlJuK0FnL1JCK1V5RnNncTdoeTZPMDlGSXVCZzdCTFYxQTRjTkdFYWNlaEhIWFV1WjI4dStuOHNwM09oLzJZNnViT0Rab3Mrcm1MeGF5SERVR3BRSExmTWlsWENtbHZhT0xaWXZyWTdKS2E4K0tvNXptZDlVa2Q5M29vcDQ0OFpvZTQ0aFZjd0xSMXMwVFdlcTZrUFNXZnFJSGZGUGswS3ZxUjNxam14bjJmTmJjZDBXQjk3ejdQZi95eCsrLy8wUGYvdmEzSDFuSjhKdTlsRURjT0E0VUR3TmRYMzFYSnNHTzNncjRtM2UvZWVmR0RZdGp1VjVWVkRWa0ZlYlJzRXRZbHlZRXhueER4OGdZV2xyQ3J3VXdodXZldmhtMkc2MndicWpndCt2OHZNRVQxdm1YZ0NnR3hIVDh4ZUhnNS9IZHdodU16bDlldmdrTXRHbHR6QTVDV3FIaHVoUGtUcHc0TWZuNjE0OU1ZZ29hOUZ2T1VKMGQzak9FenhBR1lhcXBka2w0dmg0T3JweVJSVE5ZNTFQZnMzekZSUnVhcVRtQW9rdlZFVm9JUTVzeWEyd1l3azk1K1JPR0hqQjFZRTNYRnNqTzl2VmJIc0pHUFVjSXEwL09XMTN5N3pwdXVHRENaWVpiclE0SlpxT2V3Rk0vMm90NDNoN3Bxb3hWWW5uM2N6WEN0TUtuUW5acTB4V3owL1Q3WnIvMkI0dXI5d3oyUy8xSGxJRlhwN3ZWdTlkUVYreUMyZkg0S1pmdmViK082OTMrczNlRmFzZm80MVM1K2wzMGhtTmZnVFU2eWF5RjVzVHBSNTRlMzEwbllIVWVsVVBsM2ZqcHlHdWlkZWF2MDFrVHprMnQxL0IrNzN2ZTg2SDc3NzkvOHJ1Lys3c1BXRW1BNkU4OS9lMTFKaFhEVzd2V1hkMll5Y1d2MzhMV25Ncll0ZVdlaGNXTnY2R0NPQTJnSzlMdmZsUjJDZFVhWnFsNCtXQXd6SW14Q0RwQ1FseEMyeHNzOFR3RVFUV3dhamo4ZkhQaUVpTGdpT2RiR0Q4TUxxNDh3ZldiUCtIbDdidGh3YWZ6OU50RDh6Qkp5R1FoSGtmTEc3ZFlCR2QzcDZWamkzMzU4ZHpBOG5UT0FKbnRrRmNtUzhEYzU4ZXVPdEROSDdpOEhxN3A4WjJ3cC9VVHBrbXRqWDhtaWRDcnROUVN3dXJSU294Qmd3d2gwSkoyeHRHWWJYUFhpV0krdEpOV1dRaG5ieHAxbXpHWWJzQlI3emVFOFBSc0VIUzhrczRLNDNkNDE1YzA2c2xiM1lFcFROeXhaVDMrOHU2SktIR1VRNXpHUS8yTDcrRzYzc0QwQ0cremcyK3V3OGJIOU52dmJrdCt5OE5UYnRhKzIyOCt2RWRERlhjbVpLZlpqZnpFNy96RmF6ZzMveTRZOVhjKy9qek82REhTWjlUSGJVZzlLai84aFhIcTg4cVY2dENFRlIvTXppbEJKN1JzMnMzbkJiWndmb09lMGFTYk5tV1dVOGFpNDhocjVMajI1N3Vtd0x2ZStjNzNuemgyYlBKbmp6NmF3NGN5ZVpQYlJvNi9jSFJ5NzcySDd6MXk1SWtqaHc0ZFdsbTM3a0t2YS82T2ZHS3kyS1dDTWJYS1Uwbk5FQ0x6dzN5RzcxWFJKUWhWTHFiaXZGdWd0bEFHWXpTQWhFc25qOHFudnNHVmpwOEdJZysvQ1FzUFA4S0NIemdOUzM2ZE4yMVFQTi9paWErajhIRG5jbllDdU9LY3pvWVVObVhETmNQSTFheGNFS1l6ZS9MSko4ZHQzc2RPdkRqU2JRd0QxS0hwdTB1UXhiWnFTN1liUzV5aFFZdVdYOWgreFA5ZS9VR1RlYWRjYUtlY3dnaFVmb1NHNzYxYlkxOGZaZTlPRDIxcUpNR2ZxYXBoMHFwcHpBU3ZkZVpkbDZXZHF3dG5ZMHkzRFUvclZaeW1KOXFpWTllcityNDhYY01PWjJHRmE1azYrcnZyRDYycm82eE91R3pRVmEvZHdjZ0RER243YVQvbHFOVWhCRmkxZ2M3djVuZlRrSCs3UVQ4MGxEak9tOGtFbllxbU0vK09tNVphOGFadzV0T0NRVjdPKzNXNjl1dDh2TGw1Zkh6UDU5dGhveXpUMFFXekI2ZmUrWXVQanV0enhBNzZORzNWQ2RyeVExZm1EM0dsRWRhd0I2d3BEYVM5bmsxWm9VTEtnSWRtQ3BIaWdyV21PUS95djdZL24vemtKMU1oNjRldDEwU1c0ZnJHTGR1ZkJqV1Z0Q21FdnFYV2ZQancvUS9rUkxrZjBaZ3VYeTVUUXd0bmZpcFZKV0dRRmd3Mkw3VFRVT2ExSHQrRU02ZHhjTktEMDA4M0dtOE5CSk56L1JzOFlkSjVkenpoL0RRMnVFbEhhQTNjcGcxT1hBNGVIZzNXMnpaZUpndk1yZkdLWjV2eGl5OGVHeHJ6YzBlZlM2cE1DRVk0QVdIbGhqTTVMQnVUTDgzYnVSSHNlY2VQSDdzaC9MK1habzE1aGg2RkdIK1VoNEFKL2RnMDAwa1F6SVFadk5xTVVXbExZQ3NidTJmVEV4anhDR1dkbms3MnlubzNUOXRDUFdOcTN6VkttSzFvYWNGY0RGNU1yaDU5eXdkdDFVazdkY0VQUHNLOXhkY21Xc2kydi9kTVd5c2hLcjU2VlQ3dGdBMjBENG9mZGM5dU9tQVgvQ3Y1NXJwdGViK2M2N3c3anJrRGZ0L2huenprazFZNVlQczFQc2U3d3dqTktudkZGVWZNMmJ2eGFmeEc0TnlmanQ5ZU4zK2pHYmQrZlkwaWl4NGxkRGRzY0JScGpVamc3elJCNmRIUC9JSTh0UUd1NGFDaE9KMlB0N1JwSVhsWC9ZcFR6OXBxalVHODEvTG54Uk1uUHJveHRqZGFrY2t0WjBKc3k4YUt6SzhORjBMZjJJRFMrUnpLcW82TkczYytzSFA3em9mQ0NCK3hKTWV3bnpOVTVEQ0lTdW9HcG9mbHAvSTluUEJtMVA3bVZ4VmVqZFR2aHROaDRQRHZ4cUVSWVVadytXTndETzFiR0wrTzAvbkF5MmFTRWh6VkVQbkp3MU5DQXJQV3QzTXc3T2pqckNJeGZMNlF5MlRQREJQRzljbmVzZVY3NzhCajg1Wk5rNTI3c21NeWdoQk0rVE1Gb1BHWkhKQ2ZnL08rcDY2WlpSNG9QMlVyRjFybEI4SGN0S0FkdGROaG9zK2dWU2FoeEpFZURVd1NFcnJ3SitBSlhNenIvcndZZDI0SVRlV1VwdWhhZG1SeE1UWjY5c3FZcHE5M2o1TDg1cVNWcHV0Sy9YVmQ4b05EV3Rqd0U3L2JXT2NMVHBmRFcwZktsSVFPSHZIbW5mdzh0M0xpb2dQbmR6L3RKMTNUcytrMUQ2Zmo4NnU0TThIYllkMzI1dE4xZk85NXVqU2UzdjI3MDkzODNUQWNLd0MzTVVJY3R2NnFIMEs2ZG9UT2NOc1FHUUFmOUZjZFlLS3ZOM3k1eHNkMytlTXR0R0U2UVM4MEx2NFh2cVk1aDJpSElpeWYraTYyYUxNcEovbnlKa1BXbkYyOHZKemg2YjY5UXlzNmR2cmtQUWs3Y2l1NE9VdmpuczFMbXo2cjhYT1lqSUF1cHFwbFZTclF0MHFxU3ExSzdvclZFRFNjR2ZNV0EvRHpTTnVOUWg1ZytNYXc4aTNOcUdCMGZHbkVBOVBUT0hRZTRJZ0xKMzRPeG1uODROTnBDUVRoL01BWUdtTzA1cHIwS24vaHptQys4NDQ3cDhQOXVqdlBURGdjMGVQYTFSeUhPdWlReGgydHRiVkxOMlJMSHhhQTBtdHk0Ti9zWm42RWN0V0RUaE45TUJ3VEJCeU5sZ3hINjNjNnNodTdBYXREWkN0SGF6YmZwVTExaUJYaENENG14dlJXWkhTZDlZWVRHdlhZWkJMNm9TL1g5UFVibmZ1NzRMeFVBRWdEcDQ0RFBoemdid05GMGE0MkJvSEZ2K0ZLS3gyNGhKRGYzS2ozNEY2dTJtVGoxdSttMjYzZS9NRG9NR244bnZkdk9OTk1nbGVORXVmOU8zMmxuWTBhT281My8yN2NHMTc3OTdleXo3czJWL0Y3YVZ6MGJyclh5S0xDcXp4d1djamE1NmIzWWxiUk5QMlYyVy84Smw3RExmeXIvR0RyZkkyT3VRcEx1dkgxWC9pZld3blFWMHFTN1pzMmpkbXI1NTkvZmpBTmdVRTRQZjNjaTBjT1QwK2d5N0t3SS9Qd0ZoZVhkcW9JamNNanZxY2JiMWVjYitHalFzT2ozcjR4RithaGtYSDh1RTd2M1lJV3JBN3o5dDFDaHVEUW9NQ1ZodXZHMCtubDFUanc4OHpqSVIwWVRCaHdhdnlrNnpMUmhLOWZOK0ZVdUVwZlc3VjNqZmdteWR6V1FpQ2ZQWGQ2K0duTVlNQ1hFTE4rMTIvK25zS3BOZHVCK3F2KzA3U1pUemp2MTRLWlFMYWNzWVJ3VFo3NXJiUGdwRUdIR1EwTElrMTFkSVRqUkxwaTBJMGJTN3ZWVVJrV2k2TThhT2ZobEsxcDdydnA3ZDE1Q2U4NlFuODRDaFBIZDlOZkhQQUpaMkhMeTdWMldmekd0K3RVT0FjMlhGWnlKS3g2QlUrY2hpL2VQSDRqMGZTUE9CNnUzOU9nRzM3U2Qxakg3Ky9HUVdSNWN2emFmejd0Q0p6N000K1RlTDdiTmZ6KzlpNjRzemkwMkhKRmgwNHpIKy82VFhYZGJYOUR0RjV0UXA0NkZiU1Z6cHQvbDdOeEZNYXYzNDJQZDhkZEU4NVZHNi82TDYwNVM3N08zSC92V3dhVFhqbDNiVnhuZmk0QzVzQytBNVAzLzhOL2ZIMy93UU9ULyszLy9EKzZ4a2NlRDd6MUp4L2V1SG5qUFJ0eW1lTkNtQmFUYnNpcy81WmNuc290aEdrMHl0VUlwc1d4WmpQYVdpcTNIUnVnY0NzZnV2RUk0K2ZSR0RRQTJuZ3pySGpkS0x3SnpVNnJjWERTZWZnM0hQN0N1d0Y1dDdCdWVQTHB6cVdGZ3Jkd2pSS3N5eXZSd0tJNTAwemczWUtCbVlLVEp3RnNTTGRwWXkwSGxINzlzT3R0R29KaU5XdDcrUkUwVG1OYnljMHROcVZVK2lwRHNBMk00UldnK2JLTzloYXV5OTVCTjMvZktIUFdLVyt3ZmprNEVjVHdic1pESzJjamRGbE03TGxRb010c2R5ZEhLTUlaallMK29CLzQ0MXpuWEVLN1B1MGdvajN2NnZRSXhUcHFzNDV5N2JxUUJxMXRESkUzZjIyQkhaNkdTL1BpYjQwNitrZkVCcGRxUzFiRFhMaFE3WUlwU3FmdTJiQytPZ1hieXVFOTZKbzh0RWttbUZyN2JBNWlhbFlKVlBiL3lnK0ppOWp6OUp2L1hVUDJFdGJ6NVNqNkVvb2x3SHhMQjMvTzI0TnVGWGNtbkxXQmZrYmsvQkdIMzN4Y3Y3bDVmTDd6VzRmem5YSFN2WTIwUU5SVDVSeXJia0lMRTlLcHppU1VKeHBXWGpwYi9HRUU1TDJVSTIvVHNsTlhhSlVSbHMxWCtkZjhZdk1VODRoUWMwNVhNaDhSOVNObEw2RTk0L3FCenRxZlYwT0IrKy85b2VzV3hydEkxTEdOQnpidW05eTE0YTdKMjkvKzlzbkRELy9keWRQZmZ1WWw0UDc2VC8zTlg5NS80TTVmT25QNjdMMjlhWVJtZ2hrMHJtTCtHanBMZUNXR2EwelRETjhOV0VQM0VBZ2E4WHk0ZE4xUStUZE1maVVncGhPTVF5RE9tQUpzRGJvYnM5L1NlMHZiTUwweGZ6MnpNUGxLQzYvR1U4UDJXMXlOMVc4N0lPRUVOdjhXN3EyRmdzT05SaDZoc1c1ZGFaUTJOZkFEczVsWFBEQUpmY0pJSTdkSmhadSt4dStYKzFQcHErd2Ryd1hKaG16Q2dTc2g0WUV6QnBXL2RDYlV2TnY1emZ3aGpUaFduREIxZFBuYnBHRDlza2xQMXpnSkt5RmJlRXRuSlVzSjZSSVNhSzdzWFEveVVTOU5oeGsrVlUvd21RK2JyMFArOEVQdks2dUZQM2hkamlyRHpDdzJDeXNCTlB1T1FoQllMK2Q2L3FSaHpxZUYwMkk2RC9oMG13RkxITjhldEduSG54TmZXdTdtOS9ETW44NEh2YmhPT3o3bXY2Y3cyLzkyNzA3ZmIvR2FwbTRJNnZ6ZzVyY3c5V1VUbU4vYVR2djc3clNPWG0xWXdwVVp6aDFuVFRnUDhyeTZQN1RtRUhCcHo5NmRrM081dzgrR0U0S1A1cmR6NThKWTl2WFJqLzF1dGg5LzYxZm1JWjg3ZSs1enl5dXIvK3owcWJPajRlM2N0WGU4VlV3TExQRTFTbjRxdFlXRGlsTnBuRWJnb1ozMTcyNFlJOEwwVHpmeUZyTGRLUGp6azBlNy9qM2ZPRnFZdzZjRmc5OGFudmY4MCtrYVhwcnZFQURkMEd4ZzRNU1RqaU9BNU9FYi9sMUdBcHVKZzhDMTZOL056SjAvUEdrYmFFT0xiSm9NZ09QUFN3WHR6UC9XdjhEek5HMktydFdwTFd5WUN1Zk1LYUFYL09ZRkRwelFvaWR4NEVYbzBVcXRnZDZhWlpYaUtDTWJNc2RlM2RvMHhWK1k4c3BmSDlQbGJCbzFYdnhIbkNtdWZ0Tys0eDMvdWgybDZxVzBZQk9XeXZYL3MzY3ZPNXJsU0o3WTNjUGR3ejBpOGw0cVZBRzlxTWhaOUtnaHpBamFTRHR0OVFaNmcxbk9rOHhqekU1THZVRnBWNEEyT1dwZ3FpVUJVOXExMEppdXlzcExoRWY0WmV4bmR2N2ZvWC9wa1hXWlRkNFlRU2RwdEJ1TnBCMGVIcDd6MFR1L3JnSVgzK2w3VG5ydkU3cEZkbVJGOXVoUzhxMzdpbDU5MjYzNjdOc0NXd3B3Mlcwdm85L3IxQXZrUFphMnJDT2NSbnlFSnJ5azRSZFlhQTdsamVkak1odTJFVUJERTdwdWZ5MEUrcHgvMzFYc1RsbWRQbTNjcHpXdjZ3SmN2L2xXZDRIVi92bzhnKy9uM05WZDRsazU1dGhYbW5FWCs0TDk1SnpUWTM5QldnN3psK2QzSjc5bFFMZnJ6dTYrLy80bjlVYlI2Zjl5ZGZYaUY1Ly8vZysvK1B0LytILy9mWjNmL2YvRDl0UGFmNjRmVmYzWEpyS08wTEZlcmJaeU5xbFc1NHhHNTRJbG9zbWtrZWNvM0ViUklSR05pY2R4eGRHQnFVZUxMclJTZGVFSlJ6a2hOT29ObUVTNmpoTjQ2S1JEdi9KQW8weVhha216SmpjOFFxTWVIbngxNERQQVo3TDJHZTl5MUd4M1hsL3ZFNXlDNk52OHduZWJpZDZ0L1o4YjRGZlQrdmJka2E3eVBCMUsyejRLZDFsTzFDdTYwUzE4MlNQQlZrenZoeGN4NXhQYmM0YTVFOUFtamxtYjNudnZnMzc0U2ZaWFg5YlBoRzBQMk1qb2NWQkhEcWNkMDQ5c0lRUUdqOUowVUhmV0R5U25IMGZPSEszTFdNclBNU216bmZPMExpQzV3T0FUM3VubnRBK2N2THY2L3NiQWpJMXhVTEhKYm9uUnNaWGQ5RTFlaWxmU3lETU9iSjNneFc3Q0tsdVozdXdtU0JQaGlTa0hweEhyVDJSRUx2aWFUL2xkb3lYODdrcm0wRTBhZWVoTGVQVjYyYU4vaW16bUZSdmY5aGljNXpBdVFOcVc5a1d2dERsalhWdlV4YTc2VXZqSk9iY1ovdncvTCt0a1I3bVpPcUF4RDZWc1NaalE3Ny8vNGIvOTR4ZGZ2UDdOLy9uWnYzK01XOTBZZi9UbSt2cmZlUVBaWkUySEdJQ2NxY2tzTDZTajdtb1BTc2lnQURlbzRZa2NsSTRVNGFqUFlGQ3ZiQUNJNFlrZjJXRG9Ba2VIZCtyRFQzMENHRm94dEQzSkROUk5mbkNsdlo5ZWs2OTVGQnU0NndDMGdxU0hGYlFVWDJIYWRyblJqME93TjF2K3IrUzQ1ZlZ4K3ZwWnIvcm1NenBPYnJZek9NdmhNWHJQaGFtWmJuL1c5Z0NsVGZLTzdqMjAzOWlFM2lzZEdqRnQ0ZkRvckIrZGNRNitiUXg3dkhCdFpmUTNUK29EL0J6eGw5ZDFHcVZVOWNBUWIvYlVGanc0ejlnaStpa243OEkxOXA5K2NOellHTFNGVW91elRwWFpWN0FIK3JhK3NGWnE5RGlqTjl6cjExOGYyb1YvWWhQVkgyMktQZnYxWXM2b25jK3M5RjdWaWwrSWJhU0o0QzZxeXB5WTJ3STZzZkhwdHFkNldudXVaSWhzdHNwSE4zY0dNMVl6UHJSYlhISFo1VGc4Qmp2RytWUGxuVWN1RERPMkdrNW02WGhTMytPWTdGenNmY1BFZURTTzZPbWxLYi9wcUYrMU0vTXN6eVQwcGJiZ3lRWml3ay9PT1piNE05S1g1WmpMZUpjMS96OWpiRzdyK2JQNmVNM3B5Zi8wOVJldnJ2NnYvL2ovL0IvSGJQNjd2LzN2LzhmTHE2ZS9LQWQwL2MvL1hBYzd0cFd6aHpWQ09rMXEwZ2pwcE5Pbiswb1hQQjNZazJ0YmNjQmQ2UXhxblcxVnFTNGRIeHA4NGd4RFMzYTNwMmdOS1BWU1RvVE1UQVI1VVNBbkQ2N0szUmRFWFZjZFpQYkUzT2pkRXBNSEx6cXV2TlVadVBRY3ZHa3ZqdjBneHNxNUJ2MXAzVWFxZDlmZ0l6MzJvdjNVbFFtQjk2U1ZkSDcwak02Z0F2a0pwWFdqUnI2TFpQcGlWcHU3dzBGbk5jUWVBaHR4elBTMmxlRzQzRXhBRHRia0hEdlMxY1BQODdxbzZCY1QwZ1htVFIwSm5DMk5jVGgwMEg2T2tEUENQOUdEUCszd3UzcjZaL3JJbWVseWVkdFlJRnNaSDdndURzcDRzTlBCdHZYYU1IcGxVZEFtTW5mZTFWOVZ0ZmU5YlkxeDRLdHQwWTVkZGpzRmx0TVBxYWVYcUp5UU9pbGRwR256NWVVK2Z1a1IrSzdUTnVEQ3JGTHRUbjhueFRONXFJZnlyc2JDWVI4ZjhCTFFLNGFQdFA2M2ZUdzRGWXlYSjl2S09mYU1ybXpyUXF6OStrbThxNjgyNHFOdTZNZUd5Zi9rbk5zc2YvclBwN1lsYXFGVGk0SGZNYkNCZEZPcm9zdW56Ly9YK2pMVjY4Lys0VC8yVDA0ZGM2cXR2NDllZmYzMS8zNWRxMldkL1g1OWZjM0t5QmZrZnYvNzMvZWtCc2RUTU5IanBLN3E5amdEWkFiRE9EYXlneDlhTUJHZXlTK3FFOEdEUjRhQmtUWUVIdjdyQkRCb3dBMHdJWG1wQUI0NjVlUXpJTFVqOE50YTN1RTlYeFlyVjExNUlUclNSejQ4WjhEdWc5WDJBUm80ODVSN2Zzb3FiZVU0L0RodXVjem11enZwcmJqSjJrc2x1eDM2NkREN3hmTWJmbU1mVG1zbVo5cTEwc3JyUjdoV3FMNHdaL0xSVXhzeTRld3hPeTdINllQUmx6bnhoRGNYd0dtWEw2R0JjNUNoMTJZMExvUnRuMW9aeEViS0FocDU5czY0QUVPWHNaVFZ2UzBYOUM0S0xoajBGK0NpaVk3U3A1ZWpEM2pIN1lJbmo0ZHhKVVNQTG14LzRKelh2cnVnZnNhZ2NUczA0QzVDK0pDVk1hcXN6ZUpjZ09aQ0JYNGNyZXJ4UHBZUGoveGpPSmtQd3plZCswcVRNYm1PcFVQOUkzTHhianNkOUdJbmQ2NHVvdTYwM0EzWXhqRk9aNjVxcC9iakczbXh3VS9PK1dGdnZiUDA0dW5UWDFSM2YzWld4bVJFOGU3Ky9OOWNmLzNWLy9mMy8vYy8vSWZIQ1AvVjMvMFAvM090a0QvOC9GVzkvVmNyS1JQWEpIQTBTYWVZekZaY0pnbCtRaWFUenNxQWxVK01iR21Odng2dzZESVkwOG5xd3lPVGlHeEJuVWxwVUdRZ1NBVTBTZk9UVWZBUzhRaE4rSktka0RwOFRDNnlFc0lidnZianRhN1lPUXlCSXh2ZTg4bkk0SnZNK05rTGxyS2ZyUk0yYzd4TFdGVHBzai9rcmpvR2xrK1BLcFBISmxrMWd4MVdST1drOFVqRVN6djlNZ2w4UjlEMEl6MmNJKzc5NDdMWmZDL0RONnByNjZJdUJEZjFUZXB4M3Z0cjIyeGc0c0t4MG1RRGRoTzBrVXl5eEpTbDlNVS9rOXN6REh5Q1U1Wm9POUtwTE5EMHRsekdWcmJCOHJiaWpEUHl5SW9kNU9mYjRxTkhqYlRpeUduT0ZwTDYyODNZc2EwMGVmeklVb1pMcjEyM0dhKzVNS2dQampSODJDSnREd3pmaE1oQ2t4QzgxVjdCZ3hQK2d6L2pkcVVQSCttTVFibU00YmtqQVRGMmlKMjNXRUcyL2lwY2ZURXl4Kzc2S0RxUXRlczJXeC9xeVlydXl1SlB6bm5zK3ExLzZ4dEcvL0wyeWZPUDZnT3dkZnJwK3I5OWZYZDZlZk9IVjFkZnZmbjhQL3p1a1RjTFg5YjJ4K25wczErOHJnbDYvZmJ1Znp0NzZzZEtuZHZWeVRNUXJhYnMrNW1VbDNYZTJXMXVPdkQ4eVg2bTF1UUhuMVdFYzc3ejdqN0hvVU16THRFYlJEcGVtbyt2bUJCZzZ3QnhkTXZBZHhYbmdPbmdOVjE0T1FGaEZYZmJlNVd6Q3VlYzZXRndqZHlhM0c4OTFKcUpwZzY5VkJUcWpyL0N3UHpHWVNhbkZBOXRpMzRlanRJSkxlZldjc29PempQajI5K0JLUGZnb1piVmNUNHE5SEc5OXEzZWlSa09xYitMWER4S1JMZTV0RzFlN09RQmorQlRrOVVMdlQrc25TNEdPVUhCb1dTeVBpMzd5RS9iMFZXYjY4dzJXUGZiMC9kN1ZjeUdIQTM5WDczeUhRdU85UHhnV3p6MTM5dGFRZUdsTDA3cWxkMWFwOWJEWk02b1ZySnY1cWZDMkl2dUxiZnVOdnpRYi9YZWllOVluQlplMjk1eFB0K2FybmFjRmU4bjVYVFpEYzJUR2dkc0tqZy9uOHVtMHdKK2tLRytOOTU0RjdVcXRsRjBYWGQvcFZqMWU3V3J4dWRaUGR3dTlSbXI4T3ZzYlQzd3ZxblZIOGRQQmozb3orWjBTWncrbW9zSTJYUnh6cHd1NlBTTGJSMTQ2SDF2aE0zMGRTN0dqYmU5Q0lKdUxsd2pJK09YNHhQTm85bnVhbW4rdEJ4anYrMVE5SFE3RHVvU1lyT1VwY1pGZ3Q4V0RQNmVUbTFab3g5bzNtMFhSTHpNSWFIdDd5N3U5R2w5YXFBZStOL09Md0w1VU5PcjE5WC85UjF0NDQya3F5dmJhSFBja20zSXNSOU56WitjYzV2ejNYOWVscU90bDBVK1BMODQrN1ZENHE5ZlBYbjluLzdUM3o5NDQyK2wvdlRUdi90VjdSNS9lSE42OTlsdG45T2RRYTNEdXRNS2VUcWdPcXhlM2VXZ0RGTE9GWHpxWm9XVFFhdlQ0aHhYV1FaRUFod2hxWUdKWmczdzFXZHl1ZTBNNy83YVc5VTUrWUN1VjcwMXVLUnpZWmhiYjIzZ2JJU2IyM2w3REg3MG96L1o4RHdNT3c1cFkzUlJUNGUxTFptSXZsY2dxT3NmQXkzbm1IMU1OTEhwN2lCbVM4UEVPWnhCM2t5MDhyZmFRY3ZCYW9zK2tJTEJpMzJjcmdDanM1Y0V3T1hoV3lrN3g2eVAwTkxIQlVaVXIwN0VqMjA0bXZDVmlySGpyS1p6QWUwbWo5eHlwdWpGdERYMmkrTUJUNUNmc1RTck1EckJUeHVDRnhnbkY3MXNtNlRmcFdpZHQ1YWZkbzhoeXplM1BuZ0lkSU1iUGNIQ1B6Z3AwMWxlakwzaGg1NGNmSXczTURFODVLTkxaUDJsSDc0S0x6S0Z0YnptcDNhdmY2d3VPTWZwaWt0ZnVncjAxNjRFN1hjaVNJb204d3grK3ZvbjV4eHJQWksrTE1kOGVYcjVxN1BMODk5a0l0V1hNQjdCSE5COHYvbnFWOVVqdno3WEdiWEtFc2JZdTZsMWhrbGtnaHV3ZUhQTzZSUXJndVRSWnpES0MralZad0NEWlJCSU13bG1VdTIzcW1qUWdzOUFud2s1K2ZuSXl3UGVpM01nSXlHeTRpQlNsb2Flck5yZGJoM1hlcklGTUhsNGF4NjlzcmFsdmgyek5VM1ZGV1hEMVYzVU9WSXd0dVJvZlZBcGt6akg2MXBZL1dtOXlpblRtYTJsZmZkU2FSd2FYSHc1clBCUk4zS25INS9XQ1JsMFZzc2NNMGVzM3VTeWNrWVBybDcvNW80Z0RrZDk3S0hmNWV2L0FhYmN1dXFyT21wR0R6RDZwcy9wQ2VlQTEzYkpPSnMrUm9NMmRIREJCSHhtUE0rWjNORnRuSEFjSUp6Ym9pL3NpdnBNUDIwWDZGclQ5ZGJ4ZGdkU21sU2RkVGplTTk3dzUzeWlSMlJHYjNiTGg0WG9LY2J1OUVFWDNHSjc0QU12UWYyN3dyZlZoZVlZNTdoY0NqVHFDbzhOdzBNYUdMdzFzcVYycTVkZjhkam40dHhlK3p3Y0xQZGRZOGNGM0tKajV2ZnVNVlpwUCtYYkFyWW1ubHhlL0hZZDRFK2YxaSt4UGhKZWxpTXY0MSs5ZnZYcTE4R1hDbEtuTTZaelp0WEFtUVF2SGFxY2dXQVNtK3c2MTRCRUs1K0lid2F6dkFCblpNeCszMHJMeVNUQ01WaGV2ZktpUjV4OVovZmJZSEpyWldWMTRwWGdUSXB4WG5ON1htNnk5VFhRUkh5anE1UjhZWFZJSStYaFpJdmU4TU9ubllUNzY3cXQ5eEJwY01ZT000aHRDNHhNTkc0VGIyNW1EOC9rcnNNSnJRdGFmTWZXY3lGMFJFdVpFMDBkdTBmMzZFZ0hJVzJILzd5T3hISE8rbzlPMmdiUDdibmcrVUVldE9rZmZTaU5EU0tEL0FRd1BPQ1pwTnBEcjlpRmJvRnBHMTRDbUtBK3VORUp6Mm56Zm51ZmRxVE5IRU1jWVRQYWVLSEQrNnljTDcxR1Z3NTBQdDhLRnd3L3NoUHhGZEVhYTA5cjY0S3VaTUNsR3pxUmMzNjkvWkpJZEU2N2RsMDQ2Q25Oa1Q1allYZUd3VHRPWTQ4VkRyYUd0YnptNFJ6S0c4Mmh2REdnTDFnbDNhYmorcldjdG9FRnpoYjZtbDNZYWV3N0Y4M295QlkvT2VkWTR5aDlXYzcyNmRPekR6TXBHSG5pMVllZmJqL2NXbVVIT0RabmZYZFZ6cXhlVEtuOXVKbzdmZzBETFJxZGtrSEpXWmpZcytlME8xdURPcDJISm9NNTlORWpLWGhvNUFVZG1rR2dqalBoSExLaUN3NDhnOE4zTG5iYU9WNlYzMzREZDA0MWV1QUxKb0tadEZtZFJnLzgxZUV2cmFGN29JbGU3SkIyYWt0NFJYYzhXalllWlV1dnI0emNtZHoyUGdWMDJvVVgrYk55SG9lQjcvV2IwYmYzT3FzTWgrMm5IOWE3bEgybFNRNSs2SVZlM1pVZUpwRWpkTXE1cUpKUEYzYWtCK2VzM212Wm5IY2NkcHdmdnRvSUxxUk1KaDZpdWp6VWd6TTJIRWVZQ1F3L2NEeEVRWnArQ0R4cDZsZmN3S1FDdmduNHRKM3MxOWVLV1QrTVRBK3o5VmxPOGRDTi9jU2hIbHIybnJFUFN1N1lmUzVJMnNsbVpFWXVuT2dmV0tuUlFUbTZwKzNoS3ozbXMrS0hyaG5WbjdXODVoK3JCd3RPMHVBbFBaWU5EaVpvRDMzMXUzd2NjZURHVFBKbzVFVmpwaDkwTjVlZi9qeXd3S2Y5TmJrWHY2Z2ZGUDFNcHpBdzQ3V1JUKzkrOC9UQ2QzRVhKMktCMTVPM0JsK3ROakxaMEtaVEdaMno5T0tJQ2E2amZIREdvQjJIT3c2QkhEVGc2YXcxVlFlSFRuaklpd0k4K2RBMnNQN0FOU0YwdW5RZk1PUFEwUlhXNGxTSDBxYzVnMHZ1NEpXY2FxWmpWdlVyNDQwWUhWWTk0RG8yaDM2dFZ6N3cyZlRGTy96cExpOTFvYkJpc24rTWJoeFgyYVhrbjlhcVhudmd6Uzk2VzEzdnEwV3Jlbkk0NS9Bc3F1YU52eEM1YTdscDBGVkVSNGIrZEtaYXY0bjZhMncvOVJ3TnU5ckdVSStmaVlkTzIvRmFiU0FQUC9EWWlFN3FsTk5QMFIzdTJHRHBoMDNINkErWFh1RnJ2QXFod3hzdStPZ3pXeG5LVHJ2QUMyN1Mxc2NEdURLWmM3ejFwS0ZvelluaFM2WkladlNRRjZLUGNlL0NKV1VUam9mTmZBWjJ0UU1hUEVLZkMzSGc2aUlqS2YyT1ErcVNwdjY0SEh1ay9rK2xvVTlxWEFySE9yVE55a0M1eUtjTU43WmkzN2YxMnIxdms4OUh3ZVpaQmhwajE5ejdhZVhNWWt2NHRCenp4Y1VIdjdwOGV2NmJHYlR6OENZb0JnNDQ0d3J6OUhpT3d2UXYvL1orRWJOT1BmeEVFOGVLV1FlaDF4SHkzU0UxNEROcHdFU0RRRVN2TEYwN1dqbVRLTGg0Q09DcEl6Y3BnMEkxQUFCQUFFbEVRVlFEQ2owNk1Oc2FuSWc2SnpmVW1ZVHF3eWZ5cE5FbHNxSlA1TFhnK2dNT3g2b0tIeE1RZlhqUlMxanAwK2EwbTAzZ0tVdHRaUWoybjhOTFdSMTI1TWxIeC9BckxSb0dkdzFyRytDbWZYRG9KZEpkbEQvc005YzVZYmhvWHRlVDl6Z1g5Wnl6RUljZTJyUmJYV1RSTlFGLzdhVlR6djdpSWNCWG56YW5ESmZEVXllb2wwKzdwR09idWVncXB4NGN2ckdidmdGTFhwMjhvQTNxSXRkV2lBQUhqTjVaYkFTdVRnQW5VNlNycUM3OHJjZzVhM3lFNkJVOUhEa1Y0S3RML2JSUnU2ZnRqZlJYL29tdWVBcHJlYzJIdmJZa1dBekFDZDRPMzhkNitLckxlSktmdmhoNWJCQVlPSDdhK3BOemJyUE1Idy8weW1sOWRISCtwQjhBTXRvNk9PUGtEQjR4UjNsMEFHUENsN2V5eUdCbTdFUXdrZkZOdm1mMUlyZzZBZjArS01kcEt3dnc4UjNlKzBvaGc3V1JOcngwTEZyMUFyMEZiUUUzb1RLeE0yRHU3N2RiLzVvbmVNQ0RFeDBpUzExc2tqcXdoRFh2d2NaS2x6WklCYW4ycDExSm8yZFdvV3lGcitqRURKNWtvdzE4aGJFeFhtQmx0YzZQZm51L0JBY1BlUUYrMDJ5MkxrdTBEQmZVK2ViMGU3MWw1WUpHeDljK1cxcDZzRzhlQUtLbnI1UnU0UWxmZ0F1ZUNVbFA4dWtoYWgrZThQdG8yelplNEtPTHZ0S01SekxnSjQzYzJFQWRmRUdxUFBqNzJFS3pCcnc0UDNnQ1h2M2hucmJOdE10S2V1NEU1eWU0NElWM2RJME9HU3ZhSVNvWGwwN0RQN0xTMzJmMUFmc0Ura1JIYlZDVzRoOTRjTVB2Mjhwcm5Ud2VlQ1UwejczWWRlcFhuT0FtalI3UzlBVWQ5UytZOXEzOUh2M1J3MmNUY3hNdU9UODU1ODJ5anNEVjJlQmZuTnlkL3VhdUR0cmYzcGpjQmh0RGkyNEZwN2ZtZTYxK3pOR2dOWUMzVlVpOXJtdWxOczdQcmU4OE5QTFNSTDFKdUgzZjFYbFlIekgzb09WMW5YUDE4b0tmUERJaHMrSWNPWFZoN2c3dHM3MGx1NmJIRE1qQ2htSFBWMmZyMkF5YzVIVndueXZ0YllIdEtYdlBUeTg2dkRyNThzcy85S0N4WW5iNzZKdS9Bb2VhUVlSSFl2aFAyVVFoY3dZMUowWnVRZ1p3a1IvZ3VSZ0V4NEROUTlLUmwwK0Q3bzZOYm5Qck9OOXhicWRWV3gxZzdKeVhVbGlETHJFM3ViYWUrdGU2YTNLNGlMWk90ZVhVeCtqNk5WdDNFeVlDbTgvRlVCdm9RamVPNy9yNjY2S2RWNi9mZjc4Y2M5VTd0K3BGRS9tdnZycnVXM1g5blZ0M1g5UGp2TUdFT09xME80NkhQdnB1dDlXTXM5dGI5amYyVE9yZGZ2QVM4ZTVZWDgzVEg0WGRrVTUzOWJUZmRobjQzTG5VT2UyQ3NlVzh0REtPRWU3dzArZTBRMU5PdkI0QWN4b05xWEc5cm41ekViRWxrZSttbkxGdGpVdGpWWkEvNzMxb2ZQeFM5U3dTYm01bWY3VlBhSlNNT2tUZHVqcTNUNWQ1NFdlN09ENnBDMUhEVnZka3hJdHM0cTluT3RLQzZ2eXEwMmE4SmpWMkJ6L3QyWEhsaGc2dUNDZk84c0REQjdXMmYvZTNjOEgzM0NLMEsxODg2QUcyMmtsZVRKaTJ6bnk4dU5CZXp4bm95WWY0M2MwWmc3YnExdGFIL2tlWHZxeUhmM1VEV2I5T2N2OGJFMzg2ZHpwNU5RYkRDdW1JWEFVekNJSWJlaFBJcXN1cTZvUDNQK29KNzNzSDZ3VDE4UER1Ykc0Ym56MmI3UWRpRE9wMGF2aEpNNGpvOHJhY2hKQUJBVDg2ZG9lWGs1TDZKNkFYNEowNklGOU9ST0NRMU0wZ2FWRG42WkNRZWlrWmF5b3Z0Q3p5dG1nUzQ1MHl1Y0hGdzlsaFFkNHh1Sm5JczhwTFcrQ0hKbnlrMm56WEY0akpoMC93cFM0SVE3UEpMVWVjb0Q2MkloZWVrRlFkSjJ5N3dubmxwMC9uVExpTEFoek95YWtQSnpQZzRBY1dod3NIRDJraS90RlBYaHZVSlNRdmJkMjJid1VQTG9jOGZjUTJZczNuRHZEeFNsQW1SM0NSNlY4ODMyeWZ2ZzZQbE9IaTRlS01GdnhwdFM4NjBpZHRVNCt2bUg0eXBnVmxkcCtMMi9SdlY5UWZQTHBkbFY5MVZEOTJtZnBWZDNYdkNobWZlQjJINGIvMzUzRjlaSXpjZlN5c3ZPUVAwU3phNUNUVlZuazJDai81d0kyTjFHdDNiQTFYMlRITDRJZEcybjNtQW55czlJK3QvTEljOCtucGUzLzc5T0xKWnh6bGROYXNIZzNVL2w1RGpYTmpmZHYvYjVnMzNxeDIzZHBab1FnbXJtREZ3T2dad1BJR3I4SEVrVnVOY05vRjdnQ094dmQxcmFMcDBMamxwUEVRMHZrNlZWM3ZGUmQ5T3QrRlFNYyt3SzNWaWZyVDRqMDg1eGdXZmVnZG5rMjB5ZWgyYmdPSkxQVGhDWCtsTWRoU0Y3eVdSK1pHTjdKbUFLZXVpZXFQeVI2ZWVTQ2xMbmdlbEtTZUkrNWZ2eTZIMWQyaVQycUZHZHpRU1VQREpnbnd0RTI2Qm1WMmkrMjBLWTRtRjlabno1NGY2T0RoNzhMelVmMEliWTdPb2NsMngyTXlBa3U2NmlBUHpsWjRwM3hiSzdlRTJERjQwcnhlZm93VEh2b1BuV3N6ZkhEdFM3L0ZQdXEwYTNCbnkwVjdMbW9zZ2pXOGhNejQzYmRXMEl2R0tIcDh4TkRBcHdPNTJVdTNjdGJ2MFNFMDJnQzM4YmVyamxYbHR3WDhRNThVdnZ5a25SeitCSDRBYkpuUmIreE85L0RDNXBEZm5IUEs0UUdmenVHOTBzTUpYS3BPa0xJWC9XTWpjSG02cUJQMzBhdjJSeGljWmVhWWZWdlcxa1dacmd3NmhzakFVbG83OE5CQmJvL0wwRzMwdmozV0FUbTJOWEE4VEdTM211amNXcHIwYm9QenluU2hiUHd6cUdxeUZCK3Z6ZW9rUE5LSjlKQTNlWjQ5bjFOOEdRQ2o5ZnlGUnkrVHgzZC9weTJ6NTJ4aW1DeHgvRDBvR2paWGRQVmczYTZ0N2VpSGJ2Z2ViTEFKalgyU3FrZXZ2T3EzNXJVTlQxRlF0azJFQnN5Mmpid1F2a2tmZzAwYkYrZTI4UzNxMXNIRmswNkpjUzc2UWo1T1F5cThmUG1yc3RIc3U3TzNCNzVqZTN1RDg3dDhWb2xvWXhzNkNQUWtaOVdwSytwUGJKZTJCVDl0Qy95NGpCOWE4RWxudkFRUEgvRGdSYjcyZ05PVFB0b0FsckcxODV2K1YwWnJJYUU1OGw0cDlqQlEzU3BuWHFJWSs0SGp6eGFSQVI5c1BnQlV6bWg3RXhHTVBnTCtvOHREWjV4eDBVanYrQlBkMTJwdG5iRDErNkc4UWJjMmhHWnNPUXVQOEJzNzd2T3hManR0dzlCSVk0dkFJamR3TnRhMndPRkZsdmFyeTdoQkU3dU52WC9rSzJjUEFHdnY5R3ArTDQyVE1DaDE2QmgwbkhWTXYzY0dBN2VScTZvSFh2a1crN1p6MUlqUk9ZRzUrbkdBbkxIUFNUTDZEUGk1cGNsQU1FZ044blpXOWVJRnVBaE9EaG1jZzRBSGh3RFhTaEtlZWgwcndoZkE3RGwzNTlkK290UmdFZFZ4enBtY29jR0xJeFBBMUlNMWowcmxFOVZ6YW5nbHBpNXBNNm8vcWFlN2lCYU9WQjMrN2xLMHQ2cTdyZlE4T1ozSkNsYzRUc0hRUjU2OGdLK0kxOUJNK2F6NlpHeXRmOWgydndVTkQyM1daK0xISDMvUzl2cmlpeS82NHZyczJlbkpGMTk4MWIvUzRqenp4eDkvWEh6bXJpaDZjRW9qZTd0b2J6cTJZa3MrT0lHbmJjcnFCTWNBbTI5c1hDL2twRjNTOUI4Y01UekI2WlVBamo4N3I3aktpZXhOZDJPS2pkemQrWTFCZEdqd0JCZGlLM3pSTk4wR0IxdGoya1VPdkxlMWZSVTk4Q3owQjNxM3ZMcExrdnI2NExlRnUrM09DVTVrcnZoZ0NXcytNR25veUVzKzlhSHBkSVpnNDRUdVVieU5wN3JZUzU0TnRUdHl3SXl4MkJaY1ZCYWtQOXFWODh2YXpyaS9mLzZyOHllMWFtN0RHTUFHT1NQTlNxNjZyZzBsblg3ZWVxamhWcmN6QWREWFZPb0JiS1dWUFRkSHEzU1FtTUhOT1dlZzZ2UnhWck1kOGJiMm8zVUsyTHpGTmhOUW1ReDBDZmlaU1BEVlpZSUV0MkcxOGdSM1pFbnEwNFhwZkU0WURNOTIydjFaUS9KbXRVMjNES1pwM3d6a3lBZkw0SUtIN3pGKzYxZ0UwUkhQSHVnYnpHMTU2MWUwSEtXQWIrTFl2TUVOVytzSHV0ZEZSNURZTlErYjJCek14U3I5TWRzNm81c0xIMTNaTG52STlwSEJ2WUxmUDFCYmJVUmpuMUQ2MFVlZjlBc25QdjFxcjVuOHRtTTV1ZlExWGNCM20wODVOaUF2SVcwT2piSXZuOFd1Z1FjL1BBSVBQWGhrNGsrWHV0UTBuN1VmNGpqQTlJRzJTdXNiTWoxKzJlSEo2V1Z2MWFpemNORWZvL1BreVE3UHBPU0xrUjE5QWsrcW5wN0dZWFRIcit0cmZvSEpmMXZvYmNlTkJoNzg0VGxVb1U4NjBJZC8xZEVsT0tGWHBsM2dTVU1OTCtOYlhXTHFwV2xqMnJLVzFRZU9OdllEa3hkL2xNNzVaZTh6UC92RjJlbnBaNHpBc1U0SDdiZWh4NTNCbUhBRUJoVDNKN2N6c2VlYndQT0pTQTVhRk5vQjNjNm5MZlBxY0J3Yng1RU80YXpvWS9LVFB6TDJ2V3Q3bWlaSzd6ZFhmWDNFL3h1RElvTWtIZHhwT2VmaE80Tm9uT2s0Ym5rODM5Ym5MQTAyWDhqS3hZVFRTY0JYZmRvdWpXTmRaUVUvS1p1SngvTEp6WjVwN0lwZlhqeWdRdzNUWmxPaVN1N1lQWHpITm5OUkExTW1JMEU1Z2U1a3RLUGFWc1Z4enVONDVpTkU3bkE0NVd3Ny9mNmZQKzgyanE3YjhjZDZmWnZqOHBBM3RyTnRSVWJhU0ZiMEFWdDFDUTdkVm5qSytBalMyMW9vR0dOeko3ZmZBcWNjK3JTdkNldFBaSWVQTWh6dGo2M3BRZi8wb2JxT1RnbVU3ZUhWYUdtV2tiTzJKWHhDbDNMNHJ1Mk1YcXVlNmdXcFNJYkZVVUszZi9zTWJHREg2WHJZREg3MFhQSEEzeFhnMHovdFZkNTFlWGh4VUJjWkswLzVOWklGVjJSZmFRSlp3UTBzZGtzL2dJZi9qOUk1bjU3V3g0eWVQUG50ZlExK0J0Ui9uS1ZCSHlQMUxXWC9CTTEweXJGUmRlSTRFeE4vSmo5RGl6b0JQZDRadkZadGVLVHo1ZDFhQzAxbi83cHVXL01UVnB5RzR6UmtwQVBUNFdqeFRjY1ByN242WndDUTdST1JhQTFQQTdDbVFxL3U4TVFmZmZJK1o5bDZWMXZ3RStDRTk5VE54UW1OZHJoSTRMRkdkR2pFdEo4T2NOQUlWcGdjbWhNUVkzZTRzNHEzTndtZnZsYjhLKy9RZzQyTys4UUliTVVoQjl6RkZ6ODAyakhSZzlaOVc0VWVjY3prbzlWK0taNHVKT0NmZlBMeHljOSs5ck4rNGVUenp6OXZHNmpQQk1jbjdkWCtrYS9WZTRpTzdDaE1XL1kwbVBEVWlYaUdidVdaT2pTQlMwVjFaS1J2c3gyR2o3WXAweEdlTFNwMjJXNWd1cjZZTEdOOHhsZGtrRWNuVWR1YnR2amdUV2FQdi82UXo3NTFzdEtTS1FSZm1ndXpBWnY2Um5ySEg4Y0dWN3cxaitTNC9CZ2JPTnBBLytoSGwrUWZvMGxkYkJjN0JDNU5QdlRSUlpvOE9VSnNnQjg5OEVQL28zUE9uOVliZ1BYdTBvZHVHVDJjT08wZnZLeUI3eWJHZHNaMnArbGJ0aGMxNkV4T1JqdnVBR1dPeEdTY1R4ZnFVSk9OVStiNDZtRldmZDhoMzYxOThWNmR6aWlIN2JhNGZqaWxlVHFpaGY2cVBoMkszM1VkM1Jwbk1BUGZxdnFycjE3VnI2WjgyUjBLMTIvUnBYUGZ2SjJWcmM2ZHlURGJIbmpwWktjZHBFODNoOUVUZFhNMnhzWDFSbC9YaFpPeit0TUR0QzRRYjJvVkRYY2RZR1RpSzhBVDFKTUxWd0NIcHl6Q2p3UFFyaDV3WlZPaDIzQjRpTXFXSWtlb2RoeGhqaldpRTVXRmJJRlFaNXc2b3RHUGpZSlBoMjUvT1NHL0FDTHY5cHo2ODh2VDgwVTd6b1dlYU9ubGp1SExMNy9zZldiNGpqOEsrcW1QMWRVUk0xdFFYMVMvakt5Nk82cGZ1bm5panFlVUlsZWZPRE1zNE1sT2NCUFVCNTU4bkJ3Y3VMbHRueFVsdmZlTG5FKzhlZ0VrdUtQSHZncGxlekJ5YmN1YzE1bGEvQWR2N0hselc5KzNxSDllTHJtbzg4WnNJSERjeG1sOXZQeGdGM2FnWjl1cXp1OUwwNmY5QTd4Vng3NlZsRzIyNzVIVWVXWHk2ZXFVaHZiYWFtcWRTc2JyMXpOK3dTMUVNcjdVazRYZnFtL3lhWE9SSGVyQjhCSHhrZWJPVEYwQ2VJTHR5eEpWdVByRnhUdmoya1dtSUFiWUVvWnk2Y095cnk3VlA4N0xSNjUrbXpFNitxUWZzSkxYTm1PRURRWHRsSS8rWVBCK1ZNNzVaVzFuekllSzd1bzhNeE5NWUlpRU5aOUJFcGcwZWZnZTRzMFdSRzVYcEJNNUN3YVAwUTFrdnkrbUEwd0NIYVF6cGRtejVKekp0UFVCQjY1T0hGbWI4eXdkOEdyZDZnS0NoODZkaVRGT0drODRCang5clZMaG0zUWludUFaSE0yakJoY2VCcXA2K0d1QWoyOEdFRnd5bFBIQlF4Uld2TmdMSHByVmVaTGx0ajMwaGRJODgyUS96aTE2NEI5K2dZMCtJOWZGN0NDN1RtWTROMDZtVlNIbkRCY09tQ0FsZXk1Nnp6b2YyNExWbTZJbi8vay8vNzRmQU5yRzhKWWdYdnBMaE1OT2lXUW5MN1YvTy9xTnpKRS9ZMGc3WWpPNGFWZnlVbzVlaXE5NkVZL29yQTJoU3g1UE9HaTA1ZENYTHJyVjkrRG94ZXJwQTE5eTRJWis5QjVlOHVOd2RzY1hYU0tIZkxRQ0dCcjJoUWRlaTl5R0JZZjhtNXVIemhmZEd1Z3Y0SlYwemFmdGdUVlMvUUdmdU5PdWRjSFBwd0JpSnlzemRlWXdQZC9GUDdwNFVTWWh1Zy85NXNiTHJTampzOW9rTkhrRGx1MkZWUjY2SDQxem5wTVpseCtWUFgvSEtjUllxMUhXZkJ1NUhHeU1MZFZoYXlkWUZZTWxtcmcra0dQU0NzcnlCcUxWUmEwaHV1UHpIUXVkWVVKWU1ZYi9PSXhad2RIVDV6bzVXWEx6ZllsNWNGbE91eVljSHZXL2RPQ2c1NHB0bFNOTTNheWVETUErMHJjNVp2THF3MDZOMTIwNkRNaDVRR2pBMENWNmhWL0swa3lleUdsbTlZYzlNakhYZ1FmR0hzR25OejdrNy91TjB5WXd6Z25PY1l3Y0syd3JsR0s3OGRnR2VLOWlabFhjTXV0SEJjaTFqZFJ0TFFib3dFU1RSQjl4WHB3dUhIU3ZYKzFsV3g0ZThHcnpsM1ZpZ3kzdFRXc0xmRkZiZC80elFYZGQ5NXcyQzNEUnJ6WU52TWZVWm44d09QalBlSmtMdXhVcCt0WFcyb0UyUDNRZzd5TlY2STBuNmRpaUxvUTFKZ1Y4eGRRTmJvMzNzaEY2NWF6aThWZW1PN2xDYk5DRitxTmVuVGRiMGFQeDhGcSsvaC9vbFdNRDZjZ1plV2tUbUxDbXljZDJqYkQ5d1NjODRSazdRbWprd1pTbmZyc3c5cStlMEZmN09GMjBvMHZrSkEydmxLVkNiQ2dQeHpPbzRFcGppK1RSb1RHbWJCSHEyOUJLZnhUTythV1RHUmNYdjN4eVUvdk1teUdsQm9vZ3Y5OHlUNmVCdTAwMXNOU3ZBN0hyaW5nNllCeU9sYTdKYWdJYi9HamluQjNWbTlXcnQ5WU0wSEVTbk8zb01hczdiMlRoYWQrWm8rQnM4UVJ6bTZrRDZVRW42ZTNkcklSMHFrNEdTNlRqMTE5L3VRMEl1bXFISy9RTVh2V25lQlFkSGNvSzI2QWVoNkcrRnBuR2FHLzVXQ1hBeThBaVI5bEV3RU9VTndBRjlWNFRUd0FmNXpDeTVLMVVSdmQ5djdsMXFjbGg3ek9UREN5eXdrODZGNk9adkd4S0J5OE5uVzdQQVBxSVpOSGVQTEVpWkROVTR6am9jMUZPMndVSzN0ZGZ2ZDR1WG1NUEYxTmJHeHkzRmZQZi9NM2ZWSDllMVZHNitqM0lDclkzOUdsMGEyRDlZUjhCLzlSSndjWDBqM3I5R2R6WVZUbTRsZWs4WEhRQ2U0VnY3Qk9IQ1E0dnNyMlNMNCtmdnIrK2RwUnlmcGNQTDFzWnd0U1BqVk9PRHBIRmJqdXZjU3B3d0xJZEFsY2ZISFNzOFFDSGZ1NkNodWZENzRxQUpVU1dOb1QzY1Yxd3BIQ2tDYWxMZVUyREgxalRiVHhpcytxZHJzNURlbk5pRGRFMXZGS0cwL3lXRkl4ekJrOEVXMm1OSDMzSVhvbnBVN2cvQ3VkY1J2encvUDc4dC9mVm1UTVdaa0RJeDZpTXNRYUdUd1FQWGxJdzc2eWMxdUY4ay96cXNoeHo3UWMvcjdmSmREWWo5N2xhdis5V1o2YzVYRzdPVmtnbUR6eU8zQXNOUFVES0k2RkxCemtUZWxxZkZNemdkcHZjOVRYUndPcnljc0NuajRCUDR1dlgyYXFZOXJhTW1remhYeTNzeWVUSzdlSGI2TFh2OTlFNU5sajFDcXltL1dIZ2diSE5HdEVrcUZjMkNKTnl6cG5NdVN0d3EybkZCci9menV3SmdtOU45UG9ucEE4YTF0dEk0RFZaYTNKeHpHemNOcXM4M0xHOWk5MStwTkh2TjBablRsS0VpNDQ5Y2pGMFpNNERRRTc2K25wYlNkZWRDVHp0MkhXWnR1Y2lCVjZYcm9QOTJGWWtzOXRXR2lzTEt3elBSTDlFRXY3d0FpZTc5YXhuQTFyT1p0M25kUzQ0KzlKMUkzVnlWaC9ISDk2Y0pqdnNqdGxLbHE3cXlZaHU1RVJtdDZIcXlFMW8zY3RucVVPZmRvVXVPa292bm82emc2Y2IwZWhXUE5BWisxMVh4TkxRNG5Xc0QxcjEwUWxPNjFJcG1ERDhaNHlnTHcwYmZ2aEQrRkdJTGkydnh1UHcxMTQ4cDd5U1JFWmtIdGV0WmVOSVNMdklrQ2RUMmpxMlRYSTNNNHVWWE54KzhNNzVaYTJhNjhyK2thbkwzTk9obVNCanFMYmc5a2Y5NEl4Uk0zakFwdU5tSURQc3JNYmNHcnR0OXBhVWZlSjVLR0l5ZUNnNC9HYVN4QW0zcUczdjArb2FIeXZscjE1OTNaMEd6MnJrdWg0NldiMlplRmJrSEFRbjBzNjBPcmZXVVNWREo0L3lWcU5XU0YzbFFsQ1RWZGt0THY0UGFXdnliaWRLMm1FVzNvU3hDWm5GdWZYUElES2cyS09qd1ZVUDZMU1BveGg3ekdER2I3V2JPdnpZais3aGtjRlBienhzMDhUMnZiS3VWYkNRQVIzN2o1NDFvVXNIZUczamNzeStZc2IrYzhHYkIxeGtEZjA0UjNwNDAyL3VidXpwMjR0MXdYQVJ0RWV0TDN3TWZuNFpYRCtRYThVTVpyWGo0Ui9uM1RwdnlzQWhSNkNQTmx2K3ArMXBGMzNtTG1yZTBHemRsekdIVDNqSXIzWU5YS28vSTIvdXN1YU9pbjF6QVh6eDR0bkIxcm40YWJjVk03ayswaFNlN05KOVhtMEkzN1ZOTTg2MjhiQmRQTm1tMjFsTTBHZ2J2ckdMaDVEaElSVUZOUFFvcXBZWjIrQkI5OWlra2IvbFQvaUZkL2drQlU4ZW0rT3lPakRmZGJITmRWb3ZQV1gxck03ZGRPZ2pZMVhIblNkNFF2Sko1NkZnYWlmVlJqd3pMbU5yc0dOWlAyam5QUHZNOTFjMTlYODdqVGR4ZEZJTWxzbWtuRW14NTkzZUpLekc2d0ZlZyt1eWZuMlp3N1QxTUlQTmxXOEdwRUUyRCtUY1VwTXpFeFcvL0txMUx5TE9wSmdIZnpwTWlDejB4YVlHaWRkdEhUM3pxakFIcUhNOURKeUIza1RiSHp3eVNUSlJPUU14RXpyOFowODM3WjZCYXJDWVBIQzhzaXRQUjZsQnAxMTQ5UVdpQi9YRFFZVStPcmc0bUtnaWZ1cnlnYU1ld051ZVh1dFRxejgybWpEOWtrRXVYZU9HMURBOGU4VmNYVFVYeTNGU0hHM2t3bGZ1ZnF1N0hCZEV0dVNFYzdHZ0F4bHBHOW9QUC9UdGpEbFJvOTNheFJiMmUrU2pILzd5ZUxEVElXNjM4cXZ0MEpHeE9xRnVmOUVtaEs4MDlrTVhQdm9SRHl0VE9HbURlbmxSKzRTeCtWeWN3YTJZeXpLdFAzeDhCWGw2cEoxZDdwcHBXMDdPOUhpdGZvVkxOM2dDT3ZudWo0TWQ5Z2ZQN2lLbWJ1OUxkUGpnU1E5NUFWNUNZTkkxcW8vdThxbVRGOGFHSXlzOGR2amdGOWFHUjI4WEJYM256bTEzaSttTGxWYitzYkRpcGo2eTJTWlJIYmorWUxmWURIM3NMNzlyRVc0L2tQU2xmZWI2R2Fuemk4dC9qSUdrOWI4NlpEcFBQaUU0S1VzejhKS1BjUTE4RS96NXMvYzZsUSs5QWNQWWpPejJXcG1oUFZDUmNzd21sM2hhZWJnK0hZaWVremRRT2QraFArc1hIblNpeVloWGNLeUNzMnFrWC9QZVpFODc1MGdZUG1UaGtjRWNYZEVJN1hCcVlJN3V3MHZkVFowOVZxZmQ0UW1menMycmNPQkZOaHg1OVZKSEVYTWhRMGNQZGFJUTh6ZVBqYWE0SCtUTjNjZndEMDkwOElWU3VRcHowU0NibnZTMStwV25JMXpsN3JNNnNVRWZlWGM2TnpkZk53NDgrR3pFcm9LTEx1Y0RYOHFPc2FFejYzaXM3Y1dqYlZLMDBZTWpGTHA5cFlkVUhaNEhuTVlZbThZMmFTdHE3Y0dYYkNHMDZKODltOWZuYzZHZVQ2eTZpSngwSFh4NkYycTN3ZFlWZnZUd3RpZ2UwVmxiaExSajdKa2UybTBPSjdhbVU4WUhudlJHTHcrbk5uNjZ2bld1QzVVNlR0QTRvSmNvQko4K29ySVFuYVNKS3h5L3dLV2hremJQN1ZyZithMTl6YmorREU1a3pOaVoxYk0yMS9ocy9JM0JBWC92ei9BNVR2Rk5ZQi90V1FNOUJiWkt1dHJob2YwYTVZZjNwNHp3NGRXejkvOHhBMTBMVGVheit1TnBMQ091dHkweEdyd1kySlpBdnBabVZjYlFWbURGcVFhZFBVZmZ1K0M4WmxXV0FXS1BrOXpRNENrMDM1THQ0WWlQRVFWZmgvVEFySTZiQVRlclAvMDN2K25uVlduYkp0UFJPdE1neDU4dWdyYkE1OUR5ODFBWkFDYVFRRVk2djNVcEh0ZHY5cjNXd2JlS3VPL3oxZlM3UlZPRFRGNDllb05PWGdTM3QyNnZ0NGRsbFdjRlVwT3puSmd2bTNubzFyeHQ4OWgrS056bVhid1NQSlF6cmowaDcrOVBGYmY1aHJaMEJqSmNkQm53YzJ3eDh1WWlNblZEKytSMGp0TDVvZEduZFRZM2poWWZ6bW51UWppVGNWcnM2dGRoWEd6ZmYvL2pnNE1tYzhiTEhFTzdySmRubE9jdWFYVGl3RXRxbi9ad2x6TjZ6cGlKL2RHSTZ1Z1NSeGtZK0Jxc2pHZHJxZ3hqM0ZSZktQZFo2dnF1UlBWb294c0hiS1R2alJNWGQxc3dIcGlPVE9PMXpzaFg3RkRzTHM2Zmw3NXoxalp5OVNzYm9KRStyV2NvQXQ3dS91REplOUFvNzNzeDhCckh1WDRYMXZyOExSengvSHgrQ2NWRjZ2NkcwMlhyakZmNDQ4amhvdTNuRFRWVW5VK21nLzRUcGcxak8vbEQ2SGtNWVNCcFI1ZGF6RzVQWk9yWlVDcDZIMkZzbUg3WitOUVlIYWI3dGdhNnlFNktoM3pyWDJuekwxakNuVjhabnFrM2JhaFZlZTVBMkczOFVlbFY1OHp4NkY4N3I4SHZzeER1V24rUUsyZmJHVFg0UDRvUnEvbHRMdzdnMEpNOXNQZEpEeUg0aDdRTUp2U2s2QlhaSE1vM2VhMnNMczZ0eFBaOVp2M0NNWmtnOCtCdjlqL1JNMzQ2RVg4ZGVYazVYelF6dVhUV2RmMmdHSnpMZXJoSUJpZnZhSmZCYmMvWlpMT3k0eUE5K0lFcjRDVmtBQjMwTHpueThQRVhvME1URkxrSm1RQlh4SWZ6eU8yMytwVW5lV0pXajVHLzBxUGhmRktuSERwNXVLdlRBa3VJck5EU1J3aDlVZzd4R0k1V2V3VXJkN2haQVdzVFhxRm5TL2pLN05JVFptdVhPeFIwcVZNZmUwdkJ5WkhuZEFSdjR1RVIrWncvdk1pQW81eTR0cE10eE5nVTdrMGRzWXpPVW56UjZCY1JibUR3clVnRk9zQ2JpODk0cm5Wc2pNNWwvMzRtc1R1OXRBOHVYZnFDVTN6U1QzalRYWDF3QXZOWldtRWM4TWpzZkRsZFk0eHUyZmQyeDZjOU4zV3VuMHh0U0l5dFlyZllhSGlINzZTbHlsOGN3ai9weW1DWE5meXJOVjBkWFlLckxLeHA4dUQ0REs5OVhvTEhwdHJNZnU1azBoZXhnMVJnangrY2MzNVoyeG5WOGI5OGNuYTVIWnRqb0RIVzNwY211MG01WGRhVXVoK3kwaGdEbCtXcVpweGVCbU1tdXRUWjEwemdEQzU0Z2pLbm00Nks4WFVpR3RIdFV6b1ZYbmljbnM0a002akJPV0o4UFpReDhjYUpjT2l6d3NCRHZUUnk0SmdRa1UrblZSYThjaE9ORHg3NThNTExOeVFpVHlwa2dNRlpIVHQrSWo3cVJMalJxZVZ0ZWdZdmN0RUVKcCtRMjh3VkZ0MGlBMjVnK0syUkEzQVI3UXRwNVZkZHlJc3p3NSt6MHg0T1Q3K2lBYk1hRFIxWitvZ3R5SFRoSE4xbXNsa0R6SGpJcE40dkJORUxEMkV0cisxYjY4cUtCM25rd2hPMWk1NTBFRnhJd09Gb0Y3dlRrZjV3TWtaWEhIamVEQXpQcFBRS0RWajRrU2swWGZHMGVIRGlwVU90WUNmby84eXBjc3FsZzFlc3gyYnpnaFhIaks4US9yRXAzcEV2OVpuZHg0SzZDZnRZZVF6dlhUQnlkeDRicDAwbkpmTk1pSzdSYVdDUlBmcW5MWERDVXp1RXNHUlBrUTMxQlpwdWN6MDNncXV2d0JMVkNUOG81L3l5SFBQbDVYdC8rK1RzN0xOdVhmMWg2RGFnSi85dDEzRnlEUXZTbHNZNFNZdndZSEFvNmFSMEFoaWpLMmRnZ2FGUFdXclN4N25wb05CUWFHVE5MMmxmZkpBUDdjK0FSdHNydU8wSW5WdnhPRHpiTFY0OHdWZG40aWtva3dmRytkQXREaldUTnJyWWlzakVWVWVlZUJnYzIwQUtmdXdDUjFoVE5NcmtyUkVzZEdqb1NWYncxY3ZET1E3RnFnTitxWWVQaDdKVEtIalp6NStYY0diMU9iQW5mZHNkNTR4UmJKUCtDRjlPTEtjdmZBYlVSWW1jY2I2N2pjaWxheUljWWVUWEJLdzdHL2IwYzJOVE4yTURIVmxDMmlGZDdacDZPTW1mMVk4dndGbnRvMjNHaER1cFAvemhENDJiTVpXN0tqeWlZM2hKSTF0ZTlQd2pzSlpiRjRQQzZ2UDl6dml6ay9yZ2g0ZjJhT2ZoT1VwZHdLeUt5YlRkZHJCTDJXTjBuL0ZwSlczTEF1eW10aFFHZjcrbzAwRWdod3lMbHpXQXIrR2JJMmF0L2ZiODJ1NXY1TGV4eUhkRVp1eXdjcVcvRUp5a2RJYy9wNG5HMW1DaS9qdUV1bERoRVQ3Z1RjYysxZTgvS09kY1YvTmZuWjJmOXlkQU0wRDZnVkZQSWwycHd5ZWRxK04wUHFNeXlocGpLSFVpd3hxUVZpeFp0Y3orN2t4T2UybFd5cWxqWERUckFFekh4SG5hcHNna2J0NjFIUkpkUW0vaTJaODI4ZUFxdzVrSE9uUGJqVi8wVFdkckMvbUJyMjFMZS9LeVJweFpiQVpYZm01RngrbmlFMzdxVmpuQkR3NStZdkRDVjMxa284RWplcTExOHNMNlRHREZtOW81Z1VFTzIwVW1IWlBubUszdzFLK3lvaTlkMkk1ajVvZzVadDlwUmdjMi9iZXY5S0k3K1hqb2E0R1oxZGxEMUZaMUkyOWZDZUlGSndIT2V2RmNlY05SajRidTR1Z3lreGFkOHJvdG84MW94TmdkREY3NFNTTm42SDMrZEM3ZXl0RXZlUmM4L0dKUDlIZ0hUNTEyR292R3F4U3NRem1lUWl6OFhIaG5ydm5lUzc3cG5ENkJqMmZpTU5qSFc4ckhhVVFkdzk5VlB1aTJJZWlPRlpaODB2RVZveHNZL1pKaUVkdkt4eWJ5Y0dLbjR6YXBUMkJYZlF0Zm1vc2hXdkVINDV6dE16OTVVai9RV2tIRFpuOTVOWDRHNmI2Q0tQTzJuYWFURFE1Rmcyc0dXSm00NnhtWUlVMzBuRGRXTmprNVM4WVZCUjJXeVdUQ3R5NVZGM3lwVGpDWTgwRWQyeXNtM05mM3I3WUJPcE1LSHdQWVIyTUV0T1JJNmVHQ0VMbnE0Wkt2bnM1UDZnZEF3Y2dUNVJQVU4rK0NOZTQyT2VVVDFOTS9QTU0zN1YzNXFSUHBMTXJmK3VCTjhSRFI0SU8vdkRRUlhFQWpILzVrQzhFRFR4bmVzNnNYQjVuaDBmWDZkVHVtQng1NmVmMGw0SzEvckpyWm5zN2UrbU5YQWN6M05PejcwMTkva2QvdDNKNFJjRHlSMnpyWGc5VG9pQWViUjNac29pekFNNTZVOFF3ZXZkSnVNZ1V5NE5PRFhnTGU4TURscFhnRVZ4cWU2aExScHM3NG1hMGovVGJqT0EvKzZPdlppVUEvWlR3RWZJY2YyOHpLM3NvWkRHK0xDYWtIbzNUT3l5OVd5OW8wNDJGZk1hUERjdzNhZGd4TGZmUkkrUzlKUTVzMlZHdStRUjY1VzNPN1hjRlBpb2hOMGdmNEpvS0pIb1lIWDEzZ0VhZ09EN1pTTDJVYnNma0g4ZnVlMXFUNzVlbVRzMTlybUtmOTZ3T3ozUWt2SGNHeExYdSthVCtESlNUUGNBTGpNYWJCMnVWeXFtNy9xbHRxdGxrbDFLMXFUV1piVmdhaGxVMTR4UEFwU3puM21aamJjYWs2ZHd0dTBscTlHZkI5cTFyT21Wd1hEWHgxOHRuWlpkWHZFemtkakY0ZTN5ZmJiUm1iZ0l2YWt2eHRQVTBPditQQlF3WkhJTzIyRnMra2NET0F3UEFqaitNVHlRZDdXN1RvNGFLSmJEUXBKNFVmT0pxUk96cUhYL1JPSDVBbEw4SkprRThNMy9DVWNtYWNzcGN3cEhBKytXUStubzlPdTl0K2xkZlZhS0puK0NxRG85WHY4aDdjcHA1T1FFTDBUaHBlK2o4d2VPQkptLzgyU2ZWUjVLbVBidWpCMlJlT01ybmFSNCtzWkdOL3RPQUowUlUvZElKMmdDczdrU1NFSnZqUm1icVJuNHNGeDF5dnpYYTd3UHdVVzhhWVJZWThoeTZnWFdNRDYwLzRWeTZneGxPQS85Y0VkUGdtREIrd1FFYnVsRElXOTdyUXIvTGx4ZTc3SGZXZ2YrUUZKL2l4cC9yWVZKMStVdFlmd2c5bTVWeEhtai9VSU45RUVEUnlqT2FxTkxQazBCRzk0alNacHJQM3diQ1g4WGlYY1JteEIveHRmVmF4UW93dHo4Z0dZQ1k5SHZRdzRVV0RQckJNSnRzaGVGUlhkUjI0ZUgwOVYxQ3lKdXdQQkdzYWxheTVMVmNYWFRmRWtWSE9XNGpNZzk2bFl3TGRNcmd5ZU5LR2RjS0NDZlNVUnhQODhGSVhXeHp6REQ0OVJiVDBBUmRYL2FPbjMxc0VEMCtwY3B6eXlqTU9DMDZjalh4bzRlb1hmY0FwZS9QU2hVL1pIclB0RENuWjhNYitUcytNdzBLL3RwL2pvUWRaOWxMVnB6MGx0a01lMUNuUVcweTd3Y2dPWENwSTZReXZSdE9oUHJaT3ZUVHk2Q0pQWjNDUlhqN0RxaTFvNlJlKzZzR1U0WW55NEZKUjI5dzF5S2Z0Sys2cWowVUVIZm9Udkc5bk5Xakx6cmRWeUVmdm1KeGdMaXFIUHJxbFRGNUMvR2JxaGo1OHlqWTdha2dlcEdsbmdQZ0VKaFVDQzg3QUl6blFTWTl4MDdiQVl6dlliR1hObGdCSFRKaDJQdXhmc2hQUi95Q2M4Nytzb04yTXBYR013RG02TFROb1JGc0hqaGJOU25jR2gvNkpNV0kwYVFiUHJNQU5YdWQxNjZXRVdxMCtPYTNWYnYyMm1zOS9YdFN0SUNPYkdHS2NHWjdaZHBBM2VFM0VmTk9XWXhVdElPYXpnN05DcGJkTzhWREZxa2ZlaE11Ukd3OWdUSGh3WTNnZVdNMnRMdm5vNlM3LzlkZkZ2TStCN29PQ2ZkUUpjZGo0Zy9VRUtsMHpPVExRWWdzMHNTMVlJank4NkNTUUlkREZiYXg5N2ZuR3dtekpERjNKcTBsYUtBZjd3NDl1NkdQWDZDRVY2SkI4N0VNK1o4TG0wdWdNTDNuMk53NjhodjFQLy9SUHJXYytEUFRCaDc4OCtXOSsva25aK3J3Y2Q2Mmt5NUhvRi8xZlNRZDNNL0o0ZUpCR2pqQVB1YWIvOC8xZ2VsbDF3cVdETXIxak0yMmRjYkcvRlFjUFRFZ2JiWnVrREphSUgzeTJKbVBYWmZwYVBWdk9PWEFPSVU1Z0hDLzVJanE0R2JkZ3E3N2w0c3NHRzMwZHU2dktZbFUyYmJzVWovclg5dWdUTGRYbXNodTV1ZWo0YWg0ZHRSdGZ3ZS8rZGF5N0RZSE1oTmdnK2xXTFUvVUFEM0JzTWRYeUNlRVhIbXM1T0VsREZoend6bThxaldyOHljaFR2OHJLb3VvWXZ1T01MMUovYUgvWlFuMjNkVXpTWlRaYSt3TE85OTQ1MjJ1K1A2K1A1OS9lL2VidG0zRzYwOGo1WmpKangxankvVytzZnVqd2IzUU9hMWJndUdJd0Exa0VFd1VmUE1JN3ppMk9nT0VOZUoybi92NSticjA1WnpqWml3cytYcTFiNlpWT1ZGWXY0akU4aCsrMForcmljT0ZsWXBnd3pic08rVXNUOEp4Sk80TkdPYnpsRTVKUEdyZ1Uva3FUc3JxV3VlaDlXNjkzMDF1RUZ4MmxqZHZuemxIdWc1N01SQmVqNk12Mlk5UGhoNmUrRVNOakxlUHBBbzBYV2ZKV3lsS1JqVnk4ckpaemdhS2pmTnJ0bDNLcVp3NzZNR1hxMHA1ZDE1bHB5dXFTMGtNYmhMUS9OUENpZTFLd0JHMU9PVFJTL01JL05vRW5raEduSFQ1cnV2S0JUMjVvMWFFSEU2UmdDZXFDSTMxN3MrL1o5NWxtOU12WjNUam0wS01KUDd4dnQ0dVBlam9reUFjdmFlb2VsQmZkanVzZjRLWHlMMHhYblI0ampZemdTZGU0M2JBZmJLYmZ0RnVmZGF4VFdITnhtL0dodnkwQ0JMamZlK2Q4ZjMvNVVYMkE1emMzMVppZWNOVXdLNGFhc3ozUXVxWGJueDVjSzZEeU1YRFMxZEFNRmVkczBxNFRBUnVHTmdCRkFTMmppc0xWMWF6aWZFK0NibTdEZE1DOFpsdE91aTRtQXRsb3BQQ2tHZGpOcjV5NlVPSU9lRmJqNU5FaERncGRCZ2RZbnpQZEpoUjY3UmZUeGlvQmQwQ2J5UmNZSHVCcmlFd3dzby9seHg3ZG5tWGxodzlZMnFYc0d3YlJWd29tcmpyR0xuUlpBM3gzRWZvb1BDSWo3U0NMZm5od3pMWXliR200NDFEMy9nY3ZUbjcrODUvM2cwQmxmT3oxb3lmdnF6Zk9NYTlTcDY4aUIyOTVkUEJYSGNIYnRVdVhDUGM0ckhaTWZmTmRtcXljZHFIdit1SUZIMzFnY0lKSEgzaXBEKzlHcmo4NUFoZzh1R3M0cjZOOGdVbnY2aTNBbkZzbUk5c1d4aUlaNFI4ZDJGUUFiL3BOdDhDNmN2a1Qrb0JXMllGSkE2L01DajdrVTMrY2hqYjZGQ2ZjRG5TSHpJSHY5RlgwT2s3eER3eXQvR3FIZm10MjR3WFhPR1JyZUZLNGJHWE95NFB4TSttLzc3MXpaaFNEd0lGMWplS1lHUUlzaldRTU51cDZCQlhBQnI1ZnphZG1uRTRNeUNGbjFRWVd2bmpaNmhpWnMrSmlXSVoyV3pjeTVoeHlWc28rK2FrRDhrR2gyMjN3RHU3T0d3OXlkSmkyWkJCRWxrNTJ5eGc2UE5IUUx4Y1J1Q1lYUHZDVnBYZ0pVbHNMeWF0TFBUNkpqVkIvbEJQb0pZQ1JMVVpYY0xKYTc5cERCNGNIbHBqMnNHM3lvWWNqTDliTzNXRkFPMDNnYUpmZ2hJRXl4Nnk5TFV0N05ybkg3VkN2VHpobFRwcXR3RjQ4Zi8va1o1Lzh2TTVEWDUyOCt2cTZQbVQxcHAxenYwcGVxL3JoOTNDQ29vdWM1SlcxTVhxREMyd3ZuM0xzQkRmdzBFblhnSmMzRGgrRGh5YnRJRiticFFsc0cxcHBkRkF2SDUxbjY0UERBSjlGQmRoNnl4NThOUElaS3lOenhpbDUvWnAyWGZEblFlU01KN0sxT3p6U04yREhBVTUwanA1ckdueDRIVGI4WTdxMXZjRk5tcnFrMythY2o3b2s0ZzlwZEpVbUhpb3JFeGpaNlJ2NVJEOTE1Z0NCYmJMNnJrUXRWb3JHbkxFRlcxdXAzMnZuL0duL0h1RGQxVzI5dHkvTWE5TTZmVlpMNnlIeVJxZy82U1JsM3cwK0RwbGcwZ3pnT09nTUtBTXN6aE9lZWs2Q3N3aE5Pa1FId1JIa1oyQ1A4N1gzcGc1ZlVYN3F4NGtHVmwyNzhkMEhMLzRjRHRsMDRYalF1cEFJOHVjWDQveWlVMWZVbnd3TytnZ3BTNFhvbkhJRDY0OHlIZFdITnZncHB6MXdUMnVBQlE0di9PQ0VENWhJeDZUYXJSMitzekYzR3JPbEZMbGdXVEhqSTZTTndRbGNIYjVzWkR1RHpkVGg0YWpjUEJ1NGIvdVJpdzg4Tk1yZXdtUkx3YmwyK2FwcUhuaUtZT1RxQ3pSQzJpSVZZNGUwRzA1Z3djZG5yY2NiVHRvUy9LVG9oTWlLRFVPVE1welF3RjBEZUdMZzJoQlk4T213dG1Oa3pzVUhuVEZxRVpxWFVNWk9JeXM4d0FMSFAvQ2tZTTFyczFsVVRYMVhrclZWRFBiZXRwWCtNZjdodmRmUjc2RTlXa2I0YndMSUMrK1ZCOWdhVXhmOXpqYzdncS8yMHkvNkZrdzBGcU9UT25sajZYdnJuRi9XMjRBbkp5OStVWi80NjVkT1hPMW5jdXkvNnhaalNhc0xKOW4reG9BcmtGRmlzQmdyaHVKOFoxVzZmOCtBSVdOb2VFSW1xenlqcTY4aDIvQU1CTGdtZ0QzTnlKUFNTUXhmUE1EdkNtWlF6OGVPQmc4T1BsSjFxMXgwVmxVT2EzQkc2dURoRFZlUVA2OEhZTkxvSTAyWlhIUkM0RjNZL3JUK0M3L2c0Qy9pNDdaWlNIdFczbWx2OU1JdmVPcndjL0U2THh2Ni92TFpkcUpGSDdPcmp5a2xqeStaYmF0cUp6N29CZkRzTThjVzZQeTZ5Y2NmLzZ4NHpVZU1uQXh4K21WZTE2YkxQT0IxeTQ3ZjJIZjZ4OG9tK3BJcGtBY214aGFPbGRFdEFXN2FGcGo2dEJzc05zSWpNZkR3a29xUkxTVlhXek1PcE9HRlBqcUZGaXk2U01NanVGSnRYL0VuUCtQUTZyaGxiVnR1dC9WaGYrT2NqUjJmeXhqQUovMlJkdUtqdmxmYVcxdmdKVVJtVlhWUVhrUEtLemp0Vy9Ia2Q5emhFVHpwbndxaERVM3dVMzRYQzNRZDZ3RXBYTFpOaUZ6dE4vYjRyWVM1RXpJLzlXY3QrbEx4ZlV1cmtmWFN5ZjFuMDlnNExJTndKbWZmc1cvMkh5T1BvZEtoWUFiTEd2Q0tZZVV6WUUzbVJKTkFRTXZBVWpRR0t2d01TckRrcGVvdDFHY0N6MlM2cStNYW8vK3F4WjdQWUxiOW9PTnlnaU42Y2xJbUEvNXhDcUVoMyt2TlE3ZXNjQW91NEJIOUlwSCthVDk5OFlwKzRJSVVURjBHWGZpQXlSOTBxQytaaFIrWWdDWThHN0RCb245dzRGM1UvcTgycWxOMmNiUW5MRSsvQlB6SUlWdGtrd1NPMlQ1ekhnYWlzMWR0MVN4bEgzM3JleHAweENmOGZSRncxVHN5d0xvL1MyNTBRNU04MmQzdVNvL2JxZzVNak4zZ0NrMnoyVmZabnVWS3YrTFJnVXhCS2dZWDNtcWY0N3EwMDdjeFhHanMvZmVYQlRjN3FuZDIyd1BzOUdkNEtMTVp1K1pEVC9BZG5ST01VZlZncXo3b2hjQzZVSC9TNXBTbGdXMW02YXEwUFhqS2RCVHdURXg5NE5LVlZoN3VwQ3YydS9NUGFZWVdkdG9ZMjZ3Y0lnT3RtUEVOTi9qb2hlZ2VlTkx2clhQMnVNMUFzVGRXNW05RHVkSWJsQnl6aG05YmxHMkEvRm1OZG15Y2RBTGNHUFI0d3FFUmc3czZEM244QmFtdEJvYk9PV3MwOUxNNms4KzJCcHpJU1NkS28wTXRuUThEQ205MUpvUDJ6MHBsUHorOU9tdDgwOUhSQzA4Qi9QcE4vUVpXQlhYS3dxN2pPUHpnSjRXai9XaTBOL1pZVTNyQnY2Mkp1Z1kwcXg0K2pTaVFqUmNhRTF2N09Nd1Azdit3MC9EZ1REbFIvUE5nVHgyZTBVbWR2SUNYUGhEYm1XeE9nenk4OUlXamRiWTJPSDYwYUFUNGN3SmhiRU1mL1FiK3BuK0xiL2I0NFpJZis1QXRMenIzUzFiYURGY0FFME16MFAxdjZJdHRCL1Roa1R6NnlFb2RaSG4yRTlURFV3NU9lRXZiTVZlOU9ualM4R1FMMy9PV2l1cEZObU1qNDZ4R2NOY05UWXZzTXQ3aE5kREgvMGFYdFJZc1ljMC9CaU0zN1ZJZnVjRmQ2d0piMDZuZmpOd1Z5VThhK2ZEQ095bjB5Ri9yd1NNWGJpTDQyaGR3c29qUVArcUMwNW42ODcxMHpwLzJYclBHanZvYXFvRUhROVR0aEhQSXluc3dhYlpTMlo3anpyY0RRaCtqU2prTHQ5TldGUTRkN0Q5bFpHVmxiN0VjY2RsekpzSTgrSHRkaCs2YlY5M09HdENsUWIzSzZqamUvZ1JXUGIxMHJGZGxuZVR3NGt6LzdrSEpNZmpUNlhoZnZ4bG40ZHZSSGl5ZVBxbUpVbGNmVGtLSGV1aDMvYVljVXJVTlhaOHQxdkUxZ1NxcFlLSU1YN0xSd1BON2VMWkpHbFp5bWtHalYvdUt4aTdRM1hZVXp2ZURud3l6NW5WZUt6cmZaTDZ2eVR2bmdVdCt0VmRrWklzb05HOXJtd0QvWWV0MlRaL01oQnBkUExSaVQ0N0IzVWs5cmI2WWJ3aDc0L0swdnVkcjM1bTlPSkw3dTNLUU4yeC9XYTl1ejRYUTJYWEh0OWdqcHdiODJuUTdrSnN2VGw1ZGYzbnkrUjgvUC9ueXF6LzJTczlldGVOemJpZWRNL2VqclhOK3ZaNGJMRWViUE95MU1xU3pmcUF2ZXdtMks1VEZqTEV1MTNqUVhOdFY2d1VaemJReHR0anZxdFNGVjNDVUc5NTJHUms5WnRpdS9sbmwwdW1OYytRUWRkZW1qNTlPcXN0Mng3ZjFIWXZlZ3RtMmhQVDdQQVNlTWZHMHZrdE41c2d0Tm1YbjBxejZ6aGlvYmJuK25VV1RoaE91L2ZYcTN4NmY5elgyenVvRXpQVlhmUndPWHhUTnE0WVNDbmk0MGF1NWJpZDM1ak9sWkJYUHVqT0ovWXFrY2FXdGh6N2ZWdU9CU2F0eVM0cTNmNXV0d2llMGtPZ2p0QTRMWFhEWExZWEJhL1FpbUl0N3FianhIemxFamJ5dFhhM0t6R1U4blFuZjdXbHJMQi9tNGcvZ2FhKyttL0ZUblRNNkZ1T2JzbUYvS3FCbHpuajdYanBucStacTVlK3FienJFMkp0cDM1bWtJOStGRUQ0TW5BblpSaS9ESGJaTGRJSkIzc2JjYjkvaVZOTTU2QVdwQ0k0WEhYb3dWLzcxOXYzbTZCVWNlR0pXa3h5OW9HeUFjRHdpUHRHVi9NRGdLbk4yNFNWOUxJRGpIeDJDZzIvQ1NodjR5bGMrYlpMSFMrcTJ1WTlmdGYxTTN1Rm9rUFpxckw1YnJVM0Rjd2FxSDhvRkUrWjd5RE5RclhRTmZzZTNQdmpnbzY3M1N5RGsrTUVBVG40KzhWaXIzcm9qK1BycnIwNisrUEtML29DUkxRMzYwU3Y5MGhmUG9oV2lQeGc4Z1U3SE5nazhiV3pFN1U5dzFRbkthd1JMM1pyQ1NUazhRdWRaUStwVys2Njg1T21hZHNGTEc5QW1CaGJlNkdMbjBrenhnQnVhbkRJeWx0bzJkUkdVVHd6ZVNwdDhVamlyekpVR2poQ2NLVDM4cTA0NFRzRXlGbU0zc0lUZ3A1d1VidXBXbTZnSFgzazVGZlRYaE9HL3p5bHk1anNtK3gwZU9SZTFVQkRnd3htOHlhdi8zam5uVDN2VmZGYjd6YTdXM3g2T2pSM3NkSUEwY2EzVDZiM0hYQStkSHB1a2pHaXdXcTNCd3lQR2pTTUdCeE9tcy9iQkJJWW11R3NlTEhSa296VVo0SmhNdnVybGRnZ08rV0JvT0dZNm9aRkh0OGJJeEFmTzhKNkJHbmx3VXBkVVhmaUFvUmNDVXgrbnR2S0puUHRiRjZseGpCNFFEdDA4cUpQSGM3WU01bXd4SjJ5YkFiMlZqZFJkaW84U2ZmWGxmRDF1SFBId1lodjIwR1p3cXg0d1d4bk9OZnU2SER1UlpldkN5amxPS1cxTGU5Ynl5SisyQm82dnRvcWoxMzd4dzJNTjVNRkpVRTVJZnExUFhlUkszWldzT09oRStvRHI5NlR5Q1dDSllNRUhFOWE2NnNrRHoxeElyZmpRYUc5aTlwK3pwd3dldTZROXlrTDBsSktWY2xkdWYwTHpiYkJqdXVOeTJoVWVhWjl5OHNkeTFuTHkwdUNIbHpSM2l5dnM4YngybC8yM3UvV1ZWMlRZSHdkWFRveVBlTXlXNUh6dm5ITk5zSS9xRmRMUFp0LzJvYWxpQ05EVlFHdDVoU2N2RmRGTERYUVQrTEtlcHNxTHRqSVlVOTVWTUFiT0FNbEF6UURsZEV4aWhvOTh0RUpvT1lyazR3d2JZY05CSDNoMGpYT2dTeWJPNkxmdjIzSlc2UEFXMHI2a1lPb05LUHBHZC9YZ2VFLzlyTURKREExNDZzQkRuelI2U3NtWFdrSFB0eFhZZVp6d2t5ZnpZRSs5eU43a05uN1ppU00xMTZPUHV1ZjFhOUxCNGZEdEY5dlNzTUpqaXpqbjYrdlhod2VBdVdoNW5kckR4T3d2NDBQbnRJdmNOY1IyVXUyTXJhV2hneThQWjRXRlR5NENzVVBnc1o4MGNsSzNwc0VEazZjak9ZbjZQWHFIVDFMdzBBZUdUL0RsYzFaZTNuYkc4TjFXeVpzY3RHdzhOcGdUR2ptcFVUVUgvZUd0RWM5Vmx2SWExSW5STFdsZ0thTkovamlOemNOTCtwZUU4SHVNYm9XdCtmQWYybHh3emFXSERscDkrbGMrSzJlODBpOTRUZDN3QVU4ZHZPK1ZjLzYwVjgwWGwybWdQYUhqQm83UkJoNmpKaDNvTi84eVNIRGtEWHFSZzRqamkzTTJxUmthbnNFUld2UnhZcXNPbVVqd3dDTkhXdjhiQm1lY3kvQU5EbjRtT0IxcVlYaHdFSGh4N09vOUdCUEE0SEpHK0tIQko3cU12T0VQdHVLb1U1YmlJNjcwNFpHNjhFV1RHQnpwWHA5dG5hMmRma093YmhYWnRkK1N2SjNoaDIvMlA3WEp4VVZieGo0Y3crbko1NS8vdmg0R3ZsOXY5YjEzYUxQVkhEM3hNem5zdDcrcExZMDVtVEZ2QWVKSEp6TDBYYUp5NFBKMFRreWJRaXROUHJob3hUVUVobzhRbTZZYy9rbnhFa0xYaGFWYzN5WVA2SUFUV3J3RnRORjN6YXRqR3dIOE9JQVpLM1R3L0dYNERwNEhvZjFkajc0VFdXSHVrdVlPalV6T0daMFEyWkVUZU1xUHBXbEw5RXNhM0xXYy9Kb21EeDh2NWFSZ2E3M3lZMkhWTS9vY1lOWDBRMzRqRHM4VjNvdUMzbU1kQjgwdXd0WkZtMDdEaTczVEw4WlUyN0gwN240NEdvZDc3Mi9Ddjl2SjFWVTliUGtzbjJic0gwUmNGSTdoZ0JndmcxODVkVWtEaTVIampHSzh3TU5IbXBnMzFlQUdocDg4L2lLanE1Y1BYbVJLd2VZQndlRHFLQ0VkRno0cDQrZjIzQk4wRGtZZ0Q1d3o0cUR3akhOV253ZW04dUczcGdWVjFYd2lKMjNBbHh3OFJYVHFCSG4xY1ZqS2EwalpoNER3cFVkUCtIcFp5RFllWGExaTM3NFpPbkpjYlBEM2NCUmZNYTlTZXhqMVpXMXBqUHozZXNXTUx6bWxXa1VQRG91bXRuem9sZHR5VGo1MlJidnFqemF3d05NMk5MMUNMcDRKY0dJUGVYTGdKSXpjV1VtR1g5TGdTTUhZTTJucVlyUGpWUDJxYS9DbDRVOWZPRW1EazM1TEdYNW9tdDQ1M0Q2TFM1ODR0cXlnWGV6bUxpRU9PV25yV0hkQTgrMlIwUU1zTVhLa2pSc0ZsblRWQXhqZXUvRERJMm5ZYUord3lrdWRWSjhrSE1zRGo3ekg2a0lYbWNFTnZOT3lRZDBYVHRhRnJFckdZWTNJaHBsZjZNVnMwYVh2d1RJMjB3NUU1Q1IrYjV5ekR4eGQzTjlkM2ZRVDBaa29qeHBzTTBzYUtoM2o3QU5GZVEzNG1PeGlEQU9IbzBzb2xBN3E4M0pGakNwTnpHMHZ3NDlqbW81U2I3Q0VwL0pjY2ZjT2lTd3BlckxpQUpRNW01bE1Qc2M0SHpJblk1WFpPRVZIZi9LU1pxRGlBemJwT0orMG1WeDR3YVVqM0lUd2txNzUxT09UTURqVERud00zTmg0MnU1Vjh6bHh3Vmx6Zk9pZEFwSHZVSU1mTHJybnowZXZMNzc0dkM5R1Z0WXpFYXplcXE5dWJHMVkxYzF4U3F0b3RxYUhQZXM0MXVoSFZ2U0F3eDZpdGt2UjlyZUpONExZaUM1ck93TlBHdHNwVDd1M3BsUTVPQ0R5U1pOWGpsM2w4Um83anVNSzNzb0huZ0EzVVRrNDZGTk9lNVhCTFRLR3B6YTcyTXhuYlkwaFkrcTJUZ2poT2ZhWXJhUFdxYlpBSGd2SHVzSVZBcGRmOVJyWm9CUGdCU2FmQUphNkZhNCsrUEtwVzlQVWh4NWV3bU93MUVuMzBienpmbEFQb2NhbzdjRUo4c1o2K20yZ2ROaTZ1M1ZNUHlIUCtJYlp0cTEyUjYvdmpYUDJnYVA2YWJiZk9xNlZxL3cwZmY2bVE1VFNJVW5CVXIrbXlZY21neGVkT2hNMFBQZ1hNT1VjdURkUkU4QkRENCtobFlVVkhpY3dzRG1tQlY4VVFtdHljQ2p3aGRDZEYwODRuTFBBU2FrRGs1SWJPckR3QXhmU05tVXIwbW5QM280Vm45TlVUZ2dQNWVDbExueFRsN1JmWmlpOTJFcWIyMloxUEk2dVQydFBuLzVpbk41WjVlTkliZG5Rd1Rjd3JLSmYxNjgxZThqbkZBY2M1ZEdqWHMydWp4VFpRM1dhdzBOQWVQUWxFeTRaNFV0WFVaMHd0bmpvbk5uZk1VaDRRdXdRRytTQ0dCNk50UHlCbjdyUWhzOXFLN0JqWGRCRko3UmljSTVwUXgvNE1YNW9WM28wWTV2OUltNnMyeEl5cnVZT3pjSmtkL2p0ckkydjJwckNVNURTRmUrVVUzZXNUeU5zTk9wQ2N3eFArVStsNkxYaG1BODZPa1MzeC9pRUpuaktZdnBycDVsMkJuK0hqNHhwZFVFZk9PaDlyQnpqUjk1aG5tNFhlbkxWQ1puTFpINHZuSE92bWkvdXJ1NXVIYnNxazVqY2RmdXJjOUxnTkU0RGs1Zkc4T0FKNlFpM3Z6TnBaK1hiOWM3WHV2cFZLdlFrTFNObVlpczdqOGlaV0dGd0huRXM5RW1RQnpmUWJUc0l5cUtnL3ZKeS8yalBPaUhUUVNhTVFDWlpkSEJoeXNybTZVVjllS2ttQ3pnNUp0ZHNsY3hlTE1jWSsrQ0RyeWl3UWJsenVlSlJrMnc3TmxRVUJTcTcxZTF1NU5NMTdTRkxuazU0WjBCSDU3VThkeGdqNDd3K3I0cFd1S3VQQ3ZsdTAzdlA1MlFHT0Y1c0k0MmVQclY2ODdiT2NkZVBEcng0TVk2U1AzMysvS3JsKy82eUZiUHp5SFJsZzYrK21oZE9qQkVYVVdkS25hMWxOM2xPL3Ruenk3TDl4Y2w3THo1b25VSnJENXYrcDNVU1NEUTJ0RlU5bTZzVHdaVHBTZWUxemZUUCtGcHREWllBUjB5N1Y5dkZCcTNIWm5lNGtVRTJYdkQwZmZmajl1blZRaXZkeUxjaTVqUnRTM0hBK24zR0pwbDk5K1dXdXo3R3I5dUxaUWQxYityaDZzbnBiYjJrYzFsdG5IRWJtYTFEblRVM1JzQzhSR1JyWTQ3OHVldVpJNUNZNVVjdjZBNVhpRjFhNXdYZWJkM3NBeis0c1V0ZzRQTG9nOU9ab3ovcUkyT2xEVHkwYXgxWTJubmd2NnlkRDdCTmR2TTRxV2NkcFc2cmZJQ1AvdXJ6K3I2K3lJS09UZlZkZnk3Z3BPWjNqY3NSdzQ1MTU3ZHR6YUgvWGpqbk1xS1BHLzIyTFVIckNneDViTnlVMHducDlCaFd2YmpXcjVNTDNBRi9nN1RqTnRoV1B2SjU4b29YUFF5aTZMUHlqd01EUTJleWN3N0RnNU45M2ZxZ2g0dUhvSjVlY1k3S0xnSXRveHdxM0s0dnh3U21uSUdNbmp6bDVNdGExV1p0MzJaaDQ4eGtpUzNncnZub0RDNUVwK2dPRm4zUkNWTDFDZXJCMkRKSDJEZ1BZY1dEb3ozd3lFMzBrRkNlSGVwa1hMY0pMbGhmb0dycm9tMVM1Y0MxTzg3VXhTZHkwS2dUNFdZbExZL0gyaFl3MGVwYllGOFJqYUFPWC9wS2xmR1hwczNnNllQZ1N6UGVVbzlPZ0lzV1hBaE4rSWIzaXVkbEcvVWkydkJhYWZFS1R0SUNOTXlIZWRoSUNEMzUyaFZkd3pPMFNkRWtueFFzQWIwZ1BZNkJOMEw5UVM4a1hmUGhrN3FVVnh6NXgwSm8xSzEwSys2NzRDdk9ZM2wwYkNhc1BPVFgyUFhWcGRQdjZ1SmY2bTFMTCtKVXY5T1QzZUVJeHEveDlyMXd6dlhKb1k5dWVrQnRnN2Y2c2h0VlF5dUcwQ2lORkFOTHF1NnhrTW1GaHFIaGU3TXdJY2JQd0dVOEU5UURMc1lVSTVNK29vQ3ZpQTVONmxJUFI5NUtiK1dCbDVESm9ZT2lBejcweXplYTRhVmVtamZ2WEtIelZsMTBneXVnand6cHNYMVNsZ1pmU2tldzZERHlIdEtIcGdrM210QmFKVGpDNWpPZkJoNWNQMVNBbjVBMkJqOXdaNTQ1NFZldjZrMjAya3QyZ1FtK1h6SEJKMjIwUlFQWHRnWVp6WFBEVDE5SjhYYWh3MXRmeG9id3ZaRTIvVEh0OVJJUEdhRkRLNi92NEVkMjlBQi96SzUwQms4SVB6elFDcWtQZlhCVEwwMWUzVVBhaDdyUVU5eDVUUnZRazIzbExEaWw0UzdHeXRwK2M4MkNxaDlIQXRaNGJ0a3JjdUtPMU5VTU8vd3I5Ui9vM1V5WFB6Q0Y2RTYyUUsrMHR3RkhmNDdyMW5ZZjF4MlJ2clA0R0YzNFJyK1VqNWtFbmpUMTg4eERld2JTdHUwN0Z1Tm5IOWRrNy9Lbno1dFgwZWxITVlzRlBESyt2dlBPMlpaR2FWNi9OelczMFJyRkdEMFJ5Z0FHNGJIUm1Bb01UdXBXQTRFeFFnWXc0NVNaeG9DMk5WcEdPWjhhakhHVTRTT044NVVubzFkeG15Tk4zV0dsdS9VY1Iwd09YT2w4ODJIMlZORUlkSXpzNkJ2bllWeUhudk1KUGxnY3M3M1ltbko5dTJ1RmV2TjJIeFRSZng4a1JUZlJGZ0FBSzhwSlJFRlV6V0xhUE5tRGZMaU5YM2FPSGxESUVnNkRaOUViZk1XVlArOVgxOGNaNXFnY3VGZmk1dzVpTG5JK01EVGJEclAxNEFIZTlBOWJ6ellDNTlHMnJkZlZTeEp4N1dUWlovYWFyOXVKc3pOSE1oK0tIeWVsbi9VSG1TNFNVbVV5QkRwcHI3SllYZG9oSjBpMHU4ZGI0Y0VsVTFuRU8yTlFYWUo4K2hVcy9PV256MmExUkY3YnV1Qm9SR1Z4dlJBSGo2em9pZGNxRTF5SXJQQnhwMGRtYi9HWUwzMUNZeTRLdHZiR2huT0xqWVcrMENkdjZ3RnIyaHFkazVLN0RZY0hPa1IrdCtYSU9kTW4rdjZwTkh5a3dyZlJEc1kzLzBiR2NVMTR4VjdIOWNkbGZFSWpQUTZSd3paQ2NDd29CTnR6cDZmemNGcGQ0djEya1F3K1hEd1N2L1BPMllQQTZ1UFBLQzR3UlAyZmRDdW5jVWtiY2F0Yjh6RWltTHlCbDBFUGRqem8zZmFab0ZaWmJrYzR4WEhFODlCTlhzQ0w3TkRMajU0ekFUa0NNTkhreWdCZjhUUFo0Y1FSMEMrVHc2UkpwNFdYMHdrYzg3VExGWGxiRlpWemFmbHVXYmV4Tk9VeTNPSE80S0VqR1I3ZG5OWlREbWwwSlRQeTZTUXZOTit0L1hBU3RQUGlZdmJqcGRHNXY0QldkUnhYUHRlSlJuMGNEOTdLN0NDZHRrTXljS2VmTHVwYjFXSzJhamh2L1dQUGprNXN1N2FKUEU1WmxDZGovZjRLMlp5WGdFNjlad1hrQjVhVVh1clJURHZtMUVubzBJUXVlZm9rb0JXc2x0VGpJNFMrQy9VSFhzWkM2T0ZrM09Rb0p2eXBIMTNsZzRkL2tYUUFFNlFpNThGbWJHZS8zVXFRTG1UYXkzLzkrdFZCQjdvTTNlNDhQTElLejJaODlHZXRHejBleW9jZStIR2F1aU9XWFJ3OXBnMlAxZjhwR0hyeWprUGd1OTZqNzdGdUtidnpHTnl0WGNXd3RPbzkrQm9CVlpxN0YzYjFUUTAycnRIY3N2VVJuNUsreEZOZnhNZm9nKyswYzM3WjMyeU9BY2FVakZIL0QySEt1eEZWeEhnWjlHRHdEREIxWTVoOWYxQTlYRTYwZjRHZ0ptL2o5RU9sTVdDdlJEZW5aRzV4VUF4cGNxSXowZkFnSjNWNHJEcVFIMmRMRDk4VVZxOGpyS1NsQ2ZJaW1rUTA4RVY1YjhKTisrZDJ1dmNQUzdlaGRkWGVIUlM4TmFBL2hnMHZrM2FjWXI0YUIxZWdoelpMaGVpbmZoMWswZEZxMlZZRzI3UTlhN0RPU1F1cjF0bjZ3WWNOMGJEajZENXRONmpEMTBvWUR0bTJNTURwTXZZY2g2ejlhWU1WSVh3aCtrVU9ISFRsL3B0ZjZ1SEcxdkp3QlBXSnNSbjU5RTFiMWROZGlBNWdRcmQ5czVGeTZza0tQN2lCSCtORXA5VGpKNS90aWRKd2s0RlMyUHRMeVFXTWJsYlFBcnJwT3o5QU1DL3JnT001am5wM0VtRGt2eXRFNzlRcnA5M2pvTVorNmgvRDdYWnNiVTk5NkZlZThJUVZQN0RnSGFmSGZJN3IxL0xLZDRmdksrYkFvdU9VOTdhR0hseGU5UHlLMnRQL0xxcmJlTnl1MDNpSjZVL2p6WUxQdU5ZLzMybm5YSXAvK09UMDduZUhRVlVONlFGZCsyUnRwTzIyS1lZQlN3RExwSkFYMUNlbVRyckdkYktWYjJoNTQ1QW1IM284MjVtWFk4bkRMakxHV2N4RHFUZ2JPb09MMFVYNm9sNUhKanVEUDd5N2pWVVBKN0E4YmQvNnR6dHZuZ0NiMUxPVkFWL2ttSWJXcEJxWThocUc3NzZhRy96ZFFhaTNzb3lkbE5rQm5naWVQTDdSTTdaa1J5dG10aEg3RmU3aWthMk93WnNIVC9qQXQ1TGdlSjJHYWZsMVlnSWVlL2hWRjA3ZWFtNjM4ZnhRcTYwTWU5RGpnT2czVGhwdFZyWlNQRmVkZ3c4dXhJbVJCNWFWdExyZ3lJZXZQSDdoSXcwdEhEUXJIZndWRmwyMFJ3aU5mUERXRkJ4TlVscFBlWE82QjNuN1JUbTQ4T1lrUitGdXp0cWRGMmRRTlcxL2RyT2RrVStGRGsxV3pOOTBWSzFJL1ZuYkdIM1Y1UVNRZk9EQmxjWlc2bzhEMmNGVmw3eDAybnhNOGUzbGxUNzVsYy9qZlBjNTgxZzkvUVYxOWY4UXk4QU4yL2tiVDhZZitMWmFydWNiMFNQalJpckdWM3hubmZPbi9hcDJ2UkZZQXlhZGFGeHFzRFJHMlEwUUl6M3N2TUVmaDRJbVpmbE0yQmllSEpHQndKN1dReXVCc2ZRREdDY2l3REdaOEZNdlZZOCtlYWx5akQxT2ZyWkVPQnJuY2FVQ1d2cmdtVTRDVjQ1ZStHbTZNbDZPa3FFVGJ1cW8xTWdlM1FQdnl2cURWZ0RmNDM0YkR4WWNlSGc1V3c4ZXZjQ1VCV2xzMFlBTjFqclNzeUxkdFMrL1VxN3NnaVZOdlhUMG5qUXJoK0U5ZkJ3Wjh5Mk9QS0NiQVR3ckRQanRuQ3VkZnRwWHU1R2ZpMmphbURibHVCZjk2ZUhYb1BHV2g4TlJKWStYR0ZvMDZYYzRZdHVzNFBEV3NZVkdnQ09rckkza2hRNDhNaHB4dzRVSExnUVh6SjJDRUw1ZHFELzRSTWJBWmd4dGFnU3RlTTNldWVOMHM3Yy92TWl3WlVMa3RNMlk1b2ltSFFYdHVodzNqZnpJald6YmJBbXBVOWFXNFR2MmtGZC9uSzYwOHBFVCtIRTU4S1NScytzVC9mYytDTzVqdk5qck1UZ2FQTmtwdk5OdnlvSDVNZHpRQnhmUDBLTVpXMmZ1N3ZZd0xyNnp6cmthK0xvKzF2NlBHbXFRNkdpcGdWSHVzeHQ5ZHZwc0dsOXRLcFAwbGJvTmN6RHE1alRiSEFiVVdNWVY3TjcreitJTWZlVU9yWE9lZDYvdmUyL1M5NFE5MGtabE5jR1lkWE5kZU9VYzZ4aVhuMUR5Q3ZsdE9RWkcxaEZ3T0tSTGU1dDFkV1JrOG1wYVZacVhTdWIyOGNzdlgvY0V0NmZOZ1hBMDZlUmUwZlJrM3ZuMm1kNDY4OHNHcmFzZmlLejl3dWw0Y3QzMk8xczlxOHUyUldGTDhVMmdwMGltRlAwNHRsa0pkRHNMbjd4eXdWMFBWbWpGYTdaVTNNMzB0M2xwVXp3aTQ3QXlxRzBMdEJ3eld2aE9iZGp6eFlkZGJtL25JZWs0cU5FT3I1R2wzZU1zN1pPUGZsdTVVT0hZWC83cTZ5LzYwNkR6MDBpMk9lYVdVTDBZZmZRSjJWYng5cjNUWHZLTXFJN3lGWXQ3dHdkUDdSTG5ZakcyWkM4NjR3bC83ZnRkN2pnYjVYYWtoVGRqWVhoeDNtbXJsc3VybDZwckdvYXFjc3N2UGgycUxCaVQ3T3ZYVW1wcWQzdlFvaXQxaDNkOVJ4eE1lK2lSZmthUDJoaWJaeENaRng1Q2VnbGx6amU3STV0K25mRTd2SXBrMEp0SGM5b0JpcHRNZlRRT2pGenljOEdhL2g1WThQRW1LekxBMFFVbVRZQWo0cm5pcXcvZW1oN24xL0pqOUtsMzhVcWV2ZVJaSW1udUROeVI1Tm1IdWtPcy9wbVRYZnVjMFNhZnZuV3Q4d2FtTUtlRXZPbkxCZzFxSHQ5WjUweEZqVXpRcURXc2RTdDh6WnVBeHlGMFVvTkVNS0RUMGVYR2F0TE5ZTzVWWDAxQWZESVlBdU5RdmVpQVRzQXJFejc0TisyVXU3b0haaWJrUUx4TThidys2UFA1Z1RZRE9BT0djNktiWVBXSXJ4ZE42QjU5YlFPUTNYcHNLNVh3c2JwT2UvRUlYekFSdjRTbTMzRGd4ZDV6TkcvS2IrckQvejJoQzI5OXlCZStrNDd6a0kvczRUY1RDbDgvbW9yUDVlVU1XbmJoUU5ScFMyeDVkWlZ6dkROcERZSHc3Uk1kZmF1NDE2RTNVUVR0dWF4dlEvZTJ5dE5uN1pnNTUxNUYxeGZxNkdhcmFIUWJ1ZWlWRS9WMUF2ekFnNmN1TUttUU9tMVkyNjh1T1BJQ1hRUTA4S1VDUEhuMDcrSUJSLyt1L1FaWE9UQXZoNHcrdzl0WVFkZXhGamc5WHBjeGxycm9rajFTOEw4bWpPeWRkbTNmWS93ZWt3T21YZUVWbk5oRkd0Z3h6OUFtWGV1UDZZSVRYdW9qWTZWYjg4RUZPNllmUExZZUI3L3kwei9hd3oxRWhuVDZibnlSOG5mU09UcysxNmMwVHNaNWZITnM3RTViSTFZanhWQU5LK2VaY295UUsyQ1p2ZzNFK1dVZjFFK1VtNUM5dXFxVlh3WkVuQVZjTU9XZXVNV2ZZMkZVTU1HRUlSdmUvSkxHZE1CdS9GbU5LT01ubWlUUkQ2MDRFMnh3blZKUVQyWWxCNzA0T0ZkM3NzUmFSalVlK3BHM2IzdW9ML0RHMjhEYnR4YklnaDgrMGVHUWVuQldYNGF6U3Fjcm5WYzlYS1FpanoxRW4ramtmQWJYd012Z0kzY2NzRE8yYXpqSW8yaUY0VGtEZWZSbjE3UnRuSkRWbzZCZUgwemI5OVZxZU00S3VnWitPWFF3NXBwMGJJYzJNb2JINkJ0Nk11UVRZcS9VUjFkcFlDc3V1Q0FOVG1DeEVSMVdQVmJjOEl3TzZhdndXSG1EcVord08zeTBUVmNPSXdGczdPWTV5ZlpOamMyTytuQ1ZHOW03WHVIeWVCb2RvbVBLSzNaNEJyYVcwYjFMZnZDVHJuUmdLVXNqUDNxbnZPSWxuN3JRZ3grSDhId01CMzNnKzJvNjg5czhucTJzZmh1MTN0QnNoMXhqVXBqZGdXMWNGOTUzemptUFk3NzQ1Y25kNlcvVFVJMU5nMk04YVpsaGc1czBNVW9tL056aW9YdEFnMjZMOTcxVnNwMGFxTnR1enBRRDVLemgrSUZVamtZK0RveHo0b0NsWHA4T1BEaVphRklQMUF4SXVDWkFjTVo1bmRXcnhsOFUzSWtQVG5vZXVGM1g3OVBCNjYyWDB0MXQ1a3dldDdzZXN0VXJ0blc3blhQVCtNYzI4SVE0N0xSanJSL2VZd082dDU1SHpqbVRpQk8xb2tWZkxkbjBId2NEeG1IZkh4enM4UEt6VHk1dWZaR3IweHJaT3JHdEFTYnlHMnlDQjUzbDQwdEd2em1pTmpBWFdMZUM5YmYwUVFObjE1RWVjK2NTSHRwa1pROUhuWUNtSjBLMWxTNnppbnpvb01NVHJwQnl0MytUTy9vTkwvWHFCREwxS3hrdHQrb2lNL0R3RFkyamV0RUpqOGlSUm5ab0lpdTA4TU4zeFpkblUzRmVXMDlmbXgvVjlyclFudmFMSnpNLzJIVHNiMXpudTlqN2VDZEh3RmRNKzZYN3BXcHdqdi9DZjZ4OWFHT25ZNXFVMFNaRWRsTHcyT1VZTHpRcnpuRSs1ZGg0cFFtLzhBK3VWRjNnd1Z0cGs0Y3p1RllBMi93NXpDVmpmVnZNbVhmOFZ0OWhEODNJbWZIOW5YUE8xYWlyczlPbnZ6WG54eUdNVVpRbXpHQ0xJUjVMR1dhTU03aU10VVlEbzh1MU1qQ3BhcWowdzZDWlZOUHg2dFVseHFHQzQ1M0JGU2NEaGo1MDhDL3FCUXIxWU1MdzMvZDNzMFVBVjRBTEZoNGNNNzR6ZVdicmd0T0dZMkxiSGxDR1B6SkdoOGpwVlNXejBSZE90VWZRSnZwblJRNkdoaXd4L09DTWJLdXZlcGhYcnd1amhWc1VoWnM3a3pqTGVYaklJZWNOUVBoam05bHF3Qk5zMmp3T0dqOXRFYUlidkZ4c09OTnBVeUZzRnp5NDg3dHNtMTNMQ1kvdWVOYzdwYVhEMWVWN2ZhRjQ5dXhGblZWL2ZuSloyeHZxOExXQ2NjczVmUGUyNDV2Mnl5ZmdMVWpiZHFtb05QamdZbkR4bm43WjI0VU1QQTQwdUlFcnF4ZENHNWgwaFdYY0JIZXRnMHVHMVp0OHgzTE1FL0RQZkpvMnJmcmdFMTRid1YrVmhNOHhyOEREbEc1ck9DNnJDeXk4cEhST1NIM1NWVVpvZ3Z2bnBuOHBYV1RqZjVCdmZtNHZtOHljNFQvMGl6dTFtWWVhcjU5bUxPNzk4WjF6enJVVDk1SEpXTGJYeEVPbktLMmhEZmV3VDd1YWdmWTRUaEd2eFBrUURMaFhpRDIwR2llQXh1YTlZTkxQeVlCeHBDWUJwMEZtSElzMFQvc05rakhzUGhueDgzQUtYQjZ0VkRsYkg1eWRZRFZqbGU0QjEzUmswVzREejJjMXJaYm5GNlMzbHdKOEhLVWRDNGUzTzcxZUZaV2M2RWxPUW1CeElGSS9BcHV3NnFrT1BodWtiU09uN0hWUmJhalBBMm9MaDUySHJQWW5EN3kzdldCbGRvSTdSK1JtanpSN3ZTV2lhZURndFlaTVBIck15eGJUbDcwUzRkektCdEhOZU9uUUY0dTVpT2xMSy9pcnEzTEtsZXJENFRVWEFyWkpueVdkTnUyT2dQNEpzWTl5OEZLUHIveTBjeDhMb1VrOW5OREFkUmVoTG5xQmhVYWVYZFJGSmxoNHljZEdvVnZ4NFJsL1F2T3NNUWJmblZwa3RBMDI1dzBQaldqckNNN3hhUXM0QW5rVE5ydHZwZU1rL0tSQzlKY1BURjVRdC9NZG1ML3dWcnJVaEhkb3dpOXBhSk91OEpVbStXTytLUituSzM1NGdpVWYvTUZqcDgxR1hvSHZPeGIrSUhQQ002VnNzM0hPV3g5NDBGdnhPK1djUC8zMDczNVZ6cm4ybTlQNU5UazBYQlBYY2REVkJhZ0dGMExIb1pqQkZkanhMZTJ4QVIwRnFpSFJxME1yS2FzdGs5cHEwV1EyUUExb0U4cEVBcGRYUjBlVEFVNWlPa2tLdGpvQWZORFBCSm5iODZlMUJVQW5jS3ZoeUVJUHBoMlp6Q1cyWldwekpxSGZtTE1kRXB3aWE1eTBrNE9uaHhBYWRXRFJSeDE1Q1hqQmtZSm41WVZtdGpuSzdQYVBhL0J3aXZpS1hqYnhrUFRaMVl0KytJWUhtN0hwMkdMT2ZvOXRaaHZpdnI3Q3BVNHNyaTEzZEU4L1JqZGJCZXhCcjlGMEJ2cmVYdjEzZWxvNDI4Q0hoZTNvWFdrdHNxek90Y0U1YXZhTmJMWVl2TEVESGVtUmlCZDdqSjZseFdhZjFLOWx1SUhMeDdZci8rRHMvVGFPS2ZxRUJsNEMyS29YT0wzQlFnZTI4bFR1MEk0Qi9Zby9ZOUcyQm5xOHdpOWswV050ejhPNmRWS201bUVhL1FKTkc4Z1VJbU90VHo0cCtZK0Y2SFhNQTY2NnlGcHBBd3ROZUFjZTNQQldEbTdxanRQd1dPR1JYOVJGUDdwVVZ6V3YyWGJrZXFkUDhkL00wYzlFenMvckdGMzVtTytNYy80WEgvK0xEOC9PcjM1MWYzdjM2OXZ0b2MrM0dXV011WnJqWVg3cXAxTmo2T1BVQUFHYmxYSitqWGhmU2VNSWgvUGhaUEEwK0VXT2R6OUtZOUovYzBKelRnWThYUFdpa0Fsa05XeFZCNzVPak9BNjBwUkJiSTlaMEdrQzUrS3psM05NYi9SMHJuTHdzNEtQZ3lXWGZuVFlMeWI5YWN4bDRMTUYzY2JadWtqTnRncmFXZTNhb3BrdGlZdW50ZVZSQzdPeHpieG80cnZMTDE2OGFGdFpDYnR3c0p1MlBYa3lENXZHS1k2K09RWTRPdTl5OGFRTCtHcWI5Ri9zeHc1V2Q0RXJ0KzIyUFZXeVl0ZllsRjVQNmpielNiWGpiYTBpd2NtSnJPRzVYeHpJRWlOREdoZ2FlZm9HQjMwQ1hQTGh5UXZrSllBTDB1Q3Q5ZXBDSnk4b3I3QlYvN0h6WEwza0hmV3NucXZyK1d4bjljdEtMWFBrNHVPVG4zQ04wVjVwbHlPUERMeVA5Umt0L3J5L29aVWU2NXk2ZDNGYWFWWmErS0ZsOHhVdnZLSy9kajBXanVuaFJFWm9WenF3MEt6d1B5ZVBidWJjUGpicHpVRTdXanYxeHNidUd6TC92alBPK2VUak10RDkzYTlMNDFhVU16aDk4azNqeG5pVGJzdW9SNnpVaytWa2JodFZ4N2hKMGR1SGhlZkIzVk52cy9VM0lNWXhQTDk2ZG5KYmpreHc1SzN4QzVjejVYRGE0ZHJESzFxdkZndHdCQ3NVK3QrVjl5S1BVM1RJMzZyY2dERVp4ZnY3aTVNdnYzamRLMDByemovKzhZLzlvQyszNFRjM0h2N043ZnM0eDFvdFhjK1Rkbnc5d0ttcDNUSzZYWDBuUVk5cEwrZFlwYW9mMk94UGp5NmNWTTNMWHQzU1NUUW9CTHExL2NyeDdmU2NjcTJTNnpPcUxqcGl1WjYyUmR0a2V6aUs3empBb1pWM0NpQjc2VktSTExmUHRrTWlsLzIwZy8zSUZjbFJmMzA5VHRRMkNqd1hLZWZON1J2UHJmcllCYTcrc2IvODdPcTlrK2UxMXp3UGJtZGJnMjJjSjczWmJ1L2pHTnQrSkJiQzNvOXpNVmJPU3J2SHkrWVU2SFljNEFaSG5UTGI0by9IMkhWa0JDNk56ZkZVanAzd1VDZjJhcXJhallkeUFyNWk5R2FEbGxONGpoemFBbk54TC8vYmRGWnl5Q01YcjdSLzdEK093b1VQamlqZ1MwYjB5Y0lnZWtSK3lsbThyUERJQ2IvSWhoTzhGYmJxRTc0cm5uWUtnUVVmai9VTno5Q3VLZHdTZTJqN1dpZHYzdnpYaHVudlRjZTYyM1NtMlFLSC9TL09haTdXZUs1cFZiNW05T0NMZkwvc292QytNODY1REhWMWJBZ05ZOENFZElCVVRDZW0vamk5cXdrWVhIWHlLODkwckRxOE9Od2FmejBJVFk0YXNqMGhJbWZ0ZUx4TUNBR2ZSRGdaOU9yV3NueDBnRy9GRGhjZnEyQ0RQeC91eVFSTHZhdHYyZ0tmcnZQaG9KSFJPbTd5N05GMnFFa29oQzRwMmExSDFaRVRIUEFFL01pWnR1QXh6dkdrSE9mYTF1QS9sdUlSVzdTOFRTNDdSSzQ4dk1TVVI4YXNMTUpiWGYxdm52akdOdlFNejloTmVXMHZIbVNBcFk2TTVOVWxEemQ0WVBEd0RiK2s2a0tIUmdodThOZDJvVk5PUUMrRW4vd0tnNnN1WWVVRlQxM1M4QWlzNFJzL2VWRlk4UnB3Qk52UURyeERGOXgzcGZpdUlYcXNzT044K2cxODFTdjk4bTJ5Z3gvYVk5Ny9OV1Z5ajl2ekxuNnJqaXZObjhNajR4Y2R1NmROR1VQZkdlZnNRU0FEYUZRYUhHVURUK05YZU9wQ281ejZZOWhhbHMvZ2dIOWZENWpBcnE3RzBkcHlPS3NIY1ZhRkFrUENNMEZtRlRMNERBbWVWRDNjWGxrdmgvNmpFMTdrRE41L2FlN2VzdVM0a1FNTWkzZEsxdWh4N01mWi8wNzg2QjFvRDVZbGtaSkk0MFBVM3dtV3VpbDV6ckU0UWFJQnhEMGlBU1F5S3l0ckpwODJYNERka1lrZEQ1eitZdG13UkIvc0RlYnB2NmROWEhRcUFiMzhCbW9sbnZqczlsKzhtTmpkNS8yd1RoSk9LbTROZ0ROMmJaQU9iYkdsSzMvRW1DMjVpcjhhMzdUVE56dExPMnFQSWFIWkRUYTRPNDdpS1gvRmxUOTRGZURlTTVsN0hucURmQzJtRTEvZThoTk5uS0FZSHRPMUdRNGVmVDZVaXgzWExWOTBzM1BDNlcvNC9FU3JUWTlZZlFrRnpnbmZlSnc4emZIQUV6OWR0ZGUySjlXZnhJSit5dWduOXlDd0d1SEQzZmZoNlRtaGZuVzBzNTk5dEZQbjJVNHVucWRvSng4YnArNlQ5a2Z0MHorOFp6K2RuL05oMW9DNVlsMHJ5Q2ZteVAxTExNNmViWDcxOGRXYitibWJNL2x6RUF2NlBwRU42aVpHMFFsc0I3Y3ZmYWQ5Sm84ZXBZVmpYenJmbmpZd3VmVXR3QmJtK2JyeGZLT05EbnJaYmFLb202eW5YcnAvV2J0di9OSHh0a2lZTEI3cjJ0ODBYSG85dTJ6eTlPc1dmai9QNDNMSjJqbWp1NFNuMDZYNysvWDE3YlVzN0ZqWU5xL0d2OXVrWGs4djVHZDI4M0h6TFJGOVBBcGN3SC8rK1ZxN25IaEtZay80YStPMzh5Ulh1NndQQk0vRkpMM1pwWGY3ZUt0SDE1ekk0TmxXNHRFVzY5emljSEtjaytGYWRqYlAwSzkyZnF2NUt6L2ZmZmZkenE5ajZGSnk4amNMTlBuR2pUYmY4Nk44bEJOOCtaditUZ0w2NVBBa2Z4MnpLeTQyVGw3NlFQalRuL0QwaEkvLzlPbk1GYjUwa2VmUHIydU13Vm1jWFFuU0laLzVpdy9jeXc3Mk91SFVWNTgyVC94ajdkT2Zlem85WXVrWW9NTlY0TkZQT1BVOTVUUCsrS3BQSFdlYkxUelZKKzNQdHNrR3A3MTBEdjJ5RXk5OHQxM3VlZlRGL3kreE9LK0YrVDgrdm56Mlh4LzJwK25YSkIybnJ3RWhzSEFTY1gvd29wV0FhNmtaekptOGVPaXd1TGd2YVRMMG5ndjQyV25NSmJpRkdtNFArdHV1eXdJUXNKMTlmSHV5cjBWQ3U0TDM5TUVFMTU5SmM1Mkk5RTJtMHo3Y0xDNmY3dml5LzFqTm4reWQvdUhkY2F5ZFBUL0Z2LzFkL0FGK1BGdUhlMlVyanJsWDVsN2VmSEZIVGlvdjEzc2NodWRhWVBsTWh4T1IrdlJsMjE5NXpFZjJ3Wm1MY0Q0OHdXZVJXZWVpM2U1ZHhtemlvMC9CSjYrT1l5L1dGNS9kTWpwZjdQeTF5WjN5MmFZREhlU3pXb21HbDUyVEIrMkVzNStlZXpxZTlHcmY5N043ejNQcVB0djR5Z01mOVh1aEUvenFic2hXc3RXSVoxdWZEaEJlUHp2dzBlTTUrM0JQUWZwT090eGorSGpTcmE2TmxzeUpTK2FwK3VSTlBsNzlreDcrbjYxSC81Vkh1dUVjRThmSnI4NERlTVhZL0pkWW5OZksrTWFrbThIVHZiMUpnd0Ftc09uM04xd0IzdlB0NEpmT0FpMW9kV0N4TThHU1JaTW9lSlBXczhjV1NZc3d2c0hOczdvbWZNQnZrSTE0WDY4Ny9lbFcwNjF1VVdCSG1iaG5OOXdYUXp6MXdBYWF3dllzb2pQNTlnRmRIL1lzZFZzbkhrc0QvZDF6ZHFta0g5Q1JiL2gvV3dzVmVuN25uejc4enovTnIxdVA3ZmxaS1kvTThaOHZpdHpzRTlmeGJETjUwQk1tOUlhcnByOUN2N0o5dXVVSTM5dTM4eGpldXZqZnozOS92TjJqOTh3MFhvQ1BQMnlBOFhWZWNnU1BqbGVlSGNzV1oveHlqQitQd2g5OGFxQ2R2c1lKdWZ4RUQ0b2xQZnJGSGE2YWZEYklKeHV1UHYxaTBLZExUVFk5Zk5KUEgvd0orcFZ5MFdjSHA1dzJ5TzVabi9yaWVRcVhmZkpBN29KVFovVDhqb2Q4TXZGSE8rdnNWS2Z2OXp6WDJEOXB0Y2tuZTdaUGV1M0hhckw1Y0U5L0NuL3lpYjh4OUd4OUN0amNWSlAvNG92elA5WUw5VjkrZlBIMjNXMTMxRHNZWE1hRGdpeUpaM0RoNGtFTFZ4MU5mUmE4K2dhREpCbjhCckFGUmR1Q1kvS0NGaGs2RmJzeWw4eHVQZWpmRDI1OXhkRE1QcDBPQkh4K2VIUUpqZzdqbUgzM2RORXRmQ0M1RmRudTI3MG12eEdmK1NNMmhYNHkydlJxczZ2TnBnVTJISHd5YkpPZDU1bG54NXllYXZMNDU4WGludzVXc3VuQUIwYmZoWWVqQzhTdnIrZ0hPemY3T0UwTzA1dSs3Y095NGJpSnB4Tkg4UzdSamNlbjdUaWtZM0J6ek5qTHZvVWM3R081NU9EeEtrMGc5Tk5QUEdqOGxjc0FIcVJibmUvVjhlcXptZDU0R3p2c0ozUHluamF5VlkxR3p1S2NYdnFNdDFQSDJUNi9oQUtmM09sbjdYeXMvMGYxdlM3eWxaTjJ0dEdEMmlmOXo5RGlVV2RQK3pFOThKOEQ4cWRjK2s3ZmFqK214L0VBSGV0MGhmL2lpL055NU0ySDV4Ly84K042dkNubkNuSmw3eE5jOUFJdENIMjArMktYaCtma1MxWnRrVzJTV1Z4TUtPc0JQU2ExMTRGS1hCUGRaTE5RbTdScXN1aGdEL1RWTnVFcjY5SEFCL3ZSNmFDZlR4WVJCYTczR3F4bDY5YWZSK2pveG85SG1lY2paN2ZvZmNQTDhxYmp1Yi9uL09xMnk4MDJtK1VXUDl0dzRzdE84YUNMVHl4QnNwdjM5aXd4dmdiZ2ZVMTMrckt0VDZjY3dwR3Z4RXNQMnkyT3ZqV0oxejI2RnIwZTR5S2pvSXZENHF5bWcxNjAybXJ5TmdEdzNxYzllcThySExIaFVmaEpoNXBzSlR2NW53L0p5aXYvTzZtVHc2c085SXV2K05YeDFNNW05YW5ubEt1ZGZ2ejhBaTNBZU5abzJuaTBaQWIvK3ptVXU2ZFA4Y0pwbnpTMjZtdi9FY2h4UHVDdFhmMllyc2R3cDUzbzZoM3VTYnhyRDgrMUFiZ2ovNmx1OXU2WjB6MDV1cWRPdi9oUEhmaURMNzQ0ZS9zY2h6anFReWR3RFp3WlhLZkRCVExCTjJsdXU3SzFZT3dqc3ZUNWtrR1R5b0JXMHIwYjY0L0ZEcGpRVFdwUEo3QnY0cTdodXhjd3ZqVXAxUHd4OGZxd2tKNThWTFByRXZyVldreE1VZ1dZakUyWTRXL1hzajdvdXowdFlrSzRMV0ZYdlZSdHZYZ1ZNV2VmVFl2VzZFRXpNU2JPQjE5WERnQTVQdUE5RjRTMVA5OTUrcmkrcE1EZjkrL2tlOFhxZHNuNlIveWJiOTVzZVg0WEMvMitWdjcyelRmck9lSnYxL1BFM3FzOWt4WE5QVjEyM09mMW9hV0Y5TEx2eXNTdTNjN1NwZTlNVVBiWndPdFErUUJRVHNwWFYxVHo3UFo4UVB2enV4Ky9ldmQrZnQ3TFk0WFAxelBZKzRzV3Z4bEw4NVNOSzQzaTdoZFdmUEhDTGF2enVPS1pYRTYrMEZ3NWRXekZCYWRZbk1Yak9JL1BzM0JyeDBkdWo0SGJpYUt4bUE2OHYrNWZmR2tNbUpRVzczV01IVWNQdjY1Y0JQVE9tTCt1MUU2ZDJ2elBKL285MFVJR3poZCs2UENzdW1QMWJqMHZ2M24zRXpBenovajJiT2VoSzhrWnQyZGU2QXU4NGU5M2NMbjh5VXVueERXU00xYU5MOS9RM1JHdlA5bFFoOXUyUnVpQm5oYmk4WDE4TmhzSVY5dVhIbXZEekhrK2h2K2R2d3RSVE9yUDhkM0xmbzZmSHZsVVA0eVJtNjJPSlRvYXdIY1crRWV5dTNuL2tqK2UwbGcrYmVEWUNRTDRjSHRPRi82ZXJtK2NETDdBcGk5cHltTTdxR2hxTzJjZ0VSWmp5ZnJtbTIrLyt0dmYvclpwSHFWejYwSXhrRTFJaTdnUG1zaDZtb0pzaFMvYWVMVXRVT3dBZlRGMXdFNThOTExuQUp2KzZBeVBGNUMvdi9XekNldFBQTjBpZ1djN2ZIeDdnZDk2VHAzeTJrbGdubnpRRjlNNXFNVFJJalc2WjJDendXK3hreUhicDlMc2xaTVc2K0dka3h2ZTlYOHZpTnUzZGZMSkYzVzYxZnIwa3k5UHhWV2VvNFd2RHY5aUxWVDBnR0xMSHR5cE4vdHNscmRpa1lmSndlUXhIakhDUjhzV3ZYU0Vad3R2VUh5K1dnMzA3d3U4WXdCT21qNzlmRkRZS0NadEVHMTNibi91ZGFUNzVQbXIyK1dMYjdYNVVCdSsvbVB0VGJ6OXVaZUpCcC8rczA1dmZJL1YyWXhHVnlXY090dmhUanZSMVBBVnZOZUlTUEl2ck8yYVg3MTg5bjBPeWZWdHJreVF0M1B0NlZLQndXbFBQV2RNT3dKd0ppZ2VPSU96Z3MvdTF5QTBNZFF1UjlVR3Q0bTN0RzRiY0tmT0pwZWRVUXVPQVE5L1RndzdaL2g4UmdQcFFxT0RMYmN6OE5rMTQyTnpjZTQybWZtRzRNU3IveGpRQytqWmNlOThYbkdQemxOeWJnVzBVQlk3anZGN2RLVlhqVmVlbktUMHMyV1hVbjh0RDl0SUM1Q2M0eE1udmVRVnQyaktBVHFjblIyUWcxL1hyODJRSGIyRGcxZndrOVZHajA4dGpoWTdmTkYzU2lsZjM3NGFQWk56cU9USTRnY3R3c25Ea1JNSFlKOGRzdG5IeXlZK09RTDExV2Nod3daSWovNURUQ3VuK0o4QzhvRTJYdmJ6dDNZNjFQdWJxN2Y4c1hOT01mUlRCOTNKWnVlczZmKy9BcGxzbkxKUDRmRThaU2VaaStmMFIvdnNmenFXeVFUcE9ldG9uNnZQM0p3K251Mm41TW1XaDhhTy9qNG1TNGlPTDdvNHYzNzk0YTFMNnN2Sks2SGgxUGR3NFdZdzZrKzVEcVRnbWx5Q1YweThKaC8rZCsvbVoyTHNmTnlpbU5zVVgrMWZKN0VyZnJZV1Y3dG9ILzZSYXlGRnUzeTRiT1lIMi9pOVRVNnltNERuWXBJK3V2Wmt2MzMxMnVLY3ZNV0tESG03WkxwT3V5dnFoNEZMQm54Q04va1dvQlUvZW4yM2NHcnpoNzNrNzIxdFJldFBlc29wZmo0eVQ1ZitLUnZ1WEhUZ0FKc0tYUmQ5YmdQUjRiS2NQalMzTllCK050V24veTF3bS9IdXo5aVo0ZTVIRmNqOStOTmNFYkdWSCtranJxM2taM0ZsSDAvK29NbkQyZWNQK1IzTG9zOXhuTXRkdFBmcjFnMGF5SzY2dmhOZStoNnI4U2EzaFc1NjZJUmZwOENOWm5lNWRyTTE0d2hoODYzMVBUMXc3QVMxcThQakIyNFBmUTdpaTBlZnJ2QlA2VDM1dGVNUG45eURyanU5dzhmSDhUTzUrL3BlNzBuUHhvbjdNKzEwVG4zbFI5OC9rRzc1Ti9ZM3Jad2UrZm1paXpOSFozQWFaRE5KalZVNFkyUTlUdnNKRk5RbnlNOTBCRTVHb1hNV2tWbW9pTGs5RVJqQWR0SjIzKzN3WHE3Rm1adyt1Z0lzNWtwOU9Bays3VzJiNjk0cW05SHg1QXRjTkhLT1c3UjhmYjFlVnE5ZFFhL1E5Ym14TjN6YjlKYkpoMm8yNmMybXVzVXRYQzh1d2l0V2RISEh0LzEraUdNR0l0bCtHTFhkdFIweVc4QkNwKzAya3Q5b3BNTkpvUUdLSmk5cWR1UmVzVGpyeDhkT2hkNmRqMVdQL2JuZisvejVmTmlhbi9Ib0svUUJNb0ROMnZwOEpkUGlUT2JlcG43KzhoT3ZITUViVCtXTFBueU5HWHdnZTJ5Zit1RWRZdlhwVjMwNE9zZ0E3ZmppZ2RPZWV1NlI4Nkd5YlM0ajViVDhrQm1ZeGVUVytWMTE4ZjJPdEJIcDA2bGQvWmhzdEZOYnVHcHkydmZ5MGJNMTlNLzduOHlwTTkzVnB5OVB0ZE56MXNrUDd2ZCtzQ24veWFRN1grRHZscjlZL3Y5cjk1dmZ2MysrdHFBV3ZMa3ZhVEFDRGhvZm5MLzZEWmlOMm44S3JIcEYra0NrdzhSb3dLcWJHQzB1bUpNMXNReGFQMEpxdDJ6QitQcmZ2dGtUekVKQ0ZzNkNUaDV2TXRyWm9iUEV2MStURTVnYytkTEVnRGV4NkFScmltOGJQaXhqaSs3ZXEwdTNIVFc5Z00vYjc3dDROL0g0US85amZqV2g2WmhjWHllditwT0xlUTh5LzhtNHN2QWhXZm5yT1doMEo5ZUFYandLKzcvOE1nc3VIVDd3RTVzckJvdW4rTjJUeHNzMldUTHMreVdQaWQwNHVIWmQ5SXpOT2Q3NXpMNDIyZmt3em9KMUhlTWVRL1FEbS9RNmViQXIzL3JacGtlYkhmclF4dmNMaDRmditQalNjZFYycklIZmh3VDVteTI4Y2xDOCtaeXRMYlQrNEdOYmZmS0dvNDk5Z0VjYzZkQjJTTkFWdk1NMzR4dy92NHc4TWhVODJrOUI5a2J2VTF5RHB5ZitlMDc0N056ejFIK00vcWpjTFFlbmpibnF1TmFEazFZN08vWHY2K3pmNCt1ZjhtZjdNYmxOdjZVMStqbm1ucTl4QS9CVnZ0aml6SkVYeno5K2IrSmFoTllRTm9yWEFadUVjbEFRQlZKTmJnZjZTWDJiUkV2TkpUT1h3M2dOd3NxcFYzSk1Kc1Vuei9HRXc1dTh3VzB5dDVoMmk2Tkp3YThaN0hOU2FmRHpodzZnRGQ5QmFjTG8vM0lzRU96SHV3WFhuM3c1K3lzN3UzdkZQTlI0ZmVwUGQzVHQrbngxSWdMYTRsSDJwTDc1eXo5bDUyZnhpRi9KdjdGMitYYnB2K0xObCtxbFp0dVFCMTh5c1pEMWxlTDhwSGZuOVphck9TN1hSR00vWC9qODhiZ1ZkUHBMYnFWOHgwd25IOWhvY1Y2bmlvMGpVMTdVZ0N6Z0J4a1FybjQ0OG1OcnJqNWFuRHNoOTlrR09YeDBLbXRrN2x5eXFYOXZtNy8zVUF4MHRSakRhVytkcTgwR24veENQTURiL2YxNDBEZCtmZWdJZDlyUHhyM3QrdmxWSGY2K3B2K0V4L2hQM05rbWx6eDhOTGhLdU5PRzl1RGw3c29mbWMveFI2OGVQZjcrY3pCNlJqYTcxV2wwdkJzMytMV1YrTDdJNHZ5UDljVVREbktDVXczT3RRZFoySmtVYVBPdWpVOFBjSUZWNHl1WTFkeEE1enEwKzlMWll1ckppdG1oemRscDZGOTk5ZTIzMzI3K3JXUGJub244d3c4L2JKL2NjMjVCdG11a3c2QUdaQXhvdWl3Vyt1cG82cGZybm5NVFNJeDJTd3BJaGp3ZUwxcFN1M3czcWRGOWVBUHc5TFNHQVpmL3RZYytlU29YNUhaY3Q2VEV3dy80K213cCt1SEZDTmZYbituaUd4Q3p0dUtubi9ocFFDMjEreXJEUWpRdnRaOHY2NkFGOUxkTFp1UHZmLy83enZPUFAvNndaZWwyL1BsaTBYWFBtWDY4NXoxbk9oMEx4MlRmaWxxUDNPSEpiN1NPRmI5R2IxNlV6L25NZ1g2RmIzTEROaWdYNGd3bko2QytZeFl1L3NZeUh1TU96MXdsekVKTXZweXNrYnR0dy9HUmJMN1ExNjlmbzlPWERUeWd1T0RKQWpsQVorTy8vMmVPMHh5dmVWUVJYL25ic2QzZUFVN1hmdnJuOXZqZTJOb3FuL3hUSEU4eDVOOVQ5S2Z3Yko5UTdIRGwvcVRYdnBjTHI0NTJ5cDg0N2V6RTgwZnh4VmZOVHUxMHd6MEd3emRyM3o1MjY1Q1NxWkQ1SW92enMzZGYvL3ZIMTgrKy8rREZQTS9XSjlycjVUbzJnVE53REY2SldoUDE0N3BzZTRoc0J0OE8rdlpDY00vQ1N1Q1ZpT0V1UURzekE5VXpucEpoc1RIZzJjRmo4SkRmOVJJMTJUMHZpOWFrSzlsN0Y3cSs5UEh6ci9OVFVYUzg4NkhoNHRXMm1QVGhIcHNXaDYrL2ZyTVhNZlJ1VzN4WXYvNnhaVmE4ZnFua2twdGJJSHR4dXUySWU0NTVmeGg0ZTRhVHJLU29YNjdua1Rlc1BQSlRISjR4L25VOXcrczJpUGpmckdlUitkT2taYytDOXY2OWIwUmFqSnd3MWlLNG5oRitzVzR6ZUZtVDU1YnhmL1AxZC9zNWFIcDlTZWZWeTY4M0Qxc3YxdjN3ZFlwWk91YUxMRjdNenpiLys0TElPcUk3ZnZKa0ZMbkFaOWYrMC9wQXp1TGx0cEhubnZkaXRJN3QyN1U3Zi9YNnhWYy9yNWRCRmE5M2E0OE9RMlVuWU9sd2N2MXA5ZGVDcy94d0hmLytsM1U3Ni9YcXI2YytYcjN4M3UyMTZDMk9MYnVHMFA1MW1PV0hYM041dG41dXk0ZURZQlkwSjZINWpNQko1UDM3V2NpTUVmbFF3Q3gyMXpQRWNzcFBOdEQwOFlwVmlZYmVlSVhYQnZCeWhDLzY0T1J6K2VsWmNIbGJCVHozYnBQMTd2RVZ3SU9ObDdjRkdkMjdxbi9idi9ZeStYdTlmaGpCaS9kbmM3Q3l0ZVlXL2VzVXVMakZPOCtpczdWL0JCWnRsZm1sSVJwWGMvbFdHUXprSEpPK245QnRvNjE3WHdHUC8vVDJOTStETFBIMWxlVnQ1NGJFdmZzYVlNVzlCSmVmdDJPdVhsZUREdi80TjR4ZVdnOXM1a0QyMXlsMzk4OC9uMkJ1ZHVESVJGc21ONWl6bndOekxKQ2JwV1YzeDc2bTQyVSt6SEZUYjc3Yjl6blE2ZkIrY1hObVhYZXRjVGlmdytEN3l4ZG45NXAzRHBlL0JpaVl3SzQ2M0N6U3Q0bTFoUFlCMmNTUmF6Y3BMMmZRQnJpSi9uWXRNc0JrSVdzQzdDTzcvcHFNKzRBc1llMFgrOVdZZzh1dkppTyt2Y3RZTlJvOWF2UW1rN1lGK1Z5SWttZmZwQi83UEJwb3QyelNSTnUyYjRPK2VLdVRLMS81NmNTeEQrYjI1NHF0RTB6NjllbmlsellaT3BSZjFvUVY0K1R1MnUwV0g5NTJwUHpRM3dzZjJlVy9XUFl1ZHVsUGh6NitkTEFqVG4xWEpLNVFQRU5PL3Zuek9WWWVueU9qNEUrV1RiNlhKMzF0c2N4SmRRYTF5VkI4L0hYeUVSZGV2L2xJcHpGQUw3bWQyelV4NE11em1veGZRamMyOGtjTjZwZER1ck9CUnJkKyt2YjRPaFpQL0dqeG92T1pEM0JxUE8vWEY1R1NyYzVQOGs0ZytOSFVjUGtpcDNUeUJYMUZ1TnMyUFh6TFgvcUMvQzFHU3cyOUo4Uno0dUgwdzAxOUxlYmhUejIxb3oybTk1NUhIMy8yTEliSm43VGF0N1ZTOXc4aFBmbnhod0tMSVprL3d4dlAxci95QlU1NStEbit0d1Y4MGYvU3hma2Y2M2FHWjVzLy9Qcnhld3Z2T0RPRE9XYzVYSEgvT2FkdjhXQjdvRi9CWFdmZ0JtTnZUc3VHKzlvRzdua0dON2xhc0p6OThWYjJnTDROT2pxenE1MWR2a1hEYnpGb2twa2M4MHNsVy9SaFFEV1IyTUZ6VHRUMDJnR2dQd1hzS29COTU5eHlKcS9hNkd6Um82Mkc1NSthcjRCOWk2aE5BQjQ3V290Vy9QbExScnQ0MVhiQWRJdGpUa0RYdCs2R1BvK0s1UXQ3OUlMeVJHZEF6N3UxVytZVFB2L3c1VE1jWFlCK3BRVlNMU2FQQjA0OTlIUW5weStXaXI0djYxaXM3R0xvUkR2NXRkbkdFMDJORjZEekdlUnJ4MVdmYjNqVG95WlBKM3cyVDMzb2diWkNEbFMzeTQ4WFBqOUcxM1hzZmRzd3ZtTHBCMkRUZCtyV2psLzdIcEtaK2xOZmgvZktEejJmMDRVL2VucXpGNzUrdlBoT212YUp1OWR6eXRjKzVlTS9jY3VyV0IrdHorT0ZJUjIxemNWVHh3UDlPSTV3U21OQkRmanh2OXpabVJOT0NWWlpBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ltZy9oaWxhcnkucG5nXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBVmNBQUFJVUNBWUFBQUN1Rlc5SEFBQUFBWE5TUjBJQXJzNGM2UUFBQVZscFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWxoTlVDQkRiM0psSURVdU5DNHdJajRLSUNBZ1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNEtJQ0FnSUNBZ1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSUtJQ0FnSUNBZ0lDQWdJQ0FnZUcxc2JuTTZkR2xtWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTBhV1ptTHpFdU1DOGlQZ29nSUNBZ0lDQWdJQ0E4ZEdsbVpqcFBjbWxsYm5SaGRHbHZiajR4UEM5MGFXWm1Pazl5YVdWdWRHRjBhVzl1UGdvZ0lDQWdJQ0E4TDNKa1pqcEVaWE5qY21sd2RHbHZiajRLSUNBZ1BDOXlaR1k2VWtSR1BnbzhMM2c2ZUcxd2JXVjBZVDRLVE1JbldRQUFRQUJKUkVGVWVBSHMzVm1zYnNsMUgvYnZ6TU05NTl4NXZqM2NwdGpOSVNJVFdhR0FJSFlBTStFRGpRamdneERyUVFRRVJBK0dGTUJJL0JBQ01TQWdpZkpnQ3dnUVBRUklYcEs4RURBUVB4aTJBZHR4RWdVMklobVJyQ0dVU0VrY1JEYWJQVnoydlgybk01LzhmNnYyT3VmcmxnMEhzTlRzYm5iZHU4L2V1M2JWcWxWVmEvMXIxZmd0ekg0STNZdDM3dHplMlY3NTdJV2R6Uzl0cmExOGJHdGpkWGJ4L001c2FlRmtkbTF6WjNaeWNqTGJlL3BrdHZ2azhlejQ4R0MydEx3d214MGR6dmIyOW1aUFpubU9FMlpoWVdHMnVybzZXMXRiSzcvRHd4SEdOOWZ4OFhINSt5T3NhMi92Y0xhOHZGVHgxdGZYYzE4dS82UGpnNW40VHg3dnpvNk9qbWFIUi91ems2UGoyZExTd214bGVUbjNwVkE1bVIzdTdjOFdGeGVuOThHSDkrVXB6TkxDNG1tYXl5dUxzNDJOamZDM1V2enM3KzhuWDQ5bkJ3Y2pMZnlnNjM3cWpoZUtGajk1V0ZsWnFmeDV4OS9UcDA4VDlMaStlVDg2T3FqNGkrRlRtSTNsdGFLNXRMUTR5dURrc0VoTFozbDVjYmFZOGxObUx1NmR2T3dkN0ZmK2ZWdElPY21iYXpWbExNN0t5aWhyZExpcWg2bThxOXhUVEoyZmVzODM3OHJIdFJpYS9MbkZ4UzVYMVp1eVRYNldOOVpuVzF0YnM4M056VXBYV1BXN3M3TlRmbTgrZUhEcVAvSi9WUFNGcTNvN0hyUTdYOUxjM3Q2dXVNcmdLREtCSDJuUFVrYkhSMGs3OWIyUVo5OHZYTGcwVjdaSDVhY084U1AvaDR1ajdFOUM1MmovT1BKNW1ESk4rU3lOL0MydnJTZGpzOW45TjErZC9mWlhmbWYyTzcvM2U3T1h2M2R2dG5lUThscFludjNHVjE3NzYvL0gvLzNQL3FzcWdBLy8vSm1XQUkzOW9YS2ZldUhaejY2dkxiNndmVzdqeTljdVhiaHlhV2Q3ZHVIODFtdzdTblVjQUQwT2VCMlQrQURaUWQ3MzkzWm5oMUg0aGNXbDJkcjZ4dXpCNHdCdUJKdGl1YmNDVXliZzJ3cEhZWHgzN3pEalBpc2xvU3lVWm5GeFliYTd1enQ3NitHRDJZTW83dkhSQUlOWmdQNDQ0SHB5Y255cXpOS0lkeWtuQmUyckFjajlPT2sxMEI0ZEh4WnQrUUhrQUdKOWJiVVVGcC9BbG12ZzhieTJ1bjRhdjBFSk9OeTRjV1AyN0xQUEZnMk5BMTdrenpNQVhndzRDRDhMdURRLzZPRkJPRTVlOTFPK0JVSkpYM25oUWJrQUZuUVdrZ2RPbk1Qa0JaOEZWSGtlWlpwNjBUaTQ4czBsejZmbG5ieWlKejUvSU1RVlQvaURmZm0rQ09EU0VKMkUzOE1EdktUaENUOEhpZSt1VGpRaytFTWJiOEJ0UFhVMkdzWFZLaWQwT1R3SnU3eXlPanQzN3R6cy9QbnpWYi9LcFBrVWJrT0RHbG9ycXl1ejVRRGkwa3J5dmJ4YS9CeXI2L3pERDk1ZHhkdHUrQXJ0Zy8yRDJjbGlnRGovTktLeXMzRGlMVGl0OFFqTjQvQ3htUHY2aGZPeloyN2ZtajM3M04zWnRXczNVZ0RMYVZoM1o1dmJPMy94eW9YMU84ZExlNy82NXBzaC9LSDdNeXVCSHhwd2ZmSEZPN2Z2M3JyeHhjM1YyWjlmUEQ3NTVhMDgzTHg2ZVhiMTRvWFpPaXZyTUVBVFlkNlB0WG9TQlZ0WldZNjFzRkVXeFg2VWpiS3VSTGwySTd5QWdHdlFvRUFVa0VLMmZ5dTRkOC90anFQTURXYmlQSDc4YVBidzRjUFozdjV1MFZ1TlpZWWVTN0NVUHdwWGlwYjAwVmtMRDlLbjFNTDExWUJHMFRpMER5WXJrQkoybXBjdlhTeHdFQjRndURnMDYwb2pNcyt2UEQxT2d5SWRqUUdBUG93MUx4NGFxMEFpaWkwTllXWnBISlRMVVJvbWJobDRBTTE4SzcrcEtQRG5BanpTNjN3VW9Zb1plaE53VmRpaUtVOERiQUZOMHdpQlU1NFBrKzQ4LzBnMWJmZTNmenNydjRXQVZaWEpZUnJXMEZQMnF3Rkt2UWJ2MHRzTk9PV2xnUDFvQW5VZ0xZd0xhRDRKWHJGMFdiOUFXSHJBdW9BN1piYVExbEc5b1BWMDkrbnM2Q0RwRlQ0dlZEMC9ldlN3dm11STF0SVFhcncwanVMVXRaOEdIT0NMaDgrRUE4N3FvT1Fpc3J3dlRQaFlqUC9PMWV1ejJ6ZHZ6NjVjdnBicmN1VHFJUFc0OG1QSFQvYytjdmowOGEvZWYzendlQ3J1RDI5L3lpWHdRd0d1UC9ieDU3NXdhV3ZuNTdmT2JYeHAvOUhqeit4c2JjNXVYcnN5aStVNk15Und0UDkwOXVTdEJ3V3d5eEZPd3V3Q0JydFJnSWV4WUhaWkRsRndpZ01zQ0RKbEpkUU5Ia0JsWG5sOTUvcnUrWUJTUkVFQkErQkMzek1sb293c1Y4QWwvYVVDMEFHVUZGL2E2N2s2N2FicjNsZFphMUU2WVNpbk9HVXhobjhndVJSbEhLQzRXbkdBbS9RNU5QWjI5d3Z3UEtQaCs1TW5UeXF1Um9CMS9WYktTbDU5WjFtejJJQmF4UWtvK2VhU2prWktHWEhLYzNrcXQvS1kvalR2WHZlVDkxTitLdjhqYjR1Smg4NStRSzdLZVNyckt1L2sxNTMvWVN4bDlLUTlUOWV6TU82bjhSbTFBWHRBdXJ3VXl6VDFxbzZsdzBwMWNXMTUxajE1R1BVejZobzk0VjNLNDl6MnVUd1BRTlFJcVVkbDVDcVpTdU9nc1FhczhwTG9zOVdBSUFzMmJHVFlKM0hVUjNoVlZualNvS3AzVnU5QmpJQWFFZ2p0L2RUVlhrQjA3eUJnbWpnSDhWdFpUZHF4WlkxT0hHYW9ZNVkyYmpIREFjRCsrclZyczFzM0w4V2l2VG03ZEdIbmsrbXgvYlhiMXk5OS90SzVqZG5TeHM1WDd0Ky9QMXJFeXZXSGYvNTFTK0FEQzY0dnZmVFM5b3ZQUHZPTEw5Njk4MHNyQzR0Mzk1NCsvTXQ3angvT3JwMi9NTHR6NjhiczlyV3JNUmhpaGV3K3Flc29BTG9TYXpFRG5XVzU3c2FTWkVVOENRQVNWSXBKOFNrUjF3cEh1ZWJCbGVMeW03OEtBS2FhV2twWGtLS0pQMEJrQUNGTGxUdktVRUIxUlFNU3dMWERvbGRnR1d2S2M3djVkRHpyUmdJRlhkUDE5YlhCTjBzbTZlSGp3ZjAzQ3l6YjhnVG8rUGRkTnhpNEF5WVgxN1RrV3h3QXk0SkN5elhBQTJnTmNGNk81UXRrQUl3Ny93N3JHWkExejlJUXBpLytLZW9LTCsxK0Z0ODM0WkpLOGFac0tndytVdWJLVWg3Q1VPcVYxWjhyZDhNb0lWakRGZTdIdVRyc1lSbzZ6K2lqV3k2Tkt6b3NUZldnUGpsaHFnelZiOTdSTDdyeGw3NGhITmRxaHBjYTJEdmY3dWlNdEVZNGNkVDUydXBhclBzQTgwTEtLblQxQkRTR2N0K0E3SzVoQXRhSGtVczVYOUxEQ0hEdlpqamphV1IwTDhOWGhqWlNDbUtHdGtaMU5UeHAwQTNOR0U0NG5sMjVmbWwyTzBNOHQzSmR2M0U5UnNiMTJ6c1hkbjV5YmVub0o2OWRPSGQ3WSszdzYxc1hkdmZ1M3dmTEg3cC9uUkw0d0lMcjNkdTMvL0xtMnVvdnJ5eWUzRDQrMnYvNFNyU014ZnJpODNkbmx6SWV0aG1MZFM5ZDhxY1AzNW90UmZBVzgzMDF5dnRrNzNFSk1hRjFuVVNKakVNdUJ0UThHNE9sSkJTUEFsSWNTdS9lRnMxOGhjd3IyQWk3a3M4VWgwSURwTHJWMkNUbFhZeVNsV1VWaGFMQUZFdllCaGVBMFFyZklOaktqTkptamVNQzVhR2NyZEFkMy9neFM5VEZyOEZWT1B4VGRtQXJmb0ZWYUFKV2FVZ1gySnFzOGp6NEdKTmVBQUs5NWZBdi9HbWNORmJDamZRRHBnR0Y1cnRCdGNOVy9JbE81U2xwam55TThxcnZ5NlBYTUt6NnFmQXFyd00wZ1VnN2NlVnJsTUdnWVVJSlAvS21JZlBzdStFYTl3THd4QVBLSzJrSVdZeHJxWHZEQUU5VFpvOHliS1NjWEdUQXhYV2VYdi8rRzZHaklSdHBET3YxekhMRkV3dnpjQnArTU01cXlJRWwrelNUcUQwOG9aeVZTOWVEK3RLd25ZVEhlQll3YTZpWE15RnFuTmZrMzBMQSttbmtsekdRYWNOYzVETERNVW52T0JPUDd2dmtQZUM5a2ZtRGFxelRHR2lFWS9GZVgxOWYrUXZiTzV0L2RXTjFhLzN5aGJYMXk1Y3UzTGdjUy95Tis0OGVkSmwrZVAvL1h3SWZPSEQ5MUNkLy9Jc1p5UDkzSTdEM25qeTQvNHRQSGovOFg5THYvN25yVjY3TVB2ckNDN1ByR1hjaWFBdVVLc01CeCtsbXJXVlduUlZyWmNCaHZyRlFBYXV1bHU1b05DNTNRcnlTcnRqVEFncUtTRUVwZkZ1dVEyR0hKVFFQQ3A0cHNUdUZCcTZVa2F1dUlvV0pOcVBGY2hTdTN2T2RGYU43S0kwQ3RTaWw3OElDZ2xicUlwWS91cEFqblRHMDRabWlDMGRaTnlacmRoNXc4T1k3b0dYTmVXN2FUUXQ5OFRVbytCQkd2QVl6ZkZaWlpPTEV0N0EzM0pTdlFYT0FxM0F1ZmlOc0I2NW1wK0lWOENhOS9tNzhkVHlqbmZqK1RZbWN4UjdsaVlCdmVPOXlIK1dRc2xEK295c3lhQWlzdkhtbkhsWUFUY3BhWGpubE5IOVp0WUEzZmdEdjBhTTAwTEg0bFl0aG5wTlVxelM5ajVVVmFmQXllYWtuWVlnbVFwV2hpMUUzSUJEWUd4NFFIbUEvZXV0UjFiZEdFZ0FhOTYwZVRNSWRKUzRENENqMUNaU1gwOUJzaHU3VzFyblpSdE9QdUJLbnZkME1YMlExUVNSb0tyZFJWMHVKWjN4WTNOVU1HMjBGUEhkaWJLeXNwM0ZjUEprOXlzVHE0eWVQLzUwTUQvMzB6dmE1bjcxNTYvYnRaNSs1OVprQTdmcWxuYTMxMSs3ZGY3VUs1c00vLzhvU21KZkxmMlhnOTNxQVQzM2lFNTlkV0ZuWmlWRC8rdGUrOXJXWDhmdHZQWHY1aXgrNWMrTi9ldjcyamRtbGl6dXp4YlRrQnZ3cEcyRittcVZKRk5GeUsrOFAzM3g0cWt3SldvclVFeXZpUEdITlVzWTVkd29Bb1FOZ3ZidGFvU2xidThCaStVdFQ3MCs0MkJlbllVL2l5VytGaFJkRjhSeXRQMDF6TlpZZFYvSEZqYkp4bmRicSt1amlTOU9NY3ZIcU9lRllReHFSN3U2aTdSTEdIYUFzQkhpNmtVQlh2T0poU29QQWROb21aemgzZmx5R1lQSjN2RmZhQzIyMWpzYmdhSGZFYWNDMzFLempIbWZaMWxLQWpSTzMwL0hlSUhsMFBJRnIwdk5kT0ZkL3Qvd012L2p1Nys1TlMvNDU3NXk0d25lY3BZMXo1VWNXQUdnMVNBRTY5THcvRGdnSzY3bXRWaE45UFlHMUVzQWF0QVlQbHArMUZRcThUbzZORzJmOE80Q005bWFBRWU4RnpHRnBkV1VNSytCTG1pWVFMMXk0VURTQjlaT25qOEwwS0lQRnlJS2xhUURmWGZqVmdDYndQa29qamNlOTVJT1ZiQWxhOFpFZW0zQWEwcXJ2cVd4WXhkLzczdmRtWDMvNXU3T3ZmZlVQWjcvMnovNzU3RnZmZkRrVHJRdXo4eGV2ekc3ZWZEN2hWMTU5dEx2M1c2Kys5dHJmZXUzTk4vL1cxNy8rOVE4dDJwS2lmL0dmb1puLzRtL3ZLMTlqck11THg3ZC8rM2UvOHZmdTNidjNFUE0vZXV2eXgyN2Z1UEtQbnJsNU04dXR0cXViYlRLQkF5QXNEK09IaEMzcVdRTCsrT0hqRW1UTFdnaGZ0TENFVkhqTGRJeGZ6VHRLUUlncG82c0Y5cDFoK2oxR1JlQjFVdTQ4NlBvdkJGQlpKNVF5ZlR0SkRuOUFCYmdxeGhrb0pNbkpvVFFjUGx6SDZZYmpoOElhQS9SY1k0SjVMOUJNUG9TVFZxV1g2TUpVL3NKL2w0OTgrTzZiaTFOT05aWVovd0ZPM1NpY2pUTmJkMWxwSjcwUnQ5OG52ZzRHRUJiQi9KSFhCanJQTERueE9qLzlyY1ByNW5MU0VNNmR3MXZ4SExEMkxGN0g3ZWZLYnl5MzloZFBPdjNkKy81VVpwN1JZOFYyT1VsclAvbnJ0RHBldnd0bmFaY3lxdnJNM2JBQU1LMHlURnByYTV2RmM0MFR5d05MTnNNSUhJdlM4QVM2K0dMTmtsSEFLejUvOVp0YlhPUXllZWt4K3IwWURNWmNTNTd5YmF6U3lJUmNBb3VuQnpieUVpTWk0V29GRE5ETnQ0MnNqYzBTcmF5Y3VUamJ1WGdwWUg2eEdvdXRyUXVSNmFQWm0vZnV6KzUvLy81UDNudmorMy9uY0dFaGdKcXlYbHk0OE93enovekV4MS84eE0vY3ZIbnpwVzkvNTl1L2pxc1AzVmtKZkdEQU5ZQzYvK3JyOTc3UldmdjAzUnVmdVhiMThwZWZ1WG5qeW8wc3VWcVBraHhHQUd2R1BOMWFBcTlMcDF0TDZNekNFbUpkTk9PSFdua1dLOURaRFFDekJnajhVWVRmM2NSSVhWR1FBcE84d3p3S1dkSWZvUld1d3hZZWxxRG5lekF6OEpUUUF6YnJ6bUlWSjlmd0h3akt3aHZHRm45QWUyYkY1YkZjcFRIeFVZT0Y4UzIvQUVXQkQxN3pIZmliQkFFQ0JRVHhwN1I5eVdzaTFqY0t5Zm1HVnNjeDgxekdhYVdCRjkrRkhLQUFYSWViZ0JmN3lZTXdCUnpacE5DMDNjZTNrVmU4SHlRK1hxWFp6bk5mTERKTzNMN3dwdHhkMkc3L2p1OWRHUGVhaWMrSHB0ZGgrcjRYd09IVVA0dVVoZGRsVlhTUytScUh6WGZETlNid2VqYWYxV2k1WG9PN2ZGaGlwMXdOQ1d4dmIyVjRZTHZvMTlCS3JOcWpsSjgxdThaaGpibVNJa01zdnBQSlI1bUVOYkdLampYRGg1RlB3S3dPVElJWkhxaXlUVDJOOGQyRUNTQ1NUV1ZoQXRHek84QzNtb0xzeTcvOHVKTUw2MlB4S2UyTEpuM3ZQRHQ3L3RtN3M2MXpXd0g0M2RuTHIzejN2Ly9OUC96bVAveldkNzd6VDcvOThuZCtmVzFqNDQvWDFzL2R2bmJqMnMrY3YzVGxjeGN1WHI2OHViRVZOWHp0dzJHRHFtRk4wQWZRL2ZqSG4vbjU1Ky9jK3R1M3IxMitjbkVudTIxTVJrVndkbU1GbURnZ3VBU01aV0JXbS9Mc1p6a0x2MlVMdXFNMGhHNC9Gb1VkUTRDVnBGb29IN2t1QnloY2dOREV3a3JTb0VDSlZrSXJrR2RoM0lkTDJDaGdLQTJZakdJVWpRUVFaa0RuRkxUaVRzQUZZT01xVE1VWm9Oa0FnWHdEa29ZQ1B5WkdSclJZTVhZREpWVldEZ1V6M3VaOXJCa0Zob0FLK0tRTG0vempTVmRTZXNKMmVINEZ1YXpIc2lBbnZpc2hYMFlaS1QrTDJuVkZQZHVBb2V6SzM1Z3N2MWlZeFhmaXVrZjdFMDdqd2xvUHJibExNV3ZVRHN1cUhPUERBTXlsN2hvNEN6eXQ5Z2pqWFI1SXp6dkExSzdMcjkvZGo1TStldW9TdUNwUDRianlEOWdDWHMvODNZRjZ2MnNjeUZFQlZ0SmlhZnBtSThiNTdBSmN5UTYyV2xXUTRZUHRBTmRhNkVrRHY0K3lWTTVxaitJeFNZNnlUbDQwY1BsdVVrMWpKR3dlWXJuR1A0MU5mS3J1bElmRzBMeUJkYkFEZVBNTnBhbEk4ZDdyY2pYbUxHY2JPMHpXUFk2eFlZeDNLK3U3ejIxbUxQZmM1dXpTcFV1ejYxZXVac25peHMrZTdENjY5KzNYNzVlRmF0bldLNjk4OTJ0Um9YLzQrT25qcnh3Y0h1MXVudHY1YytlM043NzF4aHR2ZkRoY0VIbWhkUjhvOXhNZnUvcWxaMjVkK2FWbmJsNFBxQVpvSWxVMVV4b0Iwc1doRUVCVkswMm9iVDh0Z2N4N0tVcG15MzB6cWJVZmE2S1VkRkwwSXdJZEtQQ3ZJQ0VDcTZVUFlrMnp0Ukh1L1FtQVVxckM2YnBKaytJblpKUUVJQ1ZNbEVjWEY4d0NWZGFGbVdDckJZU3ZmeFV2OGNVdDVXaHJZMVNaY0Z6ZlBjdURpMk9EMWJmaWM0d0I0cGVmZk1sbktXckNuVm94MlliTHp6dGxiZUFBRnNJdlpMeHZhV2xzaEtqWm01UkVVczAxM1BMU0FCN2p4V2R1OEkydmhheTlyUFJUQmlQdGtZNjZNRDRaMHVVdnpQeWxqb292STlRVC8yZjBCLzhWSnVPMmVPY3F2VHozbmQvQ1JOY3poMWFITDQva1dUb0EwaGhuQTVad1JTZDVQUTRnTlQvOFZPWisxcHNxbzhlc3o0UWRtMUN5WlhVdE0vNmgrZWpCV3huUE5tRzJVZlFCdDIzSjI2dTJ0cVpibm9zc3Z2N0c5OU9EeXRocVZpVW8rd0h5NjZjTmlYV3YrRFdjZGJ5WE1rcFdseFpqTVdjaXJvQXp6N1hjemZodUdxUDl3MnlBaVRReEdzSlUwZE5ZNHJVbjNLcnNVMkZrY3UvaG85bEo5R1EzYTJnZlBYNDZ5NGF3Mlk4OC8weUdEbFlDc012L1hRak0vc2x2L1A2dlZGbmx6emUrOFh2Zm1uMWo5cTErdjN2Mzd2VisvbUcvdjAwRjNxK0Y4ZEpMVjdaLzVPYkZYL3pvelN0ZnVuVnQrK2V1WGp3L081OWxWNnNCdlNWQUVZQURlcldySjBvTkpDakFzRURHUkpZdUdFVTVqdUFhQTZ2bE1va2JTWTZXQXIrQVVmeVBEeWx1RkRZZ3VNZ2l5OTI3V2Y2eTdGaGVrZmdFcjZ0bS8rRVBMY2lWRnI0c3lMSm9RcHNsYStQQ1VIRHhCcWhFSDBRS240TUZiOUtCWXo3bFM3M3lLaDVEaTU5dUtocXNUeUFobjk0RlpwbUs1dHZSSWFZQXo4Z0gzdkRLa21INXJtVWN6dVU3SHNRUlgxZTRsZ0JORnIvbUFkbTJjRmNtL3lxZldLZktGRURwTGJoTHYvaXRtL3pIV280VnR4WndXRnNQQU9BbjRRekoxRVJpNVd0RTB3Q3hyRGg1YTREekxwOTFCeVhUc3pMdGk5OEFaOG1QQnFiamRYanYxdDBMUjBZQUVKQnRTOVQ3NlRiWlBIT0F5ZFUwOGRqeDhRY0VEVGNaanJMNXdzNnMzU2RaWFRENWEraFpwWG9VTlJtV3dzU1BPQzYweXRKTUdnWHVRY0RUZWtoWjIwSzdtREwwTDBLYXVDWXZVNlo2YXdtN0c5Qi84dmpKR0ZZSTJCSVhhU1ZnUFJ2aWNPSEJGdHVUOExVVVdiQ2NURmpXclVaZ0o5YnNUb1kxcmwrNy92bGJsN2QvY2VYNDRDc3YzM3Z3RldVdzcyTFJmcmpqYXlxUUR3UzQzcjI4OVpmdlBudm5sNjlkdmZUQytYT0xzNjFZQnpZRWxKVUN6TkxWT3RnUE1PWitXT0E2RklObFlKeUswbWkyS2NoZXdwaTBzQXlMWUJjbVJoQnJCamFXUitDbHdnazdoSDBvS29WdzhlYzhpMTgwOHR6dUVNMEtGMHJabGNNU29SeEpmc1NwSVQ5alpJV2FSUTlRQVRCdUFHUytoYkVDdG56Z1Y4OFU3TlFpSElwUlBDUXZISEFySlVwK0tiNzg5N2lpWnlCaEY1QmxRNVlQeVIrUUVWWmNWcFR4eGJLUW9yeXNZUGt0Wlo3OEFlSUFSOHdPdXp5QkJsaFduUXh3YTM1WWVJTWU4QkRPZldxNGNnZmsvZTRaMEhESzhBeTRoUjhGVk51RzhaQnJnSHJLTHVsM1hWamoyUTRORnllTXEvc2R3cytEdC9jcWk5TnUrNGlybm1yc05YeTFwZWs5M2lQTmdGUk5XcEVyNTFUVTBFWm04UU95MXN5YVdOcDFHZS9QZlNtQWFmMnBjZ0dVWXh4VmoyczhEOEFObHluYnNqaFRaOHBFdm9kc2xDQWw3Y2h2MGpMR2F2am5kT0lzYmFwaEJ0OVcwckRyL292ZjIzbVhBdEExanA3dnErZ3ExcVF0cmRYSTZkWExoZ215YmZ6cWxaKzZmdkhjejU0Yzd2N2oxKzQvL25DY3RhVG83WC9ldCtENm96LzY0c2RlZSszZUc3Sno5ODZsbjh1V3ZzOXNaODNlZXBiK3JOalBIcW5RTFRySUtWUUg2ZUljQlZ3cFM4U3F3SlRpVVNiTHNpaE9aTFVVN1VsYTcxYkVXazlJcVNLb0F4Q2pTQmt6UzhTNnFLWHJkRHd4aWxIalhPVWZJWTNpanZlRW90T2wxeW55M010U0NVQlpXZ1U4alo5cEJLSWlGUkFHNEE5SVVPQUMwUHJrejNBTkNIM25hOGlCRTQrU0Y0Q2tIRGdLRW8reXhKUUZVR3NnQmJJQTlXS1cvYmdySDJEQ2FrTkRYSk03NjdGbVBROHd3NHVHSUkxRXJCdmd5eFhQcHlBMkdwejJDd3hXbU02YkJxYnJBcTJGak1uNmRrWm5BT1dJbitlVWoyZHg4Q0hOeWxmRllFRVBvUFhkSlN6WGRWcFcyeFIyL3RabGFMTkk4OE92MDBGSG1kbGt3VStac0RwZC9MMXpHbXJQeG84SG42bUhnQlJhWlZXeU12T05aV2d5QzRncWtpZFpFdmo0eWFQcTJhZ1RCNytvSDN5WDNDYU5BdmRNYUJteVloRVhhSVlHMmpXZVhSYnJXdkd3bDNvamFGYTlqRjFmWlBNa1k2dDJIajZheGNJczN2RTQrRnlxZXQ5TzcwRmpGbWJya0pyTmpjM2M5V0p5NWtYcXg1andUcGFQWGNtNjhVdVhMbC9ZMk56Nkt5dEx4L2UrL2NvYkg2NFdLQWs0Ky9PK0JkZUxGeGYycml4c3J2M0luWXYvMmZYTGw3NTBQdUN3bXRaN0owcCtMZ3JBRW56NktGdGJJMHhCcmhLV1k4Q1pmeFMwQkRWVzdWQ0pkTmN6YkxBYndXa2dqWDFaZ3QzdkpZU0E4RmdYU2hjNkpNMTgxNmd1b0NhUUxMMG9RL3FXWnJYck82c3pWOFVKeHBrWnRrdkpCTmhZc3pyR3p5eVBvU3loblBBQU84QUFJQ0w4MVVYT2w2alE3Q2pmYWtVQnE1RENDdHpQWWgvc3hob2R1MjZHdFpNaGtBUmhFZVh6ZUU0K050UEZ1MlRwVFpTWTlXTEN4WHJLSzljdXp6YlNCWHdTeStxK1U3cFNRRTREV3pWRWtQSFVVV0Jtb0ZubFl5eHZJeE1mNjFrZnVwajkrYnFwaGdpcVBDSm5TL0VEZnF6T1JLbGhnQnJManZLYVdUZlp0Wjk4R3k0SlRKZGtBaFN1d1EyWXVkUkJ0c3Jsbm5wSWZxeUpQYlZrWTZGWkNYR2Nzc2F6SzBWWmFWYURsVUl3RmxuQWw3dkd5cHBuK1NFcmRicFU3b1lwOUhod3NoS3dXa202eTBtWEZiY1JpOUk2NUFMT2ZLdHRxK0VEU0pvb3plTDcyaTROL0FEaTREL2gxSGZLQk1pUkM3UDVlbEltR0EzWktJT2w1RW41NkZtRXE5b1Z0cDU2QUxCb09hRXRCR00wV0tXUThrdytXY0UxMUpXeVV6Ykszcmk5QmdBZ0dxS3hZMDc1YXhRM0FwQzdHUk4rbU5VSHI3Lyt4dXhCZG12dDZhV2xFRTZTNzVYRVNjM09WZ093ck5mZGJBMG5Oc1piazh2WlJ2UXJhRjJXdHNlTGtaL05wTFg3K1BIblQ1NCsrWTFYN2ovOFdsai8wRTBsOEw0RjEzdjNudXpmdUw3emIxNjdjdkhMZDI1Y1RVdS9WZGJxU2l3M0NtVEp5bUVFbUFEbXRZUzRMTkVJa2hhOExRMEM2OWthVmtxdEc4WDEyQmxKcHlSMWhVN1VyTUtMYzBwRCtNU3QrRk0zMm5OYkhKNDdQQ3VtZ0JwUVJKdUcvMUFvYVRpS3psQUJoUkIyZERFSE1JaFhTbFljbnZFMXZSYVA1Mk85aTRzdTVVWGpYR2FsdDdhMjY3NmQ5WXlYTCtmUW1oemljU2xyR2xra05RR1N0RGt6emM2VVpkM2dmOU9zY1E3OVdGc2JDK243N0FEV0YzNG92L0ZTZHdDSTk3YlVqQ3ZMZXlHWXYrSHBNR1Bid3JLT3BlMTdqMnRxOExnUlorU3Z5OHE5QURZQW90RXA0RWplZ0o5eU03NllCTElLNFd6WVFNOWx2dXpSbnJKNVdwL2xWLzVUSFFkTjBEc0Y4M3dyY0N0ck1WYnBCTkR5OGlkcHMrMkdTL0dVMDhBQlVEUnFuRDBTMUZhdEhvbThDS3JCWVFXakthejhicVpSMDNBcEwxMzUvVmlyS2QwQ3lxMDBobHV4Y0RWUWVObk41TnZEMUptR1czbUg4cEJ6Z0QwNFVUelZnQnJhMFRqdVJVY01TVHhKWE90a2xmOUc4aTl0RFJKZVhLeHgzOURaMk54T1E1TURhaUpQR3B1OURHZmN2Ly9BYW9QTE84dUhENzU3LzhtSEFGdmwvVDVmTGJDNnVQU3hpem1QMWJxOHpad0dkSkMxZ0FUWjJOVitUaGN5d1VRNFRKdWJyQ0ZkM2RVbmtFR1ZoQStnUnRCYWtNemdlL1labExKZ3lzREpPMHZOR1FUdmRDUDhBRnVLZ2ZiOFJWa2JKQUFmSjQ0VG1JWS9LNmxuNWdNQUVlN2lMWFNFU2VDaUp4NzZGTjhsRGUvQVRMZmVkWGxubzVUVVRERGF1dks2bVowdVhvQWx2NWhjTldPTUJuNThPN2UwV1hmQVowS0xSUXRZS1pjdzdpTS9ZVEgwMGRXMTVlZDdadndHa0VRVmw3SWJxVW9yUXpYVldPVk5ZN2VSNHg3WDA5MnNkRS9TZlExZ21kampXTERvc3VhR1JablBvSUtmY3N3LytiWXJiSXhMNTE3dmdhZ0o4TkVScGh2SWNGWHgwWmgzNkxrUytOUWJ3SFg1bnFhWmVPMjNYeE9CSS9oSWY5UlgwWW4zU2NLQ0pzd1BmZ2Z0U3BuOHhFTGtVcVBqbmpKVERwMFdJT3VoQlg1NkV3N0NWbC9vSFdWYks4RGVTLzJTUzNHclBBSjRaTWh5UTNXRVJsdjRpL3ZabkpEMGhGV2Y2S0M3RmQxWnlzNHUzNTZtcC9LZDczd240eE1YU283SWxIeVVqRTExejI5bE5RMWd5dXRjWkdOemRUTUhJRjJhZmV6dU03UDl4Mjk5Ym5ONTl0THJKMXYvOEp2Zi9PWTRlN055K01QNzUzMXJ1YjUwNWNyMnJSc1gvL2J0bUsvbmMyU2FybHlrSjFLYjJkM01rSTVEbVlFU2F5d0NERHhTejRDVUg0V3JLUG5Ed2dQRUpyR0FzNHRpRHZtUEFoYmdEdjladGw4TzVUNER6RkxrU1VtSUV1RjF0YU1rbEpOd3VqaHhkR1BkeCt5dWJxT1o4S1E3ZmE5VkM5TVltMGFnd0N0a0FkbzhIUUI2T1djbVhMOStmYmFlUmtiYTBtd0xFZWg2RjkrejhPTFhQdnVrMVllMUNFTXh1WjR3c2EyU1VwYkNaeGlrVDd0eVJ3Y0lOeS9vczlpRWQ3RnU4YkF5L2RxQ3ZGbzcyUmFyM1Vlc1Z2bEJTMWhoT24vS3JGMlZWNzZwdHdUeVo1UlVudXN3bG5TYnBWK2dQT1YvakZXRDVsRW44cWRhdW43Nit5bEk1cVB6STFoL1lwVWNSRGFrVjVOV0FUbkRNT2owTlYrdnltRWpqVVkxT09tQk9QaEZPUmxXR09BY1lKMHNYeE5JVnFUVVJGSmtrc09ITGN1c1ZNTkVMRXByVDUxNlpYam9YR2luYTFWMDVVbStqWUhXeG92SXIvb0V2Q2F2V0tRbXcrVER1TGExenVpcjYycTE2RURpVy82bVo3T1ROYmdYTWtSMGxKNkZsUXdNRktVOGhubkdXYlh5ZFpoSk9VYUdJWlAxMUpjbFpCY0QyRllTWE5qZXZQQmtmKzh2YkM3TXZ2dks5OS82STNuNllYWm4wdnMrS1lVZmZmN3l4MjVjMnZuMG5SdVgvOUZIbm44MkRlZUZkSlVDUEJHSTVRalA4VjdPWG1XNUJwVElMRDBFbmdRaTJEQXMxMUpPei9Fam9BRTU0MmFlODc5MU4zZWlxYXNYdXJGOHh6VUtxZ0dNa25FajdyRCtSb2p4dDhPMUV2SUZGRnhScGxBMUVURUEwOEVmRUtCbjlZM1JvczJhcGZoMWdsSHVGSGtvODBaTmZoai9ZcFhzWjVtUHZMTHhIS0xzOEczamVjd2NnRW41M1dzWFR4VFZpVitVeXlTR01WKzdnWnBYK1FlcVQ1OWswb1pTSjEzanVTTlBBMlNFNVJyOG5FdXFpMnY0d2tTZmJxMHgzQUt0OEd4SVF2NGVoMC9nSVY4YmhnalNCV2E5cmtUNWE2OThGTmRoT1VyS0JvSytLaTNwK2VJamxFbDUxbnZvOGxBblZUN2hyVUF0N3cyR2dyd1RYTDJmdW9UdGQzbFM5bHpIV1FqTjArZkVhN3A5SCtQTnBHYTROTVgxVUZaNG5rdE9BcDQxTGpzQkxJQUVzaHIzK3BtZXBGc0FHVkI5OU5iRDZ1NzdYcmtMUDJOMWhzazhHd0xDanhhTjBSQVpyaE95NUNjMGV1TEx5Z0Qva25wNFQxbmtRc3poUk1hSmJlaTRkUEh5N0ZvYVoydHhOYkRpb2pHR1lNWjZXeHNlN0VKYjAzRGtqaDdRendFdk9XbHVlM1k1MXZDRmF6ZWV1MzcxMHM5Y09iZjIrYVhaNDYrOWRuLzNXMU5SL05EZDNsZmd5bHJOdVNRL2NlWFMrYiticFZjN3Q2OWZ6YmJXSElRUkpUMEtvRVp5QTdKajdLZ0Vpdjdsb3BqZExUV3hWSDd4QjBLMU1XQUNYeU1IRGk3SmJiZ0VGSytzUnNLYlo1TlY3cTFnQXJZU1VoelBmZm5XNFNpZjUvbTR3SFdFeVVSS3ZuUEdmTkZoamRTNGNVQ0txckxxWER2cHlyVWlzL1owN3h6dUFVd0E0VjZVaFhLZzBXbEtGOGkwWlZqS1kzSXZGazZEbzNXWWI3NzVadUpsUXFTczBXazlhVG9ENGt0cmF5dnB4RExtS0NzRmxRUGpkeFM4Zm1va2dJb1BscXZoZ21FcEcySVlGK3VKeGVyQ243Rlh0TXZhQzNqajBiUDhOUCtWNFBRSHVDbXJzV3hyc2tUemJvbVZPSmdxUUUwNGx1TTd3YlhpaFFkdS9CMTNlZVEwWnNsUWRZbmJra3dxSTJ6OFdjYXB4TGRmWklic0pjOEFVdmtxZzFyNnh6cGxYZWFkSmRuZnBhWmhxVEhTcEMxOTZha1RzaXRGZnRYSXBxNnNqWDJVdzFXc2VqR0pKUXluTEV6cUdldGVuNnpTYzVsY1BKY1pmWDVrMzRvWUUyakdiRm5SWk15RUdIQmVUNk9tYnF4V2VmamdZWGlJakNjUEpXTXB3K0lkMzFNZTF0ZEROME1DeG5xRnMrNDNpUlRkbFZqQm03RitiMTNQUVMvWHI5NitlZTNhejk3Y1dmdnBjeG1MamRpODJyOTY4TUxGRE9UdDdGeTRUK2crd081OUJhNVhOamZYMWpkbm43NTE4L29YL0Q3UVJsclFnNERKUVdaQUk3a2wzQ2NuWSs5MWdXbGhWd1EyZHlBNlFDKzZFOG4yRElCWXJJVGtkUDJwRTRlaVdsU3VkQ2lSQ1Nncm1QVTM5S3BwVlFKRlp4NVlXMTRvUnl0NksrODh1SVpneFIyVEhnT1l5NG9PUCtqSkF5VzB5TjRSZElESWM5TUZTdVVYUVJmZWVPRUo1Y1J2V0dPbFROQlJ6NnhUL21YRks1VGt5ZnRCeHFjZlo2SDVrK3pJNFdrM0Q0QW9ldmxlVm1EOHBMdWYxUWdGSENrM1RuNkVWWWFqRE1hNExPVUVyb0N5QVEyZHR3SVF0bm5LbStQeS9DWlZrc0JzS1d5Tk4rZlp1MmVXMDl1dStKVi9CV0U1VHNBVVVLK3VleXdxYVJmSklwczZ5SHZYZ3pMbjhDM3o4cVNNMitHeHd4YkFTQzloaEhjdEZvQjNhR1daZWlKSFpFaVpCUWdiV0t0TTRzZC9YSVlCUnNNcERyNEd3STU4U2x2amppOWNWbjVTaGw1WXNxekpoUUNaQnFDczBvRHNHRnFZaHJNU1J3Tm5HS1orbHl0bHdzSmtjZFlLa295ZDR3MUlQOGxLQU5LbHA2SFhZTW1XNFFKblE4Z3ZlZFBRalNHWDFHMTQwdUJiaDF6cmpmTU5qMERYWGNOUVpScEVXVm5KMkgyR0MyN2Z1ajY3ZXYzeWxTeVIvTUxHK3RMbnRwYjM3MjJ0TFIrdExPOHRMMjh1TEw5eGYvY0R2VTMyZlFXdTk1NDgyWC9oeHZuLzlMbG5udm4wemF0WEFpU1oyWDZVYllVeE9Ra2lGRDNKbUt2S05sN21RZFdQTmo3UEVlaGF2alFwQ2lBajVBMnNpUmJoVmlSUnR3QnBBWFRvQUdaK3dLb0VLRyt0Yk8rOGw3SlMyRnlVczVXMUZWNzREbFBqWTFGS2F4NUxvZkxOaEVjcnQ3dHVHT3R2eTZFZm1ZaGkvVFJkdEQwM0QyR3Joa2JjT2QrazFjby9mNi9uS0lzeFQ3dUczSUVCOEJhUEV1NW5qVEFlVEdoeC9Cd2V3aG5IQSs1NDRQREFQYzJ3REV1MkRyL0pFaDdnWVFVQ2k0MmlXb2xnZkhzMVZwWVZEQURmWklxaEc4dlRxdXdMN3BTZmJyM2hqNkhRbm12blVQS2svZFBWQmtPanJGUG1BVnBqaW5pUlAxWWZKejh1ZWFtR0xOK0wzNGxuOGR0MVB0ekZrVCtXbmJ5cUI3TENueE5QT0ZlbGwvdEI4dW45bEdLMXlxTjg3QlFrbHNBUktJclRsbXlQODI4bW5hS0ovNlFCdERRdStLaXpYVU5ZR2RpUWtEMzlzVWlkOG1hM29lNTZWbTZFUjQzaWd3ZjNjNzFWb0Y0YlA2bzNvaTdIT0xsR3pWekU2MWtxL3NZYnI5Y2NCWG0zWEl0VGIvaFE1M2dZamVSaU5qNWt5QzF5dzNKbVFlTWZnQnYyMFV6RnJrNzVoTWxNWW9idGhNMk9yN3cvOS94ejF6LzFxVS8rMUxuTm5WOVlXRjcrcTRzTEszOTA5Y3FGNjYrOGZ2OER1N3JnZlFXdW4zcjIzR2MvL2NKenYvenNyYXRaZDdjM2UzVC85Y2lWSXdPMXVLbk1DT0RlU2NZSEl4U0EwMHo3U1NhZ2FsZ2d6MHpXVXNqeVozRWtlb0Z3bEtXK1JRRWpLTUlYR0VTQUlpWFI0NEJVd05ZRldvQUhwU2FNOWV1bUZ1N2JoSjM5M0NXRXNSaU1OOUt3aEtxd2pFaHJLUG41eHQveWw5MG9TVjR5N3BpRjR6bnFEV2paSllVT3g3cGhRZWp5NlVJNjg3UWlvRkNOQTJYR0o1QVpBSWgzUDlYTUdyRTZ3bjUzNDV2R29uVWhnY0p5R0dwUW9TZ1VxVUFqNlpteDE1QVlLelVlYW5uWXlFL1NDRnZWQUlTT2NqRHBkaFNlVXBwcGo1UUhZRFYybXFWWnlVdUtMSFV4RHNBeE1VUHZhaTFwaXFJT3k4a3dEbEFFeHRJNFR2Y1ZLQ1pZalQ5YStsVVczSFJmTTQ1c2tpamQycHBzaVFZRFlTNVpLSkFlb0RTc1FvVlMvNUl2NFZKRjFTVWVhMTVUbDZscjhlUlgzUjhjcGo2U0QrT2E2b0wxWFJOQ1NkTXVLRk5kMXJ5YTBDa1pTQjNJbnpvQUt0SldEd1dJeWlGZ3RweTZzMFRzSkdQZmNnYWdTeVlUdUlhbVV2NGFGOVdvZkt6MGNCbG13SnloZ3JHME1NQ2xWVkdvdWRRYnk3Rld4Y1RBSU11R3JZeFZBMUhsdzVMV29Qa05PR2s5Q04zRjhGVS9oSm4wandLUVIxa0xmdkFvdzBrNXFQdGhHa2NOclRYYnk4RGFFWW5oKzJuQ1BkNjFRY0loOGpGZ3JBREp6M3p2cHJ6MmpqSVVsMyt4Mldlcmk0YXhjbTVITXBJaUtqbXpvV2MxNWJ1VlJucC9ZWDMyM2U5OWQvWm83L0huMDJqOTArVzFwVzlseCt3SGNuamdmUU91UC9iY2hTL2N1WDM3N3o2ZjM3K3lCLzNRS1ZaUjF0SEtSd0FqYkFUdklCWE5Jb2pNUjRBanZDYWlJcUFqSEdFZVFCSklJcmVsREJBUDBCZ3U0TkZoS281QXZLZTdNS083UGZ4RkVKY2ZwYkxBZTd3UG12UFA2RFJ0VnFKSkNzNHVHRHR5VEVnQjYvbDFyc0FRMEFMWndRTWd4Y09nMzgvdXZuZjNERkFLSXozV2gyOHNOK09RUlNmZmhLMTRVVHJoT09Bb25yQ3NKWmZuZmwrYURxTkdvL01DV0pxZitURlRJRHFzdkxPd25UZit5Z0FkK1pOTzBjd0NlNjU1bDRhcjAvZU1iZUhGWTdGNTd1RUIxcFM0WmZGTlpUQitobnFVRjJCc1hqdWQrWGYwN1RpclNjRElCZmt4MFdkcG4vRkZZZkZadkU1bGtHQ1Z6eXFuQURTKytzSmI4OHFQRmR6ZlBQYzE4aEQ1MWVCR3JsbWY2cTJ2SG5wUlkzaW84cGpTWVdYaXU0Wngwbm93QW1wNElOK0J2TjFjemlsKzhOWmJBY24wRWdwb1I2TU16Rm1XdFMwNFlQZ282Y3RieERsM2pkVVk0eDJUeEFIbzlFSjhWMzh1NmJwcVNDUThyNmRCQ29OVmhzYW5EVEhSUDJ0aHYvdmRWMmF2dlA3OTJmZGUrVTRPNW43RkZ0clA1OVN0OVV5ci91OGZ4QjlIZkUrRHF3TlpiQlo0NmNwcys4YlZHMSsrKzl5elYyNWV2VFFKWU1aWlU2bWord0xpVXRFUmh0cUxIWVdvazlpRHNLd0JGaFlCaUlyWG1CZGdIVzRhSjRwMjhDTzBDVllBQTJTRW1yOEtlRFRINVlpNU9BTlVTMEhCZXdTT3EvZlE2M3NyWkNsbGFGTWEzVU5LdFozdThWaFBtcTJMdWxFVG1KVUNSVURkcFNZUElUaWxLWjN4VEFuYUFxSXM4MmtWaUFmRThBWDQvT0xDNkM2emNHS3RoUjVBSDl0bVdaNG11Y1o0NmRoS0tnM2dFWVZCdkpSTytZNng2cUZvUTlueEtRMXB5YmZ5R2ZrZFljWGgyMERpblJOSGVBcGFTNFlTWHp6dnJLaVJ4dWlpaXovNEcwQUZYS1hiYVFGWDZiTjIrWHNHdEYwUDh0dXUvUWF2dzFkRDBmSDQ0R0VlNE5BcldRcC9lZ1Y0VTBEOGk0L0lRNldaZDA3WXFyZDZ5N0szNnA2UGhrRTVlTzhKUGZHQWE5R2N3bnZ1OUhqSlM3K25kQ3NzR2NXbmF6ZnhuUXRiUDcyZHNIbzdWYzlwNk5heWNzVHFBUG14K0o4MW5Bb2ZOTUtuK2pCc1ZoT0JsYytzS01pUVRaMHBtOU95bnNUQVRPb1Z2aHI5OEkvbmVGUmNkVlgyZkN3UTQ3T0dTSUNyMVI5V01nRG9PdHJ3NFp1ejczNzdleG1YWFo2OWNQZUZ6eHdlUEgzd3JaZGYvNmRUbGo4d3R6Rmc5aDdOenRySjJtZGV2THp4KzFrUjhKa3JGODUvN0VwbXhWV2tGcG9nV0RUTjZTVWRIem1qRlVnQXpMSEFmcXdNbUJSZ0VzUUNWdElZQjR5NUJsdUNYTnRKQzZGQzFQZnAwdVdTRHF0Z2VJcEpnUUNzNVRtRFdBSElwR3l0dkVKeXJXUU5HaWdCRm1ONXdsWlhNRUx1T3pxbHNBV2dVZDdjaTcvd0lXd0o5VVJ6SGh3c3BlRjg1NCtXZENseWc0WnViQktvTUU0Qjg3MHRWbkdhZnRQMXZScUQwUEpUSlhnYmVSbFdKd3RWWFJSUENldWJxMy8rNVRqcDZYNmFMSG1hSS9ETVFCY3Z5Wk54MU1xYnlzaTF0bW1MYUNadkVsNURnMDVTbkMzbE5MTGdSTUJYendDZU5hQXB4Zkh1RHF5cTNLYjhWM3pETm5IS3p4bTlWWTZoV2x0WjFaM3VpQ0Q1WHVNK0ZYcjhFWmJyY2xFT1hiYmljMFNDWDZXRk9YNko1NzNMcXZsMVZ4Y3VkZFAwdmZ2bXQ3RFdwN2p6OFlVckdnRnZ6OFZId0owVkxHMVhoUW03UU83UjdLM2k0M0RUMFpwbk8rTDhOSXp2cnQxTVl1NG5Yc3VGK0ZZRExOdmJHbmRVWnh6bkZ6c21TNXJCc3A5akRwVXgzdkF2ZmZFODQra2Nmc2hEQmxEc3hqUE1vbzZ0YXNILytlMHMxOXJ5NDZBUFp0LzUzcXM1Z3ZMcDdLVzd6L3lOWC8yMXIvek5TdlFEOU9jOWE3bStlT2ZPN2ZYRmhSZldGNWQrN2ZiVnkvL1IzVHZQWlBmUlRpbzN5NjVTaWRFSnpYaTFrS20xU0g5R1lhT1FDOWw4ejRvekhsWFdKNnMxbFU4QUl2SWFhbTN2OEdPbGVoWSszMTJXK295UStVdkdwbXY0U1pJUWh4SXdTTWkyWER0Z2Q1RmI0QW5VT3gwaHBIU0VsTkJ0WjZJS2Y4QTE1T3Q1OENzSi9DVXZHWGR6Ujk4M0Y5cC9nbjYrYzYyWWhGNWFIWFl4NE1pNnIxbG1FMDE1TnVsUXZ4QUttTk5Jc0ZBQkpndlJPS050bTRET0dDbDZmWTM4RDh0V21uaVNONG83d294ODZsbzJ5RlM5VE9Dc2pQRFYrZkZ1OGtWWU5KcHZ3T05iNVYvOWhjK080MW00WHFkczBrZjRzaUtuY2tnR0tqd2VxenFUWnFmTjcyMHU5STNOcWxkeWtTekZqVVlBU0NndlR2cHR1Ylo4OFZPQjg3UkhuUldSeW1zUENRalQrVlJXSFc2Y2lEV3NjV0ZjNG1pRUMwaVRkdnZyOGxjK0p4a2I2V2Y0SjNIcS9JSFVJV05BMmNnMzJUMmZpZEcxME90ZWlmb21VK3JTSmM4eW5hY2FFaEhYSnpTdHFXWDVHd2RuUzJnazliNk1DWXZENGlXbnhucFhzMzdhT0RxcTVJZWZNZndyRnkvazk3aXU1YmZETm1kdlBYZ3pPckRCZXMxUDNtLzk3Ty8rNFIvL3R3bitnWEh2V1hDOTk5WmJEMjlmMnY3TTlRdm52L0Q4N2R1enEwNXhUMVh0NXpCbnRXMDlIb0N3bTRSTXh3NnI0d0lYRHpQcFV4WURjR1VacU53R3BFd001SjBRQ25NWVFYSW5UKzE2bGxTWSthdS9HK2h2Z0NNNVk2eHZXTERDRnpCRjZCc1FHandhM0FadlkzMHBVRFhXNmp4TmlnYVlnQm1tT3p3aExxREtOL2V5b0VzQndsSGxaZHc5QTRISm1QSlNOT2NWdC9LVGlRaVRVQ1pDMm9LUmRxMmNvQ1J4MHA2M1ppcjlDVlR0QXFKQWd3OEtDTnlHa2prUGxMS2hYWTFCdnNtTFlZaHFqTUlqZ09Ed3drbXI3OUpFcjhIWk4rWG84cXpzN0x3RGNBV29VOXFqRGtlandrb1RGdFh5Vjc4SjErbEozM2lrdEdxc01ueU0rS1BNV2RITlU4ZnZ1TVhvS09oNmxJTXEwL2pWUGJScTJkNlVONEg0b3djUXBkbGJrU3V2OHBNeVUrL1M0c2lQOHU1R1N2eU82MDRlK0FsUC9vV3JIVnA1SC81VGo4ZndWUUZyWk1hOFEzaFVUNWJxcVErMGRPMEJORGNtMlZLMzBhZGo0U29kOVVhcUFMWUdOME5ZQVdmREdQTFVjb0VYZGFRSDl2Qitmam9wNmRVa1pXakxaNjM2Q0RDdlp5V0tsUVdiMlZoQzdxOW0wNExHNk5LbGE3T1AvTWhITC96eEgzN2w3Nzk2LytuTHhkQUg0TTk3RGx6OTBLRGZ3MUsyTDk2Njhjc2ZlZmFaRjY1bkZuMlJ0UkpCaXYxV1lHbld2QTZ2amhRY3VsS2hscFlzSGd5THdIckNjWTdBc0dxTUtSS0NlRS8zMEFHdWxDVkNXQW9WQVVwbk5nb0NtSUZRNGhEa1hCVEpQYlpFeFJ1dFBka1lpcE5QRWNnTXpST2d5ZElnd0FUZXhYa25rTjVacmNDMXVsamhtNUtVaS9ZQUE3d0sxd3ZRK1hIOCtsdlQ3VHQvaXREaDJ0LzdHV0NNZFl4eUJBamxzNVNXc3JCd0VyMzVGODhRRElzYTMxd0I2OFFEcTNFbzJLVGs2SVZQZnU1dFlmWWRQNW9od05lWE1VVGpvKzZVZmsvUEpNcWQxeWptc0o2VDY2STFRQnhRanJLcCtnekFTSy9UUUpsL1gvaElCS3lYQTE3eTIzWFRJTzJqTWlxckxBcnZlWlJaYzhyQ0h1QTNLSVdzVDF6Zjh3aGNPWG50eTd2MEFBMWdtbmRkTC8zZGtBMXJzWG9XNm5NQ05RYUNUUUMxeVNXMEsrOHBKM0pEVHJ1dVYxWlpyY05pck0wREtadGtKL1dhTmNvcHE2Y1pONjFEc1VPNytKOTR0OUxEdnhxa0NhOGxSM1NsOUFZd1I0OUNDOEFDVXVsMXcrQ09IL2xiWFVqamxqdFFQbDJDWnpWSlBOUmZmcFloL29QT3JUdTNzNm9rT3daejJ0cjFHM2RtcjN6dmpjLzk3aDk4NHdOanZiN254bHlYVDA0K0h1R3JzeUV2WEx6dzJSdjJ5d2RTOXg2T1pUd0hzVnhUMVFIQjBVS3ZaQXl1ZHNMRVdrcDlEaUVJMEpZd1JEQW80ckJjVytGR0t6MlVieWhJYlFlY2xLNnNXU2tRQmhJeXVSYmVibzFxYTJ5WkVaU3VGV3BZV3NESnhWODZYQ3NyUDRwRVFBbGpnWlB4eUlUajU5N2dWQkVEdk9Mb2N2bE9rTkhpMXhkNmZUazd3Zk84MG5iYTdzY3BQOHVMV0JOSEdjY01tYkcwaWdZbTN6d2ExUERpSjBmTVhrc2JNRmp5aG80MEd1U3NhZXowTzMvamZkUkhncDdtM3dvUERRcDZ3bkxLUVZxQTNEaWRiNjZSeGxTWEU0QXMrSUhFQ1JEVXNmRmNqc1ZmNFZQY3hkOVVSdlZ4N28veVExdWFEYXpTN2p6Vk1ZUUpQKy9udWE5T0c4blQ1d2FvNUVlOW8rVWFZUVpmMHNNZk1FVExPejZVYWVmZjl5YzVtRVZjMzdndWgyN2tIS2tvRGZIV3NxeEpmcXc3Vlpib2V1Zk1BN0JvZGM4cnJhenlDR2FuZkMxUkhHRlhVbjdMTnFWa2huL044amJsY0REa0ZmQU9tbWR5eHJod3lMZTExNjdaV3Q3elQ1b214NXlIc0xLU3JkU0I1bXJ3a3BZbGdZdEpXNTRPeVY3ZXllallHWGt5dTNienhtempZWWFTb3JQUFAvLzhjOFg4QitSUFk4VjdJanN2L3VqekgvdjkzL3VqMzhMTTUvN3RqMzdubzNmdjdFU09ZdFhrd0pHdExHN09HTkx4TkpzYTNDeGhPZlpUemFtWW1nR1BzQ3o0a0RXbkoxbURwOVUzWVVPRlU4OTFhWjBqTllrYzZjazN2eitrZTFpcVFLSkNLMmc4RHNGZy9RYmNLa3BvaUdZNTY1aUpIdU5RZ01nNFlpSlV0MmN6aDhpWStTZm9aVlZvN2FOSUZNS1dUNU1DT3p1V1hXMVZ1bjdqYU5meW1NUmZqdFdSTnFQeVF3bE9tTm5oekZaRlk0QzFGckphLzVIZjBkMk80Z09aWEN6UmNmQUhQOTNSQWVTaG1QSmhlV1IxUXBhS3lVZ2Q4cEY4THViU1JsaGk0eGRBN1RQZmN1aDRqaEVFaEEvejB5UzJGb05laCtNc0pGKzZqdnNCM2NNbzFVbjRLV3NxWlRBYXVheGJUYmo4OUhLTno0MnlIR1VxSFQ5cHcwclZvT21XS2t2NXdIOWJyL2lURnhhV0EwVGNXVTJzNW95eUY2K3NvTk5objFTUXBYZ2hFOTZHOWF6OHVRTGMzR3ZkTTRzcGFUZjRBWThHZUg3QzFybTM0WjNzRUlxVTNHaWNDVWg1aVYrbEVjdHY4dlRCRlI1T3NzNVRyQkV6bGVrNThtc2kwTjNHbDVNMENGWGVsalhsT1VXU3NsQWV1ZkpTSjZTRkY4OVNTak5XZkJzck5mTmVaN1ZtREJid3VveFRLenZscGh6OC90VmVMbVhzRzVrWTQ2T0Fkd0MzY2lkUHhrc1hZMDJtdWNuUHV5UzlicVFTVWhsSFBDSy93REh2WktVbU5Qa25iMU41MVhtL0dSS28zV3RCbElYa28wNy9TaVRBdStmM3hRSytaRHMxTzF1SklLd2xIV2NQTzlITVVFbjl1bTBDM0gvanRaZS8vYjE3djVIazMvZnVQUVd1OTE2N1g3OHM4Qk1mdS9sTEx6ejMzT2N2NXpDUzJDa2xZQmdGQ0hhbWpPNStCQ010SUNVYTNYaFdUSVE0c2x4S2syb2tTUDdTTTk4b1NpbVRMYTZwZUswcVJSbEtsdUdBS0xodGhXMDV6c2RKekFxM0dGQ21oQkJwS09SUTFqNGxLcHVteTZvQXJDeStza3dEREdnUk5PbVpuQkNlSTZTZFh1U3NoQjBmZUNxRkVZanV5a2hjNlR6ZTMzR05yNG1mdU5JYWJ2QTR3R0FRR045WXJLUHNsR0dSVDVRQytFbGh4VGUrS1h4Ynpmd0s1S1kwcWl6ajV5N2NvRDBBSFg5djl4ZWJHMkY5VTBZc01vMk9vWWN4L0hBMnhOQmxKMXczVkVHanFxY3hDU25OMEFNU29hZmM0bEhwU2trOXpaY1RQK1hEVDRQbisveFZGaVFhYzA1WURyK3UvRG45cWkyZWQ1WG44dkFoVndWSVhVV0NoeFR6d3lKYTQxNzg1eDNRYVZCTm1zMzdkWkxxVUcrakxWbThrQ2Rsam0vam5iWkNNeFNFS1Y0UzVxeGVSbmxnWUtSTmI4aFpXTTBmdDZvL2FCNkhEbWREQXVlYnhxMkc0cWE2cm8wUVZkNzVQcVhWTWl2OStiSlRsL2hWTEhWcVhReUthbmV5UWNGaFBlc3hTQzVjdXB5R1p1MG5WNWFPY3U3TDh1Tno1OWQzMzg4YkRONVQ0S29TUC8zYzloYys4dnh6di9MY003ZHlYbVQyTDZkbFY4MU9XSy9KakNoYVpER1ZUWEFpbEtuY0dveVBwY1phSXlncVdpMkNtTEUwSytHQVNlbmVCRGdCTjEybkF1YkVvNWhsM2FTRmJVVWF4bTFBZ3E3RWxiS0d4bERhY1IrdHVvTlY4dXVZR1VPOWtCOUhKT3dBdzdrVURad05tTFo5amlFRHU2bE1BSTJaK0FLR3BDRTgvaXRKQWxvcDU0K0grSTkvUTVoTElhYjhsbkQ3SGlYTkxYa1Q4UXhFK1lYQW9EOHBoSGRLVytQR2xWWXNOOGNESm1RQlduakJRVzF0VFB6S0M4V1NUdjFESVM0UjN1SERkeWhreWxYZVdzbU5BNktEdnNaSEdibE93WlZWSENVVXB0SVRYNWxNZDF0SXk5S1ZjUEZSU2NIY3dWZkNxVCtLUGVycFRNbUxKM21hdmpXd2VoY0hqOVVER2lRcm5HL3ozNU5JdlF2U2NqRUZyNXNHcWwzTGtYZlBISXNSUGE3OUt0MU9QL2YyYi83NlRxN2FLUnNOVXdGV1BBRXF1UXJ4MDJmeDVua1FseTdwd2RRdlA5Q2hLVjJUV0VPR3B2SlQ4eHFmL01PNU90UUEySzEzV2liQ1ZQbUU2cFFuNjFpRjVZOG5oc1F3Sm9hVlRWYmtmb3g5eDZBSmNUb0t4T25HcGZ3KzE3bU5qYzlFTjM3MnljTW5mK2Y2OVl2WGIxeTdkdnZWMSsrOWZEZS9MSnZWTlVmdmx3MEg3N2t4MTd1M2IveXZ0NjVmRHJCbXZXT0VaeUdWenZrVlMrTTk2VTFNYWoyRXM0V25CWklNdTZJbVZXbENlemJMenhkZ3FsaVd4QkNzMFdVc2NGUEpFYWdDQWtJUUFSRlhhSDIzMnRJWXZ5SGtzZmdJRkZNeTVIdTc2VW1zQzJOZHRndjYyUmdPQldGc3J4ejc5TE95UVhjM0FJTW5MaGhYOUFnOSttVlZKNTZ4S1QzS2ZDeGhOekVuZjV6a2kvcDA5K2FIR2ZGVURRdkxoUFRtYlNqQkFCRWJDZm9YQlhUZnk3Sk4razVNQ3I1a21HSlkycnI3cGFBcE5PV3psMTFLQ1NHWlUxZGxKTkxrZW8ya011UzZYaG9nOW1PeDlET2FRS0xEVnRtbnE0eG1oK2w3ODYvTStCbGUwQzFYcTc3bHIxS3ViN2tWdjhKS3YwSEpzN2o5M1h2ejMwQU8vSnFmNW1QUXIyaEZyL04wMnZpT1QvVzN2ODNmMGNNRHY5TzEyWG5tT3B4bjZmVDROcUNjNTFzNFY5T1NEK0dWb1liSnZhM2FBclhFTjR6UVpWejNORnFMQVR0NUhlbjVkVi9EVjZNM3NCUWFHWFVwT2tzSmg0Y0MyTEJhWlI2NTRZY0hOR2dXSHBhV01yUVFJQlhtMFZ2M3h5UnRqWVdiNEIzR2hITmZmWCtZdzRHV1ZrTXdjbHoxWTRsZlJPVWt1c0tNZXZiV3N4blBYWmk5bWkyeXYvUC8vdk52UFQyNThPckd3c0gxNTU5L2Z2M1dyVnMvZGVuaTl1ZHlmdXpmL00zZitaMWZyVXk4aC8vOHdNSDFVNTk0NGJNYmk4dWZPVG82ZURtVzZjdTNybDJaN1dTOHo5R0J4d0VvWTJTNlM0Q1ZnTlNZMkZTZ0xmVHpBZ3FNaGlCU3RXR3gya3dRbUtsci9MWlQzaU1neGorZE84cDY1STUxOWFPMHVzckFjQUQwaUdjV2xkQ3VHOGdYdG9USDA1bWxnUjlDNXlkU0tBa2hiQ1hvWjd6Smh3MFBsaFJSSVBvZUVRMHBEd0ZBVklYTGszRkszQTE3TWcvQWZITENsVHZ6S2hyMWUxMjRMMlVFeGtCa0FNbFF5T1EvNXpFc1J5bU9wRC8vTFVJdlRVNDhaeERJUXdxbCtEN0l6Rys3TG4vdm5sMjJqc29ySjM2Ny9zNWFSNjlvNXFPd3dvMXlTRHJobTUrcjQvUTNjWXhWdXA5UWRLSHhKNUVwZldIUkU1L3lsc3pFcjJuVkQxZm11M3BDaC8rODYzRGllWjdQZzNEejczTG4vU3lYZVMrSUh6VHJXejZPSklhYzdHVi8vcnpyOUFZZmd4TFFQa29sMUpqNmxCZjU0WXg1eXFNTDBNa0hYdVhWTXpyeTVadUx6TG80NGNaU3ErUXRsdUpwUXhsNXI1VXh5anlOTTc0MXVFZWhZeXpXRHE5MVpaaHpBeGZYeGlTc2RLelFtWGZ6ZWNITFF5ZWdSUmRZcm9Zc0RGM2dnWURWbUhPTk55Y3ZrZW1qak9jUjdiWGw0OW1ON01MODVFc2ZtZjNtYjE3OWovL3hQL3VEdjU0MHZpV2RyYlcxWDkxY1dYd3A0N1J2WDNJeHo4Ujc2UGtIRHE0TGgvc1AxN1kzUG5iNXdwVmY4dXV0RjdLakpFdVJZMDdHeW5EUHdTdG1JZ25YU3F4Q3VFZGFoODFDWVBNZWk5TzlMTEFvWnhBbzd3SFBYSUJtL0l3TFJSakFoUlpnTlF3QVdBa1RnUVp1UFJZcExtRUJjRU5KS29IOGVOdjZFT2dwWG1LVmRTbWNDODJIangvVit0c0J6b09PWjk5Mm56cW9aQWc2b0tjazBtR1JFancvelZFMGs0MEdPZU5ZUjdtQ2J5bWJncElLNDQrNElWMnUrS1ZBdVlxbThpczNBbFRRUkxkaVlESERYNVFRc0E1bFNubFhHc082NjdFellScGcwVlJNbFdaVExrVWN3TXFma3MrN0RsdHhNVERuK01rLzU3bEFJWVV6Nm1kTTB1SGMya3pmaWtieTVCNGRySHd1NTF2MUtyS0tvT2hzak9NWFM0bmpVZnhQVmxXbE4xbGV3c3EzOUR0TWdSQkJtcjUxdmZlZFB4cG5iaXI0ZUFqRDFVUllQUTIvanR2MzFQWUlOOUZwZXU0dXZBaXJ1Ky9lb0ZxMHhUR3BFQ2NjQUh2bmQ4TkN6a0I0a29OWTVJM2wyS3N6OUZZc2RaTk9OS25vMUFRd25nd1J4SFkwNFlrbTJ0S0lPWlA2VDNqSEdHYjc3RW1LbVQvYVM5RWhQUG9SU3BZcnY2MXNEbENPelI5ZTlGWVlJN1Vjc25aUGhtb2FpWFBaVk9Cb1JEMjhwN21XY2lxUW5WdXJPV3ZqeHo3OXlkbkxMNy95WDN6ekQ5LzRtMTkvODgwNm12QjN2L3JWMzg3MW54VGo3NE0vWjRNNFB5Qm1YNzMzMXN0M3Jwei85KzgrKzh4bi9vMlBmeUpiLy9LTGs2bE1ZNnprMWVKemF4aVhBb3pBcU5Zemh0Y1NQQUFLSUJOV0Y3OWNBV1NBTHQveTZSUllXYXFFWmdqczJmaGgwWTlzQVY0dW9ZcW01NFVhbHgxQ2I5eVJrTk9rVHowQUFFQUFTVVJCVks1UFAzdlNPM1VNTWFCcGVaUFdPWnFlSTl6dVpYdzRJQk9heG9WTlJHQVArQit6a3ZNc0h5WGtzU0RvakhDKzgwT3ZyZ1RFVlQxUC9MT3F5K3Iybm5DdXltdkNWbU15ZlZjbU5lRlE3K05ibDBFdHg3RTZJTUIwa0hzdC9NOHpucFFSWUhMMTh4akhIZVViN2s3NTg3M0x0TW9ydkI5bVRGVmNQTGNmUlpNdmw4ejNjL3U3OTdPaGlZN1g0VWE4OGc3ZFFSdDVscDF4UUdPeTFqZ0RCRFBjUFdhTHQzbGFubXU4ZHVLN1B1WlBwOTMzVHRjN0p5K2RWenVWT2x3eVV0LzdYbnptZS9OYlBFN2xrTm92ZndEWHoxM2Y2QTJhWi9WZk0vbVJDYTYvVjVpd0JNUzRrZC9SZ0hhWUZHL3gydCs2ZmtxR3dvdnRxSFV3RFJwMEpPR3JUdk5YV0VOZlZVYk5kNzZUbTNCZjhWaVlhSTA4dHF5T01PS3ZGUWdQcTNua2FTcWo4RnYwczhsalBVTit3cTBGaEEzRG1DUnpwakRaWHNxS0dXdkY2d2NZTThtMXZMTHduKysrOWVnM1h2bitnNjlWcHQ5SGYzN2c0S3Fzcm14dlhMbDk4OFlYbm52bXpteDdKYTF4bExNbVB0S2FxVWpIeXhVd1JSSW9EeHdzZ1MvZ0FDSURhTkJpMGJJU0FhdktISUNTZUhubTNBbzhFamYvaDhVNldZUEFLWlFySE1FQXFDWElVU0pkckJvL2ltVkpjSFZ2T2VES0FWZExTb0RrNjYrL2Z0cnk0d0dORmpSQXhRbFhNL1VUNFBBVFpsalFBOEQ0dFdoV1hncjBoclhTNE5mK2ZhZThEWkpEb2JwQkdZREpyL0lmUGlqVnNQckg4SVdaYWtVeEdyUVJMd1ZkQUU0THhUdkljWE4xS0VmS3dLTDJPclFacUZWWkIvanlMQTFPZnVTOTgrKzlHNlVHc1BsdjRoZ3k1bndYL3AwMDZ1eUVLck9oMkJvWDZRRlhaV0JKai9yeDNEU2swZW4xYW9ybWNhUTI1SWxmaCsyMCthSGw4bXpsUk5QS1F6MDNqYm9YYjhOSGVCY25Ucms1ZWszem5Xbnc1MWlBNUU2MzJoMXY2eHZqbDNhN3F5OXU4eW9OZGRkbDVsNStDYVB1bEV0YTFGb21wY0d2ZkUzeHcybDRUYUtoSWF5eGV2OXFGWVAzZlBSOUxXT256VmV2Sk9EZjlaQVJoRk4rcE0raHA4RXp6N0FXcXpRVFZsWFBEbzg1eVBCZmpldW1YRzFRY0FRbjhIK2FYMTY0bU5VRG4vamtwOUgrNmUvOThTdGZ2dmZ3NGIwaStJNC9kKzkrL0xsTGwzYjhrb2JEYmQ4ejdnY0tybjYyNWJtcnEzL3A5cFVMWDc1K0liK2psTE1pMXc5UzZmdXBWSEtRQ2labVFDL1ZtekdnTEdkS3kza1E2OFZsZkxVc3Q0UURxcm9ZVWUxUzlJUEVjVWpIUVpSdVAyRmRsbzNXbXNrZ2I0M05xb2FBWStSeHRKNFJncGlyZVhZZnZ6ZTFFV0hTa2dOZHA3bXprcHpEQ2t5TS85WldTaTF3MG1iOVBuN3lNT090ZGpSbFlpYXk1UkxYM2JJclA4ME1RRm5GWmRHR2M3dG54SzIxcVNDUGtFOTMxaWQrbkRCa1ZVU05wd29ibHVCMERXOGtZNGU1RG1JVkcwUGVxM3ZlNVQzREs0emxROE1qdWZaTUhJZ1lHa2RGaHdxbHpFc3g3ZUpSM3JxRFNTTmxtcWoxYk4yQXNpMnJOMm1oQTJRTDFKTG1hSEF5aVpjSSs1a2c4U3VwMGxlVWZyYmM4SXV6SC9iM0hsZkRXYnVIQXM2MTFUTGZnYktEWFpUYkFKMEJaZ09jR2pCU2lFQW0xczlTR2pQbjFSb2pEMnR4R2xnTnlBRENCcWdHR29BQW5OUWttVkdlNnJDS0dnaklmNjZGeUpmZVVOVlZ2bHIzV1VjbkpoMTNCM2V6N21weU03dzR0OVpDZlB5UUJaSlk0SnQwOE83WmhDUVdBM1gxem4va0VXQ2RnYmN5ckY1QytMSzhyQ3pJNlU0bzBCZ2dodDN3a3U0NG1YYzhJbGx5eDNmcFJQSWdBaGsxWnVwWlk3NmVjNE1YREQwUlNIa08zZUl6dEkxOTRrczY5RUthL3RYYTVLbUhKWTd2VlFZQlFXdHBnYXd0M0g2OXdGaHFyN3VWanQ5c1c4b09MSk9rZTduV3c0c2hwMFhERDZFVE1TbFo5a09KcTdtU1d1WlhzZ29pUUJ5Rzg3dGMyN09YZnVUNTJjN200aSs4OGZJM2ZtTmpZZVBWTjgxdXo3bjc5OTk0a0orS2YzN24ycld0QzF0YmUrK1YxUVEvVUhDOWRXSGpoWnZYTHY5Zno5KzVWYjhnR2MycXNiU2FpSUFlYWpFVm9jSlpTSTRzS3pETSt4QUs0S0w3V2lxU29CUmtWTlpRL1BHdHJLckkybWlSNDFka0kxeHhZb3Bmd0JWaGtxaHhWNHBvQUo1RktwNlFMTmM2dUpnU0pPeThaU0J0Y1l4cG1jenkzVHQvcm5oRFAwclFTaVp2L2xXcStTTk1kZkVUYmlqSVpIbm5YWmk2cG0vamZRaS81MUk2WWNMN0tKdDhFMitLMjkranNiZ0pyYUdzTmJBYkFna0dudks1bFYxY3RBWk5kYUNjaWg0d3pBYzBCYWppbjlJdHNNMXpZaVlkaXA2d3NaWnM2M1R0N3pzRUdpMTh4Q1UrV3NhWGk3WnFVV1pSYmhUcVVvU1VYWG45S3k1NUUwYmQ5TlZsTDAwQTV2TE1YeDAxOEZaOUpjWGlvL2xLR045N1NaRWZkSnl2OTNCV2VXMitwTS81MjM2R0V0Q2Vsd2Rwekx0KzcvS2Y1OEh6S1Avd1BBRWdtWFIxWHBxV25oUitYZmhzT25ocHZqdHNwK25kZDg3aDJ1V2Y5K0svZWRlbzVMbDJWMGszamV1K2hqcGxDYWk3SE5kejFqSkhCelNtL0ozM1VQVlk5VHhPOHFKYnEzNnBvdE5KOHFXZkFXVGhBVFljaUpiTkxsMitsSVBrTDdCNGYvcHJYL25hMzM3MTBaODhmeUJiNXUvZGYrT05CL21oenNzQjEvZkU0ZHMvTUhCOThjN2wyeGMyMW4vdXp0V3JmLzdPOVd1em5YUjNXQzZhc2hLY0NIL0V2S3dMNzdvVjlsdnJRclRBdEpYaXprOUZhUWxWdUM3clFkTmlQU1h1RUVUaHB1NVNLcFNPRDJBRnFrTlJhSVlUZmRheWFrSExYNVVlWHZnQitiSjR5R0xTd3lYTHNvUW5YazdiSjNTZ3k5SXJndWZaNVRrL2IzSHExOEFxTXFnQlVycjBuYTlUTUVOY2ZIU1MxN3EzbjNzdXZOZDkzRHllWHVpZTh1QURBR08xbG44ZWM3ZmJxZEt0WjRBNUFYc0tDQjlqL0ZaanBheWI5dlFRZW1PeU1EbUtSS1g5aUZKNWprSlhDU1VjR3poVzRVWk90dmNEZDM1bVpEMG5Jamt4dis3NUhhZjFXRG15YVhpQ0lqY1lxTmRLVTNMVEpTRC9pcEMvL2Q3S1dqNzF2VDRXMytxUkRMaVBmS1JVRXFZdk1zVElhL2xxSGhwODNWTXM1WVJSLzhYRFhEb3MrL3FXVUw2aFlhaW1hWWpNdjhONGYxcytWVXBjZjUrL1Y0TVE4SnpQUjZkeHltdjllc0lZU3VBbkRpZDlEUVFuanF0ZFAwdXJ6dzR3SkRiaXArNVRYcFlJS2p1NzZqUjBvN0ZJUFFVOGRlTnhMYTJWcE8rYnVFbXBudHZhNTcrVmVZbWF1Nmh0djJNN01Qcko4Y2lYSGxWa25ONXAzTTFkNE50dmNtMUZacDRlSGYvYzd2ZGYvL3V2dnZVbkFWWiszaXZBaXBlVTFMdnZBT3ZGMWZVdlh0NCs5Nlh6Zm5vWmtHbjlDRVBLV1NYVklMZHVmWUdOd2g4Q1V0WlNuZ21DUzlnV1FKVzBIeUVBeEg3L1NSZVpiSTFOQm9RakUyUEFqbUpFUUFDQ0dYeGhpczRrYndTRHdLRjNWRWNZRGt1ckZYTStiZkZLK0FLNnZrdWJPeE93UWJzODh3Y1luL0liUmZKTUROdjFFaS8rTGZURnp3UW1MUFBXaTc1WDNPbkYxbE91MC9EY2RNb3Y4ZVdiOWN6VnR0akVxZlRjUTBmNFhyb0ZLUE54cEpseXNpNTJyQzhGSE1NeVQyK3VuSGhyNjZsSGRabWxVcHhGLzV3bGRhd3FCM3NNeFJ3S1dHR2pkQTRiNFovMVBoVWVQNjZ1Mzc0UDNnYnRDcGcvSGJieWtIVGU2Y1J0Ti84c1BNZVBsVlNBa0o4WGxrYlhuK2NoQndNMEZ6SmswandJSTY1aEJHRThOODJXSWZScm5YTHV2bFVlK1UzQWg5WjgyQWxiUmF0MDNKdW1PeG5yUEtBRk5GM0Z1empUVXEzbTBWMTRZWTNiN2lXZlRSTzl1cVFoYmk3YlVibXorQ1A5VHRPR0QzU09NMFMydHBhdWZPaEsyNkhjNGlnSDV4NlkzRFVNNEYwYTRydndyNnc5cjJScEYzM0JtemppNzJjNWduVzdhSjQvZnk0VzhON3N6VGRlclRBWHoyL09QditYL29PTUdjOStiZmNmL0c4ZisrcDNIMzYxbUgyUC9xRTY3Nm9EckptenVyMjV0dkpsNjludVhMdWE1VmM1TE5vcFY4NE5ZT3VrNEh2U3BLeENGWjZDTDZ0MTRsYUZhZUdHVUo5VjN1T25qbkFiSU5lVEhLeXVzallUWjR3L2xSalZ1S3N4eXpITEhqK2dZMHdJV2lROTBoYnhLMTRva1BTbDJVSjV5aWRnalJBUm5NRnFoSTMxRmFGaEpmUFRLQUNqTVU1OFpoV09JWXNvSitGTG1HRWhzaVNUcDhSamNmYmRjeW5SVkJiNFlRM3p4KzlRaXhISDgvQ2YvejZGU1J5Wmt6ZTgxVFU5MjV0ZThRS0UrRWNYMzVMdzNHazYrY2dXM2hwelR1Tm9PUTVMZlhrMTNkSjgwNjJyc2xRR1NZNEMrZG1QTVZHQ09mVVhRSnJLVGY0MXFIaGhLVmVlbXpkMy9PYmU1eXl3bHNKWjVVTzl3WERmalMrb0gwNVpsZUxqSjg4Tk5MNDFlSGllcjArRU9yNXY2aGlmQUVIOU5vaUl6d21yM2pxT0xpM3c2YXZTbmVpZzViM2k1Tm05K1doNnllaXBYeVV3OTBmNDNuN3F1UUd6eWxiOXg2L3ozN1FCTDB1eEptUERGNHVVbnpndS9NeGZrdk91WG91bktaOHEwYnVTUmR0WkJZQWFPUHJWZzlZdncyTHlLUXgyT0dXQ0hycDcrWldFQnRlVTNLUy9obWhHdnBkV2NqaFE0a3Vwem8rTkhOYXZNNlRzendYUXQ3SzkvT0xGN2Z4WTU4WXZuQnc4dnZmdFZ4L1VJVThqcGZmVzMzY2RYRzl0YmQ1ZVcxLys1MWN1WDV6ZHVabWYzczEyVVFQWlJ6bkVJUnNKSXNCajdLVXFLd1djYXBvcUt2ZVVuVXNscTREeDQyeFRkemJ2bE9CSkRxeWdCSHJQUlNQM3NuWVRaNndySlRSSmo0RFVoRm5vMWhSOWFLZUNXVmUydEhKRFFFYUxxNHRTd2hZRytFdmZOY0Q5N0Y2Q0NVaEl5K1E2UEwrRHBBVTRDancxRG5raGhBVW0wcHk2MGZJSjBPVGE4N2dQWlJ6dkkxL3lPRUFaTFJaYWh4emZ6K0lPZXNJT01KalNUSUJLUVZRaURRbXJIT1FoQ2hXRktIU1VuZkN2ak1xNnJiREtGSGp6RzhvM2xrV05vUklUZEZYR3lad2Z6dlBzMUtuVFlZWU0yNHdKTVJiTjZGbnNaYmFZOHJVQzRvb2JkYUhiZmdhVXlyckwyZDJsbnRwNWJ3RHA3K3BNdks2bnB0RitKdGk2VGt1T05BQlZyckpmRlhKYTl5VlhTV3d4alV4M2RVMXc2Y2JXZ1NrVGVLbmdVLzdqMTgvTnAvdXBIMkdZYyszZjhqWVBycDBuWWJvQkNLVWgvK0diL3p2em1VeThMZi96bG0vVHF6SlI3K1ZVUEtyalhtZkFsbHlrckZPdmpJbzYzak02VitkeVpEVkpsNXZoc2RHVFM0L0ZNa1lXYlliYU5EeFZscUVxWDhMVUJIQjRleG82bHVQVmtycklRbExKeHAwMEJBNWlpZ0cya0liOFJvWVI3OXpLOXZoem01L1BEeUorOGcrKzllcmZLaWJmWTMvZWRYQzllZVg4QzFjdVgvNjVaNTY5TmJ0MjZWS3NuRlJRQVd1T2dndXc3ZWJJTlFWT3hNNkFZQUJDdnl2RFVTbXRoR2NDWlZpZ05nTWtUTUZNZ1FkOEdFcEoyY3A2QkxyU2dSWmMwdWJvenp5NDlsSXIxQWlkQU0xSGdabG8wNFZuTTZTc05tQUpPQUdUOEo3eDRPelorcGQzL21HZzhsb0pZNEJNaDE2Znl1UVpYYUdrUnloSCtzQ1V4UkJRaW9EM0pUL1NBbHJ1cnZ5dnl6TmlraDBUVFlNSDdKZnloRmV1UUxYQXN0NFNQdVdrdkRSR0NWemxWeURVUEF4Z3AxUVV4ZmljTFpVQVU1cXMxVHB2TjJCcTBUcUFxTFcxZ0F2dkdzUGNDMURUdU1pTE1kK3dXV1hoN3QxbDRrdTl6YnNHSUg3cXIxMkRSYjhMSnk3L0FwRDV3Rk1nazI5TmI4aEhjWEVLU0gyZXJlRENjYlgxT1pZWm9CcGxONEMrNUNYZkRYMTQ5aDJ3ZUhhOUUvalJHaXRUNU9Nc0k4MVBwUmZ2emxlSHdhY3lkS21yYmh6NDk3TjdsWE5LVlRucVZXZ0luQlhBcWd6UmtyaytyS2RrVTk3Q096NzFTdHd0cCtJMGN0VlRtYjZOQmlVL2w3NjllWm8vNGxZVFc5bElvQ2RLTm16SmxRKzgwQzJORWllN2xqTGFUR0M1bXlFRHF3b0FsQTBIVG1QVDhKbjM4RXZJVnU0SXY3cXk4Y24xcGRtZk8xeDgrdmZlZlBQdHF3aUs4QS93ejdzKzVycStzZnJaODVmTzUvVHhTOW50bEo4eXp1enhTU2FmVmloUENyc0ZtbXExVUxVZmdQR1A0M2NtUEZINENJOUxkUXlNQUVJSmx3VkVFS3NWS2pWYUZVVUlSeG8rcDJaTFVUSUdHK1dQMkZUNFNvY3dKMDdONHVaNWZ2ek1kM1JiU2FRL3p6UCtmRzllM1JPandrelFVV0RWTkJNNGZBekZsRTF4bTk2NEo1OUtZRkxxK1c5b2wzOGFLNjdEb01IMS9TVEtVTzlGdzJLcnBDRmZGRDUrWllGV0NEVEVIWFI3OFQ3NFBhVnRxQ1QwRlY4REJucXhPOHIvV0Zwb0prQ2FtSXFYMzZ3djZsMlA0cC95bHJCRG5TUVNvamFFVEpaK0RSWElZemEvRDJBYTNlSjN4cytpODZMZmYvQTZ5djJNYjM3dnZKck8rUEhTd2RNOFgrcVdHOHVlQmpncWFiUVBBamlBQTE5T2VCSVBNSFQ4QXFjdTkvaWpWVUNYdS9ndWZ1NjlEcnJqdXMvektnM3Y3VHIrYVJqbG56RGlvYW5COHR4REFTZEFOUURYTXV1NTQ2TEp1aXgra2dULzRpbDNCOUo0QjZMTmd6eHdxeG1pUVI5UWJtUmkycFpYNmE1a1pZVlZBY2xXZ2JMdHNMdVBIcDVhcnB2bnh0Z3N1cnU3VHlvdGRBRHlXckFCaUI1bVdlT2ovUFEzZnRjQzhJNGN2Zi8wMWV6cUdoTkdONjllbWQyK2NlMC9mUFdWVno4M3V6ajdCNzJicXhqN0FmOTVWOEgxeHo1eTV3dTNybHo2cGN1WnhGcUpZaDVrUFd2c3ZCVGtacDc5eXVTVDJhRURVK01vbGNrc3Mvd3ArK2dhb1Fub1pUdnNVYzV3UGRpemJwSjFtTjljcXNxUFZWaFd4d1JvSWFOUzA3ekdJcmFoZHF4dFpQbVlwQUxEZFFab1FMWW1lQ2FCRExFb3lwZ0FpRmNPajBGa0hHU2Q1ajRyR3NaK2RZSkxLRm9KOEZ6QVludGYrS3VXZlRHVE00bE8zWjFKVzEzakFobUNTMm5jSzBnZUVpZ3ZWa3B5NkRadDZiZzRBdDN2ZmU5dzduN0dobU54dE92djNoY3o5Rkp1b2wvNG1XZTVWTVpMTE0yOFdRY0tOVStDL01JY0dSTlBXUzAvbVpRNythbldLL0dzREZqTDBJNzd5Y20wQkRGMHBHdnJiQ3N5d0RuT0pNZmcyem1pNFROL3pLYVBNSW1meVl5eDVqRmR4NEJyS3JqQzEwUWZFREorbDM4bmFVUlllZXBJblVyTGRWSUhnSTlDOEhmSXpRQ2JBb1ZNdEpWVkhQNjhzL3dCQVo3d2NKak1BcHpWN0JUU2d5bEsrV01jZVRuck5mMDB1SGgxeFUrYTNlQ2hrVWhWdkIwUHpZb2IwQkRuSU1ZVjY5K2Ewb1ZqdTVOaUZDVDlPdGNpSUxVYXl3eWQvc1VCWmR4NU15bVlIOW80QmJ3cVAvbE9ZcU5NaFUyUnBjZFF3eU8rNVZLTVZtNVlGNnR4MGhBVXIrSFVVRTJGaVY0dEwrVVE4eXlsK2hPQUhYNFdHU081RmlNSHkxa0xYdGF1NFRNTlo4cDBJWHFicWVTa2JkMXQwcUdMcVR1QXF3eXE4VWxaMjBLcnZNbHhBWGNLSTlDZE9wZHUrTXdPc3FNQTZFRW10dEwveTc4TUJhaXovSHU0LzNDMnNCZUxkV01ydkVTREl6ZlhMKy9NbnJsemZmYUgzLzZqei96NlYvLzRQVFU4OEs2Q2E3b2kyOXRaeE54ZEFXdEdqeFlpQ0NwclVzSXhlNStpakc0M2dKRlozUlFDVVYzTklJaWZyR2docUc0eXhac0FUNFdubWtwb0luWkQyS2Y0RkxJRmkxQVJlTUxPOGVmSGpXK3AxS0k3YUJPU0tXaUZlZWNmY2VvZmdSWXc5RGgvMFhZUjBQS2IzdWQ1NFMrOWRzMUxoK0hmM2NhbU54OTIzcS9qOXZlK3N5cTU0blhLZnovenI4bUp3WEhsWVI1Y3F5eWkzUlUrbWsycE9UaTdQNEhWWWc2TExqNmlXSnpOQjhyWVNoRHhSdXJLNHd4Y3U5dGM0OTBocXB5UGxzZXNNdjNsZ09zNHJIdDg5MnUvd3hwTGc0Qis0aWpwcWNnclR2L3A4c04vV2NLVERCUS9rWmtHVjN4YXl0ZHk1RjJZa3BIRUFRaUhBZGUyMGt6NEZROGxiNk9POXhLbTRzaDNtQmZYeGVFREQrSzRoTE91VkZmYnBLbzhITVppS0Q3cGhnWnVUdUJhTXNTcnVwZ2FubkI1bW80MnRkT3A4WElKSi95cFgwQldMMENlT1J0UGl0KzJQZzBWVEEzSVNHTlkxTUs0L0J3TVBnMEoxRVlZNDZFQlRCYXRqUlRLU042OEM4K2hnNllyYUh4YUh2emxIYmkyODJzRmVMUEp4S29CRGJaNGFERzB6cTF2Vlp6bDVZQnNEcHcveWJjWDdqNDNlL1B4dzcvMmRIZnZxLy9rLy9uRy85aTBmdEQzZHhWY3Q3Yk9mZEVKOXl3VmxjMXFZTkVGdW1yc0xjM2VxUkNNaVpBQmhCU213WFV2RnF2eE95MmhpclRMQ0MyZzdLb0tqZkNVVmFwdXB3cHU0ZXF4SkVJcnJDc3FXVFJVUnIxTE1HNG9iSUJqZndoWUtVUkpPR1VaVm9Kd2xTYWZ4S3Y0MGtValYzSlF3anpHZWVYMUROeUY1K2JUTElVcTMwR3Z2MDllSmFqOTNQZktabDdRYVY1OGEvb2R6cDNGWHE2U3pwOG84TnZpWklpR28wUUZDcXczNkpsNExFbCtwVndwZ2dLT29qT05ZeVo5UDBCSGFZN0ZtUUMydThnVnZxaVBQMjI1TmpnazFmcUE3d0Vzd0ZCWkQxaXBaV1pSUG5iTVVSM1VNcjRiNmpDa0FVeXNZdUE2VDEwbWZZOW9FS1pxcENvMThmSmcyRWY2VnBwSTN5Vk9sMkhsT2JSTjZBQU8zZWVOYWMybW42dXVzZ29GNGREelhtbkdUMTc4U2dOYWdHTTF3TkFXblZUSnNUWlhIREltL0w0NEtVZlA2RFgvYVZOT240dmowR3laRnNhT3FRN2JkOGFEdEtYajF3MDhvK3Q5WVdFTVo2dzZsQ1grR2lxODRjTzdpNU12SU9jc2lxUlNmdlhOMEUzUnc4Y0FTV0ZMVjhLUGRGd2NmdEFvT1VnNnRyNzZCbHc3cmFYOEpJeTRUN09xZ0k0Ylp1ZzQ3aHJsaHptVVptUDlPTXU5OG9zWkdUTysrOHl0N0pJem5QRGtmM2gwZVBEYnYvVmIzM2xQckNCNDE4RDF4MTk4NXVmenM3cWZWYkFLazJYcVNkVWRSV0VPVTlBMVdENVZLc0hxaWxVeG93SWpkTldsbUt3SUVwbktIVXVwM3E0UVd1ZXlIbFZ3VWdtMWVxK2ZDb2xmblplYU8rY3YrdElrQUo3ZENVbjcrNmJTVnlLOC9kMTkzbFhjQ2J2NFMxTzgvcFZaNGZIYWJwNk91Rnc0S1Bwdm96M3hVMkVxVTRPQzkvbUxiMC9BemRNZW9hZS9FOCsrdi9PcStEZ0lYVW9hVFJ0QW11NXdxcTNjVXNCT0hkYVpzTUtVdy9WUW51V2xxZDRtcTRwL2cwYVYzNVIrL1FSTmlzK3dBSEN0dktXOFRIaDVUdElqblJDb1BBcVg4Q2NaNWluK2ZKL3lEMWpuNjI2KzdFYll3Yk5uQ3VvdURMNDRDaTQrbHhHZDh2Zk9Id0I1RnRhMUVWQ2w5QzVXSnlCYW1XYkFLOHdwZndtZmRManU0a3NUemI1ODYzUjZrMHVkRFRIbHgvYnRCdVV1bzhNZ3JUd29TMTF6dEhxY0ZqMnU2N1hMdmlwbjh2ZGQvdHRKdi9oS3Q5N3pBTnl6Nzc1eEhRZXc4ak1oZVpKZldsNWc2aCtvRXhab3poN0l4aERIYVM0dmo4WC8rQ1NUR2hVckFwYlNLSlpmaG5jMGt0TGswTFJ6YnpWZ3FoejloTkJCdHNQcnFWbUJnaU83SllXeHF1anhvN2NHSCtGbkpSdFFybVFlNTZNdlBEUDc5cXV2LzVlTCswZi85WU85M2QvNit0ZkhhVnFWd0EvZ3o3c0NydGEyWHIxMDhiODVsNWJlRDVzWmgrT3Ftd2YwMUFvcko0cDFVa2VTRGNXdk1KTWd0QkFPd1l3UVRDQUZhMnF5Q1JGaGN3bFRZNDk1THF1a3FuMElpRXBzNVdxQjRkZlhmR1g3M21INUV4RGRvWFlkZjU1UHp5VW9SZE1ZS0dFb2UzWDRUOExVTklUbG1sYS84K3ZudDMyYkM4Ky9MK0c1NW4rOG5kRm9XaEhoVTdvVmh0U2lNMmxnL2FaWTN0TzVtSUExRnNzRUxJUytmbk1wOTk0NGdJYTR2dUhGMkJ5ZlJDNksvQ2lUeVlnQ05xMnFFS2tZSWQ0SnJzdFpjc01CcHBBczRNVUxPc0tia0tsMDhsN2hwdkpvTUdaWnlXdGYrREpHS0RhRzJpcXJ1QlBQQUtWQUt2RmFOcFVqR3RMaXVsejVOZURXV3V6SXhHcEFjR3lWam1XVjdydzBXWUR1anNrTWtScjJrcjVoTVBFWkVzb0Z2UzQ3NlVpdjBwenVKZ1BUSWsrR2doQm43alJlV3AwcWs2UlhxMEJDazJ0YVV4WUczY2wvZ0I0OUhHQlpGbmNDdHB5N3Q1OTBPdDk2QjZOc29tZDZpdmwza25GWVJrNUtMSGtiTzAvRlZkWTJFNmgzMTd5eGdsN3BhY3BDMTE4YVhLZUpQNWN3SnNqNHMyS1hsOUpqU0dQMjlOR1QvTDViZmhNdU8vNU10dG1za3BWSXM1ZnVQdmU1bzZkUFAzZjRuZS85ZTNmdm52dnFONzd4K05VaS9BUDQ4NjZBNjdWTEYzOHB3THF0QURZMlUwQUIxOEJPZm1WZ0NBRXp0aVkyVXBoUHRjUXArQktNcVVCVXBtdUFadTRUV0NiUUFOYnBYUVdNaXFkY2RDbUNXWldXY0VGYjNhY1MzSW11ZE9wS2ZIZXUvU2dBTUVXdjNlRGpUR2piZjl5SFVsZ3VkVW9qTkN0TzZKL3hOWlMxMDJzYXJRQVRHNkhoUzRmdEoveE42ZGMzT1V5WXdYcmx6US9nemJ0M3BvTkFLeDJCYmdVOUUrNlJEMkdjOWNwYTFBdW9uMWZKc3pJZVAvSTNFdFY0VVRnMXl0clYwQlhkeE85MEFFd3JpM29ZZFRCV0txajNIbk5WQmtzQkg2NFA4QWFhVFNjd2xTUHB4bGllTkx4ekxLRGlGeDlIbzdmUitjYXZ0Q20zT091eG1JNm1TVlB2d3NsandVUVlPRWtqd0krc2RWelBsWTd2K2VZaUh3dTVxbjdEdC9ROXI4ZUtHclVXWHZNa3JESUNQQncreUMrYWxZZndCNFNNVnpidDAvem1HNnVOUHg2NW5oL3dYUDdLSVlVa2orZzl6YXk3TytmdUNzZW56NFNseTBvY2E3K0xSeldZUEpTT0pVMnU4eThjVitrNWNDWDVsSitUeEYwTVkyaytJd1BxV3ptTUpZL1NOYlQzSkRQOXE2dlJlOXVkTTNGdFpWQXZ2ek81cHdkUUU1aXBWMVpxeVZQU01uRjRuSEp4RnF5eWp2TG0wS1pzTHovYXpSS3M3YVNyd2NwRWFvWVJEby9IRDJoZXkrVFdKMS84eU93azQ3VTVhUC8vZlBtN3h6OHhtMzJBd2ZYSFgzenU1eS91WFBqaW1sbmVDTXRxdWszcWZ0R3B1eEdhOUh0R1pkVUF2clY2UTRyTXB2Y2hGU3BUcGJzOGl6YkpXbFV5ZjM3b3E0aGgxUks2VkhRRXcrbE13b3ZiZ3RkanVBU21CWjhBdFVObmQzZWtRdWpRY2hlZTh6ei8zbjYrdS9DUTVOSzZ1dysvaXBnL1RhUER0ditnTjhEYzg3ekRlN2twZmM5TlovN1pPYmp2akZ2eHBqL3k3N3VyOW9Ybm5WK1h5K24zbEFwQkJ6c0Vtd1dscHpHMnNhSXhRQU9TTkxoMU9qZy9UU00wcXM3VWdZWGdjL25DZjRjZFBLU2MyM0l0WlE4bzRMTjRKak5uZ09ITTMvSVBuL0hOaFhhVU1rTVlwMmtuSG1Cd2xTemtuZUU4ejRObjMrWXRxNjRYTWpDNnM4T3lsYjgrc2xEYVF4SlNRaWx6SUNHZmR1WlZXdmxvV1p0R0o2VTN5aUQ1WFkzVjliWkp6YWxlbTcrUzVmQ0RaMk83M2xQUnAzVXREWDR1NVNGY0g0T0l2ODZIWndVaWY5TEhyN0IrdnJoRmFRUlJBK3B3M0t1dWtoNDNMMS9pYzhxalhFQzBPZ01UbU9JL2xaVzhEeXRWV3NxUGhXNXBsZml1cGREbVgva0tJZWs1MFEyZm5qc3M0Uk5lR2JCK1BSdWpmU3UvUmx4eWtQQnJXYXExbExIOTNZQXByTkM0WDc5OGViYi93dDJpdGI2MitUZldOdFovNWJVbkwvK2RiMzV6bGw5RWZIZGROLzUvWnFuK3lKMmJYenEvdmZseGgrTnVaOUd2N3FSbEtEWERxL0lEUXZVenl0bU40YWVjRDZZeHhSUlZSR0pVc0lvWVk2MEJ6Z0txczRvSFhsVlJBcWNGNzFVRUpqWkswRkxKaVZLTG1JV3poNTBqY0sxRTd3UlgvaXJhSVNwRHdFWkZFd0RLNHQ1WEVjc2ZsYzlQR2hXL0ZDTENNd21xY0t3T3h3dHluZmFnWDE2VDN3U2l3K3YwYjRldlFwbDhwWGZxSHovUExENnUrWE52M2p3ckUrK3R6QjJ1NDR3MXFRUTFQaUhsVHZGWW4yYS9xNnpSbi9KVjZVL2xwTXcwbHUycURGTWU3cXdTZHhhSE9NbzJENVhJUElCYUFsWDhKVDBXMmVCejVNRjRKQ3U1L0tmeXhpUjY3bmhLS3NtNytqQWNBYVFHSGUvOEtmSUlmMVpHMHVndXJMU1ZFWERncjN3cWo1Vkcxb0hHbXFMd3d0UWlmT1daTkRxY2svZVZFVGxCcTdZQzUxN1B1VnNhTm1wb2xKS3d3SVk4b2lGYzNlVTl6M2hBdzkwMTc0QnFEWFBramtlMGxFM1RxZTNMU3FiS1k0QnI4Q2RsMzJXbURBWm9xdVhtdDlOU0J2eUtoenpMYzRlclRRWHhXNDdSWkV0dGxWa214ZVRGc3pJU2Q3N3M4SzZPaFBGdDFNbW9GOS93MzJQUEdxQ1dsL1BuejVmbDZ3emxKMDh5N0JBeFV5YnJTZWRwMXNFK3pIa0g0dmxSMEtXbG5CV2I4ckRlT0w4YThsenVQNVdSOHIydGMrdjN0ODR2N2I2Ykd3M2VYbHR5K0tmb2Z2ekZaNzk0OWRMMmw2NW5pK3VsL1B4RGZpNTM1dkN4OVNpSkxhODFFWkVXZno4RlpOc2pxMkNXdFhhMVVEc0NTNTd0WHpaeFlNa0lvWEErYWJrZ0Zic25JbEV0bHAxUjNnNnpNMGo4M3V0T21JME5xVGhBSEdtcWlRQUMrRFF0SGpEbTUxMFlsZTY5L0VJdkQybWc4eS9qZG5YNnp5bmdVdWQ4VGZqYS9KQm5JRzBTd3ZEeDJCMUZRTnBxQ2ExRU1JdmUvOHpJVDBuVWZlektHbW1qQlpqZEM0K2hYSzZhSkNuK2lqVWtFMWVjY2ZjdXoyRU13dVFHa0lZRnI4SEJWNzFyWkJJbXJHYk1LckhrVy9oNGVBV0dWYjRzbEtUcnZOZEVMVjVxWGJGNENkT3JJRVoramFObWFDWUUraDN2K0xHT1UzZlkrR0V0cDB0Wlc1ZHN2TXpHRFNzOURnTE0rNmxuQiszZ3pmZ3Z4VmJId01lUUE4dThyRWZqZktFcG0wNVFxcDFHVG1USzNuUTc1S3d6VG9DRVQ3cnBGZGtxZlpURGZDd3RjMFpyQWEvd2tjT1ZOUHplS2J0WmM0NDhXR29rNzFYdTZiYXY1d3lNelhSdDYveUFnRWVkNkpWaGdOVUFqTUtwTkNKUDh3MFBrTUI3ZFpzRGZDZEpyLzNVbVIxSEptb1VPaU1qQWxQUHlWYlZ0Zm9lamN3QXVRTEswSkhmbFp3ankrMEZkRXdXU2NlV1UvS0FOMTF4ems5Wkt6dDhwcWdKYW8xRE82ZmhKSTFOY3A1Wjk0Qms2dCtFSzNBRTJpN1BWUWZLSTVjZk9GeVBKYm1SWHpyZVNIa3NCOFRLSWc1WjhyQmdRbE1DRVNRVGJzcldVQUZITG9EaGZzRFZrcXVFcXVHUUtOZFUveVFreGxicTJQR2lBTk12d2k2SEJqOEdsdkZkcTFmSWlvbncxV0RLT1d0ek0zeXc5L0N0MllPTXo1NmNXTEtWK2tsK2Examw4UGd2Sm85L1plbHc4U3NyV3hlKzltNmQ5enJNdU1yNm4rNmZIMzMrMXNjaUpkczFnYVVGVFBtcWhQVlVrSUozOE1OaGhPSXBpelhncVlXckgwMmo0QW5qdlN3ZkNod0Y4YXppK3h0dStTVllWWnI3dkJOZkN6a09wUTRBVTlLOEExQnV4RDJMTk4vQ2xoRGhJK0U4ejgvMnNpYktUejdpaXMrazVjN1pLRkM3djRvM3p5Tk1MZXJPZHdJVnF1VmZqOU9ma2EveHJieEd4TlBISkRwQ1RwYnBlQmwvcFMxK3UrYlBYV1BSNzc1VGxQYnozbkhkUng0R0hVdlo5Q3I4QTIzaUFGZ0NEZTRHemRBTHV0bmNzUVRvOGgxd0xHaUlDcXVWK3lqRGFyUkNaMmFSZjJqS0hwYWxhZmEzTng5b2RQRzR2M1F3ZTVybjJvUUFRSk5PcFRrTkxZejBNOWFXaEt4YzZIeXQ1TWUxZkJ2and2SXcxU0hlY3RXQy9kUU5WK0dTVnVlOVpLSTJvb3o4QW0weTYyclpDOVJNUEErTFhCdzgrRmwxUExDcytMbklXbHR3MGl2WjYzSkpuTEwyUWhzZnd1SEQ3OFc1aTE4V3JZS2FuSERBdGU1VmJqRVk2RkhrV2puaDh5RHh5RHlZZWpRZGtwS1dwb0J1UUZlVmZvamt2OFphUTVSNHdwaWc0MXBIOElHbTlEby9xZVhpV3pqZjBaRi9ZUkl6NEx0VzhRZU42YVF4Z2VPRU4wd2dyRGhuTk1kYVkvbXd4TTBFbDIvQzV0Y0ZhcjNyY3NaVytiWHpERGZRMlVoRFl1Z0EzYmZ1NWFlOTA1ZzQyZE11cjJzNUMzWTN5emZ2WmVIQS9mdjMvdWVGby9WL0VCcnZ5aERCbndtNERtRE4rTS9pd3E5c245dkljRUJhdUpTOW4zMW1DQnpWdnZNc0ZrN2hLRUEvOTZCZ0hIWlJWaURCU1l2S2FtV3hxaWpDYlFHNGNDVjhFUjUzRnBLN01kcnFkdnVlS3g1bDRiQkc2cFQ0Q0w2NHVoYm9GWTJwc3Zoei9EeTdWRnBaaWZWbEtJc0tyZk1zK1UxeHh0anFwRXpoRWIvdFFxNW9GbSs2d1hGbjRqRkNkZHJlNXAvSDE3Ty9lQ3MzV1AyWGhwM252L054Um1Yd0l4OHRxS2QwRTBqNDQxajlFTW00bG0rMTJELys2cytReXZKMEpLQ3dBRlU1OVRpc1p6K0ZYcE5VS1c5Z1kyeVdHOXRuVS9mcXNmS2lyS2xxMGtpaFZCMnpaSThvYzhCaTBTUkY2aUVmeHc2bmdGSFN0M2RkZlB3NzNHTW9zVVpqQU95NWMxUGQ0U3Z4aTAvUDRZVjFhbGdtSVZPM2VpSkpLNmxBckxGN1RzOWx5QURnMCswWHI5SUxuMmo1cmFlU244Z21vSllEY2xleitnR29jenM3a1lHeEVGN09DK3pDYTFLcCtNcTE4aFA2MVcxbmVvZHVkNUgxdXRBSE5CSHRzbWJyT1RTcTNDaFFuR2RMc09vYi9RZ0lhanhXWTdrM0lPcFYwQm5GWFpzbklvTDFBNWd4YnVTNzlDbGxzN0k4ZGxFcGc1UnFnU3lnWFVtYWVGTUdyRTdXbzE0UHA4R3RYcEE2MU51c3VrN1k5QWJVRGI1NmNzczNzb0ZuTzdHcTNpdlBHbVpKakVhc0NPZFBOV1pwY05Hd21XQjA5MU1QNGUzY1ppenNDZkN0ekpDV2VtRmxTK1A2YkQyTlNpYkJzZ3R6VmMvbnlxWDBqR2F6MTE1N2JmYnRUSll1SE9RZ2szZkovYW1ENjBzdlhkbituYTkrOS9jLzhjeVZrKzJ0blJwblBaZEIvS1VvU2RxZWFtbVo2cTdEL0dZNVFUcUlGRldYTENHTUFWR2FHZzZJSUd1ZGRCa2p2VlVSTmVhYXdsRlJGTFhIai96RWNrcS93SXQxR1ZHc0MxMUNYQUlTdVpSZUE0c3lMa0JJNVhBcWFmN3lyVnpvY3I1RmtzWkwvZzVnSlhURFNrSFhsdDBLRi9IbHhqYlhDRGx4RE0rNk5PNWNoY3V6T3lBWGFzU3RyQWh3R3JianpDSXczTVJTUGMrL0F6enhvZ1VqZnZpb2RLV2RTLzRyL0R3UDhlaDBGeUtBOG0xY25BdTdLYVRCUHlVWWh4aWpGUUJJanlLRldTQXJmdVhEVHFvOEw1YUZ5UkthR3FaMDU1VFBXdXFSVTdUTHV1VUJ4UW9UUG5IbTkrdXhicjJwSG9OK0xLdk1JY3dhdHQ2dVNVR3JUTUxnVUY2aW5DUHRZdm5odnh0R1lPYTdMaUlRWGNucDk5NUhuR0Z4b1lNMzErQjlxcXVVQVl1U01qZjRHVFpvOEJNV0hhNzlwQTJVRzJEUk5LeUZockR6UXdiem9PbDdoVWxlbXdmdi9TeXNOTnFDNXM5Q1hVMTYrQ2Z6MGdhYUdnYVdOR3NPSHc4ZVBLaWZ1V2JJeUErZTBITG4wR0l4Y3BWR3ZxSHA4ZzA5YnNoRjZtMVVZYW9tUENYRktvTnM5ZlpkaTRBTERhSEcyS2FTSGhaQXl6cmhrZjVvcEFiZEFham83T2ZJd25KcCtGaWtMdklBQi9heUZWMERzSm9oRVJQVlIrbitrNGU5NElRR1daaUxPem16SlB3K2VMU2JJWWo5eU5EQzdOTE91V3cwdUpHMXNmZG5mL0JIMzd2d3dzV0xzM2ZqRElJL2RYQTllWHl5ODlFYjU5OXlDUGIxbU9TNmVjY0JVVHREVXFxMUZNT3BTQXFpZ0ROQ1F5bU1rVWJiYWsvN09FRm5oSEhndFJZMkdqd3FMd3VVdWVqSnFRRG83aGdqUEhVQU5SVWMzeEVuSDZwTEpQMElERmZDbWNvbUVDNys3dnpiZGRneDduVUdxdnpiWXEyOTRZVGVWWkFIek5BUGxRREpJRWNhUjdxNjIvbGFTWXh3NDcxV1J5UXd2K0ZHR1BHbE4rajB0My81dmZsdjNnbHlYL3hhb1FiTnR6Y200c3JYd0x2bVBYSENNMFhpVGxMK2cxN3VwWVNCeENoVXA1dW04ZlNaQlN1ZGNRMVF6NVJtZmRlVlg4a2lkT09Od25GamZEcTBKZ1d0Y2crZ20zWFhlT0xqU1g1ZnFldE12S3E3cXVrb1hocTJ3eHg1MTd5dzdLUzlHa1hjWHowc1lGbFBHRXBzM0JmUWVFWkRuV2pZZXhKVFBBMGxHUzNRQzUvQytSVUYzZW5NUWxkOE5EZ2dKbXdQWVMxR2xoZXprSjYvOHRJT0dmZXM3Y1hKaDU4R2x3YTV3ZStLTWs1ZWEweSs1RFJFWXlVV1FDVk5UdmpUbnlOS0dLN1BaZkRzdXkyanlYWDBLUFVWUHJkMnRxdm5adE5NSFp5U1hpSW56Vk9BVFRoeHhBK25WWnBFbEZGaldSTkFyN0lLbUFOYTVXQ3pSd014V3FNVXdrUHk0THR5ZFk2QWJ5M2IvRmlZNG8zR1o5cWhOWlhEa00weGFjckFNdHkwbXZIV1NpOGE3YnVlcDNkWGxTdTlTNFBzdWNvLzV6VkljekhBdTVmZnMzdWEzWlZyNTdabXQyOWZUWmF5dSt2aDBUY2ZQLzcvbUx1WFg4K3k2ejdzdDI0OTdxMTNWYi9KYm92TmxrSktzVXptQlE3aXdCa1FzSkdCQVN0QWtrbXNrVDFTL29FQUdoZ0lJQVFJQWdTUUJ3R1NpV0VIRG1MQUdYZ1FHSGtZRU9BQWxvRWtjbXpUbEdRMjJ4SkY5cnZyWGJlcWJsVytuKzgrNjk1ZkY1dVVLTFZpNzN2UDc1eXpIMnV2dmRiYWE2LzlQRWYvOGZtTFovL1J0My92Z3ovV3c3WS9kK1dhOGVXcjU3Skw0L1V2dnBaZEV5OWt3TnczMUkvMnptZWxBT3VWSmVJTG50Wmpha203dHptRU11dW9OWG9TUHpPNld1b3lONHFWYmcwNUl4SkxDWTRnSUtLSmtraERsVzJGaGhLUGt5WlVUb1Vrd0d0YzZsT3RQZ1pFcUJielYrWEcvSEVWdEtRVnZpcWVleXBSS3V3d0ZYNmVYWTRTckZ2UktsQkZETjRiTHVsejUzSEZBMy9CWHNuODd2cnRodTNpcU96UE8rbkdQVXQzaUlPMmNWNWhMamk2RThvVllXRVhDdlN2MnlhRkpRMGxkc3d5akRJSThWYTZBSHkwYjQyaXlwS3dWTU0xRnMxMmtaL2Y5RTZTYm5EbjFZcVJleWNjNDJIS3F6MkpIQ21uQzdteHRUQjdkTitHbzhrVlIxQjJ1Mmtzb0JsNmVKWmhGM0R4U2o1andUNk5aV3huMEg0T2RJSEpsSmw0a0RFVG5iNU80ZlFsT0ZFU3JEV1hDaytCOGwrckN4WnNEVTNMcXJ5NTBQQmVKbVRFOVVVRk1td0NVMWdkdkFMWHh4WlpxRFpmbkE5czZaWXl5VEJDd2diVzhIWEtBZ2JZbGYwdEhweUVMenJHU3R6d29LQUN1TFJrSFhMeXNRYVVrcm1iUmZZUFk3azVmYzVzdTUxVGx5N2QzdnZCRDM3UWVQS1JQemdMTnRuSDh6V1RQN2dKOXd3SEYvbFFGbjQreTVUcWtCbTE5YzA0Y0ZKREd4YWdxZW9KRksrM1pmQWNCYWR4bE8rNWMwdStsbnlHVDhhY2s2ZEc2RWwyYUIwL1NyN0dwT0lPTXFRUU5vWitDMmFObHcyWXZNL25STFQ3dDI1bmw5ZGhkbEptR0RMYXpRVDR1ZlJ1cm1WOS9kNnJOM01Pd1JmM2Z2czdiLzlQNzk5KzhGb3MyT3QvbkJiczU2NWNjL0xPTjE1NThhVzlselBXY1poVzV5ajdnQzFWeVdLUlZFeUtLSUtYU3NnUk1rd3krNnBpTWZrcFZneWxSTUxTU0d2dWlKbTRIVTdZQkY1NlVNcmt4TzEvNHJCMk1JcHlUYkttVTBuTXFFNSswcmd3bmw4WEwrZDVCQmpzWGRjNEc2N0ZMZkJIK2NzcjRsRjR4VVdtZFNvY1JiYkN4b28xMmJQd09DMy9xcG9yWGJLcHE3S0Q0K2JtRWYya0g3Zjd6TSszc0hiZGhNOTl5dTdPRC83Y3ZIdHVtV0pxcVdpZXJlcmdWbG9pWTRnSC9Rd2ZzSENYa2tQNzAvRzBGYjhWYnV0MWlKZnBpbG9qUzZFbGJheFBaWnA5NlllQmw1ZkNQSWp5TlNGNjNpUlhWYWFoR0IrOU05dS8xb0VhV29DanhlWXF2WHZ4Q1paVkJybkR0VDJOS0VMamhCeEZYS1ZiZVZzZm54VC9JTmJCd01aWGp2OHN0M3F5TmNpc1FvMjFLUEliMldGOUN6UE96MDlhZEs0RkREK1RMYVhUa2tIUHd1RStpczZzZTFkTUpPL3lMZThVam1kNGFCaGM1VjNDNEVHUmxWZnBBVHFZdXVPNVNWOVlTV3U1MU9VTUZkeU1zbVhkeW5lczdzTFo4bUlGV2dFalBCbTJicUJkV3FlTmh2aWZkYXNhdkpTTmhGcWJEZ2E2K1d5UVorbU41UzVMZDlHMDVZemlkeGR1cGNiNlh0b3FwM1JkMFpHR0VpM1FKSnE3Y0ozdktqK1hNREJtRWc4T1U1NUhUM0owWWNwZ0RQeEtoaVBoNUhpS2xDUmZwNzJ3OXpNLy9mcmU3VHNmWkhMcmd4ODhPdnZnelMrL2N2bnc3ZmYrZURZYWZPN0s5ZEtGZzIvY3VINTE3MUs2TWhTUVFsL2NMSU9IV1FUc3lMNXdwcFVTY1VLaENpTGw4M0FiZzYyRnljTFppQkthbDZCRDFOQXlpbk9FTTRUTlgyaGRKNzlWa1pJb0JLYVUrNG50NUlzaHp6dCtMaFZoMTRHRGFkekU4VndCQ0hQaENKK3BnT0tuc0xoNGtnL0xzZjdiOE1BdVRMQSt5OG1yYWJiQTNXZGVoaUhHaWN2TnZjOVJJTSs3Z2VHK0czZktNdkVydURIMStLL0tHbGdiUG9wMk5nM0htdkNKVlpKNGxLa3hoSm5KcjlKTmV5aWZLdFdRMUxOb2ZtREwzNlNHaW0wY05VMW02SWl1SWdkbWFQWFV5VnBSVXFtbmVRNmR1OEpnVlZwanAyQXNCYk1xZU5Sa1lGQmd0bEt1c3dQRUdieGtyOXd1MW8zeXVWUmU4ZURvWFVWOGtyeThnMitabEdmK28xejFkc2cxM3FQWEtzYzJEaDc0OSsrdGIwSjFYREN3T2JBUERpanVpM3YzenR3NzRRRjhLa1BrS0JhYlo4WUZCN1o4cHp5R0t3eGxYTXJTcjh2cDVycTNETnN1SjhxYlZXenlCMDdTZ25mNzl1MWVsbVc1ak1VcTkxSmNXOE1SUE9FQ25ud1h6NWFzREczR21nNFNHeDJ6WENzNG9KOThwQlhYTXF2aUVuZ0hGMWpMbDlJN09JVXBQbGpOUHdQcnE0ekNseXpMLzBtR2krRERnY2wxUWk0V2FKZnJwYXpjbWNpQytPSzZQT09iTXB2SE9aK2xZZzUyaWU3dkdQN0ZQSC94Q3kvSHF2OXk4Ly9kNzczLzNhT1BQcjd4NXB0N2gzOGNtd3crVitYNnAvN1VWMzcyeWJNbjN5T0lySStybWJsRTNQTWgzSk5ZRlBvUXg4Wlc0eHhSWjlJQ1FjeHdsdUE1QWZlSnZkZGhWTTltWGRXeGhFZGlsVGw4cVZXcksvVGdTWVlRQXNmNGxzRnQzMEovSENJYkswUHM4NW44WVhVOXkxSU1ZNFdGRVFJUE16QjZLaGVjS2x3N2Z1SlZxTGJXV0p6SVVmTlVtWFZQd3VJS1FOQkk0QklJOGJnbE1QRkwrWVVFWE1nUzJueUdreGMzZDdqQWJkNVB3cUo4K0MzL1VaWUxCM0dtQ3pWeGVoKzR5VUxkWFduRmh1TlNoTllkT3JNMWFtdnJZYWdzcDliQ3dLTXVrbHYrOGxTNkJHWVU0SXo5N1hjOEpwRkNrTFhlZHBVOXVTWmh1dFhud3AvVWpVZmg4OEh4cHBSWWxGc0Z2YkNObzdLSW4yVEcrSDRXNWJPUExrUVJxNGhrNDByV1RKL0xHazluempvRGVJMzlwaHVZQnQzYXoyNDJDR3ZnYklLUGpNSEhlQ3dZNDJwbEo1L2o0T1hTY0Jqbk85SVFaeG5UbVlmTE9rVWpKMkE1K2Y0Z0NvcmliS01hL3ZjQW9GUnljRm1MMTI2Y1MrVysyL0xBTVUxUCtSanByU3p0UDF2SzM1SzJycFE1em1IeFlrV0c5d05YM1VFTGpmZCt5anBLa0NIQ1lJR0xjRXNZeVVpUzdwM0xubnZyWjUvRUl0MC9NcG0ybGp3cFo4OUFUaHBmK0hqNDhFNitQM1V6UXdXdjVEbm5KMmROcUUwUGEva1R1VHlPdGJkNlZwV1IwSVNibm9JeU9sc0NUdVZYbmp0QmkzZWh0WU9zeit1WjVaM0xscDd5Nk1tOU5aVGk5TEJMNTZPUWc0ODVHVU1vZDdOMDdkNzl1NldSc21mcWUrK2xteS92UGJweU5jdXdQZ3grRDlLNFpsSTdobG5YKzZhQnNwRWpERzM1bmR1QkpvWnpudUZsRk1UWldNeVdlVDY4djhhZnJlKzJSdm5pbGN0N0h6NDg3dmpyMllNemU1ZXZYOW43Wjc5MTlwT1BqdlpmZSt1dEt3ZmYrYzUzYmhYeHorbm5WTkkrQjRBSDV3KytlZVBpeFYvUlFtcEJGSnJES0lJd0ZmVDVkMkVUVGw1T254ZHpKeDEvYnVEMlplZEhQRzdpaXpldDJiUzh1NnB0TjU1MDRrL2UzajFYMENNczRqYWNOUDhJTi9BRTcrSTRhZmw3NW5iRGQ5K25qUHptK2JQaThodTQ0azFjM2NESkE0eFR0K0tMSjYxckdoYzBta1pHQjl6N3dCaC82ZmpGY0R0SmIxeVJuK3MwSEgxV0hpdnZ4VE9LbGRQVFV6bVBqakk1UkNHbFFxUzVPTW5mUkF6Y0tOZHVjYzB6dmZ3d2lwWnpVRExGWUNpQjB1VlVlZzBCSER3YlNsQVI0VFduYkZHdThySmVjcHdWRDV4NDVLTzBDYS9ORFF5TmJESVJUbkdTNjVPeUJwNFMrZnlJdkNrb3l2ZHB6S1JyMTFZZUZDdVkxSXk3UEdwNHhPZHNadGZUekNlSXpLMHl3MDhjVGo2N2w5NFlXYnlRSFVqaUNHTWg4cE9PazhkWXJlakFpWXZlazRaQ1Z6YnBEYzBzL0JxMWRmWkpEcXRXZHlzRFViYkNnUWVQbjdYbzBzdDM4QnQ0b0p5TDFheFI0TVRsREFjK2VwcEdNbW1lWkFHcStQQTRXOWpad0JEYUtZc0p0K05zWDJhUVhjdVNObWNPZlBMSlIvVi9jcHhlYitJL2ZyYTIwZ29yMzlNWUxyZlZnYTFzNGxwempkN2RRUlpjME9sU2xPcGVWZzlvTVBEblNScWkzL3p1Ny8zZzQ0ZFAxNDZMRGRybmNmdGNsZXY1TTJkZmYrSEdqU3kvdXBLbEwyRkNpSW9CQ3NuaVlGRjZWbkRNV1l4YmdqM01tbnVKVXg0dDRaekptU2swdU9QRTVlcTNFWGVYOFJXS3pSK0JKejRtai9NOFFsS2NNV2NIVC9FYVA1YUhMcXR1aXJOa3ViV3VWdjZNMTRYWEtlUkdPVkhKb2NqeVNMeFA1Yjk4MTBSYzRzenFoOTF5aWhManFtN1NGdGZRZE1yN2RGTkNFLzc4WFdKK2FMSjdvVXY5WTNrODc5QkJtTHZ2R0UxbFhtT3M2RVo5YkFxYmxSNjZOTzQyWmp1S0ZWeEtENCtmNUNzVVIwbkl5cHlLNHR5Sk03TkpJSEU3U1loT29YY2dGb2RuVCs5MXpGRGxnUDloNUl4Q01ZOVpHZ1NYb0JDbkV1Y1padkJMQlBIaHJqNE9YV1lNbTZLRk0wc1BDNDJkV3NtUXVya3BLSlpmWnJlcmFMYnRuVkU0U1ZKNU9FcXZhei9IN2xtclRRbmJYYWFjTHRRWkpaZGROSkJidU9xRlVhNlBJMHVoMVJvT2EvQkpISGhTSXRaMGd1RWEzQ2xOT0NzWEo2OHJGMDFlclMyNjZFR0pwVkM5dkhOZ2NGVk9nVCs0Q2JjOEVueDAwanVEMStMMzZsMGMyQUdYdGJpcjExWXd5WC9CYmJwWTJPSXZIRlB1MUhud3dYNmFjdzN1UDFzVGl2eFpybm9haHlhZzhxdzZQYzRTS2tvV0RNTkhEbnRSempPUmwya2tGajRyRC9MakhYelh4YXlwajVRbTN6U1d3Ui92ODVEZFhZNUVUT09UZkJLeWR5WHpRYSsvZkxPZjZMbDdPOXRuLzhYN1gvbnlLNis4Ky9aNzczMXVwMmo5Y0UxYTlQcEQvUjZjZi9ZTkd3WXVSaWlOZHpuaEtLS3FkUG5WMGhIZ1UyVXFFd1JwWlFzRENNb1FhVlhRSlppaFhTS0dnQ1E1a0lhWTBuUFN6TjN6Q0I5NEdEdk1sYzRsZk5KNDNyMnNXUzBzNnRDWXNKcWF4NFZYUWdMZmMwcXovRVJMRklJUm41YWhBUEl6ZU95K1U4U1Q5L2p2M3VFSDc3bFd2aXN2OGNaYUc5aTc5OTF5elBPVTkvbDRuNlZZd2I5Z2E4dm1Cb2RRcUg4bTJTeFU1NHBYeWp2T1U4dTFORnZLdmxtamJRMDJwUlpGY3RJNDVHR0xHcTJROHBydHo5MEhLNnNzTnA3S3phSjdoM1NvZ0NaSjVET05DSXVPUmNTeTdDUk81R1JOVnEwWmJTc09xbFEzWEZsSk9iY3dGVGRkOE9va082T1dZbFVXVnFqMFQyTXBuYm5FVXFOczB3M1BFakRqb1plZVhLcGxWWmdhSXZ4bk5RZUhlOW5qanM1RTZFVGhKQk4rRGlxeTMxMWRXUG1rWE04eThaVGhNcCsyZVp3dlBKQXFSek8yZk9vQ2VrU3h1dEswVkk2dEF2RGUvQ01yOHlsdk1OVWphVm1CSS9QODhISGtRTGd3ZnVpcElkQTRtZVNhOGRvMXpndHYvSWlGdlUwbUZmSDhnTVdCTmE1bGpIOFZZY3BMVGl0emJSaVRKbEg1eWJ2OGpjTHMrR3g2QmthU1dQMHZaNmpnd2ZtN3hjUE9MQ2ZveWNzNDhZVkhGeko4RUtVYk9JcythM2lDd2tRUEtNblAydCt6R1Y0NWR4eSthclJTZmpqdG8wMGFxQ3RwWk0ra0FkblBkVEhXNzJzdlh0Kzc5K1lYRENmOHh2dnZmL0xuOXI3OHltKzgvZmJubzJBL04rWHF6TmFyaDRmZnZHQmZmeXFoaXRQS0U4S1ZHR0VFQllTcENLelE0ejd0dDVTZnlrbkJobDVoaWNvNWxrc0VKWjZkbGQwQVNHL3RJVDlqUHlWeTRzaER5NDI0Y0JpQm5IeWZGdzcrRllqY01WVzRkM0JjM2kwOGNsWDVMNDNhbVVsMU44RW4xbXp6UUFNRkdPYzl5c01mQjk3Z01IZUxuajByMDI3NHdKbFo1S3E3d0VZTDVacXlHVFBseEo4S05YZCs1WXY3enRVRStSa2NKbDlsZmg2UFZ2VGd4dCs2MGhVZStxZEkwdTJuUVZWWktiSHBncy9FSGp6TTVNcWJwZWxkaGFPOFN0L0FmQlRMV3pnTFF4ZnpVaXIveFNnbFk2N2lxK3gxcWZqeVpNSEtxNDE2NHQ2OWM3ODcvdkM5YTFhVGcvTUVyQktBNitIaGtpLzBvbHhPMStJdS91NW5xVm15aVNOUGNQUWVpem8rYzlZdCtiMTc2MTZzbzl1QmNiQjM5VWFzeFV6ZXdGdWFSejY2R1ZwY3lBZjZEZzRZQllzMjZHSUZobmpvYUp6dytQaFM0dHlyUXBUbVlzTGN5YXlaKzJJU1A0MitkTHZMeHNTYnVpU002NnFhOEkwL2gyWXU0ZUlYd1lhc3VpaU1Za05EK0syNnNyYWVpbWFkcWJMaHBmVEdYTkZ1NmdTYWNzTDRDZVBXTVpRWit0RWR0end3TkZYbTQ0U0xLeCt5L0RRbnoxbmVwa0c0RmpwZXZYcjlCTGJlb1FZVHlLQVcxQzNuSEF0KzFaMHBaN3Y1S2VPOUIzZGJkbVBCNWgvVXRLZHBGRnRQS09EMHZDNkVweGVpeUorbDRTdVBMbVJlS0kzMlAzbjY3Yjk3LzhOYmI4TC84M0NmbTNLOWR1bndtMWN1eHJJSUhTUHZvV1dJbmdKU0pMbzdMQk5yVWxzcE4wV2xDNGE1eGduNXUzcVlTVXVHbVJHUVdDSVlzNFJuQ2RBU2xDVnNpVkJtVVRabGZtQ01JQ0Y4aFhSak91WUtXN0NXUURUUE1GdGE3b2xtdEE0OGNjS2NJTEJXQjRDOTRoSmlhZWhYbFp4TDlUeUJzNXVIc04zM3lhdnBaUkEzZmdSMDRrNmxtRHYvcmgzYzRuc256S3VpcmpHbDd0Qkt1TEM1cE9kMjAzdVg1Mjc1dmVPYmU1VmQ3b09YK0J6bE4zNnovVFdRUTZRVmw5SmtEVjNOdUJibDVVQ1JHUnRFT3p0MzRNTnE3RWxiZWE1eURhL2dBaGI0eXFYQ2R4SXAxcHdQV0xLczBqbzFmWmRuS1hzcXJuTFpSMjdRekl5OEhnNVkrL3M1ZklRbGszaUJlZ0wzNUZoQWVPUWlteHBMK1o0TC9MTlI1a056RXlhVTZzVlVScmo0RUIvM0lNcjdVYmZDNWlDaWh6bXdPUnNHa2lobGpoVWJXTkt4bHM1VnFWUGNhd1hDaFJnZUt4K0tKNU9IZWdPcDJCcFY5ZVdnOUZpejZMNGpwaHd0UzhTa2ZFeGNkT1dNUGQ5N2VLKzg0a2M1R21OVTY5cHNiZktCUGxXR2FKSXl0dUZMWFJqWThPRUh4dmUvLy8zeXkvRis1Q3JjRFAwczlsOTFKOGh2Y2hXYVF0bFBYR1VyWWVlemxJMHN3TlZoUjQ0NFBKOXljYnJ3RHhKZG5XeTlUSHoxeHdRaS9JeHZYOHFZTWplckxlQmhlUjE0OEV1MExmOU5kamQ1dFpKaXlxbGN4U3E0TlYzeXBSOVl2WGR1M1UyamZUYmJxSy8wSElUekY3TTIrSHJLbHVFT1EzcTMvNS9mL3ZOdjNUenoxeitQOWErZm0zSjk0ZXJsWCtsSk5La0lpS2o5b25TTXNhNkRPVTZWaU1KekN1NGE1WXJKWWQzR3FGaEZKZVNLRzJoTjQyY1lPUjdTQ1hYbjNFZHd2S3RjYysxYXRzSzQzYmpIVWViZWk4c0d6M3VGTTV3MXF4dlpJV05oYTl6S3NsMGJmaWY0Qy91VVcvalBXS295ekxVYnJZcGdDeHY2N01iYnhVdTZob1dHaE5TMXJlUkppRW9nUEk4a01rN2MvYTV5V0lwbXQ1d250RXU2OFpjR0R0SU5UU2xMZmlxZVl5UmJvV01KNExVNEY5SzZYcjVpdWREbHZ0c1FoSFl6cnNxS2FSblNGQVh5a29IQXQxbUF2KzQwK0IyN2pMSm9oVXJGb2FCWm83NFVERCtuWisxSElUK0lKV2lNN3ZhZFQvYmV6MWpqQzlkZXFzV25Kd08zZFk1dzhsSDJ3SjBkUGltWjRqWFBQbXcveW1yN3FyZ2FaemhOZWQwMUN1SmNWeG12b0JWTDlWRVBHT0YvTFd1ODBXYnhjV0Jnd3FLNXVnR3VpYS9qYk5rc0xRSms0V2VjZU1sNzVUV0tGKzNFMXhDWjZMbDlmKzFxa3BkOGRKazVkSEp4dS93VHovdklyODhVb1F2L1VYSldEWXhGVE1uQ1NiaUdBaDY3QmtvQ215OWFpRk9hNUptVFRsNGNIeXNjempod2hRTFVTT1dkaFNsTkN0eGhBWTJCb1IxcHkrTUl6Sm80UEo5M2pVSU1wTWljaGhtT2s2ZXlLOU9xaXd2ZjRtd1ZTVlpBK0NJRmxRci9nRzcrTmlpUW02ZkJ3Umc1ZkRUV1lMMlVkZmsvLy9OL011dmh6Ly9xM3Q2Mzl2S1o3ci8rUi8xTXpPZWlYUCtkcjd6MlN5KytlUFAxNjFkanJXektOVlVsMWVkVWNTRWdoNGpqVGhsenFzd21WTHlKVytMc3ZFLzZ1WXVIc09OR21QakxBNEhkeFJtNDh5enV4SmRlNnpXQ2VKci9xYksyQTRpYk1NOHNWdi9jTGg3TDU5Titpd3J4MjRrcnphVERhTStENzhCd2w2ZEdpNXR5elBQZ3JOdjI0NXh2ekN1djlIUC9kUHlkQ2hLYXdZT2IrQ293ZWhMMFM0NTF5MTNYbVpURDRWTEdLY2NLb29pVjVTRDcrVlVZeXVIaG5RZFZGc2V4U01TbmxFOG1tMEtWVEhzMnJrOENXUzNnR0Q3S0JSNFU5dmwwdGVHaXNsbFJZRUpLdUtiTzNUNTZsUVlPM1BDM3F3OUMyeVJ0K2xVZXZNR1J5RVhTdy9YaVlmTFlLakdsY2o2bjZDdXp5UlZqcnYyMGRPRC9WTlY0QUFCQUFFbEVRVlNZaERtTU5XdGYrNGNmZjlReFMwTVdyR3M3b3FTWm94V3BHckRoWXVjWld2bkxTNVZxenoySVhteWFSMWxhdGltb29hbjNTRWpwam9idzRrZEpqcUpVZHY3ZXlSQTNQUE1zZi80SDZUbElpL1p6bDlZbDdjVTBYdUlLRng5OTF4QkxsbG1sVElacCtPT0hOT0xKeCtVNVBxdlppaDR3dEVOV0FtNzE4Rkx1dzh6SnlNZW1ubnNaNTJVUTZPM0NoY0k5bHg2SWh0anVNbmwzZTNRQTlFakY1SEhoOGhwejF4UGc1TXZKeDhVOGZmUm9HWFNHSnF3Y01TYXVqanA2OHNhTm03R1VrM2NtSjYxV3lLR3Y2UnhIMFo2N3VQZkdHMzhpWWVmMzN2dmd3MS85Nko4OC9Ec0IrMGRhbWpWMXRRaitZWDZNdGY3VXF5Ly9iNis5OUdMWHJxWGZGQnBGK05QaVdORDROSzNJczdRaVpwa3RsSDZnNVpCUkN1eUVuV2RtSGtNbkMzMHRFdzFaQkM1R0paMmhBMTBFKzc0eDB5Z0JCV2g5SVRqT0F1MDlaaTVyeFF2cnNCWmltRklsbGRheDZ4RkRiT2RkOXV5Q1ZscUNnVUc2YW11OHpGclA5UjJpd0Fnd2d0RnRzc20zU2lUNEJyMWVoTERoK1ZGNWJkSHNOczBFVTBtNzE0VEZXMVU3aVRmK0sxMzhnNy91aTVVV25TWFBQUU51SFl3M0lFK3BwSEFuWlN4ZG84U3M2M3VjZFlibmZJTk1Hc1EwVzVwSFNkejNONEZjaCtaRVlRWGZ3d2hmdStxVVkvaURKODRLVllrb0tMUHhMVWNBQkhLV3lGemR1M0g5MnQ0TE9hUDNTaXE2Y2x2dVpCWEFRYXlHL1o1MEg1NUVnSSt6RHRuT1JadEljbGh4ZDh3OGlUSnlUZ0dsU2RoYk9ZS1h0dGVZdWNYMitLekxXd3NFejRNL3BYcnhVbGFocEdJZldzOGFaZWZNMWtzWEwrKzlkT09sdmV0WGI4Wkt2UmpsRWVXZS9QRGZWdXF1N0ZEcDdkb0pmTWJLS0ljcWcrQmdtTURZbTNFM3k0ZjBibnBvYzlKcEdDNUhpWnBVZTVMeUhHZnB6cHIwV3NNQTUweWVSRm40U0tGS20rWThsVnUzTjJWa0tVWCs4U1lTVmpycXhiVmhpUFVrL3lyd0tDR05GRnBrLzBSMmNRVjJxb0h6ZzgxNE95a0xmdkpOSVNPVkdXc053VXplV0V0YjY4K01lT1FnWmtUd05OZmduT1RNTndRSDViWUJSSmpoQ3JTd1BFcWRvclJYSFloZ2toTktQbm1jRCt5ZUlKZTRQZC9BK3ZTRTIzbVdoUGxYQ2RTZDFKTGtCd2grdU1oYVB5UVkzbFZwSnFGeGQzVVZQY1A0UkVoWkE4S1pzbVNmbFdzRHlZSEQwdU92N2ozT3NyRDdEektUbi9YSmRwMDVQL1ppaGgzUVV2b0FYM0tkTWlUVlNwOHg4S2ZaSTNzK0RkMkZuTmExeG0zVHVLZlIxT3M1Zm53M0oydGxERC84ZkpCZXdNUHNJR1hOWDB4NU5ad1hMMXhKbTNkbTc5MzNmK2Z1L3FQOS8rdjZhNitkK2NPZS8vcEh0bHhmdkhMNWw2N0ZvckQ3NFJ5QlNldHUvSWdOTXVPU0NOeFdNZ3lZbHVhRU1SRXdRaVpjV0prVlFYR25HTnNhYlV5VXBrd3RZMCtaMjNRSUhyY0xoNC80QzJZNC9seDRQZktUck9yRVRXT1pkNVY5Q1IxQldzSHp2bkJzbmp2bDhmNmpITGduVnlnemp0KzRTYis3QTB2NCtJdlg1eTBienhNMnorN0tQM0YzNGMrekhLZVZUelZZZUFVbXYxcDcwZXlzUnBabXFCa0ZsYVU1L0xiUFFUdXdCTnFxSmI1WkRDOVBWc2FqTEplNWNIN3h6WUx1ZFI1c2VKQks5U0RYb3h3RmQyK3pYQ2tWanFLanVPUVBSK05yNEdsWWpnT2oxVC8rOVV2NXdwN0dKUnZTc1lKWWM5THJWdDY3Y3pmV3p1cXBTTVB5b2JpTTBiSzgxRnhwWGVnMU11YVpVblRJTkRlVGNFTmJlS3FnUXp2cmNjR2ZjbHp4bWVjMFJyZXlyQWRkZExVcEhXV2k3Tkc5WmNnRFBQbkRDeng1c0E3NTc4ZjQ0T1EzZVlzTGQ5ZFJlQ0ZOeTVKNHdoYmNaWm0yRVFrOGFia3BYM3VVZ1NtUDh1MjVPaWMvc0lSTDJ3WSs3K2pMdjhaRDhyVkRxaFpyRk9mQWwzWWN1b0F2amwxU2owSm5rMXFHUThDeG9xTDBENnl1ZzIyckducm5qNUtWVm5qcHZiK3NaQVlQbkVvZkRVemN4SEVYQnJabnF4NjhveEVGUFB5eENtUDFzdFluWXhoaWx5NUZ1aUxmSmc0ZnBzZlJSakxEUGErOS9OTGVWOS82bVY5Ky9PamI3L3o5YjMzM3Y1K3kvYVQzUDVMbCtyVzNYdi9tNjYrKzlOKzk4cUsxclZyK0ZEUUZNcVRlbzlWQ3FPTzBPbXZjUkVWTWE1NXdUcXZKbWNVdEl5S0lXbFZFZGo4aDhyYWp5enNoYXJOMmtqYVYzOWhWbFBGVEV3SlJpajJsUHZFMkhkU3hVUGtnK0V4S2VWNlhFRzRwTWZBcE4ySE5LeUduY2JjMHlmdDV2NExZZmpCWitEanZuTHVyYXhtMzU0bmpQbm5PQ1QvRkpRSTY1ZmJ1TXZsellwa25IOURuVWdGV3dTZi9vVFhCMjVSS3pGaXoxQ3hBMXFZRWtpMGx0R2I1ZldYejBER1I2QklUU3NWZ3ZWMjllclY1cWNCSG1SSHZtdGVVcFFkY0J3Zzh5TFJ5aGtxTERsVzZPUlE5TzZudTM3c1RxMm1WUXh3S29vb3ZkeFdqNlN6RkNxU1Q5OUM3eWlTQStSbWI5ZTdaWGVYWC9VUS90SG9VSmRVdkxRUVpjWVIxU0NKcnI2OWtodzc1NHM5SlR5R0NNZlRYUlYvMFhBcUYxWVpPS3J2clNtZ2dqWVhweTRwYjlQZmV1RWtQbm9wTllUcXptSlBXdUNuNVpaV1QrY0daQW5EeE8wb0RWTmlKSDRKMHRyeEx6UExzUFZxdWVNTWR2Y0RnaHA3SFdVYkdyLzdrQTR5VWQzRm5LWGo1akpJbFUrS0E1M29VNnhzdWVqdktZZXhiK3VLZk1qNktGYTduSTQ0ODlIcndFYytVR1R4ODBBdlNPN0U2aEgveFNKeHVBR0hweWpQMHdBKzlCRHJXZHVNcFMxY2JiT096cXJ1OFNyUEFTdUtrTlRSQmZTMXVzZkwxUU9DMzhGMld0alF0NHhaUFJsWmVXQUZpOHROaFVTeCt2YVJPcktiblIvNnR2NzE3LytIWDd4Ny83bi83eVNkdDA0dmJUL0x6UjFLdVgvM1NGLzdLcXkvZC9Qck5iRWYwRlVhN1ZjeEdxbGo3c1dDbnk2cUwxQUtrVUlzMml5Q0oyb0lpd0JxZnNueEM5MnNwVWtTYXc0TVJpT3RodldFTUYzRHQ0cnRYbU9KbnBuWUl6bnJ5VEFYSlZ4ZUxEbVpSVjlIbVRnMnZ4ZElSQ29JUjRtTTRGcDdlUFMrd005YmpsU00wdTlmemZvMjAvY0JSSGhObnd2Z3JYOHNZUkwzdlhoT3ZBcHJLdWU3TCttckZVWGx5Rlk5Z2lqeXVwVkJWMEFoakdqNUs5VndxcCtNZjY2ZWlCbDRWYTRUc1FvVDc4SkpGNHVGZ3VxKzJuMm9rS1pjdWE5SDF6TkJEdTR2aG1kVUNCK214V0s1elBoV1RKWmtzb2orU1gyamU0YUVRVG9Pck82emhZeG5Lai9LK0dDdllVTUlvZVV1bjlJQlU4bGJtcmVMYXlkVUtIUDh1MGNxN09Gd3JNdm1LRWxQaDE5YklCS1JHcG1qbE5RVW5Yb29TZjdoc2F5VGpNWERCQXBPTUpGSng2bHJZQUZIeFp4TkxLRkhZaGlXNjl0YndoSEc5cEdVdytQb3JKWXVHeXR2aGplQ0ZIcFFWaWRSWUtRZWhmQkNMcVExQy9ORU5EVm5pVFIrWkdMN0N1ZkpSZkNJZjVDUlhqWWxWQVNxa0dtZjFDUzBVV0hybDBpRHpLNzAyV0dTTXpBaDNlUzdkZ2g5THQ1OVlxWEdUK3BQNnJGZTYwcWVPaENhaGNOS2xySXlhOGpqNGtpMDhEK3dPemVXdThveHl0MG5CNFM3ckZMYlYwNlVRUlVMVE5pUjVXNVBjcTh5dHBlRGw2c0ZFUlpPV1dmeFZuMFBlN1ZwbHlsdnBxVnhvWUtpTWpHQUEvYUtzMWgzalAyT3VjaDNaUGtyUFFlTkpMbU8zM2JoNzYyanY3ZC83Nk8rQjk1TzZQN1J5TmRiNjJnczMvdHJMTjY1bVMyTEduTElPMVJvMEJLZGdIU3ZZancrRzBmMW1UZ3BnNVVCQ1FvUkZDY1RTaWhBR0JjUWdyWmZDRCtOUmJBa1dVdVl0ekpPZWptS3hQZzdEYTIyaVdpbmNhS2NXNjNxdFlPNU9xaEZVZWZRZVdPN3kwVFFzT0lNakFCVGFyajhVVHBVcTVzM1YyRnVZWjNuTUpZK3E3dmlObTdDNWQ0MXc2WE9heDFRUWVWSVlCSE9OYnlYZitnV1haa1pCTE1Wd29saVRZRmxldXBKUm9LRWY4Qzdkc0NyVytGTytpa2pCYWhSTklPaldNZzRvWUJXQ0g4Vk1RWXMzU2xWNEYrdWpRNVFYWE56aHlMSXh6a1pnN1kyL21PL01zNFpZaUxWQ2t5WlJtOGFkOWVDZWg1S29WSWRzRlFtZUxVc0xUU2dXRmFiZm5wSm4rWEN1MzEvU1c2TDA0UDB3Vm9rS3lMS25NQ2tHeTZnMCtsVUtOUVFpZTFFa3JMTGxsR0lwNGg1Wm1VcEhMblU3SCtZeWJrK2VXWm1YWXRVYkZuRHExRUs5QlNrWXNuMlVQZTd1ZUV6QlViSmQxcFZ5ZVI5Wjhrd3hDNSs0dThxUW9uQUlFVmh6VmFZMjJhMWZ5c1JpZHBFS1BZUENTeHp3eGVIQUdtdlVIZTNreVJxWEJvK0tWMk5ISVFXdWhrSjNtdjhNNVZDa3hVR2RUUjRhOENXbmtidmszeG41d09pSmVNbjc5TEQxTUNGcFdhMlBXZHVKWTV5WEVMWXVLbE42UFlXdHR4YmMxcFYwY1o0YmI2ZWg0S2VlNXJhR0o2UDBLV3dYV3ZBbkF3MlhZUng2TXd5Q1llV2VVcmRHVmpsWGIrMzZuem0zZjN6dTdlOTk4UGVhNENmNE9SMHMrUWtTaVhybDRNSTNEbE5wVkZaSzFTUzZDbWF5b2hNeFNwRC9WV0dpUkNPSVFma2tsMU5pSlZLY2Q0NHdsVGtoZ251SnE4QUpKZ0Q1M2VKcUdSRXNBU2FreXA0OFlvN2F3enV4Sng4aldhTENvc3ZENEZNclpjVkpjR0ZRVnB5OHBaWC92TmV2eW5lRk55QS9nL3ZrTmY2Nzl3bUQ1OERlRGZmTXYzODdPSno0YjM0aGNPUHhCM05nRFE0blMxMUVpT1BQYnkyRkNxL2lSeWsxTFdVYWdhN1ZFdHFnL2N6S2hxMElqdHB1dVJJdnpEU2V5ZkpxbXBCS05GUmQwU25vVExpa1VtU3ZZM0dqbkh2Nldia0JuOFcvVm93b1BrNFpXTktzbHFQc2hPcDRMYitFUFl0ZmxXMmVWMlZhZC9pNzZyZlJsQlZDQVppeHB6QW9GZWZJTWhLck1DNnlDSmR5a0M5RlF6bTc0TUJpN01Fakd1MG9rMGVCMzdLUnhWWFFOQnJHSFROVWtyRmRpdWhxOXNDLytNckxhd0Y4NEIvY3VGaHI5Q2laYWxBTzA0aDhsQXA4UHhNbmhrWTBkRjBlbG9OSkxpZityUHVGZzVVT0g5LzZwTDJuamlOcjZDSi9GRG1YczRtcU5QbHg2c01vUmcxWlhRN0c0WWMyckU4MEVjOVdZdnpsK0tITnFrOUxSaFp0eWRabWphcEh5VWVqaERiaFVtRGlkeXpCbEVGYUpDa3VhZmlXWEs5M3NjbkgyUXVwdjVuZ05MSEhZblhRamxQSitsSEtEQS9CWitxclNiN0hKdURPckZQRjlBVEFVQTRaRCs0Vy9wdjhwdXpoQUxmaWgxVXgwSzZrTjhTaEorTUFmc0xGVmVZY0xCWERpOFVzN0dFYkFNTkdCOWR2N0IybDEvRnVUdFI2Y085MjVNNVkvclc5bjM3cnAvYnVQbnp3eSsrOTk0Ty85WS9mL3ZnZkZmajI4K1V2Zi9sVkxQYjZyVys5L2M1dW1PZU5JODk3Ly83di85cnJMLzNuTDc5dzgrdFhmZE9tTThscHRVTDBqclVxRUVWS2dZWHdQdG15ckVhdDJzQmV6RXB3Q1NBZU9scWZocEdMb1FYUkJKaU9RTVJLejErOVpMRTZ2THBkN2ZnMVRUS1lTa2N3UEllRld4N2lMb0tYc2MxenRYWW5XRVU1R0hxb3Bkb2FCV0g0eUg5MU1ZYXAwa3hlNEkyQVZpQzJzQ21IdUgzZUt2ZjR1N3ZBTE53dDNzbjdGbllTYnl2bjVERnd4U2VNbE9odTJvRzl3akpwc1ZWTS9zWUErWWRyTFVkaG1UQUpqaW9vV0xXUU0rWHZyQWlWa3FKTDBsWXNsTUVJZDhNRzVUOUZ1L0VxeVFzNzBFL29yOTFMWm9tVE1tOFhXUUZqTld4YlYxWW1jZTFDcDFMQWh4VjBzSjNSV1ZwdGNTeTNHUXN0ZzJqRnJmR2oxSkpackV0TGpOYkdBTW9SUC9XVThGTTMzanRsNnE1ODVGQWp3OUlqbDJDb2pEMWJJSHltTE1qYy9WaXdKcTd1NVFTdFc1L2N5Z2xkOTNwNkZ0N0FUNk9DWnBTcDl5cWlRRVB6MGwyY2xJc1NMbTFUSGpERkU2NU03bmhGdmpRYzNDN3Z2WXREY2JpVW9Ya21yVStxRE53T0h3U3VkOHJFSmUrUkszQzQ5Z3c5SU1KMnI0SUtYUEZacGkxYmNKY1dUK1EvVnppOS9CTmZ2SGIvZCtCMFhETzBWZzlsc2ZpdUNWODBmeERhZ210MWdDL0hnaUVTK1BJdk41SVFQY1RqSjR5RHAyRXFmblViSHhxVytKd2hRQXBFRHloSXhHYzFIaWJqclVwNjFEbUNiRWxPbnQwTkdSbTVsSVl3eWY3RHgwZTMvdFlIbnp3OFdaNlZWUVQzUHZqZ2sxdFhyOTQ4dkhIanh2SHpxd3IrVU1yMWEyKzkrczBYcmwvL0t5OWN2M0p3S1VzamRQK3BQZGFPOFJkTE1TaldrRFlLTU9NL0tWakxWTVdpT0xuOHhKRmR3a0tJbHlKMmFzK21hRUs4aVZjaUozNUkwWUl2MmtUUVE2QUtiWWloc3B3bzFFVGdUN0V1K0VzSmozSVZac3lLazk4STJaeVk3MzNYZWErd2JFSWxiT0EybjVUUnZYQTNwRTlnYnJBS004KzcvcnR3d1ZjSm5nL2Z4Y01Ta21KV0lwSzdDSGpLWFN1RlVNVlNhTmN0dEdaTmxHSjU3cmhwR09UMGZPaXc0S3k1WEtnTk1HT29XM2N3V3FZVkowcXpXeGducnJLaEs1NTJIRFdWaVVMZWFHanNDbDFZdVMwYmZtMjhJTXhyTW1FcEZSVjl0MktBV1R5REZCaWM3cWQ0RkNqNldGODZzZ0MraWdUbk5VNTIwR0VpTW1MSWcvTmJaWkp1ZTRyY2JqL1k4Z0xYSW56d3ZKZitZeVcybU1zUFRxeGNNOTI2MjNoc3drUGpmaTlXOHExWU8rKy8vLzdlQng5K1dJcUxZOWtjNVN3dm43UldUdW53dzcxZCtNQVVSemtvUnNwMDkvdGI4QmthZ1dOSXdxU2l1THQwRStiZHBSeG9VbmlKNTdsOFNCNFRwNVphOG1wNWc0djBYT01ObnFrYjNoTlltTHJUOEt1ZnlQSDNQUHdCVzJQU0xuWDhOWlJrUXVNb0hqNW91SHdKQW80cXZuTTJwSFB3dG5xTEZvNGlWZVlERFVPVWE5TkdyNGluVExOS0E4N3c1emZLdEhDVGgvcE1sd1NMNE94cnNvRy9qUmtIcWRhWE5oTEpYeU5xek5zOFFqYzZaSjJ0ZVpYem1lenlTYUVIc1lCZmZQbVZEQkZjdlpJaG8vL2duL3ptNy94VnhkOTFsT3p6aWxYNFQ2eGN2L0xHRzYvZnZIajVMNzl3NCtxL2QvMnFmZDlocEFvWTRiZE5rR25aY2RRd0RhSGFIWEhYVWhHcVpLbkJVSFI5TFVSYVhiT3NJVXpYNFFubGpCa3NqSVEzVGhCZGswNmwzRm82a1hFMGExYlg3THNXVW11VkZsNnBwTXV6bFFsUE1sWW1IcHlTVmVDazRuWTRRUnpLUlV0TU1GbG1VU3p5UC9rRFpmM05CRUxYWnFZY2xLQ3V5VnliSG9zRnQxcmJDazJZdjhwQ3RBS0xNQ1cvQlRIRVYzbGkzckg0OW8zenNQcnlESDBXd0JwZmpJS0p0YUJWN1F4K2hJT1VDaytDeEkyQXg2cThZRzFpZUVHREVDNWhyQWJXcHpFbGVmbjQ0TGwrU0U1RlVPNVZDYnAyRmtkQ29CN3pGMXdwUjgrVWxJcHlMdS9zaTVROEZVSER4R0xWb0NZc0lSMXJEVjFzRGpEVVFPR3hqRHVwRWNGV3NWYlhsYklKclJPSCtrL3l3Z0Fua1lNcksyL3hSTVc0R0tYWVNjemc3L2xDRm50ZnVYd3RaVWxaZzVmMW4yUkw3OGhTbW5BNFYvQkxocDJjREZ4bmVSN2tDcFBYYkhmeTFaTXlESEdoMWgxWWFCNGtNMnpoSTRmbk0vNTZPYXNMenNVUzdsZUtkVmtOV2RoQkZoNnRzY0sxRXNiNXBTcnBmVmJzQjFtWGVTOEdRZ3poTTJRdEM5b2ZaOTJxdFpmV2Nhb25HalVWMlhtamR6SVVjRHRXcjNYQkRuYStIQ3RwcmROTnZUQnVtcmdkcm9qbFRmRWVaNnlZUXV2RUhzdWNURWVSRzNmdXlvVHdrSHp4bytSOWJZSGNSNHFDRUg2c0ZTZ1VtWXVTcCt3cEtrcUtMSzRlaUxxU3NNQUphU3FEWkNHY1dZb3hkYXVIcDBmRytPRXZYRnJPWWlCVlBNaE5oaXFlWlU0bXRXVVpYaW03ZGR4WnRWZlpNWkdwUjJITmJoQVAzMEs4Tk5oUGc5UGpESU1GdTVRaGZIbVFNMXFqQk5WVmxjUVl1QjdJT29TSGdrN3lGUFlSZWtUbVJua2JGMDhCcTNBcDhjYUx0V2VsMGVOY1Q4S2pSWi9FSy8yaXcvS1IyT01jazhpaTdUeEdaUEx5NGNXWEx1d2Z2L0hidi9PZURRYS9yL3VKbGV1WFg3ejVpemR1WFAwck4xKzRrdS9TcE5VSWhFNW1oUEQrK3YyYkNGdm9oYlJsbk04TFl5RGwwaXFaNTNIVGltdDFLRnFFeE9peEp1dlgrSmdWQjBiaVdzTFZTMFdQTjRLdDlON1dzNjZidUFnNmJ1Q3VQS0k0a3RjOHd5OGNhVlN3UHN2QmQ5eHVIR25CMFozWlZhd1RkKzdOSXkvdTYxb2hGQ2w0YTJKdjBRcWNXbTJwVkNjdGRPSzEvQ2tYeDMvQ3dFTkJydVU4dWFmQ0tSc09iY1dpTUhrTkR1Ty9CdnpGVC9TSjZ6SDVjcWh0VEIydWNoT2ZBSVpqRFpkT0pTME5DaVRlZ1RObG9TeVVTUnowMnFYVjRDaTgxa3RvT1YxbThmblpOREJwTlRqOFZFNThBV3Rob1M2ZGRsZlJSenpPc01oUkY5Yy95ZzZ6S085Y3V2ays3NTVDdFFjQXZyVytoMW1TQTNjTDhoK2s2MzgvQjR5Z1c0YzlrcE9HMVJLZXpqNHJZeW84NVVMSm1mUUNVK05pNHE0VFFNSEpRbmlLUk9Oczhvd0NmWmpsVjRZVjNuLy8zZVpGY2NvZkV6ckJsa0tCamNiS3QralU0dlJadVllT3kvZjBkK1FkaHppTklJZC9JOHNEajE4VkZZVlpneU5xTTgvQ0U5UUdZZUs2czByUldaeUJTVm16OVBtdkhvdDZ2V1NiWHkwcjhoTzZsSlpSbEJvNTQrenk3Nm9pL0lSajRMUjJKMiswdGt6dDdEWlVBRlp4Mk9SbzhnZkRSYzdRM0IydCthMnhZbVZaTkNnZkU0NjJrOTZHaFVCSTNDanc1RTlScndhSzNGN1l1MzN2d2IvKzdPSHQvL1hkVHg1OHI0bCt6RThnL0dUdTBxV0wzN2lhUXcrdXB6dGxOMDJHbDhQd0lCTWtDV0lMRjh2UW9MWDMxZTVGSU1KYzFnU2lUdUhrM1BnYlFid1AwUlpERjZINGMvd003cHRRR0dYTUQvUWxkdUF0K0tPQUNOQUlFUmdZdit0VytnVWJMb1NSRzd3bS9ieHI3ZUU0ZUk1Z1N3T1dTanh4ZDlNS0g3ZnlYQXptOTZuNHJMekFNYXVxTzltdVltQ1d2b25ieitSc2FlUXRQM0U0WlQ0cEQxNEVUdXZTVmlhV2FTY2JRekluUlpWZlNjZC9zQmxhU1dmZzM3MDc0dkxnMlpoY1oxUmpBYTJsYnZDZE5ucFRjRWszVkpZR25oU1d5c2dDSGtVd3VNSmR2bjJQaGFJOHlpc2U1U290MS9lYzBDUnVGV1lPNEZCbUtoOGR4R01CRHgwbW40R0J6cjU2OFNnV2tJOGpYbzBGZkNHN3NoNWtZOFBqZkx4UWR6bFJrcytxV0w3cDVzUi9ZNTIydVpiM3lhdU5TL0txcFIvSnkxTnBDY2R6amhXTThqQjUxYktIOXBRaVhPQjFNMnZDdXpzdFh5VzFCbFFQSW9nM0Q4Y2Fmbkxtb3lveDNYL2w2VEkwL0tPUVdIeEJrTUlkUG9Hclp6SzBsTWZXRGxheHBFYmxQWVdDZDM1OURsMWM5TlVqa3Q3N3lDRGx5SzNHTjJVTERsenpTLzVEVytsSE9aMElUK0oxbUNBd2hSK0Zwc3BxbkhVTjl5VFAwTWZrdDhsQ2hrUlhoMFNMcEhDVnEyQmZPbWM2S3Q4eGlQRVFpeDNQMEZ4dmc2VEJGWHd5c092Z0tteHdGRFlXT25rVWZpN0RtTGE5aW5kR3J6Ri9UN0l0RGkrazY5aDdFTlNqc2JQUW5NNmQrNW53akx4Y3lmaDhldXlITDcvd3duKzA5L2FIdjc2YjkyYzlUNjM0ckxBZjh2dnFTeTlkdlhMdDhEKzVmdjNLejkyOGtlMWtXZHRxaU5sWExxbFo0NjI2M3lvZlpqanhwNFUxM3JFcFBWMTFZUzFjbU9vWlF4WE04NWwweDVhZ25ESzhpR3pEQlEvU0xSQzN4NVVsdlpiSlFtRFdnSStTR2VOZFJFcGxHTGdJS1c2djFlSlZPS1ROTldIeUtaekVIeWExSE1GcjhQUGVlTXE4Q1pIN1BBZFkwMDY2S2VkdUh0S2Z2aE44QXJQZ0VsU3dDRTdIQ3JlSkIzREFORGJrTGoyRjRsS0dDYStnRjJUSzdDL3gySE90NHBHd0RrdWd3OFRaN25BUWw4NVZDV2tMeis1Z0o5UGVXODkxUytLU2F5di9HbGRML1BpeFpGM2N5aU5DSGFVNk05Y1ZjUFJpR1ZHMmFCaWc4blR2VUVBRWU4cGxlSUYxMlN1MDBQakJCMjB1WjMyMVo3VFRkVForS3IwU0dGb3didWZ6TEpleWc1QS9DMmsvOHFlY1YrTG5EQUE0R2tzRko5MitXRWF4Y25PaG5ZbXF1L2xraXkyWUZCb3k3Q2N2eTRwcWtTYVB3eWdMWFgxd3JERzFPRjFFeW9sRlZLc0lqdExrOGdYVENGTzcyNzV3YW5qRmlnRksxQzRpWTdtR0YxektZSWtYV3VnUit0cHFyYkdVc0FvemVlSjNsWno4UXZmVlMxdktjOG5rVlBIbEo4SElsa2JIODlRRmRPa3hqUXJxaXF0MUdiamlnRTlaY1pXVmNtM2taZmxaMmtkcEN6ZFU0Z0l6cjNVWFVxYm1GNDhhUXZSQkJNMnFBWkUwNkRxUDFxTXpEdkRNRWpuR2hoNEFaUWUxYmhUUkNDYWRIaXk1WUZuV3FBTWpmdTI1eHZLc2pNZzlDUzNQbzZNU1hMcXBKVEpzYlVsZVZycTA5eGcrRjgvazBiQTArcVQ2WW1RazRmL3UyU2NQdnZPOUQrOSthdlZBQzdqek01VGY4ZnJSajIrOGV1M2ZpRDc5cjY5bHJQVmFEbUNvY28xQzY4UUlCS01mcG9zMkZxdmxUbXRMbkVyQUNscUtWNEU1aW1LVUt6L0tkYm5GRFFQVEsrNTY3NEIyaWl0NWlSK0dVN0NxdTNqZEV4NGhKQVNQY29HUGFSV09FRSs2Q2tiUzhQTzg2M1R4cEJsbENtYnhTanh4S1lkZFpUb3dKaDdsTHIyTEh5ZmQ1T2w5cGZFVXQya2dhSWhqMDRROFdHOWpjWW5XOHFTN1NibEtYeVdWZU5MSUN3MG56K0xieGlpS0xVSTNlVk9zenR0VjR1SjJnbU82ZytnQmlZVnlsTWoyQUs4K2hqY0p0MlJLK25EdVJEbnFEQmlQbTN5RUxuWEpmelZDRkFUbFlULzgwR3hvS1IzblRnbE91ZEVaSFZ6U3UxUWk2U2xUWTlERzYxVlNud1h4ZlNnd3V3d25aYU00eEhPTkVsbmQ3S1dJRkV0Y2s1d1Vxbnd1eDVxRkE1Z1BNaVpxS01Ca2lKclY4ZlNXSHI2aFJlaFp5NVBjazV2RWU1eTcwSTR2aDRhR0NGaHZhS3VCQ1pNU25yVDVPNDcvNDU2MXNCVHNZY2FQcTNBQ1E4T21MT2dJWjBNWE5BSWFVTEI2TmQwUkZsb2tVZW9laGI4YVlIUkVPL0VvcHE3bFRON3VHcHhMVWRndVF3QVV5Wko1MUZnTk5uOWp6U3g0YVNoNVlXVERPT3lKR3htSi8vRGVQbjFLcUkxSjZPcVpiT2xSbEM0QlFsWkt0NlJuSktscjBWMmhiMzdDQjJYY3o2RkE1OElQWHlzb0xtQkVkc2F5SHBraDg2UHd5UVZsTG94aU5aUkFPUnRpd2RzRWRId2VuVnBmZzVzaGc2NVhUanh4cFBWK2xMa0RtMmc2OFJzYXdONUUvZFdjcTVFb21jaDgrTlA3angvK24rL2Rmdmp1Q1QyZWUxZzIvM09lbi9YS2FqMDhlL2FiZUluQTlwU0hiSzA4S3AreHJDNFVEZ0xXb2JXQ2g3UmFJYk52WTgybVdBMURGQVZwSVlkSmdkaDBzTitlVCs1YkhBZGw1RU04YmFGTVBvRnYxdFlBTnNXTDBLNVIyUElBeloyYmUxL3lNL21QWWpLK3R1dkVKNmlGc3owTGwyN3Vua2NaUjhSUDhoZ2xNdmVWOTBvM2FRc2tQNU9IYm9ybnJuOE01b1FVN0s0VlRBWHpETjdFSDZVS1RuRWtwWEc2L1djOXQ5aWhBVUl0RWpUYzQyQ3lVbXpwNDErTFZmU1VWMWp2Mjd0MHFUL3hENmJCZy9XNjRzUS9BQ25UeG9kam51RkpTVmh4NEZuM2NIaGM1WkY0YVA4a00wRHUzWFJBY1ZBc0NSdWxtR3lUVHlhd3NscEFlcGFyT2crbU9CUXlKUXFic3hhTlJ4N081UkFQbHc5WHRvZWpZVWhscGZEdTVjTjRNVm1iajBOcXdLZ01wSUNMdGdHZThyT0d2RWVBbSsveDJYWDJRVmNEUk40b1oyRzFWQk92RXpXeFFDNXU2ZkRyY2NZS0g0UTJ3dTdsUE5ITE1VemdhNElMclUyNmRzZ201YkllMUdZTENvYXl2dnR4VHZtS05iaHd5bEt0ckU2QUswV0FScE9PY3Uxa1RmQmYxdU5HNzB3eXIwWnBEVXN3YnNBYW1SMjVIWjZaM0VSM255eHZucUU3dW9pbnpNK2VManJ4STBEZ29CUG5XVzh4eWZzTURqeTlPd3lwaWhHOTR2Qk9PUXp4UGM0UWlXNi8rTDA2bHE0bm1ranhNNW45TUdQVHk0cGVxeTVxWFNZTnZGWVoxTHVraC9jbU8zQlVCcjBCVHY0bXMyVk9ZUXNQaWRzclNNVEtqVSs3cjZHdnh6azU2MzUxeWJrTVM1elBJVERHZS9IbmVtUXdCMVY5N2QwZmZQUm4zN3E1OTg2UE92djFENnhjcjE0LytJWExsNjc4aWlFbGU4blhRdkVRSmExSitKWFdkU2xYTzBnZ3pjOEF5WnIxUDIzdE1HQXVCUzV6UHVPKzhVdVVGUjh6NDg1a1pjSTRhUWtVUXRzRlJxbWFJUjJDRTVpNUdqY3dLcENiLy9qQmR6Rm81VEh3M1NjOUptRThKMzdMbUx3NWNPYnFiUDhHWC94SjM0ajVHUmkxVUxiMC9Eb21oY0haMnp4eEtveEpzNHZiaE1tZkV5YnY1L05KVGh0T3dTSGhUNjFHME1obHhVQUNtbGFhRGhta1dCU1hxNVcxK01jdjk2NG9FQlplY283b1l3RVg1MVRFcElodjdvSE5iNVFpZWhrT2NLZFlWWERQTVdGS08zbXJYUHlVUVZwbG9pQlZTUEhCY2swWlBWY3BiZms0NUZyY3RVbGlXZkhnU09zT2x1ZmhNNyt6V1ZWeDVsRXNJRG94bG8ybGQrZk14QWVPc1ZYeFdiRm83NWpCZzBPV3BvcTVHdXg4clNWZk9jMDRZbnlsZjVhS3o2aXdNcUpESFBwUXFmUWFHc01GMFZMRm41OVRxcDdGOG5nWTFyR0Y0Tzd6MEErVC9pZ3JEQjdtKzJCbnN4U29uNHdHUDRvSEhtTnRLOGR4NUIvTjRDbjkwQkE5T1pibXhVMDVpOC82TkxUQ05EeEtQdEhqbllIM3BWdXVYMWVJUWhwNU1nYTZWbXNzaTFVNWFyS0ZkbWVpNUUySXdhbXlHWGpOTjNGTzZrTm80N013NVYyTzJFcXkwSmhGclNHMm50am5jbUlSQmgrckVueGx3bW9QWDIxR0l3N2U0S2NxMU9JRnV6MlUzQTh5bk1PQW1Ub2hMaHhpR0lmeWVtQkxOdFdPeWxZVUViNktNdzJMWjJIS1ZrTXNvN3VUcDhuWnlnQTVpSnhZUnZyWUYzckR5b1BMa2RlVTRrcTJpSDhoaDd0ODhJWGIvOVdkQnc5L2ZlL2p2VjhyNHMvOS9JR1ZhL1pSZjhQdWgvTVhWYURWNHBhd0FhandMV3lJUFJXQjhLbVA0c3lsQ2lkMkN6SjRLSlRyZWZlai9Bd1RkTHcxZWVaL3M0eFByV0hFR3BpMVZnaEZjT0RncVlLTm0zaHdIbWFwVU9NdjNxUWRQMHcvRWFTRWd5Zk93TlZxVG5rbjdXNStwMzRMcHdscnhRL0Q5N2VkVGZMYnpjczdnUWh5VFFKZmp2L2tEMGJxeG5vWFRSYWgxM3pkZ2VKY2sxTUwzK2FwdFE5WWdzOE43b1QxOURseGhteVJTT2xXbXFUYVlaMzRLcFZ3RmloOHgyTGwzN0hZTk1ad2I1d0lNUDlXVktpR1B5elN4azFhNmNYakR6YWhuekR2ckJES1pRNTFiZ0h5dzA4NDVlcE9KdHlMTjZzb2NtenJnSHdMTHdwMzN6SzJKL3Q3TDcvMGF2VGgvdDZ0NEdWZHFYS3ZTZGdsMnozcG42SWxTMUVPWFQ1RUtZUzJPZ2UydFNxZlJwNkQ4OGdPUEhUckhpYXU4VVBqdGI1bXk4TFhRems2U2g1UjJKUXdmblM5Y21BN1RBVXQ0SG9oaWhNY3k3aXNWTmdkbDFkR0NuZUdWWGJMYlhJT1h1Snc3a05mZEZpVGRrY1p4MTZmcXhHSFA3elFuOU9kSDlwNkQwUzN5cGc0aFY5ZXJVYXh0S3RBTHY2Vi9vSEJBdGFUUFIvci9YeG9mZmF4WFcvSks0cXdQZHhZdHcvei9qUkM1Z3NRQm1EQjM2MFQ4cHJ5d0dua29zTThXem5GRjBjWmhNdmZzcXpwWlJTZlRiNGNOQ1B0ZnJieWMrS2o1WDVvL1NCMGZwYXZ6aDc3M0UwYURsdkFyMmRTM3dIYjE5Lzc4TSs4ZGZQbWIzeVc5Zm9IVnE2eHJLNW1CSFB2ZXNaQ3JsL0xNcXhyT1JBNDNTM2JYZWU3UUYxYnVCRUI0aVZXQ3ZjMHl4dGM4ZWhNSVIyYngveWtOV2xSNGxGcktJUlBIdGFza29GT2prbVBZU0UweXlEVnBETjczV01kR01aVU5GdVBBdjl1UG5saDZRU21zZ1FKRUlFblRqNjZCcWZDQWp5TzhMUkZoRmZnRU1vMG9zRnRhUXp4UnhpSFVSVzRMYnp3OHp4eCtoNUdRcDVpYitYWThtcStNazBHTTBRaWZzZVV3a2pheXRka095RUJQcVU0K2Fob3FZQXIrV3o3V3pqV016VGp4TmY0Nks0amdxeFhTUlBJQ2tMSGVDWWtscFBuOURwWXNsSG9HTkwxcmdtZmNVMDByQ1VRRWpjZGVnY1A0MmVka0FLOUZuR0xYQnh5SEdjRWsvVzRGR09BaDZmK3NEc1dZOFlZMGZwU0pnYU1rNEpyUWdsK2VrRUhzUndxVCtRZytaZ2t0WVdVRWlQcytHbElDZzBOTnhtQ1NwVVBuZ2VSSmQzTWROdURJeVYzS1RQdStIVW0xcU04dWYxOEZQQTR3MHFQSFkrWXJoN2xkRFpqbmVUd2JMNmw5SWpsbDNUMzB4Mi9FelB2eXJVYlZaRG5NNmxGQWRYa1RXVy84d0FPV1hhVU1ySFVOQ2F0d0NIQW1jQ0gyNlBnK2ZoaCtCVU1EOU8xZE5ETDBkTllxRkc4aHJMd2VpbGpTaVdFaTZYM05ESXN4UVBqaGVWamFKZTRUOEtMZ3d3bm5FOGE1KzN1eDlxdVFvazFpVy9kMEJHYUhCeGJXbVlqem1yb3JBNXdNRFRhNzBlK005YXdGRldzU2IxQW5JbEVkaGpwUEt1NS9JOGNSbzRwWjJQSnpTZjBvNVNZVEt6dUNIZlNzRzQwdG03aFIyYlpINS9KOHJQRVVZL1FYTDBMd2NNbkNpcngwRG04ZkpLaGdJZHBwRXhrV1Jsd0ZDVmNFaVRoUVhTTVUrN3VwQUU1Q2gzU1k0NTZ5RWNVTThsMzUzYVdZd1V1UEgzYXg2b0tzbFpsVzZ1WjliNHMrMmRSdWcrek1rUWRoekk1U3I4cmo5azFtcmhnZEN3NHROV3oweEErdGoxV3NmWWRvcDNQK1dRTjdLTW9mMlBjUjhFNVVjTHJOTnpKKzR1dnZKU1RzeDc5RjdmdVB2bTFmSXJpMThqWHJ2c0RLZGV2di9IYU40eVpNT25QbjE5bldySlkycHBvM1Z5SVcwSXZCVGJLYUZvWTcrdGE2WW9FYW05T1FibFJhT0p5OVdkR3hmRmI0NnRyUlFDRkpIenljQTlkVDJBTUxIRW1mM0htMlgwWWRScTNXWjNrTjIrVFJ2eDVCdmMwM2NwRC9PS2N1M2pqZHYwbWpmdU1ENGxadUZVYUVmelRwQU9pOTRIektjOHRMVC9XQmJkd3pOMExZQnN1b3l4WlN5YTdVa1hFQ003Sk0vY3FpTUE0R2FaSUhOMDZ2Y2lsSXZGWnd4bVBMUzg0ZVZTZUtadHc4ckZnbXpsZWxicGQ3U2pKNmY3em56aVRYdHFCQS9aK0ZBanJST05uYVJTNExqUHpoRjZGRnorWXRXRjI2TFh1THN0V0phOUNTT1hrak5sclZPQUJoZ28xMXBoOHJTNHdac3V4VXNjU3hIZHhIOXk1bGZXdjdON1FJNU9MR2tIVjFjYUpXcW5XR1VVdTg5TXd3d0FVRkxsVHlSc24rU2lYL0tmOC9GM0hGeFkvMWd5N3loODRjU2xLNHE4ekV2RElPS0w0Y0FRTDdub2xWaDkwaDFpZTl3MUpKQTJEdzBTeGNocVBoUXNuVGVtYlBNRGtodTRKYXQyWWNmUHlKdUhpVHgyZ1lBT2tzdUVIdk9pZDNvdlBsbzhTU0RkNWdlWDdXdDdSaW5JOWZwUlllZStLam9hZDlrRGxaOFdIdzlrZnNlNHowWVNXY0hZWitwQWZlcUk3K0dqRDRYL3gyaHEvUndaWmg2YUpYMk1oOEE5NnpzT1NJYkNIUm1qRzJaUmh2UHM0RFVJeURLcHBoQ01IbFB1bEt3ZGZTNVJmYThTZG56K1FjZzBsWHMrczJpOW1lcUVuMSt2cUlZeGo2YlJ1ejNLRlRNU3BCWnVDRG9FaE9zaXlyTXpHY2RyQjNoRTVyZ3hvd1RjTGpsOWFsVGFRU1dLZEcyRnNpNG93RzFINXVhUWZJU2tzaWlGK0xtN3dFSGNSZkUyR1RCck1tYmlMVVlzeDBvcnZ3cmg1SDlpVFJ2aTQ1OFBHUHhtYzRFUm9sSTlqeFRTUFRTQjNsU3VMNGNlNTNYeFJkYm1vbWdnV2E2RDBpMmNuS3pZckZINTBBTXZMTUhieFRSemRWZG5CVGNWYWlsVUV0QW1zK0tGQkZYUFQ2MjZ0Um9ZaUVEWmxCMlAzSFY0VTVIUmxoZU1scHpJUVpHRm9UMUV5VTQyanpjcUZaYlUyWk1HTllpay9CTENtQTg5dUxJcW5sU0lJbStUa2o4N2dkcTFrRk94aDRwTURmaVpWNUsrU3loLyt5YlV3RHJzVUtnb2dGZTZ4OGRXRU9ZK2dSeHRHbHUxSWU1WlRuVkxxS0dWMFN0b29HclRBdzBobXJhK2pmS3JiR1BINUMzYWNVV3A0SGxuTzF3M3dUNTdrOEVJYUFjcXhHeE9DczZWYnJDcHhobDdLM01aeFV5NFVyREQrbjJRcnJyWFFVZnM5WWQ4Um5FM0xaa3NjUzc2T2s1ZHlCd1dDSFZqQmZWTkdnMHU4Rjh4b1MzakJMNG1hYndxNXZRZnZnTkR3cGpETlp6OXc4TlJLQ0EzRWNpSXNHZE9vZ2ZVMFBhYUFLOThPN0xJTFB4NnIzL0Z6MXJERDJkT1p6emd4ZzBsakdFVWErV0FJbzQrUEduWXlUSDFKdWR2ckM5ZnNLalJPZWliNSt6S3ZMMFNjU2RyaFBSMEFIa0JuV1BGQkRkMWNlcHZQTWdRanp0SVJxK3hPN1RvNjh2bnpUSEtsd09melJRTzlISENjL1hyMStwVnZmUG1WVjE1OSs3MVBmNUw3RDZSY1k1WGVocHhXdk4wZnJRUEpRZEJ0QWl2a1NsMVlsYXlNdzR6TllkaGNuZVVMRVJCNEo4cGlWdUtySjVaS05EekNaWXNkZDVSOHRCN3JtTGlsQkJHRUpUc3R0UXFsd0pPWDdtMkZJdW1yMUZNR3VISFNpdXNTWjlMQXovUEVtL1JObEo5NWYvNHVmTmV2ek5vcElKaDEvSEx0aGpmdjBLUjVUcnlUNktkMEJOOGZkd0l2ejVNdnYzYnQwUmZkOENnS0FWL29jSG1LVTBYUUNvNEdFYUJvV1YwcHFKMjQ4T0JwRmxlZmExOXQ4WU9TUDU5S0lEK0taSTJyUnRHV2psdVpraC80d3ZDajFsWHk1ZVJOZVpFampyQVM0bGFjVkFEK3RjUmlHVnQ5MGpXTnViZFJUTVZ6WDJVTURsV3NhMm1PaVorTHNjaWtIMXFBYWN4MFpORzlGa21HQStBa25DTTc4R2laVW80UUpESmxLQ0diRERJa2NQM21qY2g0WnUzVEpmWGRKempZUVhVeGxjdUVUSkRNRUVQRzQ5TE5sSWUxMW11alJ1NTRlRFlOZVpTanhtbHR1bGg4R0R5SEJuQ0IwOFUwRExXMjhtNnBWNWdXL2tTNTVSSGVqMVBKSTgzbG04bW5KeW0zZEdQSmdnTTJPc0hWczAwR0p1bE1SSHNuQjF6bHJVL3JaOUo1ODl6NmtUb0VQbmd1YVRXd25xdVpjbGRlaGVVWHR0Y1ozN2NzYmZFczliVWFlSlZSdkZBanZOZGREN3pRVWRsWWhkYit5dU5DNU1ScWdXZmhvWlZBTmxobzBCOGFrMDVENXh0YjZBQzNLZE9GS09Uak5HTDRmdS9lZy9hTzFwS3pLT2xzUVQ2U2J1T1QvT2dFdHFweWhtMmxoMG12TmxZYXRjaUZOYlFQTTh4eUo1dEM4TXJYaEIrUmNkdWFvL3dOVVIwZVhQaUxMN3h3N1cvc1hkNzdqYmZmUGxXd3Y2OXlkVzVycVVXQTdWOFBFdmFkKzliVGNlNEtWc0VSeVdQK2hubUkyUEFFbGFDRUwzNys2c1NYZnNlVjRRWTdVdHJGeE5VU1lkSXkxeGRNRlJvVUJaN0tZUTFmQlJ6emtsZXhDWHg1anBQZlZLN0JFMnp4WGQyVHZLVVhWeHozNS9IOFVlOFRWenBYeTZ2TTJ6VjRlRis0YnJRSkdmanRVdVA1UENidDgvZUoxL1RrSEw1SXlHb0pRQTJoR2VCVldkVFhWUzVkT0FKcjNHbFdCU3ljZ2xzc0M5OXpPczVCTUdpZG9qUU9YbmVpa0FxVlBtRTlQU3YzcU9jSTl4b3JKUFNVcXdzZGhyNXc0SWJtY0cyakhXRVhSdG54WTdGYUkrMVpHWlJObXZxSFQyZXl6ZlRjWmlsYXRONHgyVml0Sm03a0I5YVpXQnlwS2luL0dzOW1lWUxqcTdXc3BmUG5JaU9STlFwK0hYNGRxelZwZlNkTHIranl0WHo3S3dyMlNaVG53ZDJzcTdYVk5VVHJhV0laNSt0NUdta25MaDVmUEZHd3hvQ1ZsUzRKOTBPUnlIeDZlSndKTE9OK2p4OHZtVVJUdzJsVzNzQ0xzbmdTdUt6c1E1WlJ4bkxKc0xwZzdTbkxXbStEOVdsY0hXMG9PUExmK3JFZkJaUzQ0aW0zUm9LMnMwMFlQK0JWaFFnWitTVnQvYnpId1VCZXU2NTV4S044RUp4OE56MFp6OUFUekpSaDZqUTh4RkhId3JIV1dmU0ZOeHlDVUM0OFdqS3B4MVorbVk3SDNkSkRmbnFWV1EwUmVPcGs1U2VvOWV5RitKbVlJaXVVNGIwc2RZT2ZzZGVvN0k2TmkwOHhxZ2lzWmR0cVhSUXZITS81RkhwMEdyb2ZSaDZLYjNtUUlaNk1qNXYzVVdlT2p4MDBVOG9zV1k0d1dqcjJKQitTUE1wWXpRTjVweXdaaVhwMWI4MWhwaHpML2I3SzljckJsVzlrbFAxdlE1N0ExbG9Kd2dRSEx1MXFocGdqSEl0NEEvNzBMdnprU3RwaG1oaTd6NFVUSWc2TGpTTWhWSmRyUkZnTWRJdVBJYnRuVkJhM0VKd0NIcGp3RytFNW5hVFpsRXpLSWkrRXh2eUo1ejU0RGw1ejV5OWMzcnRPK0dkZEEwZWFnVHZsa3I3d1Fndk9tTnJBOEQ3eEptOSs0NlFqb01MZ2dnZjhHamV5VHJGU21vQ28zTXBPQWFxUWhBajI1VnNqckxUR0JYVm5WMzRSK0tLVnRJME5Sc2EyOG1aeVJmYnRwVlFBVHl1Y3lvUVBjOEVOWG1qczdobzZ1SFBpanZXQkQxeGlONTVlQkVWek51bXNuK3hrWHlyLzlGUXVYOGxaQThaSVV3a3BhTERXZHN0RlU3RGdNSGxVd1FTMmRhTXNQVGpVVW5teXhsWjlIK3g4dXZ3T0J5ay9Vcm1vRFVvNWdKSW1zL3M1VDZNS1NnOG5kTGZwNC96aFNtL0psQzRrdUJxdUpJbkZGS3FKbDNkVysrSFp3MVorQ2hGZThKdUtEVDhUUUhvVHhwblJ5MTczSXBPeTZBWm54M25oaW5NUVpTSWV0eVpKWXdBZDVnTjdnYU43SGFJbGN1cXMxVDNKdjh2SjRpOVBibmp4S1JsTFViMjdobWZ1M1BpUnFzWUowQTVuTlhUOXRPeGJ1WW9IdmhYZVNsK2U1dDM2WVEwR3ZqNEpQdXVvMFlVVEdIQzhISHFkejFqb285RFVLb29JUnF6S3BRalI3dUJnRGFtUU93NGQ3OXo5cUxqWlBNSFp0aXc5MS9IK3JIWXlxVGRHbWNtL0I0Rkp3U29USThQUTFWYmt3TFN4Wk0wekhXUzF3Q2NmZnRBUFVUb282RUZhVXZwRzQ1ajY4OG11MWRyOG11dVArVGwvY1Babkg5MVRZeEVFRXJGZVl5bEFKRmoyM3JHS3pySkZpRFpZR0tKU0lkUXVFeVdUc3N6SmkrZGRoMWxoYTcxVU1xMUdkMlVGem1MeVNsR2xxR1dLdzBUOTN0MUt6Rjk4ZVEvUnBxSk5tUGk3T1BKZjVWcDM4VjM4UnNERTRRYi8zV2R4dWNsM3QreVR2bVhmWURieUZqOEErL3A4WHBOT1lKK2ZJOWpDWStFanZOMmMvQmIzVkdxTkhiUldGMTdqcUZGSmR6RXRNR1ZaUlVFNVoyQjJQeHFsQjJPVXJPaVd0QWtEcTRvVi9BaWZpM0RQK2xLVzNGTHc2YzVsSWdrL2Fsa2xQbVhNd2RPd1FtRnRsVzlvUDJWRXI3T1JyekJ0eVUzNGI3eVZUSXdNamRLaExWakZGM055RllWVUdVdyt1bnFzbjJVRnlSY3RLSEFUUnBzeXpYdEE5aExPMGh2TFVPL0hNWUx3cFdCVlF0M0NVS1A1WFQ3Y3h1L1N2VFRXV3FzNllZWVJ5UDYraWJQZzBCVVQ4VmpmbFl1VkZNT0FaWVV1NklZdkdnUVhWOTRsN0hGTzBxSWtETHM4eU9xRVo3Rnk5N05jeWNmOEtPLzdSemx3T3hhYlNxMWg4WGx2OFVFRW8rT3RHLzJRQWMwcjUzbnV2UmIvVWlUZU9mekNGMldPbXVnZHZOTGdwUDZzOFBLby9GNTFWNXhFN09XNXRYY2pybmM4TWxReUNsQit4V3Nib2tnYkZUZXlackl0S3dTc0tFblpMd1l2MjFWVmI2c0xEQnZzeHdvTktWcmY3ZUNTdFViNTVERHVMRlc3RU04bG4yc1ozTUk1Y0VLbmF4a3Z0ZXJES1dURk4zeEJCNk1NUHFSSjV6aG1zQTE5ZWpWdHRKTk9KMGZ2U0owUTVtemZoMUd1ckdxeUwrWHpialY3ei90dTcxLzd5bHZmakFYMCtyMEkyTVV3V0Rlb1hhRUs1NUxPVmd4alNxMlFLMkdaSEthVW1VRmM0VDdMbFRFWXNlUHFsM2VDTFYzSGFITUhVNWcvejFwcVM3WDRFUTVFVWVqaWsvVHVRTSs3TEtaaXcwdGNkM21JQTQ2N09QUGUvT1M1aGUzQ21qQndQUS9zZ2JkYjlsMTRqYitsV1hBWGJWQkJ2S0hHYmw3U0RJeldJaDV4Z3dObHh6WE5ScE1VSXhWcktYdDFlZkNqV01lbEtxNDR1dnFVVUM0VzcxcENGaVVBaURpRFZPSXRvV1VOTFF2Q2x0YWxMSkovYU5rbFdsR2VxMndyb2VkSmgxZVVBVGZkV2VIODNkSFAxYVZLNEFYV2JobzlHV05pVmF5eGJOd1RyV1dYTG9WWTFsU3NQRlpwdUxzVVlHakFDcmI5Rjh4ZGh6WkRIemdVMzFSaXhvUVpkL216WnM0a3Y2ZjVNS1B5K2dTMWN6TDZtZkRJVXJ2R3NmNFA4bWxtWTJhT1ZiUTkzTEt5KzhuUE9zNU9ZRDFlUm9BOHdHUVZlUjVaM04rVUs3OThVS1pvc3RiZ0lJNWxYTXA1SnN2WHpGNWZlWmp6Rkp5MHRjbnRzcVNVT3pLWk1qZ281UXlyTDBvQnpEUEdzOTIzUE4wNU5LbGZ5dFR3K243NmgvOWE4M3ZLMStZYkFRbGI2bXpLbUxLUTFmSTFQT255dWVCdmlHYTJpRGMvZFRFeTJYa0JmQWwreW5VL1N1OUN5bmcyeWhKYktWZUhxNXpKbUd6NXQ4bWlJWTlWZGpSOHNuZnQrdFdUdXRKekhvS1ZvU0p1ZU95K24yRWhpaE4rckZldWNoZis2aGtaWTRlTDh5b1llSllMVmlrSEdRb1ZuWU5LWlEwK1dZNTNvMEIyZm42c2NyMTQ2Y0kzYjMzMC9pODlPcnEzOThvYnIyWmJYcFpFSEdUTUlUT2t1a29Sblk2NVBVckI5NTZ5Wk5LQ3BoeUlLM1BDN1NMVXM1QjlEVmlIaUpoTDhNT1ZZYVowZW1DdHpVQ0dxT0RZSXl5TWU1b0Nsd2lyMzZZdUZVNGpneVd2M0RHYlZkRUl5WXUvU3FsQ1U2enVGZEtFSVE2Q2MrZTJKVHQ5K1l5ZlNRTm5hZHpIZ1R2aEEzTUVyWXBQeE5JaU9HdStGOCtMYndxMmFMRjFaOURuSkVJRXFXWGlFenJJMDJ3eHEvSnM0TENaS0ZncHVyNDNkOFdwbFprNHBXOEUySFpLbGhPSFQxRkRBTWJhTXFrVml5a0FYSFpodFd6bEQ4V2JzTkJPdDBweVphTlU3UVlxM29IRWp3V29pOHlwM2xhRlJGMVhFWjlOOTRvaTdQNXgrY1pWU1NsSGNlV2pCTXF4eXFMOFRxK3lNMFpGb0hEUGJzckhOK2dwSjNpaWpUM2k2RC9LNm5abXpWVVNjUTd6M1M1Sy8zeG1kbk1ycnNNUGNDbDdGMWkzTWlaM056S25PMm9tK0lJdmhFWmhFQ2JqZFdlZVd1S0ZWK2dmNytZZm51Z3RaSXowYVNaVXdLWk1iVXFJaE96bHRLTlZnWlB1UXI2U3ZKKzVDM0tTYmtTdHVoNU9FaHFURlR2STBGSlpyT084a0ZPY0tKRFNGM2tlNVJEbktKOEhVUWdtZGU3ZmYxaTZUaG5PR0RlSVV4ZkRycmcwa2tHL1BRdis0WU02QlVmbG5ZWk8zcFhsTk00ejF0MVZLaW1rdU1MVndCai9yY3Z3bjhsZjZVS094dEZzd3BVbFg3bUxvSW43N0Vrcy92M2txd0hQQUtXTkJKWEh5bFNvRjhWSWxnNnppQitmYmFSNGhCNnhWdTlsdmV2ZEhLS2pkM0x6K2l0N3Q2TG8wSWVCeFhwblVhclBucFZYejhVMjl2MnNyY1ZmaDhYQW41Rnc1OWJIeFcveGUvVWU0QW1lY2VCelNldHpPNWJ4R2N0M1dNNUhPUVQ5M1hmZjNidVJ0ZjJXM2p4OWx0VWNPZS8xemlkM01xa1Z1VW0rRncrdWZPWE5OOTg4L081M3Y3dGF4R0R5WTVYcjhkSFJQOU5hWE0xeUZBdStJUS9KTWlhSVZ0MkZJQncvczRiZVBDT295dVdaS3dQRVNVSEdDWHYrU2dtM09KU0FIQlp6Vjd3bGdKTW1RWFZnRWhUT29EWEhEM0g0ZXc0NkphQXh1UXAyNGt6WUxrNU4vR04rS2ppQk4ybmcwcklTb0sxOHdsemV1WG52ODRabkE3YWZnZVUrdUlXS0s0OG91aEsxY0tKc1VsTW94dUllWVdCdEpsbEpJZjJpQXNDSmhCK0pFekhmY0ZpOG1meTI3SHNqZUp5R0UyemxYTjE0aWplS2FWTkF1cnNUbHl4QVJ2eE9zc1FLNkxxdlFscVlMUHdXbzVUdG1lNWR6aEVZSGtwYlBGZi9NR3AzVldUaGxIRXJCKzBRQngrblZsVUdJeHR0d0V1YzRCUTRjRnlXK2FyWUdocCtkbHloVE9takVRb2MxL0NMOWFLOFhNc1V1ZzBOaExWcm5VcktQZHRQNDV3aEFXT0E1Vlh3ckJMSzNmdDZYanpQUy9PdHpBUVB6cmVod0p5OGg5OTR4Ti9aQitLN2REYUZzNkRINzF6cUlacGNpcHpERmIzQUVzOFNwTU1PeTZ5SlJLZnBheEFOd3JPK0pxOHBmMmtmbko3M24vQzVGL0g4eUtkeU5XbjZ2c3FxZ1JEL2JKVFB4RnZwbDZ5V25wbTBtdTNYd2tCejU2WU1qWmQzeTRWdGVuRkFPVHZLT3RkenNXSVBNdGxFNVdoZ25xVHh2Si9MTGlvS1dVLzJ3NDgvV0hSTUhEUXpia3VPeUlFSlJlUGUzdVZESVhNalozRDQvcnQzQStOV2VQeG83NFVYWG9qZXk0bHFGN01hSkkzcmh4OTlrZ1kwTWhKTFdLUDI4YTBvMTFqaWg3bXlwTzdkWGNVSzdvOVVybC8vK2EvOFFnWjhyc3I0bFpleUpDWEhzMEhPUjcwVzhaWndsakZLRytIZ2hHRjZyeWpYUmVDRWljSnA3amZDZWlVY0hWTkx1bzYzSm95bFVHSUxENEZyNVZWdG5BcEljVWpjWVdBU25EQ0tIOEl1UzJ0MXd4Q3kxbXBhVE9HSTY4NDlmNi9uai9pWnVJc0dwMElCVDM3Q1hlQnpFMy84Qit5a24vZnB3cVBCR2pOY3NOZWFTUEFLcldPbmhSL0tyYTc4eXFOK29UZnkxb1hlL2JvQjh6My9rcXZxeGJIc0dvWkVlVWY5TGpjVlE5cVZaNWRweGNJaW5MVldJekZnRkgvbGphYU52ZzI5S1lkVlpyRHNVSUpUbFFKYVIwWjZabVlVUmhWWTRvQXBYTHppbGJ1Sk5TZWJvWjhEVmE1Y3p2YlFLQmZyVTdrMUJCRjhFMWRYODFsMlE3WHMyYUVsemNKdHJWaW9ZbzNDb3JUcVlsN05jWGplVnpwK2E4d1JEKy9ldmxPTHQyY3NoRVRJT2ZIZ3VwK1A3bG1hOVN4THVzVFBXLytTY2Q5Wlp0SzBZeFVjTzlRaS8wMnBOOFVXRjF5eTdYd0NhekhoVnJvbXZUSFhpL3VzNWlWTEdoSU5YNzg2RWIvejJXbVdsTXRnaUhXbFc2MGNsN0ticVlyRVdzeFlxWjN4Vm9jMjVkcGhsZEJwVi81M1pWY1p1U216T3pkNHRZYzBmc21mYTl6TlQ0MzJuaUxXa1FQeVBQVWhmWVRTaitIRVNFQVhCRHZEY28yYi9GbVJqekkyZWo4TjJXSEcxVjk0K2RWK0JQTCtIV2VyNWxqR1dPMlBZMEhxbTUrSkpwYk8wcjByc1M3Uml2VzVQZ2k1am9XY0laaHIrUkRoc3pSQWl2a2c1ODJhN0pveWtzdnprYmxyTjI1bXc5WEhlKzkrK0ZHVjZvMmJMK3g5T1FyMHcxaXd0L1B4d3JQcFRleGZpRDVKZmprOE95dElZamtmbi9taDA3RStVN2wrNVU5OTVXZXZYN242RngvZStlUVhydWZUMmErOTlscG1JZTI1ajZXaVFvVW8zWDY0S1ZITW9SQWhDVUh2dllmNFE5UkY4STNpSmVOcEpWMFZZb1VaTU9aVUpRd2lRQmpVNFlYQW53cFVBZDQ0dUJUU0VtNkNKYS9KZDVScVp4eURXN3ZURWE1aG9yemtQMmxHaVBoL2xnTlBYQmMzOThHckZTNWhBM00zVGhQa1o3ZTh1K0hGSWNRTk5sdDZUeW9vR2R5c013T29jU2xCTWc5OWtTMVh1L2dORVFhdlJYdFZYWXFsWEJQVjhoUDQ1eStxS0hCenIrSmlJV2NBUDQwcDJxekpseWlUNUtkc1ZqM2hSbGpiTWx1Q0JWOWp0Q2RsajJJOGE1eHg0OHZReHJ1MXFDMTNFQjRhYXJoSHNZSE9TVU8rbHFKWXh3VmFLWEpzNkNsdTB1NzNVQkFOSkFLZ1YrSkUyZHI1MC96ejNrMFFjTmtzMFVoSXlyWVdzWU5WZW0rS1ptVDJmcnFnbmc4MnhhOXNHZ1owUWdKaGs5Wjl2Y2V2QmtZWkVmbzJ5aW92K2MyN1lTa05sZDFTOEd0K3BYM0N3MkR2dXFiaVdSL0tyVjF5OEZVSHJQRzJXV2NwWURBTnk1QjNDck84aUhLMWV3ei9YS1c3K3BqSTZtZUtFb3Q3TlZ6Q3BaR3ZxM1NIajBnL3hrMDZVWkIyYUxnVnVkM3Awcjg0TjFaK2hDNGM3WjR6ZWZyTUJIZ1ViQUF3ckROaGxFWTZ5dXBpOHJlMVBhWHRNTXp2L3VEOWJLczl0L2ZTM1lkVnJpKzkrTVZNNGwzYnV4eDVPRXE1YXNGbWkvSEZEQjFaRDB4eFJoTG8zR3cvVHE2QmRmZWV3ODdmYXprdnBOSFpsVHYwNnlxT0RCK1ZibW5JWC9yQ245aTdldVBsdlZpaWU5LzU3dmN5dFBSaHgxN1BaU1hHdFF6UlBMd2ZwWDdtZm1pZEE4MXpYYm1aYmJCUG52elpuL3Z5RjM3OVcyOS8veDJsNWo1VHVWN2NQL3R6UjQvdS9jTU00djZYTDczNjBqKzRrVUZpUkIreUk1NkJiY0x3ekpxUDBLNUUzbUZXNDZqMW15dkI4NnhGUitqKzVrWXdJbTcxZDE4QmhEYitXdlVRa0RpUDByVzJzUUlSb2NIZFBpZmRXb3BpSW1FdEpPZnY3Tk91aFV0YzZWVllBajZDSks5ZHdlSXYzeC9ueE9kR3FKVEw4L2dON1BIalAyVnZwSjMzM2JRVHRoU1Z5Z1ZtQkM5Q2l1bEJPenhZaWtkY1ZGblZmVDBQNlRxN241QjJ4M00zbGxxY0tGQjhHOGlCSy8xU3dtc0l3RE9sU3VCOHNkU3hjeHpsV3lXam5La1VMR1l3KzcydENBVmMrbTBtT0IyZldvbUpuTlFVQXo0dVhqbjR3cmd2ZUJTWUM2eWhhNEIxYVk3VkRUMVRJR1VuWjhJcE9JcDJ5ZUxpUXhHVWYrQnIwRlhVYWVCSkZvdk5SRWUvdWRYeWZscUJUTjdTc0hpU1VWZFV0QXVaQ3FjTGZud215M2syWldSQ2llV0tKejc3YlFtUkNScU5XSXBVV2RiZ2RjSTE3NWFSclltK05BQ1VhT2loRE1hSVc0NGtna1A5WXJHenNKUUZ6UklsWlYrSHRpam54VXZMT3Fka3dTd1Awa0Jka1BId3VjWkplbXZwdWxxclhGaXd3Ky9rNDVMdnA1WGtxY3lYemdrZmZvZy9yalRlNlA4OExQaU1XMmxDbjFCanlYQiswK2h4R29sS1JmS1F4dk11VG9leDNzOGVXd0tYOUNuTEJ4OS9zdmY5RHo3WU8vL083L1lRbDUvNTZaK3JzUWQvOHkvM3NyS0FsWHIrN3ZxYytzR3R0WnJEd1RiRDhDV050UUFBUUFCSlJFRlV6enQzN3RRUzdaaDVsTHVKS1RKRnlacXdNdVNwWjk3RDFtTkV2dlRTUzNzdnYvenkzcy84N09XOWYvemtIKzk5KzU5K3EzV0NrWGxrd2l0cld4OGRaZGxiZWxWUHE4elArRlRQWDhyZ3dTKzNrTnZQWnlyWDMvaU5iLzNQRSttdEw3NWNacXpGeVdGTXJQYzVsSmVBSUY2dGw5emJ2VWV3Q0FjM2pKbjNNanBoL05jellwOHlscitGdndTTHNKbVZXNjJ5U2g3LzhObFJaUU9IQVBSNTQzL1RGNmRWd1ZpcmlNZ1p0NnBWdTJVM01CcTQvU3hjVG9WcE4yeWVDZWE0RmYrSHl3Q1BLYU80RTg4ejZKUER4SE9mTUNKWkRTRmVhbW03L3EwN3FtLytTaTl4a2taRGtERlovbmtwREUwZ2VDbzRWRk9uRXJvVWt3Zzk3RHJoZUJZaktTSnNuRXpYT08veGE4VVQ1ajBDWEh3Q3M3a0hhQ2R5RWgvOHZLMEtzdEZFWHBSVTgwa2VRK05WL2tVM3VPSERYUEtiOHVObnc5T1NhQWc1aWtRRFNkYWNDNkNSQ1lqQ3RzZGN5Y0dvNVpySnJ0bkgzOFQ1TVVQL0pCTkx5cUp4bWp5a1dlbVVhU25tVWNvcjdvWXZHdWVTenJBR2VVS0xTUytmbHJNWnJqS2pRSmVRSlUwSTFHc2FwRW4zMU5JM2RGUCt4QWNmYk4vcTZqaHpLcjR5OFlPWGNXUCs0bmt2VFpPMkJzTTJZOTd5YkR5MENMNDd3bEpmU0loMDhVZ2RZbWdzL04wWGIxWVpoZy84R2o5NDhkdTlIcWViUG1Xb1RHREdGcThQbGI5VngxTzRTTWpLVHpSdzF1UzNmSFBGMHFKZVNTN0wrcHp1ZmRqK05FTXVQcVpwVXM3azJuc2ZmUFNMajU2OS84Nmx5eTk4N2YwUDd2N3FLNis4MHAxemxHRjM5R1Z5OVZaMlVLR1ZPc005em9RWXE5YkVHR1hxREYvNTZ3M2N6VzR0WWZ2N0QvWSt1UFBnejUzOS92czVVK2ZnMVV1WERyK1VEVFcvL09LTEwrNjk4Y1liZTIrOStlYmVsOTc2bWVpa00zdnZ2UFBPM3JkKzY1OUhGaCtrOGIyUXlhMXIvVkRtVVhvWkgwVjVVK0Juem1TV2E4ZDlwbktkY0x1ejdLR0dMeVpDRHRFUlgxZXB5SWFBUFptS2lJVHB3NVRGNkVWUThIYVpPTy9WRTF0bVlCVStka1N4K2lpWUFYcE1TTkRxV2hHVWhFMGxtTHpNSW5ZdmR5S2EwQksrNHF3eEhKVmw4QS9BNG5LU0Z2QzRFYWoxRmRrTnFjKzR3WkY3dmp3VFZmaUU3ZnA1YmhrM3p6NG43c0E3aVR2aEZSTGg2THdhbE9UYWl0NG9RYU5ob2JzN3hjajFpNnNJRzcrZU5acjc2c0t2WVFJV0JONkl4OG9kSmN1aWI2VUJONkJhaG5iUFZKSHdQZmowY0dlMGJwNkxEczAwUHdHVm42QVhZUU5uYWQrRjcwbForVWR1bk9yRU1pN09sQmRRRkZqUzBnRkRFNU5HK09oRGYzZ2NHKzFrTEJNdEZwMlhqS2hZdW9BT3BGWnBLVzlER1ZiaFVDL2RQeDhZNE1GdjhvRC84T3NFVDJodlNtekpVWkFLWE05a1NWa2RaQ1IrWWNVUC91RFVHQWpNREFVblh1Z1c1VXJGc1BLVlFRTkJvWkRIVWVMZ2N1QlJCR0FXLzhUeC9DUWJDY0JXeGhNWGYyRXNWbzZTa1VaOVdidUxFZ2JYY0t2S05WbklaN2FXU3lPL2xpZDM4TDFQdmZEdXVlV0wvOFFmQTBvWU9vam55azhid3BHTk9TODJ1YVR1cmtaenhtc3Q5WU1iZm9QYzh1YWRIbmtXNjgyNmRqSnJBcDExK1BEZW8yLy94b2VQZi8zbnZ2RFJPL2NmUHYzVmozcmdlRDdUODhMTldwZ09QN3FiODNCWnF2Y2YzQzQ4ejZ4WE5EUGpyMndzMVlleGRJOWpFVnVLbGQ3VzEyOGZQM2wzRnYrLytXWVdscHg1Nlc5OGRPdk9sNzc5Vzk5OStFOWYrNjIvOVBNLy8vTi84ZlV2dmJYMzhoZmUySHZ2dmZmMi92bHZmcnVLZWo5YmJXMDRpVllNcjdPQ0tsUk9LYisrdDNkNk90YVBWYTR2dm5EMWw5YnlodFVOc2tENWhKZ2JjNVpsUmVsdHpFUG9qV0RoODBuOE1pRCtRaytlaGU5Y0JNVlJaelA0dmhpOUJHZy9KK2NTMUJIMjNnbHVCQXpoTU1hei9kL1NDZGNhRWpnQ1JPZ1F1b29Dc3B1VGxvTlRCV1pyK2JiZ0gzbWJNb2d3TUR5UC82N2Z4S2xmOG5FZnZIZmpTZHZ1M29saXBUZ1h6SFdmNTNoYVJSREdTbThZMW4zZ0JraktIMllISHVzVTNGQ255c3dTbWZZMG9nOTZhSXM2R0cxYTVicU5yeFpXbE1VYWxnbStFWnRGd3loWWhVSHJBSmF1Y1Z1M2pOMnBhQ0tjNHJQZTFyc3lVMHBnVFdOWG1nZjM0UmsrQldoMU0zN0JnZlZxQWJpODlHcWFwemg0bnl1YUxVdGp6SmJua0pia0x4eDhGMW5pUkJOZmc4MmZXL0JXdUdmaDFuRTNiUnFieVdmdzVVK2hWT2tITjNTVlpwMFNwdnhMNFlKZFhnS05JQ21TZUhNMTMvQ25ibFBLNWVaR0YrVitrQ01PV2FvczFsVU9WcXlUb0RKZEhWaFYxc0c1eWlQeXZNaVdjbWNIR0ZwMmVBdCt5VHZNV21nay9wUnBaYjVvQUs5eDhQNHNKMDdUdGk1Rk5panFsRUY4K1pGYmZHcWp2WlZWbzE5NEo4bzFNa04yRUNTWDlQZ2JwR01WckQ3Uy9hTTc1Y0hWcXhuZXkzam1HeDkra2ttcWYvYTF2UTgvK1BVSEJ3L2Z2WEJtLzgvZCt1aitQL2pnK0h0SCs3OXo4K0R5algveDlZc1hEMS9OUVM3dkhCeWMvOUwxR3pmK1RGYWtQTHg3Ny82M3N5MzJOL2V6ZC9rNDUxQStmbnIyNk5MQm8xZHpPc0FuTVlnUE14NTc2K2pacFhlK3U3TjBLa09zc1R3LytQWmJiOTM4d1hlKzgvR3QvL3UzZnVmWHZ2ZnVELzdxemF2WC8reXJyNzc2bitZelFsLzkrci8xYisvZHpsREYvUXhEYUJ4OFo0MFZuS01sLy9MVDQ4Y1AzM3JycmV2ZitjNTNicUdoVW42bSt6ZC83cWQrOFdmZmV1dXYzY3podVpkUzltdlpDV0l5ZVA5dTFvQ0ZvTHJzdHVOcEpUdWJtM2V0eFoySGR4ZHp4VkhKVlk0d1FqZGZPb3VZeldCaUZBWjFuMjZFeVpnb0J0N0wyWWtFeHFrM1ZhQlZ4d3lIeGNnSHNXajVHL1RtTUN1SkN4dDhCeXlBVXladVRCYXZUSFpQQ3o3UC9NWDEzcnlTaDY0VEI3KzU3ejdYTXorN01KNFBuekIzWWJzWHZGek4wOEVWY1YzZWxEc2NMTlhSMGdvMy9rbUJFZDYwT3F0Y0dmL2o0RjBsNmI1Wm5jMEhqT1JKZ04xcnNRWG1LQXhXWEpJVUI3RE5Tc05uRGZ0UW1sdTVoMStOcjRJdmExY1BZZWdMUHJqU3d4SGZxb0RrbjNqODNlY3FYaGxQdTVobE5kUEZEVmRYK3R5bEp3L0dIWDNPUlRvMG9UaFlIZEtjalg4cmMraGpUSzYwVEduUnEzUUtiVFNvSysycTNDdnRPb1RiRnpQZ09ISEtoK1JCTWJRTW9adndxK2x5M3N6TU14cjVXT0M5TzNlTDM3UE0yRnRRRGk4TjExSnVhYlNqazhCNG5EWGhHZ0J3ZXdaSDZIa2hmSnhsZ2NtNStjQnZKZ1ZWVXZIUjUweldnckplRFlXSW84enc5OHdaRmxKbWNxTE9vRi9ySUZwSFNWa2JPNVpyMStER2lsOHJHQll2WnRWRllTVS8rWEp6cDQzN0hLVmZmUEF5VWZpaGo4MGp5azdSNjcxcTJGYXZjZUNjeXZ2QUJBZk9ydk1wNitTWFV2ZForRW5qa0M3NzNad1VkajhyMTI2bnlPOThkSHZ2Ny83OWYvanUvL0MzLy9mWFJNN0IxTmMvNjJEcUFzclBtOCt0TlIzL3orTk9jZjdKTC8vVVg3OTY1ZXJYSXFOZlVqL1I1TjEzdjcvMzlyLzQ3ci8vLzBZWjcrWVR6ZlRaN3VlLzh0Yi8rTnFMTDc1MHFGSkZpZzU5a2xZem1QTTBFUTFQa01iZWFpcWFwVVM1T2pWOW1OSngwekNDWW94bi9SMlFVV0lHUUFmZGhXMlZBeWF4S3dxL0xWcmVsMld5bEN0QnZwOHhsQXBkSjF4MGcxWjNoREM2K2xYSUNDSkdpaWV2dVlOZkxvSzc0ZU8rNjZxV3RyQkp0eHQzQkdidXUyazk3OEtiZE9Ec1hvM1RzZElWWDdmeEpPNkd6NG9mYkZLNW1VdVVwVHk3dkdyd083bXZjb0toQ2padDBybXJ3TzZVaEh1YXRCT1ViUlpvdnF5SE9JTFN5WjlhVThzUE9vVURkdE12eGR6bnphK1ZYY1FOUnVOdlN2ZWtYSENBU3hvdjNUaE9lY2lRT0hvbDVHZStXWVh2RFUrY1JHaWNsajlqNSs3Rk5YaTZyMFg5SUcxbFQ5cmxWcVdtU0cxdmxjOTBpejF6QTJ2eXNzMFVub2JEVEdxSlpiek9XS000MnA3ZUU4ZjRIVGk2dXl6ZTVwTUlzOXdydWNtQnZpcnRTaWRhSkc2bFcrbEZtL2V6TWIySHRpMmI4bS94RzJkb3NYdzMyaXphK29DZi9KWVVlTXFGalUyejVSVmt3SEZ4UC9RTVdmNWIyRHlmMENmcDFuTmtwNmpscC94WVJvK2ViTk5zZWV6bVU3cHQ1V2tjOHJUaDBRemp5Zm8veWdhTWJGRE52cVRJUzlhMTNuMTRkT1h1UngvOXZSOThkUHVkaiswNy9USHVrMDgrMlJrNytURVIveEJCV1o1MTlKdHZmL2R2UG52MCtQK0l2QjduNk1tdkhsNktKWkF5UEhyMDRKOWVQYmh3OTcxUGJwOHN5ZnBNNWZyMXIzenBGNzd3OHN1L2RKamRIaGJxWG9qQUhFYW90VkNVSzZZN05LV01DUUVRelZHQURyend4VVF0UDJmODA1cEZQSmh1ZTVWeDNrUERwbHZNUGJVOEh1ZUlPeTNqTEs5Uy9iejdraXZMUUxleHg2ZHB6Y01SQno4OENvNFVMenljZG1RM0RxVlVLeXYzaUZKNVo3WjVoN2VuaklYczVtelBXemlkQ3VHOGk5SzFsV0g4SnJxOXA0cEhHbFBLNXk1eTFnbWs3YjdHblBJU3BRWXJsWWdsaVo2NlVQYjlPNDFKSldRUmRBeFNOenB4bGMwQkVhd2crUEJiNlUveFpHSG9YV2dFVlh5Tm9qeVg5YnFlVjRWWGVkYVFTcW16NmxNdEVjZm9GVzdUclRRc1pIV2crUWJuS3NtdFl2QmI4VmM2dkJyTHNNcEV3cmloNFVXN3BUYjV3RE16N2NyV3Y5d3BWL0RHa3BFdXlKWkdoUjFGU1VHMko1TXV2OFhqZUNxWGptbWlZZEkwdjFEWEYxZTd2RXpYT0hRbVY0T3orNkxyc2pUaHVUNXdsK0dCNUdNTGF5ZVZvbHlmUkxieGZIYTRCY1htTXlkYVdkMmdDMjhuRy93cGlhY3BXNGNLa201NmEzbXFNcEpYRUduK0xVdXR3SGlkaXdLbkpCUFdRMDFTUHVYcW9lcmh6ZVN2VGlWUy84bHNhWTF1NFN2bHFteVYwdnhVM1c2OUcvVlFXRlB2M1BtNUpyejAzTUlSdUR4QzZPMFpWTExqemsrampKOWtyZERqVjFuYjBvamo2b2hYVXFHUlpXZVQ3L0EveWlaam1ORW5pV3MxeHFXTXVaN0poOHQrOS9zL2VPazMzL205djFuRS95WC92UGZKSis5KzUzZCs5Mys1OWVEaGYzUDd6b2YvS012cnZwMzFzYS9kZU9uR24vN3Q3L3pPM3huMGxoYWN0OXkvOHNZYnIxKy9ldlV2cUdTM01yYXdIK1Y0K2R5TkVDM2ZUdytEamxMcElxT2hVNGdWUXJycmFoZ2lvQ1JhTWVLbklyZzRma3ZnMWpDQjlKcHppbGJYUnJ5blI3R3BZdld5WGlyd2dZbFpWZEJScWlvUitENTlqQ0dleFhXT3BuY1ZxRXA5VTQ3eUhZR1krL0x6dXh4L2JzTEJJU3ZQdTRrbmZKNTM0elRkNW1FY3lYdXYrTkczS25zRnNiQ2pERmlHb1FsRmlFSXFhS3BQS3RhWnZTOTg4YldXeldEOHZmdnBpbVliWCtGSHlXWmdvRHlZdkt2THdRNWNYYlNsa0NnUEV5am9ydTZwMk1GblJlcllhNVY3ZU5saGdUU2NlTU1pNDNUSjVhZWFLaXZsdjV6S2d1VXIvdkJaSEx4WURjTHFrby95SFQvcHhadTR1cmJTcjNLdE1JMGgvb0hGZjBObnBkblNna05XSmh3NWxUc3FjeW44cEpzOGkvdUdxL2dqTHhvdnJqRGlMOTQ0ZnVQRTE1anpHVGt1SENzVVFsL1B6Ym54TE05YVJrVVdBVFF2bEE4MlNjMnlQc1g3YlBqUVhsbXlIWnBRK2h5YUhMYnhET05DK1hXWi9MTERhQzB4UEZOVEZQUlBPL2dhOGdwYlQrQUd5Wk5JOEMzUGNpL3VHMDA5NzdycE1jaGgrQldJSjFFR1p4Njd0UE5ldUZzOTlieDdGWmY0S1NuamgrR2hFT0lZSDRZRmVFOFlGdG5PbW1ZTjZYSS91L2ZGN0pSNjY1WFgvbnlpL0N2bGpOZG1uUFp2QlNuWEQ3a2ZVcTZ2dkhyalZ5NGRIdnlpWlNmMzhrbUxTMUd5MWlMNmpJVXZJejdlS2tYSmpSaGhkaGxMU0VNb2hDT01GQi8vVnJSVUdoWGZ1NU45TUprL29VRmM0MnlQdHpWNUhZZ1BtdUpTcnJyNjdyVktBc2Y0RTlnUHM4L2JhVVVZWWh6SS9tTGRzc2NaVStNM09NMzlWQkJ3ZFRsK2M4R0RtM2plNTNuRlhtRXExcTRUVDlLVlBQQXFQbUR4bDllcU9LZXdscFVlc3pRMFlmVkhXUVJrMCtXQlVtM2VTZGZKZ1pRM0xJamYydlo1YnByK0NDUTNyOFVqNzhiNXJBTG9NcTdBNEErSDZ0Ymd0SG9Rb1JmbHVpbFc0NjE0d3JIQXVJWFhLRmpoSzQ1NEMrWXByWWFHMHVHUDhPSHh2SXRETHA1a1Ywdy83aGM0NHVBWldRalhOaVcyeWpYeHk3OFVRVHhYR3k4NGhDZ2FCNDVWQ0ZielRCa1hQdkZQdXNhSUxEM05zZ0VOOGQ3QlJ2K20vT0VmbHFheXNzUWVaWHcxcG03a1QrOHJmQXc4c0Z2KzlENDhvNjF5V1p4dmFaZ1BUSEluWll2Z1U0anRUUVd1Y2lvVGx4VmltdFFLandhNGRVWFo4cnhnRzQvZmxoREdUenFObnZEaWtMUXNjZmszZnNaWEQ3YXpLUmFPaVZkYW5WcXJ6VGcvcHpER1o3dWZ3RjU0bnNDSmYybTg0VEZsa0VvY3VMcy95NXpJOURvbkQyRU5EeTdLengrc2xMeXU4ZkxHejQ2c2ZvRTFQSFhxV0tiMzk2Nms5L0dsTDd5Njk2ZS85TVgvN08rLzgzdC9kVXYyci96dFU4cjFxMS85NnRXTUhmMnNGdnRlck1palZQUnIxNi8xbUVGZDFDb3pBbFo1Q0dNMzZpRDBkTGRDdVNyRHBSQTNvb2RvTTZGVjRrWkVuSjRqcnQwakhac2x4TGtRdVBBQ0U0d0tWUHpNRnF0Yzl2emFGbGNMTjFhaVFYd0NxT3NxTGtVVi9yVlNkRFl6ZmlPbzVjYVMvUlBHN0laaE1weCtuSVBmcmhzQk92RlAzdU0zOXlCd0lraXBpcXZDcXhoUnNQQTFkTkN1ZDhyLy9lOS9QOE1lYVVTMjRZRXF5azFKc3k1SG9UZ3pvQW96RlZZK0tpZDM5dXluSjdTRXFjQ05FOXdKT1dWcVhMQkMzeUluVHU3S2dPWmNxd0c4WFJSWnJ0MkpzMTI2U1RmbG4vdmt0NnNjcExtUVdlQjdhUmhOQ3VHWGMxVTVjaUh2Z3l4VjZudkNSZzZHeHlaM2ZMQU83RTZtVUU3Sm13TFJFTUdQYS9oR0R6Q3EvREtFVVBuWTVBRXVwMkdyaDdXYlRuamxMM0xmQ2NhazQ5YVlkeDdvMmpDdnNoZjU4N2tYNlJzbitQU1QxZUhoR2hiUW8xdjB0YUtCMWkvZjQ2bXh3NS95aFJ6bjVCejQ1aXVIR1FyWUpyTFNDUHZRb0UrLzZIVlVVU1ZkeThDU2pReDUzaDNTZ2dkOE5Ed3k5N3pLckhJc1hBYmZlbXcvUXZsM3VkUUV4SFBpS3VHQ1JjN2t1eUx4cXh6RVNLckMxNU9GVS9KbWN0VHM2T1NhQmx0am9CNnNwV2JOcjZSYjhjK2x2R3M5ZG5STzZ2cTVuS1A2V2hiMmYvbExiL3p5SDBTNW1uaWFHZnNwd3IrTSs2ZVU2K0c1Y3orWEZ2Z2JSMWxla0VuNzdKVElxVE01R1VoWDhVbG04SjZrVXVBVkppR0lDa2ZtVkl6eE0zNVU0VWhwV25rakJDd1ZmZ2g5L3N3NjFOaXp0RWNadzNXNkR3dDF4VG5YN2xnWC91cVdKUjhDM0RHbnBQSDVCcFhDMkZQOUExL2xyK0NrMVdRTkN2ZnU0aGJ6bHVBVHRIR3RiQ1FrVHB6aXRBbkx4SEVmT0o2VmFkZE5PbmN1WXJudWVSKy9TZS9lY2VEaVVNSkZ5bU9WWmNXRnVNTFRhMWgwU2tPaUJlZkhJdEpRY0drK1RzclQ0UVowQ0U1d0IrTnNEcXJMVTU2VkNYZ0N1NVJuTGRXK3J3YUpRaTF1cVFncFdOTWJPNmZvNStCc0ZsY3JmdUMzN0lEdXVJWlJDcm5Bb3BENGVVYmZOb0o1WnNIeWYvSG1pOWxOYzdkNTJURWpqc1o4RkNqUTBtS0RNa2tqakNNZjRuUEZPd29IN3cyQktMdjQvSWNXeHVjTEszN2NoSU14amNqQW5MelF5TVh5UjNjOUxWdUdveWtXalB5Q0tWMGVsaldkQnZPNDZZS25rN0JHeE5KNGlxWXcvSlJGWFJuWFhYVEJ1MzhiL2tOZWNkR01nNjg4aTNjMlJYQjQzK1dGVWRhNFB1VWZPUklmcDd6bjV3VG5mb1ltNy93bmpiaWNlOVB0aEsyQS9pNVlXMXo0VVpBQjNySHNXU0ZoM29BYlBzM3o1S0ZCUXV2V2RSWjk0cGRmOFlQUHBTalNNNkU1bmpvdU1jdWJNckcxdjNmanhSdDdyNzMrMnFzRi92djgvUCtsV0g4L0pmNHA1Wm9TdmE3Nldvd2RFa1J3SEFSeHFTZkxQTHdYS3pJRW1BSDhVS1ZFSVN6REZCWXRvZzJEVkxoUXJINkl2WlRoNldvQkZabFNOUUdvZ3ExMGEvYWZjZ1dMWllNQkNGOUxJbkE4dDd1NStVdG5ITXZkckxPN2l4TjM5eHJsdE1zZmNUSFlaVHowZVNmOUtieFZ1Zmx4YmtuV2UvT3BTSzk4aGE5MGc0OUdhUk9tWkdNVVZab3BYN3VWc2VpbDZYT1VibDF3RXFlVys4TTFiRkJMbDJLSnY3QmVVWXBuY3BqRjRDWXRDMm5oU1BrRTJid3JaeWhhLzFiY2phYkZKZjZsUmVvSVM3RFdXZUZ2eW1zVnV6aUtMeTYram5MdGlvMzRLd09ldWloWXZOUkllOGE3ckJuc251NzdLVStWNjFZK24wSnUvcEc5azZHQTVBbFB5dGdKODhlcDFLdnlobWNwaVhITUV4ZGF0Ynh3VUVibFYrYThveFhWSkMxODVpNnRzcmlVUS82ZVFSV25ZNktiWEl5TVc0cWtFZXNrbG1QbkVsbHZvTlpIMDFHc280UXBJWHlQbktWY1hPRnU1U0pSSi9JVm1uc2VITVJyM1BqaDhkUFF6M3QrL1BjNW1CZGY0WnowTHF4U2p2d0VsNjBuRUR6Rm0vekViMWtULzNuSHZ4Y0JqeXVzRGJZdmdvQXJHVmhEejh2R2hvRktXWXVuaE9KczVZajQxNy9sUzRDMHBmbVdWeWlab1QxVzc5TitEUFhKUWRKSEI5MEliVi9NcDZ4L25IdCttZGFiZjR6THN1RHgreW54eFkxRS9PcFhYN3A2NC96MXY1d1owbS9jK2ppZlNzaE9yamRmZjIzdlM3bUkyVkhHUDN3UC9ueG03aHlhWWIwcTVoN2JZdXFLUXJaRmthRDAyelZob0c0TlpXYTMxWEcySnRvZDVQUndpdENId3U2bWExaTRHSlowamd5N2xRVzVOZ0pnM0lVb1ZoV1NNUFFUR3Ftby9BbHhqMkhEOUtUdHJDd0xJL2s3VzREUUU0UjJsWE1mcHlIUXJRdDdlNjFXTkpVaVZnZFEzdjgvNnU0ZFZyY2x1US83dHg5bm4vZjdQdWJPakRnY1NoNVNnQ3dDaGswYk1HQUhodTFJSVZOR2xoTkxtWnlKa1FFblZtYUhqT3hFZ0VKbU11Q0FnQUNKZ1czS29zV1pvVG5EZWR5NTczdmV6MzMyOGYvMzcxWDdmSE01bG1VRDRwM2I1Nnk5MXRlcnU3cXF1cnE2dXZxeDBOcjkrWDJteUdHMjdwN0hUN21FWXdrTndka1hSSTE0R21seENRVEt6SkErNkViUWdtc2V3RUNMQm10eHZXSFVVZmdhN1BNdWY1TVdMbDFGZ0E2V1FuZzNzLzhkcXJlczhDTkRVUEFPTTV4MHh6Tmx0aEZWNFN5ZUhHUVdEYWl6ZkJ0TGJWbjlrR1lYNGdNN3ZEbDduVTdPMXNPa29UaDZsbWh3eE1zMkZtaHN1Q3REV1lJNEY0V29vVkdpMHVPRHl6UEYrL0dubi9kd2tYZmVmWGQzNSs2ZEt0ZzI5dUJZZnp4ckxXV0pvNFNiTjNLaDA0TURHY3BleGVDMmhzeG0xcDJCWUlXRW5YMGFKY2FadUxMUndiUFIxSXFQak9VNWJFa2VTbzVjVzluek9oT2wyUTNreTdISlU0cU1GTTZ2d0pNdE9BU3QwTEkyUWhqU2szVkdncDFaWlAwNFBIeDFwalBKcUN0eHkvZE5vUzJheUVDS3o1WGY0UjI1d1p1TytJSzdkem9iUEZ6dkZueGxtSS9vYWhVYUtuRElpOTFvMGxscTVpQ1g1TXE2Y3k2MHJCUDJPM2kvU051QUova1hwRmR2N29KNjgrelNFdnNlbnR2NzRqdHBrMTY1S0lDdE5iUTh3YThpdHk1dHhFdy9mampUMWtUMFM2ZVhiZlZDOXZ1NUdYN3M2QXl5M0ZGbzdyWU1YMDZIeERYeU91NmhGOGx6bHZtWXV2d2lyNDllK0Vqa28yLys2WTgrUHArUmgvK0VMeTdUK2plNUxHdksvRmZkejVYcjNjdDMzcjUyN2VvL3hDb08rRnZYcis2Ky91N2J1N3M1dENYY2pBSkxvNmJVd2t3VjA4YVNCcVRCbkMvNGo1RHdmN1Z4cDBHdEQ2VWxiN1NIeG1MckgvVkZlSncrSkMrZXExeitKTDhKQjlqaXdCa2xoWWdWbDRZVVdGUHg0dWFkT090YzVhZm9DV3d5YlNLMUJEb1JUZS9Qd05oL05nbFZPR0I5NFpLdUlncG1yc0Z6Y0NpYzhLcnB0alJkR1pCbmlnRTlqTWNLYXhJUlpjOFVxRVpYS3pUNDUzODdDT21UcldsU0NZVjdvWEZ2R2tjN2tCYTQrQlB1TmwzL2JMZ29ZM2gyYnBtblRQV0tJa3A0K2JoeTMyaXVFdGlld1ZMLzZKM1RyY3BqZlA3Q05UeWpaTldkY2lzUHVYdEdHY1d4djFEZTZNakJHYmR1M2VwM3F2eVdIMS9KQkhrQlY1eU91dnpPTzh3eHRENWZQcFRmZ3JRYU0yVWtMYitqc2wwVXd1QWpuY0NYcTB6M0Z5WkpOMXByTE9RWno2U1VQdDFqZitkV1hybnJYQ2VOblZONEtxVDJra2tDdjVmU1dyaXQ1K0dOdE9MN2U2SFUzK0xoUDNMbURrN2xhSk1ER08zL1poa3ZXdU5xaXJBcG1qS2NuWlNsZ1J4dStaVWh6dFVBWmIvWHJ4VzF5RGxQTjJrbjMvd3VUTzB1U2xQYnEreVhRY0VqZkVpTTRWcmVhNTk0R2lNZ0l6VWRBMzl4U200SDlxSnB0L1lYa24xUyt5eDFmLy9aazkySER4NzlPMDhlZi9RUFA3MzM0dE05RlB2NHE3RlV2MnlGdW8vVE51N01FcHdySjcrQlNRNEN2cHBUMk4rNmZUV0hFK1FzemZUa0RqOGdyQkhQTUhneEg2TllKMC9pTXowUGVVa0FWREJtc1ZDNXExcjVVY3ljL0UreXRNaG5jcnRsTEwzU3F1UjFjSzJHZExhdElOaHZuT2Z3OHlDOW9KeXBYTUxrbVNEYURhYnh1dUFvbm9YZ21EMkI4cC9nM1lUejUvUytBbGdEYzlLNEwwRmRaZmw5bnMrUExjamIvSkVsNy9YTVMrQ1g0cGVNOWZPbTBiQ0lGZzNRc3lkOXdXVVR3RkdIdDNEcStMUDVJM1d4V2w2YStFZ20zNktYNStKeEdKNUFZUXJ5ai9LaE9HdnRCTCtBckwrUzRxbUxJY000K1ljamNLdjFCRWJnVC9uRFUzRlRCME1IWmNwMVEwbTUwRFI4OU01MU5UditLTlo3RCs1MzY2REROMXhHS040N2xBTThhWHhOd0xPeXdDb2VzUXlWQWE2dlJwUlBVWDVuaWUvN3RGRjVpbnQ0WTBXS2hmbVQvN2gxZzNmTE1tU3BYb3k4bXVSalZKRC9oc0RvaEdnVUFZdTFzKzdoajFBK2ZlRzVlR3p2cENrdWtUK1dwVEF5NFM0TVRmMlJQM0FHbzh2eThMdlBLMDdhb1duODhPV3JGc25TVGgxTytxWGNCNTV5bDF5TTBURGxLN2N3VXM3RWdlR2FJTDVwRWpIdjl1OXc4dDU5Y0hSUVRpUStPU0tIZWRkSnR2QjEwcjNLMXdGTVlLc2ZJN1pqejNtdjAxS3lkcHFvK0ZsVHY3VXlsbHpTQnpleTV2VzlkOStKYnJyem4rYkV0SnM1SStCWlJzZVhIajU5L0YzYlZYKzR0NVYxYVBneTcrZktOWitUK0EwSFJFU1Q3bTdlV2w4ZGNMaUdSbVg5YWZqSC9LbTVqOEVZMm5NWHd5U05vZzA0Y1lZQlB1bE10YjNJc3FneVBnSmdXeW1HV25IZzRnN1FTRmkzS3FJZklReURwVEVjbk1iWmNxTEVwMEhWU3RnRUZCNmpsRHlyd0JmQmZ5SExHb3hpeVRDNGdwN25WR2RtbGM5Skx0L2wyUTlwUnl0K2krelBEWFlrTEJYKzgva2xVL2JjNTVsVjZIa1VhNzg5UnRrMDZSSmFOSFhTSkRSM2VKNlgyY0FJWUdneG0wb1pydnRDYS9HblpTVkNsVlJoSnYwbzA0c2JMbFJzclUrTkwzRmprYnBUeG5VcHBONHVVQ3J5cEJ5OEdINU1KK0xMblFKY0JHbngweVZNK29sWGQxK3NQM1U0YWR1b05wN0x5NC9LTWgyRm5MYlNNalFtU3RkWm00SjgwaDM2RWdEbG1yaFp5OXVKbFNqQlZIYmtsU0l5aE43cXhlb0puMjFPaTYyQkVQdzdva2tDQ3JNeUVsaFdCUGlpcC9XcXBTbjFSN2thMnJld3BJbDZiK05IdXpSRCt4ZDVrYVI5dHppMjhCakxVZHJoaDNRVDhNK0Y3OU1SU0lmdWZmaEh2c09URUxXbDhrUHlzbFJKd09EVWZKSDJTRkZTam1IaCtTOEdlWlM3SC9yN0M4bkZEUjdTK2cxUCtjVVBYV2VIMlNRU0Y0YTY2ZzZyd2w0ZDFVSG9lUjQrVTcrd2cxNGNqUDBkNnZ2UE44NjRwd0kyZ1l5cGg5eFNGeGY1YzNOLzhlVEpmNTlFMlVWbmkzU09wankrOGp1M2Z1UFd2Zi8xVDM3d0M5MEZJSDBab1pyaTMvN09yLzVHR3VLTlRqWkVxQzdIcDFWbEVNM2FoaGxDVTQvdHdVZWd0ZzY1VEIxWEFBSnEzSWVoOWZHUWNJMDNETERKQVB5bk9Xald1dFlGWjAxU3JXY3VBSllJUDk5cW9JUkVIaFp0WWF2TU1IV0NDajdISjJtbDkxdjhTZExhZjEzbFM3a25zRm9Jd1g0ZThYNVAzS3BVc1N0TUdlNENwZlQvRkZwMmVEWHdKdVVvcHI0dmpHV0YrVEtvNC9DY01IK2FkWmlHVVdleHRwUWw3eG4raDk1K3dqbHh4V1hwcVQ3RFNCekY2dDczc1FJRStRd0xXMytoMlR1VEx1cHQwazYrSU54R2pIL1RnUEJoZU5MMFd4azZoMmxNeXZFT2p5bERGMldvc3hYbm1rWUhGdmkxTUNuMXpiS2xLSi9FU24yYU9sYnZPbVJXN1BqYUJ4WWxReGJzNEhMM3U5Wms4TlJwQ3JVMGc4L2lQNnR2ZFlTaEx1bWJKSEdSSVlxWU80RnM0aHUreEMxVm1PamVGR3MxZEg2WGwrSnFIWmVCTFpHU1ZrL3dZSEcxWEpQQkc2MFNqVXdxQ3krVUowaWpQR0h1M29zWEtyZGIya1pzZitxajM5S2N1enN5SWh5NHltc3dBb3NzbE43QU9hZDE4TnhneURkbE50LzJPMXpaU253akw5SU9QZk55SDJkeHg4ZVhzeFkrUHVQd2QvY0tkK2lFOEM2V0tPWHFreXprc09jZFJENld6elp3eVZmK3BRWDMyZnI1dzZUdkpoRTA1UnQ5REpYSGp4N3NIbnoyZWI5R2NCSTlwZDJjSEIvK2ozZHYzUGdmL3NQZitNNjMvc21mZk8rWFpoMXNwZS80MHNsdlpUajkzejdMU1R5MnlscCtaWnNseXdkajFxeHhTQSsvVFdyTnhnSE1uaUhuWWtwNjNReXgxaEtZcmNlTmFVOWMrTW9zdWRJd2xoVmF2cmRpOFE0c2plc3M2UWtXZ2FOVVo5WEFLRnpyL1FRQ01aZTBVK2xyc2llTjJrUkhHdkVzUFpHV1ZjRGNVNGwrYXpTTkEzS0JMYzNndzJmQy9uTUI1SVg4KzZGQ25iaFp0VUNzV0gzS1NMTTlMKzhnRXhzYSszRWEvbEkrbEpYR2xIU2hveE1uQlV5ZzhwQjNZS3lRQ2FKTU1na1VBcndveUdtMHRVNEpaUUNDelljNzcwYVJzdDQ2ekkyeUtGNFVlb1Y0OGZCd1czY0t0a3Yrd3ROWUV0QW43TC9EWjRxMS9BNFB3RU5MOFlOSDNudHV2aHpWTm5tbEs5L3lRdnBWMTJzNTErUjNsMmJ4eWc2bWJCYkJzSEN4OVo5N0o0NWFsd0NGTWNFQmY2S3FlazhsNThtRUt6N25SZUNSYkpOMjBISjNsYzNKYUxSZ3NrVStQUFhDWkJ1RDRUaWJPWWFXa1FHL1hmQU05QWJ2K0h4TDMvWTg2WXMzSEFzYk9tOTRLclBmKzNIempBZE9OVE42SzdJNmV0WjY0c0JhN1c1WjN2SXdWTXFuL0IxKzVyRzhsQjY4L1ZEOFFzRGdOZmR6b3BKNGNKOThROVA1N3lYTXdTbWoyWW1zdWd6YzRPU1l2c1BVNGVCekdMbkpaRTdhYVdoSVhwYXRaVzJXOUZLdVZnOUVpdk0reGxjNkVZYmZwWHpFOFNBdUlXdkJiYmwvL0NRck4xNmUvWjI0ZHY3cjMvek9OMy9yajc3M2t6ODhML3BMZktoeWpTbitqUWVQN3Exek0yTjVFR0RmU3lwekl5RHAxcU5FR2ZCUmt1RTBrNzltL3dqSVpnR29MSjlXVUtIeU9nU0RtK0JaaGdtR2Y5d0JMTmo2UlVtNndKR3RLK3Q5V1JPVUwvaExDVWVnVTFFakNCcjZWT2grUlk4U0FVWmFlVmpOMHVnTWhQcGVjeGNIUC9jdndrdW1ueE91MG9HV1hNSXNSWk4zd2p4WG9CTS9iMFlwaW1jdE9ZL0JUR2k2OFFCS3F2aEg0Y3FDUGNxWHo2UTd5OUY1aHJtR3R4aE9RUWhyMVVLeFc3amszU2hNTkZTeHdwRlFFc1RRVDduQ0czc256TE95NEVEQk5pNUtCUzd5Q3UxWXQ5K05iKzNqM1lJL1BGYk9XSzJUSDR6aGIza1NITHh6OGJsTGoyZnFXR2NyaVBPZWd0Q3BUaWRNNFpJRDcxbXovRzZENDFpczFycTJQTlluNVprdzlSVWlXOWFLVk85cDlMOEF2NG5EVTBxMFZuQndGSzhEZHN4ZzhZZ3NvYms0WU1aV1Z1dE9oOUtZbi8rek9vaVZ0dkR3UGdHOSt3RlB3RkZPNnkxbHk5dTJsbmg1VjVGYng3ZEhTeVZGeHhtWi8wVUI3TG1tYnZiVGVkZVEyL0R1L0w0bFBFK3psL0dMc0V4ZUc2bEdmVEJqODJlVnEwTW5iV2d1cjBJUGVDMWpVNjU1MmFWbXI5dUI2T1R3U2R2UUNsSXp3YzBYV045NzU5M2R2VWM1bVN3ckRxN2w0NmxuK1NSdFhRZXZELzY3czZPRC8zZ1B2Uy8xc2NvMTJDK3JJWlhLdDRFQkxzUk1aY095NXdEa1R2Q2Y1L0lPYzFTNnk3TkYvcDcxcUFTYm9GQ3NzNTdSMlpjRVJyeDAzV2VjZklIZS9BNnJJRXd1OERTcUtzcWtrSzlLT004aktIbGNjRGFjTllyQlB5eHZPWVBuNENxUDRQY1hnN1dKNHZldm9VMWFTOHFtN0JHMnVjc1RscDBIQ3FwNUU5bGxRdUVYbGZpR3A1c2lpL053eXFnUWJzcTNWbWI1QW1wd3ltM0tWcFpHWHp6emxwWHMyWVFHV0YxNW9BNHIxQXNyK2ZGbWxSVmh6enNDM0VOdUVsOCtxN3VFenNMbmVmQWF3aWEvdS9SOHBlcklKUzBGQ0E5QkhhdEh5bEphYVhLd1pxcHd3WDJheVZBN3RhVG5UdWlvSjhNODhrTEdoazhqTDM2VFQyV0NOeTRPNTJBSXJZZFJFbzBaZnJHaXc0dVVZMWtiT00yUk80czBFZWxNRnY4R2pqVDF0MUtYNFZ0eDBCRnN5Z3N0KzJGdzFWRUt5c3IvNGxTOE55VVBiM2dPWDZXYk9wWFBzN0xFNDdGbnZCRGZ2SnNoczU4L1NKV213bTI1aXhZd3BMTXNhaCsyT0dtRktYL2VvOVU3VnVTODMyOGwwcCtuN2RPYlA5N3A4Q3lCdTNEa0xJU3QzQmhTWVBZNjJNNE9DWDhuVHI3ekszbE5mR2Q4SElYNTh6amlCZlplVHdmcjQ0RlA4L1hWYi8vVnQzYnYzSDBubjE2SnZHUnI5Y2MvL3NHZnY4SG95MzA2L25mLzVsLy9uWnNYTC81WEQyT2RQbi9tRk8rcnFjeDdzVnpmRGlHeFBHTnQrdWpiWVlaRGhqbFBubWYzVm9qa1k3SkV3cG82akhIQWlrYmtXY0NJcDVsNWZaaVBnejFLL05yemY1dzB6czJNSW82bHhxVXdoeUJyaUU2KzZnRXRXK1VXVnVBdEZxY05pTTlzcEVvaHNFdG9JMXFCMDUxRVlmek1uRExINnVOSkhKc2JMTWFnYXZPOGY4RjNLcG9sdDRKU0EwUGpTbGtUTHViVUlyak9rcVJSTm5wYkM2dERkbUdubEFVekVYaGhmZTNTQWZnRkJ4Q1hrTDhPUDhEeEZVdmJPS1ZuSWRkNlRTcWVLTFFxYzUxMEZlVUVyMEpRWHZETXo1Q1hlZG8wS0QxK2ZYKzVyNEtDUzZLOFQxMmFGYWM4blN4OW5IWExJYkRRRERkUFU2NUdiSTJrdXhsNWlzUXBVWjd4dGZSc2lwUzdSbU4xVmVGS015RUVHNkNZRU9WcmYzejJkUGM2a3hJNk1HbFpxU2Vad0tLQXJTQWhHemZ6OWRKYjEyOVU2WDd5eVNlRmREWG52elo5NU0razY0VjBQcGJjc2Z1NjZzSndLZVdyMDRoaDczQzN1UUIxVFdlblQraDdIWmxHcDlQYXBDL2Z3NCtYMjZxWHFLSTAwaHhyU2RieTNuSXNzbUgwOWpKcnYwK3lOZmtvNWIvT2NKVExDZDFkOUI2WWwvTDlwYVBROWlJeVdoOXU0aUswaGFNV0MwOWNBaDRLeFRPODhOc1Y5Wjh5alhMa1VNczZ5dFZSOFZUMEhOZVVTV1owTHR4dDNaeXcwWDhZL3NOSldVSnAzc3FzaXlObENkT0dQRTlhei9BKzdFemhVbjZkYUUxK01nWnVQSnlTUWE3NUZFT2U1N1M3ZzlCZ1htTFY3Mm9ycXhXRmtpUitaWmlFdDJBQ3MrRUpueGVKTzR6UHR0L2x5MXlFT1lkSE9iLzRwYllSZjltTFp3KzdjdWtrZkw4YTE4R0QrODkybi96NHozYnY1U09xLzlaZi9XWTc1UjkrL3JQZkN0Zy9oK0tYSFk1elhOWlBIejE4OUEwS2cvV1FyNzZ1Y3l4RDlGUUFDM0JWeVVKWGhXRUtCbnF1ZFJKaDgyeFN5a0x0VWJhR2RTL3lqcTlVSGcxMUJBbjhFVEozK1FmMldBWit3MDFlbGV0NFFXRXF4WDJleFVzajFKZWF1M2R0UUxsckRDZjdqVis2clV4MytPekQra1hQQkJsdVZVQXBTM21Eb3p1ckNoeU5DdDZDTkhEUVZEajZEZnREN2xiMjRuT2tMZSs5VytsWld0TERnWEl0ek1DNnNBMTc1eDFxd1pkTzNHR1VnTjl6TlQ4WTI2VXhPb1JuOFNTcUorbURkdUVydzhZTjd4elYxNG1sYkVkRUswWHYvY0J0bXZEQlhUemFCYkl3dUNxemViZXlhNDFHY1R5UGtwcjBsUFBselBvdUJac1JUcWpBMzdvQThwMGljaUdOSU0vSXpzaU5zdWFTWmc3UUhxVUZoOEhIZXpnTUw5QWllQSsyKzRYVTc2UTM4dWdFbk9wc3lxWGs0Q2N2R1p1MFU4N0FkdCtIL1FiQ0FpVC81QlhqdHp6Y1F2TzgvMzVna1NudjhYM2lwSU4veTl3VS91RHhSUmdSa1ovTDU4ZWtYVy9XMzZrZitkZTFHVFA4YmdtRDQwcTllT2daYitURlowRTZkU0Z1MnZqQWJJTHRqemg0b0d0dGVDQ1UvcTk2eVdQZXJiYkFCM0F0WDNGOTYzYU11Yno0N0tNUGU1ai81Y3RYZCsrKys5WnZmL3ZSNHorWVQ3ZnNsL0dYL1h4OGNQcnk0YjJjc3M2QmYrZk9XN3U3ZDI3Rmo1SGxGQVJyVzViU3BTN0JURStKQ1FLbXVUU0tmZ2dzbGdER1dCcXhKcS95emZGc0ZERDBxNldiUmpPVFRCWEtOSm8ybERCZG1FWXpsVlpCMmNxWnlpQlkwazNaYzFmdVhOai9jemltd2dZVy9LV2JvTUxCbVBUaUorMmttZnVrbWNZNVpSTW1lYnlIbXp1NExJREdCNzVRL01MVEYxRnVTSmIyTER0WGZQeU1nc3NDMzZheGZFVyt3Zzh0Zlo3ZmVHNjRSQkJURGQ2WlFSMWNLTmNldFpUeXZNdmYzTis4WDNGU3NiQVhycW5scGpVVU0xblcvZHhCY0NuSjBKVk9RSWVwczVDbm4xSUpqaFFlUzNPZm44VTErRXluVXNWNXZucEFoNVF2bUdZTnRYUTZYUjkxTTlyUnFVdkxRblhFNHVPY1BTQTQ3ZXhPdHNsU3ROYTgrcFo4UHVVUm5CWi9wWmw2T1hlTFpDTFd1bDJUSFYwbkdUNnhQZ1ZEZjgrR3ZCM3Q0TjhtRDYyUDhIVjRPenhOQlhVMHhYMGc3OHZnTjY0UHk0TDhxMFcyMVh1Nm41YUZ4c1h2bEU4ZXRrNXY0dDJWcFZ3OG5IalpwWis4QmJiOWtSNE8zbnQyeWVzKzZiV3grZTArWWVCenljZy9kVFF3d0VHemRPSXM5SGZ2NUY3dWRFRGhiWFJ4NzRXamIvRGVDaklxQWorSjF6c281TEo3TWkvQzd5V1hZTTBsSzFkQ3kzYXFXSkthSnpuZ1RraG53WG9tdGZCNy91RGg3bFgweXRzNVVPcmQ3UEI3OGlRZGRkSWVKZTN0eU04MzNudm50KzgvL093UG8xei93WWJTbDNZemFnclJXWDRWQWI5MTYrYnU5alduWU1WZkVxRlpZVlcwSGp3MGxBRjZJb3doR0JxSGlpcmprK0ZwR2h3RlpJKzRaNVhFVDJwM2x3WnNLSWozaG9ZOTVXY3JSWDV1QjhNdWxRTTJaazdqQlZPRFYvYkVqMEQ0UGZHVW1xQ2l4R3RJbmxkWU9MLzUvU2FkOTBQRFBQdTlmNGxYMFJORzJiTlc0VEo4YVI2TlVvUGNlRk44d3RXVDhNTDdOZHhpK1MvckZzMkd1RGtQYTZONTRWeFlwRE1CRFAvNnZQMUc0L25sN2RiWUJ1K20zUnFFZEpSWWxWUEswMkRNd002WFg4SEhZN3gyTktEZ1M1ZnkyRjdydmEzSjRLQVZ6ZUlFZC9IcWJlcU9UTUhEN2l1SzAzc1RFVDVkYkEwcmhmbisrKy92SGtXWnlpUE45ZXpTOGt5dUJIbnNucUxRdkw5Ly8vUEdnU3UwSWVjKzVjT21rM3U1Ry80dnZxNU9sRUpOVjdyY0lubnk3R3BJUnFRTWI0eGV1WmdZQWhTYTR3b2R3OWxEbkZOUFVjdWhqUUtJTW9vQ3lOK1VsM1JKRHpkNEMxeGd3dkJGWnl3TTNsTlArN0xzL2NSN1J0czVuNk9FaEs3YU1Ia1VDdUE5RTFuU3lUdDBleDdlS0NNdnoyRkxNM0xyR2M3U2VyYisycjNuQUxmRXBROWUyeVRRTXFSYnozNEw3aS9DSjdKUm95UFlPWW9SbkFtSG5lbGE5SXVmZC9JcS8xVmcyb2lnL0tRcWZTL2pDanFLT0ZyT2RTZHk4MWV5ZGZwU3RpdlRJYmJRMitIMVhyN1llcExKWWdmODM3eDI3VC82emUvYy9ZTS8rdDZuWCtxcWdiZzhML3g3SjlldTdLNmt6cTVIZUMxejROT29jQ0V1QktzZ3dZRVptR0RJU0hITXhBT20yQXpnM2JPbmFaeXh6cmdGTUs1K3FWZ1NNZmlYajJnN3BFVWpCa01lMTRSNW5ydjRFUkJ4S2sxNUl3amk5cS9CVlZ6VEpLM1FpdFE3Yk80Sjd5ZE1ua25udDZ2NGIvY1JncEM1WUlXMlVVU3NzR2tjbzBUOFZvWWxKQnBXWWFYemNKemdLbHNqMjZ3RGpYSkw0OTFjMm4zeENONW9LWjRhRXRyMjBrMTZUVTI1Z3o5NjV0MDV2OUlZZlgzVmVrbnZXTTNLMXNGUzduYlhYYnFVRHF4N0dkSmhSTUhnK1VtKzl3NjJTU2RCR2FNd1BFODV4WEVyVnlQVHJsaTQ2Mk9SR2Vtay9pa3FLMUl1di9WMi9HdXZkajlMUjlUT00rK2VacDJyenNvc01QN2V5NXBHT3dSdGpiMTk4MWFlbjdaOGYvQ1VCYS9NK1dBaVNVT0wyWDNXTEJ5OWg0dDNYWjRFOThoZVh2UWEzcElJTzdSZVJyRTdCYjg4RHF3dVhVdFNaYVgxdDl6S1EvSlR2dFIwYWhKS2xlbkV0cjZVR1dSS1IwZ3BMdVY1WXBYcGtrYmN5QXYwL1lhek1pYWR1OS9tS056Mytid1BSN3hyNU1rejJOSlVOamJZazMvNDR6NXB0RXNIMDdUODZPT1ZmOE1yWm1WQXBzUDVpemhVQmxLZnpnL2daeGVtSExCZDVpVUdQK1VvVjFpeWt0VkcwUjM5cWtHTW1QWWpLY3hhMW54NkxlSDE3bHUvOHZWODBucDEydS9uZUU1ZlNQbmFONzZlZzREdTVsdFdIKzZlUDM0VW1kMzlyVXRYcitZQTZ5OVp1WjZkUFg4ZjN0ZHpsa0MrL2RXekF3aG5leWltZWhSdHFHMVBPVXVhaGptRVh3Vm9mSkhFTW9wdmRWVnNXSkdLek1MVnNDUVREV200cklLbkdsZmdZU3c0a3V3dmNCWS9sZXk5MzYza1ZBenJ4YktNVm1JeXVwZmxTU2ZOUE8vSHJ6V0JRU1B2T3pNZUpRL3UvdFYzZXdJNzcvYmpKMjRtc3Z3VzBESldsamlLbHFEWTNlWStPN1RhZUpKRitpcUNESTk4bDUzQUtLYzhNeEZ5N25PTE1IdTc0ZXE5Y0pqZXU0S3F3OXA0TUdrd00ycjNuSi9TRjArb3NuS1NCei9YRWkyQ3ZoMWV6VExJTy9qbSsrMjFWQy9IMTZwZUtaU3l0aktSQTA1aU9TZ1h6bFAvOEJHbnJIbWVOTkp4RzAwSEJQNm5uMzVhbDhEMTY5ZWIzZ2xaYzc2ck94ekg2bFVHOTBIeGh0ODJzbEhXMEk5T3orVkw4S1d3K2UyRVNjZW5IY2xNd3FVVXhOc3kvRXFIc1NrZk1FNVRIcisrZFpjbUYvRmxlS05PbjNPVmdaOWxkQU1iamVSTSthMm5NQTBzY1BFVUgxL21ETS9oV1JITEgrOEZkN0FFZDVlMEU4QUZSN3dkV1liWXl1dW9ETzZKV3g4c0RQNmJyN000YlRDSFQrNUtjWjh3WlUxNVF3UEwwYnQwd1Z2UzFkNFlXT0lycitqT00zamxmZkM4SEpsK21kR056dEs3b2Q4OTFHVUMxWnhMMnFMT0wvVmNPdUNUZXNtZnJFSks1NW02cXhzbHRDVmxGSFZjSjVsSTV1NjlHWGNBZmNGYXZaS3QxRWJEREJyYjhKL2w3SUd6ZE9USGtmVXNKZjNYT3A1dytQQnY0bjc4Nk9HclA3eDVhYmVHWklROUJGY2Rha3hXdENkZ2ZBYTV1YlBBMW5DZVFoRlBNRERYTEgrSGsyRUV2MXhQNGtsY2RPM0swL3V5VUREZEpjZzdsZVAzeEhzRy8xeXBwT0lJNlFpeHlwUnZQOGc3OEVDdkFHemxTQmVlbjhQcjc3eWJNa3BqeXRzUCszZ09YdWdlZktkOGVTZnQvZnYzSzFBYW91RzByemdRTEpkR1Nra1FYSHhEQTRGcjNsb0V3VC8vL01ibkpXVEJLUUk5K0ZGMmhUWERRdzB0NmNHeTJ3V1IzdmYzUnQrQ3QrcUtRcWV3NEZFNmdzSEZLTktMVVZyeXZVcWRwNXJiWVVobklnc2ZYOVdpU0VlU2hqTzRUN255ZVpadWVMTm9XOXdjUGttanhueEY0bUZjQXU0M01tbEYyZnNnSU41U3RCU3hDd3hsRFh3anBjUER5K1VGbUZNVzNnaCtENjNpNUo5MFUwZGdEUy9sbWZpUjR5cVROSDRIdDNNeEhjVVByZDRvMjI3bnpLbGhHdjdaeTFEQytNZzduYllyNmhUSXduUWZQaW16c2h2NnAwT2Fjb2RHZUlxTE9pOE42SENCTWJoNVAyRm9sOThsVEI3UDNrK1FUMzIzekdpbzRZbjc1Sms3V0o1RFJiTlhEdjBLUDZTM21zVDd3dHB3RkQ4NFhNeEtnM0doU01QcTV3TlBUMERVVzhkd1dicGl1WjdRSjRCTGhzTFZwSWVETEV2MnJRMzN0ZFZMMTV6OGRScnI5Y2J1N3R0M096TGtpMzl5LzNIcjZ1N3R0N0tlUG5YLytlTkx2L3FydTB2NURNdmU0U2NGK1pmMjUvakc5WXYveWZVTUF3M0ZlbWdGZndCcnM0eDdVMkhEVEhlTkFITXdWY01RNTdmclpTd3ZFMW9ZMkdWVkJOT3dLVXkyWFJEekJIbW5VbFNNWjhFeURtVVRRdmY5Tk43UGJ3STdGYnB3WFpVeGJneHhWUW9wVTJqYXdKN3l4VTArK08vVDU5MkV3V3Z1SXdoK1QzNTNZWER6REg5bEdXSk9BekhFTnVNcDRCWFJLUXdXMVJZdVp2aTk2QXJlNFZsaGIrNlk0cEE0Z1FENnJmZUh1enpnODJrTGc1OTZnSWZmOExoK1Bjb3BTc05XenZyWjA2RzZKMlBxTFBVWEphRitLVGR3TGNQRDY4bGZ5emdOMVBGMnlnVFR2ZVZrU00raWtNOG5yQWNQZFNvZnhTK3RFWWc3SHVpTXlKNHl4SjltU1JZUkJFZVpWVWF4NkZtUkpxbjQ4UENrWlc5NFNZZnE3dFRLdzFoRDRveDBwSldINzdRN2dwSitjVEY1NUlObzNvUGo0NWV0NDQzUDJyaTA4b05mUlF0V2VaT2M5RnJTVGgyQTFyTHlmdUc1K0E0bUdvVjlCVnNaMlpOMUl3YjVYQlBnaFFaWEo0ZnpyalJ2OGRKTm1SUHZMZzU4bC9vUkZ6UDNIRlovSnkvYzUrcG9wWEJEaWZTaDNydWtLcnpUSEtjbzdPT0g1cEd4WjA5WE9aMjRDczM4MGx3RVBjWXpoc2JEK056UlQ4YmtRWk15TDV3dWQ5L3JqT2xSdnFSbis0dlhFWXJGdjN5RU5QSnltRTZQL0VUcVE5SmhPMlVqb2FQUGNpalFveHpDL3ZKOTM3ZjYwaFFySGgzOTFYZXUvdS9mZk90MjFoZG10amJMY0s0NDE3T05PYjFKckp6RG81aTF0WFlvaXV3RGYvbXdueHEyT3dJTDByVFVUbnNyTTczUDA2TmpHdXZuTEJWcG05ckxtUEhQRXZmWVVPQkZCRU1GQnlhQjAvUFROeHFCMmVGVHp1eGFBaEd3bEVCWm1vZ3d5OG4xY0pMZnFqeTFwdDd6SE1FakRHbncxbTVleUxwSkNzWmttZk5obTBqalRyN2ltMlUvL01EMUJjZnY2QmhFRm1Zbk81TE9zcUN1NlF3dUtoT084Q0lBNGs5emRmdUpNWW9yamI0bi82QXBpc2d3SmNCcnllaE1XRURvTWRFUmxaYUpvdVZ6TlB3MDNPRXFNU2x5bEE1dFdTM0JXZVBKUHlUcWxNZzI1NzM3YWZacnYwNDVtV29LajZOOGNrNERYc1BCT2xSbmt0cW4vempLc1pNcm9mc1Yzb1hPbzh1WGRqZXo0UHBpWnV5dlpUM3A3YXZYVSs5WDg5MmwxSk55akRoeW9FNzlyRmtoNERQb2hGOGpxeXNqL1BxaXIyMGFzQVlvbmM4aTArK2U2MUlLRWRLb005ZmFnNy9xclJ0SXhFNDlJajEwVm5Hbkx2SEE4L3lXM3FmcmZMbkJSTnlxMC9DSi96aEM5RHAwd29NeWQxN3JVUm9kMlZDQXpSWDlLbTdrbGNKa1NCaWE5a1F3dE9lWmtyeVF1ak5DN1NnMU9kR1BIclVYWUx1VFN6b1ByaUNkajJWdDZoM2VVUlNoTTBVR2R1bzQ1MFh3UGZiZFpvWGhpWkhEV291TnIyOHVIRkhmM0djajgwbUFOUzJYL1BOM3YwZ2JKRGQ0YzJKMGxFc2lJNHV6ZEdnT3RDK1BrN2RuYStTOVNTUnk2QXhsQTIxOENITEZsMlBxVmVUbExHMzNZdmpyOEpwZ0ZWd2ltK0ZsTjJpb3c5REhrRHIxR1pmSUxNWG1tbFVVRWN4MjlJK2VacVZINmlLWVJEYmpRNDlMNk41bldmRC81SEU2eU5SbjVQUkpSaTJQNCtwNVlTV1I4a0tieFFkUDQwOTM2RXNhYitqS3FxUG9naWNaNnRzVHJnMmFNTlM4ams5MDZzRXl6ZTlaRG1xeTgxRjV6eU8vcDRuOEpCc01QdnZzczM5KysrcTFnN3MzYjF6ZC85dzFkdjVsaGV3RG1ObmdZQm9FQ1lCQXFJUnBQQlJtcjFpbXF5Y2pEdklJSzQ4bmFZVHVkMDZGVWpBdk13enVFQ3ZwN0RsdXd5TTRxV0JocWRFK3R0d3E1K1NEdy9UNDhzREZCSUs0MWVnWGprbWFzSENmdkRPYzZYcFJqVTBqQ0R3KzRhR3RTbGtaS0FuTUtvamczSElDMU4wMStDckZPb3JHeHdkRStDYVB1M2lLeWZOWmxsYjErRFZDbnNhbFRPOVpaWUxuM3ZOSGVuNmtkVjhLWXQ0UDNQazlTMkpNMkpUNkNOenk2Njc4SnpraytlaGFGQUN1cXBiUXJ1TmduVjZNNGoyaE5OT29yUnlsREZpb2hIWnQzbGlubEEyOXl2YThqNE56T0FYMFRGM0RiUzVXUlBPcjYrUmQvbVdLZjlXWmNvU1JHR2tFWlZpVkpneXM5ZXVOTEJaZXlnM2d4Yzg4a29mcUxua3B4NjBjK0xFeW0yZmp1ZWZoNDhnUXVaaDRjWjNvQ3FnbEw4dFFxRXhGdWJZT2cyZUE5RkprcjhDZHVZQjlYZzBkaWgvY3hYbWVNT25Ic3RRZUJ6ZHB2WmRlSEp3bXZYZndHZ3RRL3FhTmU4YzdBYjR1OGRNdWRQQkNmMGNodWpPSzVDRWpCMUhHNWNkR2I1amE5SFdGQk01cDNDTGVqN0ZST0pIRnAxRzBjTEJVcmk0ZmJwMFVwVDJRMVNCUjMvdlJoV0N3NFFkM0hjQ2x5S1dKUXNyNjdOWHp1aWlMdzlZV3Jac256ODZVb0l6TGoxaXVhVTNwT0tLL29vYkNwZDNyK0Z1dFBMRUs1ZEdUSjM4dmZjM2ZTMi80bXlYZ1MvaHo3QXlCRWNKV1RvZ3RZV0VnRWVqSEE4TzBtdkt4VnQyZFVWbi9YaFNDWGpMVm1zczlsbFFVYVFBMEhrT2VKYjJWQTUxZ2lMQVRrQWFtUWVVMGpTM3hLL3k4NE1GRGVwY0tVWGxIc2NBSURLVXBMbm9oOVRhK3ZxUE1ScSs5Nkh5RFpoMVpxRWVaVE9DdnFmV3JpMHlRdDdQQktZTnluZENodFIrSlB3K2VjN1ZTM2ZzNk5BWkdjVkQ1dVR4SGhSUWZRcGZta0xRL0w1eGdUQmc0dy8vMWJzRUZUL2hpR2VKMFZIWDVCVlk0c1R2UW9GNUZvVWJJV01tc2Nlc2ROU1E4QThPeisvTllPSHpwWnU4SnYyS3FuS0tFai9KOU0zVzIrTHZvSFJ3R0g3OEZzTDU0RjRjR2QyL0xyMDBwVUs1K1d6bmdYcnh6OXp4d1RCWlNrQlBYRi9relpmbGRxeTcxcjlPQXVBNWlWUjlDM3F3bVVZL2dGSmM5WHBwR3FOS1JTZm5KZnQ1SjVwa0Y2TDF2dGhGTGxsd2JkSmdGM3RUZUYzSHN1N3dmZmlzWHo4Z0JHUlFveUpSV25LWWRWRGtsWGZGTW51S1c4b2ZtS2NkdnNQMEdaOEZpNUsyMjZhNjhzOHI5b29FQ0JHOXc4bnpnMEpQQXdQK09wb0tmOHo3RW1iQm15YUwzWmI2WkozUkhXdXR1NGYzQzVHZmdnQ1h3citxZ3JlaFF6cXZUZGFadlY0VUV0aVY4cll2Z2IyTHk2TUtleno0S0ZjN1dEc3RMS1dzeFBURXRiZGRYSXV6YVBFcGI5eDQ5UnFVbXhIeVo5MlhxaTFKbHpqN1Bpb0pIajU5blcreTkzZjFIVDZKelV0R3ZML3o3c1o0WEljWDJML2RQejliRlNIdm0yem96YkFtbncvd29pUWlDSVlndkRiZ3duZndURUpKWHdrTHN5eEQ3Zkx2NDdPeFpSN2d2ZGI3STFZWFBnVmxCbWZGV29LeHRteXJLdTBXNDRTbGwxK1BVMGtENkhGaEpuU0l0WHIrMGhJaEExdFNaQnIwRTdjSERIT2lRU3JXT1ZJK25nYkRjWGtUQkpuc3NxTFhicDhJTUJvRkd6b1lBdDhBSWRrdmQ4SjczN2pvVVE5NXVJVlczYWFHR1MvSTVHd0c2ckVad08zYkpFSXRaNXNheWt3NjVCSlJpclZXU085amhjTjhUdXNIRGZScXE5QlRvZ3EzQnByTUtiRFFiNmpwNTdDZ0hXVnlJalEyK2MzTWY1WU9Ucis4L1dPNlBLRlZ1Z0d1eGtHNkZWaWVnbWN4aThUbmFzSlpzeWxQbS9sVzZFd2ZtL3JYUEYveUNwOUFxeTMzZTc4TmF6NHYrNFVQekpOT2FHRnF5SW0velUwNjU4SFJjT292L2N1ZFY4TUpRYVNtdDZhejZNbkpwOU1UOW9sdytaR0h3cVVJZ0w3blFkU0VOdVdXVy9zQnU2dlZuZGNZTGIybkJRTzg4N3lYdG8vZmd3eGxNNlVZcFN1QjNaWFVySHl6eXo1SzBubGJhK3FOVDUxWW9VR3pTaUo4eVcrOHB3MTE1SGFybkdSLzRxVnNSb1IybkxxVER4UnVLMWJaMWJvYUxyeTgxN3prK1liTE94Z3FFNGh1emNKVVYrU0ozYVpHNVZTK2c3ZW5qSjEzcEFXZmgvdjJYWFRaM0xldmxmU2FlNGpTRUp4VlBzeFYrZC9DODY1YlZIem9ZYjJUT0pEai91M01EMENMdVlWd001TWl1U25FNkFZRk1jM0c4ak53ZjhNMm5UZDE3OUd6M3dhZjNkKzkvK0VsY0Naa1BPajc1eitPS3ZQL2RIN3ovM1diNkV2NUV1V3IwWVg2b3FCOWpFMmhFMWJjU290dVRSYkhXSDVUS0VlelFTQjNFV28wMWxQeE92bkpwQUh3ZnoyS2hXTE5tanpSWWdvWXpndGFoc29xT2YrWk5ZMWdOUUdYT1JXQXdWa1c0aWxmaTF1azd5UnNCMHBPWmVUYk1tSU5BbEZPbHZRbTB2S3lkODhZZkdDR2lBdWxSd0F0V2Rodlg5anZWVnlWS09CdlBzZ29MK0tDc28yd0RTcVVUUE05NDVWNkZIV3gxRHF3eFEyOE5oK0I2RDFaNUhvSFhDTkFyOEwvNlYwS1RUdHI4VHo1eGFXVGVodS9oUUJMTHM0YnRwL0c5dnNxTCs0OStWaXRWTCsvamp2eXZuOSsvMTlVYnZqdDI2K2J0M1pWTUNOekp3dnlENnpjTC8xV3NYaE50NmpubUVEVUFBRUFBU1VSQlZJN2ZkZWhmWlM4YzROWkdwdXdnaEkvcVpmQ2V0UHlJVGF0dU41cThrM2FmOXowek5mSExKOW9zL1RNdzFWZDVGRDZCTTgrVXJHdjlYdms4RHh5eWJOMSs4K0EzNW0zMzRwaDZhSFVuWGwwSW5Rakw3elZoRlQ1UVpIbG5MVEE0Vm53RVNCS21uRHgxYzBHNEROQlMydHNkTFBXNlhjT1RtV2tYUDY2dzRyelJwUXdYL3BBSitTaXVLbVo0SmQreTJoWWZwWlZHZW1tR3I0V2ZPTWJNUy9oUG0wbGErYzBacENLVzBSR1lsR3ZkRUlsdjNTZlBpMmRML20wc29hRHBaMlU4Zjc3YTE2V01pbHIyUmpzTDlWRTY3aWVacUNyKzhZYzZ0dlR5TmtsSndUcGpCQzdGc3p4SXZhZnNwZzhjeThlNGkxaTVOb3dZWWE2bFZjL1dCR1BTYXMvU0oyZnVLb0ZQUFIxbEZtUS9qaC82ZzA4ZjdINzRrdzkzUC83WlI4NEgvcDNuejE5LzhHVXExbUM0TzdacHdKQVo4eTBmQ3EzbmdjTEFXQXBEN3k5d3lHc0FsQ1lIZWwwQnViTnNuMGE1V2x6QmVqTXNaNW9iZnA0UDVhSWNLTlZLWlpRQ3hWckJhb09rZEpad2FsamlCUlU1ZC9HMW5pdm5xK2NqNkQ3ZVprZllROXQ0ODV1UWNkcXJKT1YxcFVJYWcrMTBGTndFd3hzd1RXb29UNzRKbnZjdjhYMGZLZVIzN0dRVi9nUm1qMURjbEt2cVIySm5SM09IZnlDdkR3OUc0M0poRkZiZUhXVFpDdVVMYnVsTVd1VHUwK3g1cm1hTThraVNkRWlzK3NESUQvaTh5SXlzZEtlaHV5ZUxSVUVjcFo3R0pjUGExbEtxL0xNRHo0UWlPQjNTWmE5L2FRdkFmRjc5bk83Qlk1OFArK3Q4MnpnMlBoVzMvTGtRZVJKQ1ZlOXRFSXVvUlZmd0t6MlJwMUVTVFpnLzR2VWhza0xYWFFlcFlla1krZWZTU2l0UEVsQ0c4a2lxTXdNUGZWMzZrN1NsYWF0dmRTMjhTaWNrZm5DWGh3eFVEdEFld2E2TUdWYUdROXJGR3NJditZL3FhbjR3dEFPWEFKNVExMVB1eFN0cDNPRmEycEpHc3VGSjM4bVQ5L0FRRHMwSkJCOHlvMjZldklqU1NsMmFDYmVhZ2lGVDZ4d3Z0akI1L2ZRTTdpaGQrTTgxNVhTRkNaN0NIZjNwaEUwQXluT1F3OXJoZHhyNjNUc0NyQTV3c0U2dVdLcktzSEtqY2gwNTFPK1lRT1pidlh4eVpmZnBKNS92bm1XSWZqR2pJenY5S0ZobDF4OGVYeW00eFRsMVNzRnJ3NVE4R3EvZHVONjBrNFlTOWc0Tk9nQ1R4clpwMDBOeEV1NCtlL2gwOTZQM1A5ejluOS85czkzM3Z2Lzl2LzNadzJmLzgvT0RaL2YrN0FlZjN4LytmRm4zNHhLVTAzejBTS0h4UEpTeFlUNkdkMWhGU0JLb0F6MythWHlyRkNzNzRHVUVnaHVBTXRaalVqaEVyUXpjQkFjREV4T21iSTByOEVhNFdqdUFKNWdWYk5qZXF4U054NlhjeUZZRDJLM1FESlVvVmhVUDE0dFhISFcyRkpaOTBheGFLeENFVm5EeUNmTHJUUW5xK2RtMVc1b20yUHN6ZUxvZlZMSHEvYU5VVTk0TFpTU2V5bFA1SnZJSVhUVlgzdVdWTjZGNytaNk84dzBoUWZrRWxOQjRMbTFiWTFYT1hCcnZsQTkvZkhRUEc1ZGxvc3lVd1pJM1BIYS9rSk9uS0NtakI1MmNEc2ZRaWg5V0hYRXI5RnpkMEJENVRzWEJLRW9qdEIwRkJueGN3OGZTblRJSGo2Wk9YVXo4ZnRwUk51Z1c0Q2JNaEE4WkdEaUxubFZPNDVLSmtoTXZpSnN5UnZuaDEvWnlXWjVKb3d3dURSWXFoYXZYYVQ3eDNtK3c1T3NvU1R4QndzOXNtVFQ2SWZ6S21LVnRaQ21weW9mNnpzS240cFY4TlJZVVIzSDdyWFBPbzlEdHNzT2IvTWFiZGhoOSt4Zi9ESTF6bHdJZXhTVnd5RFdldHRPSXJJb0hVM280dWp3TDdqcVdPUnlvQy9WRHZYT1Y0V25vN2xRMW9YaUI3OVBta1ZOdUFCM3hhUTZlQmpORmxGNWZ5U2h1YWVsd2VIN3ZZZk5UZUw1V3dnMUIzbTJaenc2VUtrdTc2aDdHbXIxcERYUHdrVSs5ZEozd3Rzd1Q3N1dWUzdtMFFSM0g1V3dHWUkyQ0tkaU4xbzZ0SGV2eUhZZUt3QXN1Y1ExUXJOLy84L2QzZi9LOVAvdnVuL3hmUC9vdi83ZnYvL2dQbXZHWDVNOHhNL3hLZkc1NHJoTE5QQXN6NUIxaGFXUjZPLzh3KzFWNmVNTlFYeVpZdGxSbHU5L1ZJa3lFb0cwa1BadUtYQmZoV0QzK1dIQ2QvVTcxTkFTZWZQQ2czSVZwZ0o3RktXODlzekRpU0U5RjhEUHkyZWpscEc4alVMZ0drTVFUcDFHTUJRTWZEWldRc05pRjBpWFQ5bHloSWhTNTVqa0ZyVTRrNVJuSzZFWnFGWWF1d2k3ZGVVN0JxOEZIY1BNUFhiWU5iNnFoL0JqbHF2RVQ2TkpYc3ZFWXZYQmlaVVZCbEs1dHFKWTZ3TWV1RWtqbUtqQzhpYkkwUExidld2cVg4V0dCU2FtNlBEOE92d3g3ajlMWWpnUC93dlZyNFVNNnpCUm82ZHBaRUMvL2d0UGM5L21CanZtOWNGcjh4cytXbVlZa0dDRW9yd292dU9nMDVXVjVDUENjUFBJcFgzb1Rsc05yOThGQjJscHNxV013cGUxT3BlYUxVZzRmbkgvQkFwUFdKZDNBSFpnbjF2SWt6Rzl3bW5hTDg2N0tlc05IdlFpR3lYeDcwZysrWUV3WVBJdFg0dWVkK0ZyZmlmTThyamZwWE1LazNYL0dLN0lwajB1YnNJbmlMSHlVWGw2V0xlWHI5MXhYMDdHYVFIS2NwRGhEYlIyS3p1UkZadUtkOGs4V3VEekFmTXdmbjJWU1oybmIydExaTTRyMU1EUDJXVjJTb1QwOHBHUEllRTlSdXJnQjFBZTRmbnZtQ25pV3VRN3B4YkZjZlRtZ01oTjg4Wkwra0paMURqOWx3VkZiWk5rYUJmcTZnRFluSGRxbFE2LzhqcTYweS9OK0RLcjNQL3gwOTBkLy9QMC8vT1B2LytudmZQZjloMSthYjdXVitBditITi9JTVYwbjNYRVNNejdFWExOT01wVzR2cE5PNFlaNWFlQ3Z3d0IrdjdCNTl5SkRCM2FybWVkWGVmY3NpZ2JCWm9JanFza3JmZzFmVkNUbW5EcndKQmJreFppNEdsYlgyZ1VoekNNTG1JdVpaK21Sbkt5VHNXNTdYSEgxclFTdVNrdUdWb2huWHphdzdFSzVGQVJoc0pSRUpWaUhPeFZEUVlGaDV2TmkzQlNDZDg2Z3RENDB6YVcvYzh0czZ4cm1KY1Y1cGE1eldwZWxGa0lhRDBWd295WnF5VkNjaGpqd2FQa1JaR2RiNmdwc1dlMmFpdkRoNlBrU0tEdC9LQnpyTllGeGh1VUxTblJycjN5U0xBSjRzSXdxWUJId1dxak5GMlVUeHVWTmFFaXFDS1lGVmhjMjY2RWYyMHMrNGd4V05HYzd2bXRKVEtDN1dTQVd5L05jWjg5VFYwbDdOWi9nT0k0SmhoWnBwdkY3ZHNHQkZUelByWStBVG5Sb1hoM2lMTm1SbG5JVDZ2dExmc3FDb3RId3pBaXpWa3BYMG5KVDROWkJEbGxteFhmOUtQMFl1S05vakRBdVpkaUpwM2E1UFF2NFoxRU84R3hITlg3QzhpMXBVa2xnS1lPeUozZHFBdDdEVTNLTzkyZ2kyNTNkRG4vRGpvYlhrU09yVG81ZWg3Y3N3TWlwK2dVVFhqcDBrME02OTZYbzhDR2pqVlFrdlBnT0szOUpheFZIS0ZLbGVwZUZROUxvUER2YXk3T2xhMDZqTzBpYlJPOU5Qc2drNTlzRW4vdkhaNllwT3ZNTGFDbDlvVTBiT2oxZFNuazlydzdiOW1QeXZ2Z2ZIcWVOQmJIaWJMMjFnSTVyYVRzdnM2eTlpazZIU3k4RXZvdWMzcmlXRWRIRnkybGJxOE9oM0I5OGZpOWN5d1JxR1BZb1Z2Q1RuRnJsT01BTDE2MUM0a0lMZmR2STBjSi9hMWNkT1huN3lxMG8zbnoxSkdrdlpiZlYwOUQxSkc2OWs4aVhEdytHdzhVdkRUb1RXTHZkZ3l5eGV2d3NuY0RCMWQxSEg5L2YvZVNqVDNZLy9ORUhmL0M5SC8zMDcvNHlLbFk4VFgzSGVzUGN6QXBhNUV2d2ZkWFZUUHNhZG8reTBZalN1UEp2aHNFQUVEVG50VnJrTGxSWlJsREpFSUV0ZzhOazhYMmZGK0xQZnlmK0YvMnV4a2d6SXFDRW42WFdYalJ3S1ZNVjY0QmxnanVLMmZJcytEZVBCcldWNnk2dnk0SjB2NVZKY2JzOEM1TVBuWVRXYjVmbitYMHgyL0FpenZtM1FtRUhSbkZJNDZGY0tKVUtmSko0VDNHMXpHU0NnOUI4ZVZiMmxOdWhaYXl2NW9XU0JwdzZ5VTBPZnpMaVhSTmdRd3VMcmFmb0owMktDbmZ6ei9BdTdoS2RsSlB4TGE3WHlaM0VhcndjWEZnVFk1VW9TK1BtTXovTkVQRHVuUnNMMTQwbnl0eXZuN0hpeGFOaDVWOTh3bnREOGswdlZibTFzNkNzdHJUU0M4TmJkS3hPYXBWRG5paGRjbG4vdkQzbFlZejB3bUxMcWh0OEJuZnhkOEZWVHpTaitPS2RQSjdCVXJaVGw5UmVvaG9mSmdmMlVvamdHK3BPV1BXeUxGWFBGTG9EbkFlMnVKRzMxRnF6RFgzMURZYnVOZUc2MnRCWlJudDJ4c21EVGdIOUM3K3Rmdk5iaDRLT3ZJbWxHZG5hNUV1NlVORDBDNStORDRXMDhUVHd6YnJQV1ExNE9USzNSbmxyV3pHNU4rRko0UjduTGcxK1hZMHlGNFkyOUlpZnRtSmtRY25Ebnd6TjZXYVdXV21UeHhHQnM2UFFGM2lGdytYUS9HdWtlREdiTUxnUUtOYVd6VjBWdW5TT2w0S0xkYW92WDJkVFF5aDlhdDRtQjdHRWlYVmpQWW5SOSttOUQzZnYvK3pEM1FjZmYvNlBQbnI0NFBmL3hROCsrdWN0Nkpmd1R6NklTaGdKdHJZY1M4WVNCNVhQajJxQ2lnVlpTVXp2cVNkTEQ4UFpqZW11NmJFcDRtV2x2bEdXbU5vcmhLK21FVDVGR1k1d2psQkowekkyQnBrVVNGVnZqU0hvUlloTmFsaEdjeG9sd0xKdUpRUlBRcUdTNUs5QUJEZEJZMXJsTEtVNnZmR0ZXRWpLazI4RUNoMmpRTDk0OTI1ZmtQbU91QmVLWTNwWlEzTytvOElLSTJ2eGh4ZTFsTkxldUFvTXl5eUFUc3FrWDUwVXBaZ1Bxa1d3WXJXa04yY2w0TDk4cTVtVml0SmcyY3J3S2tad0JEMVdZSlNBUTY4N1NkQWNoc1pKbDNLZXhhb0JCMDRYMHZQWHdON292UnlsZGNVdXRQeEdsMFppY216eElHNkRXRG5Ua0laUDlUSENQL0RyT2docXd4UDU0SVp2aG5SNTBmenU1QWpOSFZFa3YrRHpRT0JiOTJ6a2NTVTd4WnpTVlQ0VHhlU1QzcENTMU9EZFdEN0tzVVczYWNQajFFeHBQTWd5T0xSNkR5OEtzM0tYTXFlTytSeUhYbmdrU2VIME9UaktLNCtoUTRyTWNKZDhMK1cxNktNUVEyZmVEZXpoUWZPbUxzUS96WEJWRjlEUldYRHE0Zkh4djh3RUVkb0V2S0dNd0pBUG5pNnliVWtkR2w5SENlRWZlZENCVkNIaVIvSzRodmZnZVZZSHo3T3NrcVZLdVlKYlhxdWJsQ2RJb3kxb3F5MHp2UGZiczNvbUxNVW5rNjBYc2hYNzdPSXFTMTUwK2dTY09ZNm9oZDMxeTlmalVyeVNDYXZudTQ4ZmYxS2xlL3g4MHhkSnJ5TklwdDNGek9sUXduaHgrNWJWS2xrQ2VHa2RRV2tYb0szUzhIZTg1WEZHVHcralVMdjhNMGFlRlVqNUxsWmwrck43bisrKys2Yy8vY2Z2Zi9EaDczMzArclBmLzdLM3QrTEp2eXAwak14S2paN0lCRTJHUUxWQytWalNPTkx3VktLMVpPTjdmUnhyc1pXYlNxREhLQlByenNLZU1ONlFMa09JQ01BclFybzY4MWFLU1FGaXJ6Y2VRVmFKbmwwQ0JuZUlYbkZLUlAyMWljdHJ3bTY0OURqQ3B3ZXp4RWd3SklzMEZMLzZRRk9mUzZnSU5zdDBFOHFrNjVkVHJWZ2dTTnVGTGhOMjF1TldRVVFJLzRMd1Jya1J1aVN0QWpFcGNISnBmVHNLaVNhSHpKVFdaeFdGSWYvaDFpblpQa2dCVXE2bGs4VVNRQkhqeFo4b0dSTVB0V1FTUHp4RG02Q1JXazg3UEROczBoQ0tBL3FxNEJmLzVIMmRPTENTb3hhUGcxZE1ZaVZUaDZXM2NyYnE5V3g1cGNSZWJXc1R3Yk9YUDZpR0Iwdko1M1hMcWFLb1FsRlBxN09jaGp5ZExINUx6d0o5a1ZIRjY1T2w1RHlyZys2U2l3dUdTNE84K0R3MkdMYmFYcnFVSWIzT01aS0JiNlZ0R252S28xeDljcVlodk9vUUY5TTNSaGx0SGVnd3lReXJIMmZ4SWZCZEtieThtenQ4eEk5MXVOSXNsNFYzdGN3VkZtdFo5akMveXRZZDlFNWlKVm82QWUwemF2RnNNWDFoNWgzZXE3ZVRmTkpJQjZCZWxreXVrUTVhdWJWbSthQjNaQkJ1WUxKYUtXRERjSmFkRUxWV09Od0VmT2ZLRktSWjY2OHQvTThhNWh6UlNKR0RRMkd6TnZIMzF1MDdIUm13YUxrQ3lvdTBMU3QzdUlPT3M5cGo4SGRucFBqNnhzVDVYRkZwanR6WjBXV05mbzJkdUFQZ0g0OWgzcWN1SWt6YW1QS3Y1a2pUbTNkdWR6VUEyWU1YbytNd284RGoxSjI2VExPTjNvZzhSN25lLytpajNZT3NTZ0NEZmM4bCtUZ0svV2NmM3J2L2d4Ly85SGYvNkNjUHZ0UnpXdkg3WHllRUg0aU1Bb3B5MVFidDA1MWxSbVY4b0tnK3ozeFlWUUlzbmZCdjlaVEwwcTFRSDZiWGFvV2txVVQyQW80VWRpS0FrQmtvVUJhaktGU1NDK3kvY0tWVWNrTUFVbkI2c3VWTTl3SEVXc244cGMxUFFGaE9obTJFWVpUcEVtQSswQkZvSGNnc3hTbHFFVFlDcDFlbkdOSGoyZytEbDNTZWp5SzRMak9aL0xodERIazNReVVmY1dJMThybDFPQmM2TEV6WHVWUUJST2xXc0ZLSVlmc3B4Wm9PN1hVYVJ3cUlNbG04SGh6S3o4UlRzT3BoV2Q0c1lMOVo4K29IVHpWMnlqbGNUeGxSZDNYeldGM0FNbVdwR1A0NXVOcW5mQ2pYWjVtVWdDK1kvSHRjQ09IaWVWMm9Kd3JGNkVUZDQzY0FuZGRmMzIvOHc4TmVGcm9uajRrT1Z1cmx3Q0FycnJXWkpBb2k4RElVaVNJRkx4MXhYcXFucTdGbW5QT3FzZUkxZWl6OXVoaEZvQTRmcHdFL2Z2U3dlUGg5a2JXWU96RENjaStVZ2Mydnp2S3JBUi9CSk8vdWNNUzVWZCtSZzR3ZVdOTmNFTjZpYmNtcGtVTEtDS1BMWTNJZHVMT0NodUtmdE9CU0hPUVFYRzJsSFV1c3dPaldkTGdISFhHWlJHYkp6U0hnVG5VeUVrTjM4UWtleWdTdjdxK1VOOHIxVWZiU0MzaXRYQXBhdWduS24zWkZ5Vkp1MGdoZ2d5dGZkMlhsOUNpMDZEaG1FYWFPZVBMTFIxR1czcTF0T092NTVyVzFQcHFGL2VFSEgrL2UvOG5QMGtrOHFteVpiN21TRlR0WE1sRjYrZXFsM1lXY1orRitOVXVzMEJ2R3hWaEtoV1VVY0pnNlA0a3k3WVJXb293QUdUa1A4bldCVC9MeFFVcVY1V28xMHVjUEgvNzVqMzc4L2ovNHFpaFcvRzUzaU5tZDJTWlFFZlpoSmdIMHp1ODJzREM0aDY0a2pZTWdIQ3ZZZ3lSQy9KbDloVEZsTWI5NUFyekQrVFI2N1o1Q0FhKzltbmZLeWpXaEFwOXlranJDSWo0d2MxdGd6VlJtMHV4cFprZWppT1JiNitNMHppaldDRVFuTDVKK1poNVBNdHdoU0dPNXltTUJOeXVkejNqOXpwQThOTXhWUWRzUW12ZmlYUEJ6WGJ1UkNaWFF3azB4dTlZc2NiRU4wT1NKVDM5SXA3MzcwQnU2V2E1Y0FCbzRSVWpvTllLd3NGWXJTeVdaZWgxVUV3MVh3cWM4NGw4VmFPNWd3VTBjUlZycktBcWhGbTVTVys3Q1phQWhVWTBtcnRwckFwOXl1Z1VSRGttSHJybzF5cHRGMzNSVWFFaDBWQzFseTM1WWRYYVlvYW9HUzJucnJMaVBiRkhrLzY3UExaTVdyN1AvWFBtMmtpWnBoNUNuT1pNQ240OXpBaHVaVVRlV0FSb3E2dGpjdVFqQ3NscW44b2QxaTA3MDV0S0JVU29VelhLVm1KQ0VaeEtHbVVaTm9iWjVGdjZwYzNVaVAyWnZ3Vy9scTBmbFdINEZON0F2amM5UjJ0Qm5WNkQxeUpCaHJmS2hnazI1VmphU0R6enVNL0dYTWlFWHgxbmZXVkdUTGlmbmkwSnZ5ZHF6VE9ZSThyRDhITEZJRnNhQy9lbFBmOXBSRU5oa3lnNm5BSzZmWEI0VFpQQWVHbGoyaElTc29Ra3NkTER3S1d0S1hIMVJiR2pVanA1SERvNWVMS3VTMzlWN2xXbGQrbWtPU2dFZnJIMmxQRzBrdTFzTEU3OGRUdjM5NzMxdjUwT1MwdW9ZTDF6TnlXdjVvc25iNzc2enU1SHpvYk9RUG0wMWhrRFgwMmNFYkRSanhVYm82K1JyZksvZUtUUG5BY1RQR3ByeE0wUnhzYnovMFVkLzhORzloLzhvR3hYKzhJOSs4dVVlZnQySysvL3d4emFKS0ZZVzIycGNpSnkxa0dxTnVsdUwwcGNUWHFWU2FJWjNHaE5sbDVwdTQ1QTNrdENLNzFQaXF3Unk5MjVadFdSbEd2SVNlTDhycU1IRlYyWVYwWVhqVVRRdjRncVlDU3lOa01Xak1iRURtVU5yQzJ4K0tTdEtobEFRRnRmcWVSYzNLcXhXTEtURnBMalFHK0ZOd3lLSTduQm9JdzNGcFJFbEc1NGdMRmpMSFFCV2hTM0MzK0ZXZUNGT2VzcUs0RkdtZGw2dFlUdnJVZU5uMlZ6SVdaU1pUWTFReS9zc2lzYm1ocWlrL3RPaGxINUlKblNiWjZ5bTJYQUJOenkxaHJmdWtvd1dEdU5YMWY2bFZmN2x3SmJvSUhWanRyWjd5TGw4WWpGKyt1TFQzZk1zNnFaY3VSaXVSZmhQc3FzbTFkL2F0cnNPUDRScFhOT3d4QjJIWmtOSy9EM25ReHF0WjhGZlZqaStEdjlZU1llcE8zRkg4ZEVKWUpncEZ0YUlJd1FrNEVuclk0TkhlVXc5VVJZczdKbmNKQVhLMERueGozcTJGYnZTVVZrc3lPSVcwV2d3S1VVV2RYckRMeDgxZEZUbXlFUmxWWWJJRnpBajF5YStSdWt3UXVES3dFRDdZWTdLVnplSDI2ZlhrN1Q0WUFpOFVLY2psRjk2ZWFYSEI0Yzk2M0NkYmF0TmZaNVRuZHdOL2J0OU5HVzl2clI4bWFHeThNREVGN0FLZjRPRngvaVVVNkVxbzl3RDRFcm5YY2dNZnhZZWN5SWNkNEsyMWZZVlBLV2IzMkNUZzdHQ3RmMEhXZXVxay83WlQ5K3Y1Um9UWW5mMzF0MjRJdTdzN3Q2NFd3djI5dHQzZGxkdVpvVGtWSlhBZDVRZ1ErY2dxNFdpdGpHbGNMbUt6b3dtVXMvM2cvZVBQL3BnZHk5V2NMOGNuUTc3bzQ4Lys1Lyt5ZmQrOG51cjlyNWFmN05LaG1LS1lEanRwa09mVFdCVm1pYS9WYUlHUnNscTBaU1EzeXJBM1RGL3pzSEV4SHp3c01Jb245NjZBa2VRdmN1MW10OWlralRDL3IzS2hERHROYW9Lc2NZWllUcXlWQWZzNERldzJ4Z0tleldFVVlTcnZDV00waE5HdEU1K3YwZEFCejhvclh6clBtVVFMaGV1dU1DWTVUTmdEejZVYVRoWUJXQUpFZ1VyUnNlUzZFN1VhRkJnNGQwRTVZQkpjVFpzZUZBVUZFd3ZzSUdKTmFyem9zUnhGSHhEYkdtZkJtYmhiUHpHbTNBenFWajRxejdVbTgwZXI2S29Mbk83Sk1oRHVlRGQwTzk1K0RaSzcrVGlvbjM0aGdacEtBMWx2WFNtdzhiWE4zQXowWklmdGpsZWVMWDRlSW5mTnpoWDRjYVNzZTd4R1dXVk5aZHdtUUNtc2lnYmVGL05GelBnVlR5akFPc0RwY20yb05OdkhXejBnN1d1bFVCNTZLTmNCMDVoSmE2MEtqdCtSV0g0NEhueGh5VytMTVNvaDZibjRtamQxODJSNC9SaWZkbVYyRHo1MDdLQ0w2UGc3SkRWdHZpa1RBRnRhTlJaNGVGM3Z2T2QzWTkrK09lN2p6Lyt1SjBnbXVGcUhxT0IveTRCMytVVjNNR2pwSzlkeS94QjhsQ3dlQ1llZlBpcncrZnBSVm0zbE9UQjgweCtKbzE1REg3ZlZjZHZYQnJ5a05ObC9UcHpOMjA4OWZ1VG4veGt4OEsyMWxWWlBtaHFGTUlTdnhsTC9LcTEweG51aC9nMUFScVU2OWFLL0Y2OVpqSTFQSWc4Y2tmMjNJdkU1ekVkMWN2ZGQ3Ly9wN3Y3VWQ0czExall2Ly9nNmZQdmxjaXY0SitjYVJ0ckxFd3dJV09ONlpOVXdEUVlJcTdpL0o3cndQbXVhZFFPUjdCNDN6Q2NOWEdZQmthUXp1S1VYdHREbCtMbzJ0STBZTy9zOXFCd0tGM0RUMEpEVVJrK3RaRUUxcXYwWXQzbGxVYWdzdmQzWHpYUGtxMEtTeEFoOWJsV3IwNFlVazlSOUJtZVhVNlpVVHNqaEVFdjZTTDAwVWJpQ0lWR0lSQkF6K0lKSFZ6YXNNS2IraXBad3hFeVBsYnJSdzBqWDhUM3hhcGdOYUhDeEJXWHg0RlQwUFA3WWdUeGVvVDRTb1pFU1ZUK25JUzJhNWQ4QlBKV2Zjbjh4M3pBYU9DVGZXWWx4bEdFTWtFbnc5b05jZ3lvWGx3Zkw3TitGZzk3em1uNEI4L1NIVm8xMEZzNTBvMUYrK3psOGU1ZThHQ1IxVmNJUnVBYXRwcEFZOFcrU0VQaEt6dklHYnRYTXFOYmwwcmcrUWNtZDBkbmJUWEtXTUg0dzRmSWQ0cC9HcTJ5QkhnNG5ldHlMTGRuVWRJNlIzd1ZMeTNjK00rdDVmVjlMT2NFOVpDZjhPMHNTdElYRUo2ZWhxZktEWHk4c212d1NzNmVmZkw0NGU3ekREMnZwUEdTVjNpQ3kxOWR4WlpuZ2F5eVRNbERJQlkvalZqb1d0OCtNUXlTTHJ4a3NSdnhkQ0lvZE5VYWo4OTQ1QjVzeXFWYmhZUFg2L0RTeC9LYzZkcDkrbEhDdG9jcTEwakY5U0xwTE1lallLM1Y3VGJzRExmVndjWFFhc1ZCMUYwMmsrU2R0aExaTjhPUEhzclZocFpmKzlhdjd0N045OFY4RG9laS9TZ1RQSlEySy9SNTd0Sk5aNGZIbmtmMmcyUitwNE5MVzJNNHFiUEhHYWtRZFlyMCthdDg1ZUZCck05UGpuZFBFL2xaNU5uWnY2bTAzVW1PV250Nk1hZjhtNndOanRlenB2WDJyV3RSeG82cVBFejVOM2JQczh6cmVTektleDkvRmprNExaNWZlL3VkM1oxOGZxVXJBcTRzUCt0SmZLM2tBWjlWVDZnTFg3bVNZZ1ZuTGIyem9VL3BnUGpaajlOT2l1dnhoN3NmL3V6ZTczM3Z4ei84K3pkdTNQbk5reXRYTC80ZlAvNzREMXB0WDhFL3gxV2VhWVFhakFvUzVxN2hqTkp4MTVod3FzT0xWSXAwRktSNHdsRWxrTVpEc0lXSjk2NktNSDhIdHZlZVRWak1ES3gweW9IR3BBT0RNR25VZ20yazNxM0Y2c2xmdktOUXQ1NWZCV3NRd2d4dnBLZVkzVm1icHhHSzhaRXBVd09qVkluQWZ1aTdQZnI4TnV6bUU5TEJESTc3NmREcE42R0hFMXdPMHVDUEltU1V3bzBiMXpwTTAxTnJTQnAvL1lGcENGMktrbzVLMEJpOVE3K1ZBYU9vbkdDbDV3ZWJvb0V4cThaN2FXMWZ0ZHZtTEg0QzYxbFA0UjlsOHp4ODRuNmc2UGhlRGQzNVRmRjdLYVc4RDkvbmE1OGt3YnY5OXhycTA3TU16ZE1ZTkJKaDFkY2E0ckdnNFFXZUFDZlh3UEVjUnVlM0x6RXNSYzJLeDhlZTV1VjkrTHJ5NlpUZTdFSWlBNnlqd3cxMjVUYjRnRDF5Tm1YV1JhU09FbGJkcDdQYzZvc2NORTl3SGJ5bS9pWjlNKzc5QVVOYTk2NVdDR3hXbW5MaFAveXJGUjRhVnYwdm55VmFqSllHTnY2QUphMzIxZmVCSTRqblp3VDduUnRmTy9mSEtvZUMvVEFYcXhvdkJIbmxVYWRDbFd3Nk5oYmd5N3BLSXZNNWpQOVpPa25EN0NjNWxlciswM3M1Q2N0bzRQWHVmcFR3L2NpbWI0bWQ1THhLeXZYcVcvbThlU1k0TDF1UEd0cmdxenlId0t0L3VOeUlUL1dkOTc0V1BmNXlkeU9uV0YyNTVxdTlONk5nWXpTa0EvRGJoQmEzZ3ptT0YrbHMzQ2RFU3R1eFZSYXlIZHk3b3hnajNCZnBVSC9sQng4OS9uRDMwZU4vUE9tL3F2ZGp3MVVWY1VaWlJnQlZGbXR5cWRsVjRWVkVteUN3UjYxUDFBdGlsMTFkbU44OHlXdTlwckNHc1pTUkpyY0VrN2dUVUlFQUttc0o1bXBRS283dnJ6Z1UxbW9nckFBOW16eExTZW9JbHJMczJ0QllBQmZpMjlIbzIvQURCd3pDQVA1cUhBdXVublFhQXp3STZENU9nOXMwT0RpNS9IWUpDMTZvRDc4MGl5cTV2UE84ZXVyUUhMckJya1dUWHZzd2swSW5VWkxYSTNnM0lualNFZHlBVHFaTlFZWUdTMVBxN2d1Zm9qUExQN1N6VnVGaEdST0ZiUjJvMzJaZlJ5SDVmVG1IWmVQd2NlckJudktEV0VWY0JZZXhaQjQ3K1QwZGkyMmpkVk1rbllBZVBBRkg0eTJkNVhWK0IzN3JnNHprWXRlcGI1eVF6cnBsVnFpeTBjdFM2L3U4bXp2WTNuK3gweE5uS0FzK1pkTjZDQTRtUnNnTldTSm4zUk9mTXVVL2k1VTJkVHQ1d0hFSm5ZQ0NYZkRLcjhaeG81RHRKWHE0czJnK3B6dTRDdWdCR3l6UGM1ZXV1Q1dOaVRrVGNrZUg2M3hSYTBHUFluVkhuV1YrZ0RXLzRCVGc5bWZ5dXg5bGhuendUOGJTdEhZZ0xweWVaalJvbEZDYTRnSzRtMDlHVzBuQXgybFZBYm5CWndyWUozdWtPNHBsRERaUjBEYTU3MWl2dFdCRE4wWDZOSFZQdVQ3TVFUQ1hMMlFFRU40OGpDdzhUUmtuR1IwNGl2TW9PcHFDNW90L0hWY2YyQjFWQnA0bFpnL3ZoYmJRcU95dmYvM3JrWWRNTHFiak1GbTJYQktSNjFpczhLdHNrTm5VMjJFVU43enBpOVc1V3YyUU9zNjdmaWs2STVDaml3ZTdPM2Z1N041NzUydi8yYSsvZGYzWHYvdkpMOTkyMXEwNi83VnZVYTRSbUFqL2FXWjJ1OTJOVXFzd2FXdFJVQVF6dncxVFV3TlpHN244WHhhcVl6NEdHVHBIWXJaOFVUZ3FuRUx3Ym5YYVJXaVQ0YjRQeEFvWlFRdjRjMkcyRzZ2Q1p3aVdCbWN0NVFpNmszQlNVT0tuckszUlhsd05UK09iM2hYT2dyeWV3UVN2bGJ6aE91LzM3M0NYWjY3NURjWW9aVW9Hdk1sWC9QSkRYTlJXbEcxZjFWcEtaQlJVR21Md1BzbGk4cU5NSG1adzJBNk51NERTZkowdllxS05EL0xpbnBWak5RQ1ZFYkdQc2xuS2kxVjJNYzhYazQ4UVc2V2hYQnNJOFB4NkpvbE9VNm5PRG5nZGhlcnJwcStQMHVCaXRkcWkrREo1QXk3MExZVzR6NTgwNy94YlBBVjdjVkR5cFdoYXIvbmx0ekxaVDlKMURXOWtvSGxTRHBqcTNpVmQrUklaYTUyRWoveUJUWnRuY1o1ZDBuTzFpRk9QK0JPelp1VUxObDNiR1Y2cUIrOExiN0c2WlN6NElXeXo1RnVIZWUrT1lPK25QbXVsYjNIY1ZFTFRiWGZwaFBQMFNlczlHWE5IMDhpYWRPSjBsaXh5NVZTaDkwN1NGeXpwK3BubzRDKy83ZEZnekNZTjd5a2o3eDVreVpsZ1NSc3I4TzdiUHJ6M2ZQZko1NS9WTlhXWWFmc3I0VW5iWmVUR3FnZ3VIRjlBMVdhTUJKNm1ZK0pIdHc3WXlNK1hLSjVtZUc5cFhwSW5MK1dYTWhKbnRHUHl5VGZLaGk0S3NIVVgxMFcrWExwNzhTZys0OGlIdXVLaXFDOC95dnZLdG9KRVorSExBTjBTSCtYZXJkcGNnam9ScnNQa204TzhiWndoODhFbVphd05EajQ2K0hiVzRWNDl1ZmlkM2U3aGQzL3QxMjdmL0xNLysvSlB0MnBGL1AvNGM0eDVMc0hNZXlkcFVtbHJ2ZXRTR0pqVDJmc2tzeFRrYVNwWnFPV1ZSbFdoakhEbElVcUFRT1pkaE1UYVJjSkowRFFJUXpOcjJabytJcmVFTUhGcERDdHU0WkQyMlFxZUR4MzIyTUlJaE1YTUZ6TVREbC9EWnBYTVlpWHdKblJXT2F2QlNrUElsTHVlMThxQTExRkFWSWgveXFSc3RhMklWbjliNmlSNE54Yzh3U2ljVGZoWWVab01xNVdRZVNmdXFEMytjZ3NZWW10QWVudERkemJsOCt5RmYvNzAwckl3d2t2eGg3RTJ5NmV3TUUzM25DK3dNc3luNXF3RzBMWGdWVC9Ua29iQjczcTJIZEFCVnpCTU91RERZWHh2WGVPYWcxaWk1aXJJaG5hT2xCdWxPWFRoVVpwQzZJanlVRm9TT0xoSDhCZmNUa0xnVStwQlBzdUV1QndXNzFNM3dZc2k0SEx4WHA3aDM5ekZCN1YwY3BrRWlmdEd2YXFqeXc3czVtcVFKNzhoOEN6K2FMN1RqbnhTTGw2YmRORng0VFZZUXpNOEo0Nmx4Y1ZUL3plWkNRVmR1eHBZU1JYK2tCTjF0K3BYdnRiZEJnTU9McksxRDk5empZWGc3QmxHTE1KUjhwTldYbUZHVm1CTERaNTN6NTA1c2RVVnZ1dG9yQWRlZVlMWHhjaHpGSkZPZDJUWGhwVTdVYTYybmg1bmQ1UHRyUXlGSjFrUENtYU5CbklXdU03d0tQNXBKMWNNNlhPUXkvV2MyM3NqNjVzdjV4eVJEKzdGWjVvRitvK3ladml3Vm00bXZxS1U4ZnFJOVJyMk9YUGpXdEphRTIycjZrbU1GeDJBZG4rUVNUa2pLNTI4RHAwc2RxUVIzSlJ2TFRXODhWaUhmcHhoalJabFBiQzVHYU9jMTUxalNSckdSdWpzbkUxUzBTZGZlK2ZkM2EzclYzOXJ0L3ZrOTcvS2lsVjlIbHZBamxsNk4vSTNRdXBlNWRaS1M4OFdadGtWeGVlRWVSaWgwbFZrc3BleG1HdUlJMjdXbDRhVkVjQTBxdVEvSDNJbVBmamdDQ1BJNGt3MkVGaUM2M2YrSis4U0hFTzl5NWY1Z0ZhalptVVIrS1ZZVTVrUnVJc1JQZ0hzNTdHQ1J2akJBYThuV0RYRitnUG4vZkRGMzk3QnZYbHpMN3dvRVFHZGFhSlNyRm44UERtUXhGcmZrMjJDaU1Na0h3YUljdHJsbSs3NVk4MW82TEhiakdXMjNDZnB2Wk1YTE1OcS9tVEtYNkJNVEd4UnJ1ay9ldDVxZDMzbGQ0cXZjcDVWR1pTSy9kaWhzaXNyT2lLSmdGdUwybzBoZ1RNK1Y5YTB4ZHlVOTRVQVowR0VpbG94cFRmMVlHVHRPYmZXcjNvaUk5TjQranR5NFAycXF5aG9EYXgxc3BTSk5LN3lLdS9nSWYra0FkOTdmTWRiNlJ3bVFzNFVkamt1Z3ZxYzB5bDN5VlZvS0U1SlAvbm10N3lHLzcrb0RzVzVwQkh3WFpEM2ZFTkEzbG5UT3VrbWozU2VsV2M1MWdTd2h1NjVheGZTcG5iTzMrRXVlbDBteDRwbnl1MFpIcUY1VGZBdUdYTmEvOHNhQzVHVjBJSlhaT05paHRzM0F2WnFUdmkzek1wbENOOXlBMnZhNER0ZmV5dEQ5T3NkcGgrSGR5YWpybWZSLzgwN2R6dDgvL2grZGpqZWU1RGxWUGQzSHo5NXNQdkp2VTkyUC92a285M0xLRnNiSGFTL0ZsY04vK2ZOK0ZDdnhnV2c0MHMvVmVYNjR1V2pkSHo1akVyS3BseVA0NWRGRDVySnkrTnRoeHBheWZ4cXg2bHZLekJpSmZ1NmNUeXdvVzN4eUVhUStFb3lva3BVeXY5cnYvcnQzVGZmKzhiZjNYMzN6MzkzK1B4VnZjZktEOUZoRE9hb1NKYWM0RmxQeFI5N2xFcGlrZkQ5c0I2RVMrblpNRjFESnFBc1c3MjFMV3prZHhyUE9oUWpTakpLcFJVZ2JhNnhLaW1FaWRlb0RLdVdRbDJOWk41MS8zRjY1ZWZQVjNvSFFCeHNhMktsbWF1NEJENzhLVnVYTUpaRTlFeUQ5QlJCbGEzOGtQWjd3Mi9ncmRUcnIzZHAyeTFyMXJPMlkwTERSb2RoWFdmZE14elMwUGcrTDV5bWNRV0VmZGxYY3BUYjFheHpGYVJqNlZ1YkdhaHB2S3RUZXBVMWt6WjFLQzlnRTc4YXRtUGluSXJQU3RUd1RFd1p6Z210dFFobnZHMmRvSERPN0xNbzhDZWgvM0hjQTQ4aTlJOXR3dEFnNCtPcWNvMzFleUUwbjlXaURTN0JKMm91T2kyZDNGYXYrMjRVK0t6ZGNXbE13YWs4M1BpSmwzaG90RUlKamVMYjV5TkZ3REJsR2RXM25CYnJUdms4aWFYS2lqdkI0SVRTbmtmMTJEWERvVHRkYkdRanVHOUJHcUZwVTNabExtbW1qcFFuU2Q4bkhWekVqVEpvNWkyL1orbVNlNktiZnNvUUtiK2hMQmlVcDNOejBRbEhIY09LWDUyRkVZVGY0bWtkdUpHSFMvbks4cjV5TGZ6QUZjRGhFNVdQTmN0RklrNTk5SjUwYjMvdG5kM3R0Kzd1N3Q2NzE3WW83ZjZ5cTYvL2xXOTJJdXgyaHRkSHdZL2NVK2hyK2QrbDNmWGJ3U3V5SU0rOW5ETDF6dWNmN243MHM1L3U3bi93NGU3Vnd5ZTcyNW05djNVam13RHV2dFZQcmx5TksrRlNGS3hOTzFmVC9oNDlYcCswZnBYOGFISjFGK1VtaDF3UitGU2VwMDdRM3hGcjVGWGFBL29oVXVaelJ3SmVXQ25UYmZRWnliMFh5L1Zidi9LdG0zL2puWC81Ti8vRlI1Ly8waDdLVXVUL1gvN2s0SlkxaEZOSlpoa0Zva05wWW96R0ZLbW9rN3hEbURUT2t5alZLbzR3UzU0bGdFdEFOQVFNcTBWV0psTWJnUmptVm01MXlKdlFFWmo5bVZUbHNaWW5ySW1zS1B5MFNHVklEd2RLM1FrNkJIdDhXOHJNLzFxcjA0akFXYmk1cjJjckU2U1ZacTZWZHcwSDRUWmg4czV2ZDNta3I3S3V2WkM0d0JhSFpubndidElkS1Mrc01kd0s0UmtPWjU5MTFtcDZqNDU4eUgwMW5EQ25QaWhFQkFMUGJDZWQ4ck93STR3OWJJTmlSVXQ0VVZ3RG5CRXcxbGZNMEhaMGZsdmdibkxrU1k2Q2U1VDFvdytlcG1PTXNxV1VLZGV3ci9pQzM4WnZwVUxNaC9JNjk5YlQ5bHNjRWxwblNXL29TZ2JVZ2Z3dXdjNDQ4WDdMNDcwTHJGck5VUlQ3N3ozanhVemFYQTZkUGZwUXZpaGZQTkE0OGRhWGcxVlBGUTE4Y2sxOUthT05OeDBGLzZNMHJzb2R4SUs4Y3RMTjl5N0s3d21sVDFtSm1PZjlPM3FrNXdhWkRsdVpKbmNFY2VUM3laTXNiVXU2NFFrWTVGY1E3L2MrenVCcFQ5TEQ5K3JoelZqb1dUNFZJK1plRk9qOUhPbG5VaStsbDIvY1FyZHkrTW4xNjJ2REFialM0aDk4ek9TYkdMcVZpVEFuY3oyTmd2YjVkYnpuTWZIMUVCTldOMkxkbmtRV0w5eTV0bnMzTS85UFU5WlpEcDgrVFNkM05STmNsbUZaQSszNFAwdmc0TWc5ZVBiNldSVzFTY2JMR2JsMmRVNWt3Vkl0L0w4WU40SUFsOUxPZlJSNjRIL2FkK1llMGluaGRPcTFPME9ERi80OWkzSjkrKzIzZDMvbEc5L1l2ZlAyTzcrOSs2b3JWNGZuZHVJcWpjMjZROHN1bjJiTjI1T2NkRU1SMlVXalVSbXUrQmlacFZDWHdtajcwQTNiREZkOVRiVGZpRXArRmRDaFZlQ3llbDdSTE9uRkQzSjR4UkxXS01Dc0JUV1RHV2tMazJNSlJHQUlZRkNJQUtUblV4VjVCeGFMaUdPY1k1NVFudm5rUVlSRFQyb3JicW94Y0dLTkJDOE45Vm0rOWFNWGZCRkNXSVE4WHZLTkVpYWNpVkQvcmZDZ21lMko4RWladVZOVXRYd1dGajMwdW8waXZEREV5WFI1clZTNVg5bm1XV2Q4R3ZaaDlrajdyRFdGRUlIcVlDNUZPUi9WSkJiVnBPbWV4T2Q2bUNIdnhUU3lhMWxvZlk4Zkt1dGJRMUtHVWRubm4zTkRPeEd3MGV5YldyUXpQbDBJRDAvak0rMFNxcjZQZlptWldCYlUrT2llUlQ4K0NROGVwTUhkeitsQ0Q5TVpQb25seWwzQVBYQVVlS3VCUjBtaE5RVWIyaDJsRVlYRXJqZjFmVFJEUkw2eDA0d2tDRDdmcDg3ZzhPcFNMazRxc3Z4R2c5S3dLUVpMcFFRZmtkUzRITENqTVYvS1dRYktmTWh5enZyZ216N2xFVzV3U1oxR2NUeU9EL0ZCVHE5WHpwMTMzZ285dEg3a0pPblRuTE9zN0NRMHhGSkszYmtjQ0ZLWFJ4cXR1dFhwR0Y3YTlhYXUxRk5wcEZ3amd5eS9ocnpydXQvZ25PODNodWVoUFlURzdseldZZXJ6Nk1xTjFwUUpsMzdQTEhtQ2JOdElFbmFIRWRyUXJReUt6eDM5Y09FWFZkdW4yZWJxdC9oVVZlU2FleVlBbnExT1NKMkNZWTN2UWRaQ1h3clBmR0w2VXVSSG5zdXhJSzljenY3ODNMa0F1RW5NZzl6TGVjQ1B6MkxnVU1yQmxYSy85bmEycEtydjhQRTQyMGtmUG81Q2ZYMnY3Z0JyU0FPeXZHVUltYlI2Rmx6d0NSMjN6N0llKzJwNGV1VjZmeCtrenBSUEdWdVgvdVFnbmJHT0pUc0wrY2F2SE56ZVhZNU0rYVFUR3M3eVRsdmtnbkQ0ejUzSWRDZTRkUmJoL1hOR1FUNHoveUowM252NWVIZnQrTWJTQ3lsL2ZhTXNkUkUrV1FWN0lmWDJ5ZjNQZDkrOCs5N3ViN3ozcmIvL3YvenhkMzkzVmR4WDgyL1h1VkltR09wNkVvSFcwM0R3WFRwZUh3dXpQQVN6dzRNSThMSldDSlJMcUNJTXM5WjlNV0xldWUvSHIySC9wdHlpSFBYWXBHOEVzV2xKYzhJcVk4R2JNdHJxRWdWWGpWRitQbGgzYVFpc01QU0FLMzd3R1RqdWduaHBwUk1vYU1GN3ZXdlRKWTMzcnNJSjJaUzFkOHFyYWtaSFFuRmk5ZWwxQkIxRXpxbWp4QW16WWJuUEFxKzU5aFYzeE05WG1HL0tVUWZLUTlmZ0NFL3VCMnkzTHBDeXE2OGMvM0xCNWQ3TEp6Mnk3Wk1zMi9uOFlRNFNqNVdxdExXK04wT3pLRXdLaXlXSVZoZThoSllUM0pYRFhhVDhvWEc1T3FJNEVxZGN5MjgwY0dGNEQ0NjRnU2V2ZDBPRCs1VTB2dUZ4aDdQcHNQRU0vWlN6UEsyUHVEVHdvSDE0Q1Bic3VFTTczZ1p2K0o3WHlZYi80QUtPNEgwWnR2MVdTOE5QWlRaLzRKYm1jR1prYXZBR1kraFk5eVd6bnFmc3djTnZob1c4eWRRN1hrUnF6dm5BYlVUWlN1TmQ1U2RweGNrL0t4ZncyUEltdmsvM0R6NzRvTW9USDZwWXcyZGJxZUdSLytVZEsvSmwyaThhcENOcmF3SjUxYS9lRTgzZUtXdDRJWDc0NWxOQm5wV0JET2tFTkxyZ1lxS0x5K0xVSjJKUzFvc2cwRWs0YlNGWHovM1k2RHlPOHVaYnRwTGhIS2Vrcnpzb2QyV0J1K2pJQnBUSWcvcDk5OTEzZDcvMXRhLzk5aDkrOE1FL0tnSmZ3VC9IQ01ad1RDcWpva1FKbWlVVkxBSHJJbTFSMDBQckFYczRRd1NjcjFFRFpGbE94VlM0QWd5ak1FeVlTb20wTlY0WkZlUUFLMk9qTEpLb2NjcHFYTnVEaHFOQzgzNExVd0YrZ3VGYURXMmJXTnNxQ1F4Q081V0d4c0ZqNHFLS2k0KzcwSGpDbCtQeWhGR3N6UmNCbS9MU2ZHcmxVRkQyKy9OVEduNnhpS1hwb1NScFRLOGNZQkpRY09HVG92TGh4QnFBajRYYkp1cXE1QUxETWpnbDR5RTR5cFVYZmRPWTNDOWtWeEhXT3ZTQ2dsTlBSZ0U2UUhEdlp6ZlRady91OTNvYzRYY0VvZkt0UjJVbEJjSGdCWGE2QkpaZzZsSWdBMnBNRXFNRXNJUlJtS1BRZkw1R1BYU1BmekNHby9NNXBWdXp4dHY2MitUbDV4TlBVYUFKL2dLL3FkMXBHcEp5eUZDVnlMV2NjaCtMeU1nRFB3enYrY1NuZ1J1S25tM0tGUy9MNzhncnZ1R1hkUERaRDFOLzRrZCtwRHQxSWxUT1paZ2RWazBYR0pZaUJlbndkWFhTL01qZ2d3cFBYRkp2WUlDM0h4U05oMkI1TjdpWXBCVEVrWW5KUjIyQjA3WEhXWUNEVjA2Q1FsZjVxWTVpQ1YvZUZ1bWIxemc3eUdlWlV1L2NTM2hncDZENmI0ZVgwNmV5RHlCV3JrMGFXUy83NG1ubDUvRENVb3pLZXBWMXoxWjZLS000UVRpQkxMeE8rN3NRM09IdHNKV0RMc1hhMm1UU3ZJbzF6MUsyRE10bzRHR1doVkhtWUlIdDZ1bHY4cU1sdUN6Wmk2c21jeVhxZXE2enpQSXVIRlo5a2ErSXkrNyt3MmM1RytQQzdsZSsrWTNkdDcvMXJmL21LNjFjTVJiQktzTWw2Tk9RVEVoOHM2YWZVb25BRys1cElCZzNBdEtLeU84SkhqRjFMZHFPd0FmR0V0d0ZyNzdCUUNlWG5RU0xoTDB5WklwaU01d3pVWkljVzJXQkNwTzlIaTQvbGEwaXdSMEJydUNra3NkbkszNXdIWHpSS2E4SklYY0M1ZDBvMHBhV2ZCVE1sSkZDV2xZN2tzU3Z4aDVjS1NpWVNSODRWVWpkSGhtaERXMkdoa0xMYTVvbzgxaXhPaXdyS25yb05JRTAvRXhTdUlTcVBQTzJ4cktNeWFiQkVHYVhaL1E0cGkwb1JiRWJwaG1DY2JjYzdPN2xpRFkrdXA4KytLQjd4UzBhaDRNWjNjVi8vSDFWWHpXL0tyeUd4dGxRMEVtNmRCVE9CZzBKNWEyakZVZXhhc3hyK2RTeWZIU1VHanFMRXgrbHN5NGEzT2FCYjJpWFR4d2ExSUVGOFQ3cDRkbG1pQlAwWlVpSngydVlIWGRUNU1CeVBxZGV3UjkvaHc1ODlhek9oYUZqamE3ZUtEM3hYd3hORzJ2ZVIvbjZQbmV3Nm5LSTRsNWR5b0sveXQzU0JWRExKS01iNytZK2JRQVBmUDlwd1YyeTZkMmtnOHUwQjVpekVnMmRqMUlmbGMzSXgzSGFtSG9hUXdlTm5rY09YcjVjUHV6dTdrdGJpMGNwVjF3VHNmVEpqZFVWcnlJanIvaDgwcVpleEQxeDRmVk1QS2N6U2FkU3BZWm0vRTFOKzAyeG1yUTJxYXJOV1hJWDFKT0d2S2F0NUJxZXEwZWRZWHdmdTJmYVVHQjUxOG5Ta3lqanlLWkd4R0xYeGxuUDRGekkxdXcxNFIxTU43ckk3c2dPMmJxYTdibXZucnpjM2MyRTNGLzd0Vy8vK3U2Zi9UTnMrMHFHZERSTFVaMVhaZ1Rzd0xLSk1NWHVpWWVaQ0RITHJBSXVwaEZVR1VXSUNJM2c3c0pjQVR6S2NTcUNNRlh4QmFTNHRZMDFRcFUwa2F3cUYyMEVmTnZnTWtnOXo3dXNWbm1xeGdxYkpsckNPdkRlNE4vSzNiNHV1WThQbkFtRUJyOXdpSUtOVU1HNzYweHpCN09XU2U0MEM1eHJPYUVyRFh1VlNmMEZsL1llU1pOMDRLWGZEdjZHcmhvaVdHVkZZaE1JVjlKUC9xczNybVk1emVYZDY2ZHB4aHRzamNMeXJXQ1RwMFVmWEEzekRNTkdzWXFqWEZ0R0JMRjFvVEdsYlB5ekYvMVIzQUp3YjhPQlc1QjVGYnhzTS9aMTF4NWNrempEYTN2ZlIvSGhjT3N4YUZIMitETkNiKzNpZklrejZ4OVdSeEFZN1p4Q3I0WU9Edno0ZDRkVzVNUExyaW9CdkJlUkpZcVZuN2FLTmNyMVdpWlFsQzJPSE9ZeHZzWXJoZnNxOE1UMWZJVFFaZVVLbmxOR0xrRjVhRmIveWxNTy9NVjdqbzVwa0U5ODZ5enAwTWxmcjNNOXFnSXdaR2RZcUxPOFMwWnBQYkxVeWg5dkEzZi9DbVhGT1VrYnI3RG1FNUVncmJ5dU1LMXhGR3RsQXl3S2paemt1VGhPMnFTYzM4UGZwMC9Ya2tOSzgrS2g5Y0ZXTCtUUTZoaEdOaEE0djBEYUt6RURIWFRVWFhXWnh6QzZRbWU2OHp5VGc4aEEwb3JURnFzSTRaUTQ3UkFmd2FsaVRiMHlJbndBVWpuNGc2L2swaEdiemhVUko4OUI2bVJ3dGxKSVhLaG9uRHc5V3ppdzBDcElLL2hOc1YvT0tNaDh6NlZzODM3djNhL3Qvb08vL3AzLzRwLyt5Ky85WGhOOXhmNTA3RE9DaWhFc3lNTllFWlRneXd3aDdmVG9pb0UweHM3ZVIvZzBxaTRIQ3JIdUxwTmloSmlRcTZqYzFuT1kxN2o1WFlYa1R4cGVVdnB1aHZkMmRjd0NkYjh4SGQ4TlgxZFpxektXMUU5bExDVVBiM21XNWIyR1ZXZ0NRNFZxOUFTbGpTUENNSUdGT21HRHZpbzkrZnp1NnkxOUxjc0lRTlRzMW1BSlRmQk9Lc0xsb0dVNlYzbHk3Z3RQTzVqUUVRU1dCWkpoM3Fzc3hyWWhnaStUMFBaRS9lVERPK0ZpaG9PWDh0Nzlnb1lmd1hQbjA3S1dsOCsxWlVUSnN0YnhnQS9UOFpGZEVwWDZZaFhwd0E2RG1OT1lURjZkWmhrT3E1QVZUSEdiR2VZdnd5dEQ4bGRSVUZZVGdJMXZWZXhaWTJsTnN6eTdmTXh3UmdUdTBpMkZ1SlNIUEhndkRpV2V6MkpkNFlzNjhtMHYxdnBKT2dtS0lRWlJRbVFtYm9DWGFiakJOblcxWUttemw1bWM2NXJLNEd6VndPSGw1WDR4T1FTZThsMmVYZWh3NythRFFKNzM1eDJsbWcyY0trL3Y4MXllZzczQkdoaVR0eGh1OElmdjNna2plOHBFNDJHVWY4TUdhMkI0NTdxUTljOE5tekx0QkhEU1ZqYkJUQjJCSlovMERsVXFEeE1uUkFUeU9ld002ek5oYTJXTytqbThySTBzcGNzWGFrOS80MU1IUFdqSWpzWWNLdHZ5STROa3Rxc3dZcldIQTgxcld5NURvKzlTWnRnWUhKWWN0MU9JakpZdmtTbnYwQTFIZFVTSjRPZEJsc1NZYkpSZXZDTVdheEUzRDJrQWM5V1h1M1F1ejJpMlBOUElUZjJvdnhzNXN2QmIzL2pHMy92S0tsZE1Vbmt1ekhNaTFhVXN5RFI4dHlEWU1oNWFRME1hQlRWTWtYNnVZZFpwZkRxRU5aMVd3MkpwUUd4cHhYdVdQcExVNS9aN3FSMlZmNWFXaU5GTHdLSk16aXRqczQ3elcvNVVVOU8vcVpnTi93ekxoaVl3NEx6U3J3WmVJV2pacTZJaENaUEJqd1UzZ2ZLMVUybnlsTzZtRGw3NVJNWGtxWUxkaEtTSFNCT21BUFdlRldCeGlyem9DMEZSV3ZaajV5elZXS1lQcno3cXVsTldKYWJadWlwSUMzZDNlVDIzd2FUaFhNMWhHWmR6c0RUYW5VNTJMNHZDRGFkcnVSOFRlaDNjNGxNZVd4ODlZQWRPZ2FkOEZzSzRHeFJwalRFcjUxVXNTM0FwVSsrdlpjaC9LVXZISENMTmgzcWNFN1NVUTE2RThqb3lSREd4UkUyNGpTejFhdzBwTDYvS0MvWEJ3dWt5cm5RcUdqTWxESVpUcHZETHA0WnNPbm4rUE1vOFN0ODdGMnRkZllCZDJRaFBoS2wvOXduZ05JMzNlZlk3Znhxbll2eGVkYm53WjVWMkZVWWNsdGI4Tm4zeTR2M3dmMkFhcHhBQkhaZzR2N2tzWG1VWVkrTFNNcWZDenZ2QnFlbWtWVzd3N0pLNndGYW5vMXdkQnlrd2JOb3hTUnNZTG1IbzdvLzh3UlBHQlB4cWZlZU81dUV4dDlKWlZwSWNhZHNCWFJsV1JPQU9UOUJOdnZGMXJiSG1obGtsTE55WFF1L0hMcE5PSElxNS9BUy80UWVlMVNvZEJWNDBDbUhnSkowOGJHTjNIWHdNQk9DSGx5di80Z3U4MFVTeEZtYnlPSGpvVzkvNjVxOS8rOXZ2dlB1REgzejBZUXY5Q3YxWnAySnRBanQ0STVweW5YV3QvQ2FVYTVlNmhFbEQvTDdRREtQMXFMV1lIUHNrYk1LeGZyenA4U2lmTWpwbHBiNldJS2FjOGRXQzNSZjUyOHFSYm90WjViNkpOL3dRSjkzeitCbzlxeXhoS28xQzhKNmxDSCtDWUlrSnBTUElVMldhZkZPZUJpU01jaFdmVXBvL21aTW43OXY3TCtXNVhCNFJvRTM0ZERJVDVGV3VDUlIzVmh0L3BldGx0akZHcmNTcWl4TFpwSHR3a0ZZRHd2K2VVaFFya2xLK2Z1Tlc4WHo1NmVkVnJOWTZhcFRYNDNZWS92VFE4N1FzUENnZndpZEsxYmZFcHJOVURoK3JUM1pVdVBQc3UyUXMwQ3JYbEhVbFM2ZXVSc2s2N2VoeU5qaFlHc1MvcThHNzVLTW8zQ2wxY2ZBR3c2WHpHWVVzM2FSVjEvS3dLa2VSUFE0dldMSFBiSW1ORlRqMUNKNzZRYU8wbzdqeFZ4cnZxNnhDejhSNVVoZjRrVCs5VTRTRmhhOUpxeXl5RHE2SzVoNkF6d282OE9BYmhRbUcvazluT1hXekplcTdscEVJY09DUlJDMW54WTh4RVZ6ajEyU3RvNEZpaFV0TEMzeDBkTmNUcFp2OFRaTTdHTklKTDdjbFh2QitrWTV1RG9qMzNocmorUzdha3RsVnJtM2o0SUhUVHdxQnAvWFJ5NkhKeUtyUUk4OUhVV2pLVlJ4OFRNQytaRkhDSndxN0xxN2s4UnVkUnJYOVJGRnc4L3M0Y21wbHlvdDA5dFhVQVhTUWZGTTMxdkFLSXpkSlZGamlobWFqbXFkQkRFMVdEYng3NSsyL0ZlWDZsWE1OSEw5STQzdWF0YVBQbmFTZXBWZDZzK2M1YzVMZjQ3UFBIMlNvWnZrRlg2dFAzK1lJc3MzeVRFMlZlQXlnS0ZXRVNyS1dNcmRjWWJvYTB1Q1NRQ055K1M1N0JTNkpOSzcyNUdFd1JiUWMvSVNTY0kzRnRwYWJHT0hLNS93RFphN0xnRVI1R3ZRU2hCQ1IzMHV0cVN3VlhQeFlIUEFLdllUSDUxQU9DRVpnNXFud3hLTmZ2dk1MdmlrRmJWU0hCc1pTU0V6akk0NGlZZ0VFQ29VYjRUeUlPK1hNaEVJbUR6cE1pcExJSnEyc0djelpDSm50UGNtSEhDOWV5YkZ0dDEvc0huNzJjUGZwZzZ3SHpkQ2VCWERDUWd0OVY3cTFtTURsRXgrWkJiNFM2L0ZXUHdseUpSMUNGSFBYRTE3WWZmVGhaMW1pays4TkJiRzd0Ky9tVktMNFlJTVp5NkduSTJXZG9tZjRvd205bHk5WVJwVjFyY0hjVVlUUGN0N25zeHdVWXFQRFNkWXN2MzNwMXU1ck43SkRKL0F1dlpzOTdTbmZhVnNPaFhra1hUcUVGL2MrVzhQMTRCcXV4VmNlanNRdGNTSGJrOS9Lc1lwb1lQM2l2MjNUemtDSWd5bTRSRTdpZmxEdlFXZzEwT0R3S0oyREJuZ2wrWjlsblhVVlRiVFFhZVR5UlNZNEtFRHZYMlZ2L3ZWWTdsWGtpYlBBWFZvckNSQmtzdER2RUZ6NHlxQ3dyQkVWenlYaTg5cnc0T29oRzUxRXpmdTZHbUlOZ2kxUXN2Qk1rZ2JIY2xhZXlFSGdrd0E4blpVRjhyMStsVU5wY3VvVU9ZZVFlUXM4ejFSaS9hRm5tY000QzQ1NHJmeGtyakpDMjZYVWl4VWU1TEFuWlNranNrd1JWc0VuL2EzcithNVVWbjg4ZTdiMjhKTysrdlp5MTlsYm9KK0hkcGhCTW5tRFk2Nm9zNkNldWtvN3hvZkZveWc2OVZjL2NKYnNwVjZjQjZ0OGxxZzZURXRNR3FYa0ZwbTJlUVUwc3FxTk9ydmcwS2FBcEkrbVQrcDB6cWx6U3RoNUZaMm9EZzlTZWUxTUhLdUpaeE5BYzBBUkhwMm1YdXpjeXB4ZHRnQ25yYVM4T3huQi9OcWRkLy8rUDkzOThWZFB1U0pLT0ZjbUJERzlpeUdIdStGQ0xTWkR2akpsQ1ZUemhQbmk2bS9kS213WU53ZC9MT2d0b29JOFE0cjlNamNVbW1qaHNkSVBMTC9nT2JpdXR4TzNXV1dwOUFxMzFwS3c0Q3dsT2Vrbm5tQ0JWZDh4R2doUWd2eWV2TnZQdi8vYzNVM0pINGxvSG4rOEJ5VlB6Y3ZIT2E4MU1lK0pwMFhwZUtvaDFkOFpueWNCRmhkcFQ4UGdmMzFEWnhWVStGNi9aKzZzUUphdXlRbU5uTFY2UDhvT3ZxeFpJNHZuc1ZLd1lBN2hzY2J3V1picW1NVkduMFlMRHB5VXl4SXpRdUhYZEFqSHhYempTbmxtZzI5bnA4OUpsdDJjWmVINVFUcWx3UjBjdUFuS3BvVEUyWnBiQ3pzNEtzTjZSNnNXYWhVbUxUazYyejY5UEhVQUQ4OEQwL1BFa1VIUCtEVkRZRXBMR3FHZFljcUhsL2Y3TUNtakNaTWV6alBKUXQyWnZBSS9SUFR1ZVM1NTREUzRpMGVyalNtVGh1WFpFVjFvaFpINFZqeWx1T0VJQitYMml4U1VacDRYSHN0YXBwUFVwZlJvbUtBc1llN0RiNTlCV3JpOWFiZlNuT05VTVh4RGgvamlrdVR1ODd0eHVvZVdzK3JTTzBwVlFMczBSZ3ZLbnJhaVV6cDNLeVR2dkpOUGZYVDFRMVlMNEkxVlFEMklKd3BVT1l5WUt1RXYwRFU0dGN5OEE5TTYyR3hkNnZQZFc3ZS85ZTEzNGhyNDZLdmxHdWlwV0tHaVRFZVVZUlQvbllhTGtaY3pETldnTGFmNCtVcU1zRVVveExrd3hpWFVUNW03K0xBcWQxWXRJVmFKYjRTQ1VzUFlsSjVyQmI4YmxaL3IzWUlEMUlMM0puNEVaTXIyZS9BQmJmSjducnlLbW5SNlpEUzd2Szh3YllYN3ZYQjVZeW43WGVzbFFzbldsclJwa0pSbkZsSzBWWG5vTWFPaktqbUt0a0thaVlYaEVRV0dyeHBuY1NiSXNVaWJNT0RnNUoyaGVWY004SGRTdmtuSDdOSG9MV21hYlkvWGN4TDhSY29vUXAzTStaKzBzVWhZcjFaNzNNc25uTzN5OGIyaVVVcTJ4M0lIUExVZTFuQTdGdllvY0dWU2hsd0VweWFUOENQLzZ2Y05mTytlNWlzR3JMM0R6ZktvL0lSd25ZUXZON1NCUFZsSFZDclRSQXRMVUVPY3J3eTNqZ0tiYXlLTUNJM2JFREk4NDBxNGxXMmVtbnZkT2h0ZnlvTTg0NGN3eWhWdndadk9vL1cxeVVUcktlOThnVUY2azJvOXVJWlNDSXg1RDU1blllcEtlYU1VUEh0UDlvLzQzYk9HMUc4d3JNd2dCNVVsbzZMK1hQS0ZONVFMdm9pWHNGdVlZLzM1K2k0UmdwZWhOMW5SRG90RytiNXdVazdQcmxBbmtUTzQ1SC9MV3hDWHJOYlhLVzNsWUhWR1JpNHJyUFphbWRNdUMyTzFRL0JOb0lrelVpZ2U0VStKbnkxc0FBQkFBRWxFUVZUbE4zSUZIbnNkTENNODcvR2xaMlNrTG5RY05xMXdwM1g1VlFpTlZzaUtndVdUTC81NXR4L0VDUXVmUUk4WUZHWm9WTzZGeU42Nzc3NjkrOVo3Ny8yZEtOZmYzYy83eS83OGM4cTFRaEdtYXJBYW91MXBHaGxoNWI5YmdyVjhscGd5UzVGYUdXRmdoUmF6cGlJak9LeWFLdFk5cFlvcFpYUXNoeFhlTUpod2VqZlhsdUNjK1JpLy8yNXdYa0l5UGZFK2pJSHc1ajc1M1FVd1BGZDRCdmVKWHduYUVKb3ZRcDhjeVJPcER2cE5UZ3J5Z3ljZ2JUWi9JcHpwU0NqQVUvNkFDSjRHNWR4SzFra3R4ZHlWUjFsUkVvN2hRNFBKRHZpZzB6djhwNFFwT1hHVTJYSDRLbGhxQTZmTGVXLzdMMlhnYkUzd2JHZmxselJCOXZtMnB0UTNyQjRGQnk0TDZIZUdQc05wT0ZHUTRGT2FyR0FYNVU0SmhwdVZnY3Rab1lCMmFlelNlUkIvcnlHL3JhZkRQeFk4UEE1RCswRW1WT3BtMlhpS1Rkd2NGS2docFdjOE1DeVZSMmQrTFZzNlBlT0JvZjdGdDlJSnBZTi9rSzJkVTArRm4zenlLbGZBdTdtUExJeXMyT1lxNy81RlZzZHlwUlFHZjJLS0JrUGN3cUVrZzVjTkI5S1FlWENOVHJ5ZjgyZTlnNWMydzJJVGlsdVVjQXJ1TzJXZXhQTFV1YUNmbFZjRmxyekxUYklVdDN6Tld5anJEOXlGVUZHNnA2T2xaSWN2T3I5dGpOU241UVpnQU1GaDhXZGtYSjYxU1FkZk5sd0R2M3hKUlBFS1g0d0FsQ1dmVUZkS2hRY21LeCtaZFZXcEpqTHplc0ZmNnMxU2xUY1hHSGdHSHZxbVBzUUozcWRXOHZURzZNSHJPeGxGdmZ2VzNkL09pNitlY2wwVnVTdzNDb0hWaXNuWFRHU2tjWHR2cldRYmJRV2puQXV0S3craHFpQ0dTYlZtODRhSXRnSlRzUlJSUkhNSmMvS0E1MXBMckZnSWU0Sy9xcXp2Q3laL3BoTGNWY0M2Rmc0RVpDcEhlbWtHL3Z4MlQzR045NzZOQTV6Z05HbmtRUi82UFF2dTBvUHYza0M1UmltdzVOSTYwby83bWVmUVNWbUUwTUNOdXpWYTlrbEdlVTl6UHVmVnhMRUk3R3ZYY2RtVWNmM1craENmamt1NXAxdVp5aDhheDNLdEt5QnAvRDZJZGN2aUdwb052ZHNCUmhIYk8zNFVQeSs2bkJEZjczNkZueXdMK0Z1VzQ5UE9CNmRSTmlIUi92bCt2am5LMVlsZEFzWEpKZEREa1BNOXBLZVpYRGpNQkJpZjY3VWM1bkdhTXVEc2hQeFBmdmJoN25IbzBSaEdrYUVsdldrdHpla1FXTjk0aVZkd01WSDFJcC8zc09NSHJ0am1vdVRBcVN4Ri9qb0VUN3hPUmp4bGU4cUNTcDdoRVp5RktWKzgvT1IzNHNFVlIwNm5idnN5Zjg3cmRZdVFUaHB3aEtsLzhmMGRQbUZWWlNPS2pjOWFXUjB4TkwxT0tuSXFzYllTWHJEZStES3R4dENSK0w2VUZSdG9ya3N0dnM2MVRYVXBXWXEyeWhhOFhNcUdoMmZMbmVCV1dVaTY0eXl4R3R3cWc0cEsvRG1kVWU2bFoxT3VReHNZNUJWUE9rZEJoaFBJZzNjc1pQV2tydkUyaVZvTzNrZjZvd1FYRDhCejFkRHlKdXRUS2ZQaHRieUxGdTAvTXBjSjc4YWxESGlYZHhzTXNsTmZkalpFb1BkQ1lEbFJ6cWVOOGkydlgvK3F1UWJPTFZlTVJTakZ5cEpSZWF3WGdvMEpHRGhNOGR6S1RyeDNMci9Gci9XcXE2VVNNUk5iY2RjMWpUSldwUzdoemQvbUkwTHl0NklqUEFGekhscE8zdjNmNU4yNXMyZFpjaC8yMzl1WDJxdDYzNlo3QUhDSWdBS1VnZ0dZOGdSWlE0K3k1RW9XNlFtZUdERVJHbE9HSXVRb0ZQb1BaTWlRSVlNUldtRElJRVVEeEVDakhtSm11bnQ2cTMxOSs2YnZKOC9OMzd0VjA0REJVS0Nhd3FtNjc5N2ZXZkxreWN5VEo4OCtkL0pwMStIZTdWNE41eThKZndvZERzcFN3aDNjUi9na2tLbThJSWxiM1o5OHo4dVkvU29sOFpVYlJjdlZLMytDQTJ0SVpWTG1nMWlKK3hHT28xaHdXNFEraXNuaEdtYmFiOTdaeTBsRFdTZ2YrcUwxMFZRbXRDZlFIQndKbkhDS2l1S0w3cXdMNHZES3RrbDRtamk2c3BGVGpoTHYrT0d6eE0yc2JTYTgxalBqZmhCQlRhSEx5cVY4amIyeXJtdnBqeVZicWRpMTNUVGFJTldzOG9BVEdvMXlxOEJqcFlMTEFxM0dhT1g2eGh0dmxFVTVFYUJ3OWdjdjdQYVJYdmV5ckozUS80eGM1ZURsc3h6a1lkWEVhVnFmODFqNGhrZWxjVkE1NjdySGNLMlJOUFNCVVN3cHQ1UlNDTFdVSy9RQUh4MjhXNjZLYi9sTk1iZE10T1VLdDVLQmlmOFVCU2Q5dTlxd0VwcUtGd2twR2NEZm9ZUXlLV2VpRnE1NDNZbnkxcGVReGpCTFdyYkN4NDQzeXJNbWQreWd5dS85L2FHa3pyYUhrdFFVeTM4OU5MR01MNmJpRE9xZ2kvd2FSMHJaNzhJdjlJSzZzQ3BydE5kNURuYWg2TnBSaGF1WnBMUVd1MXg0TGk3Wm91alJ6MUJKdTRhTnh1UUpyNEZyWldsN0t4bjNrQ3Q0TUtoRVFoR05UR1dGT0FrVFBsYmRESjJCQmh4NERBbHZmbFVmSzM1b0VCeWxrN2RiTGt4QzNrbFA2Wk8zNy93N05UUlFSdzRXZ1VKd2hXVlorYjNzam9ZSmZ1dk9JTGJyY0RsTXdGVEVhY1lYbkZZNHNaeVdGbXNFVEh6MEpuRGlWV1dZQkdzT3o0VE9Nanp4T2l6Smw5L3lHd2VZREJ6ODlvZ2piVHQ1WW5uN2VUY1RLMnlLSC9ZWGZzM29rZTVTc1BzM3VCUnl1MHU0VVJDaGk4WWlkbThpWllZN2xYQXRBMGdIVWF4bVRjOElaTkpTbm1pc0VhTmNiUjNWaU8zblBBRDA1OEJ0SVpTM3gyL0NkcEpUcWpoV3FiUmo2VkxPaWMyTnFqdnBaWnl0eDBxTWdHZE1JRmU4UktrZVpadzF3bC9udTBhNW9wUHVhQTBwUkdQMTJCN1lsS3BIL21paHpxMU9GOVcxdnpjWWhnWGVmZmZkM0Z2L2JYWmNQYXY0MGxuaVZrZm81ZlJqeXR4WWFUVUN3VWxGamxRVUQ3cDgvS1FiL0lQUEpCdjhVbTZOa2NGcmNjUTFYTFVTSlMrKzM5WmxvMXYxSGtJWGVLTVhQdkVYejhvUStYV2VZUGtXUjl4YUFoYy8zMmJUaFhzNGZwNkNBMWIrTlZ3dzhNRmtWUUJPZFlHeVNDblRLRmJhbE5lNzg0YWZPWTJBcWxQN0hUT1pDSlhYZWxaSHhCQk5lYVVaeWxCREk3d2Jnb280L1JubEdHV1JSNW1Hck1ZcFQzNHAxU2hQOEtzNFU3bUFzRVZXZlhCKzhLVkxYWS9za0FjTk82dFRPZzJOZjhtay9LUXI1WnJoQUcvbGc3R1Q5ZGFTWG05Qk9qZEQxSjF0a1F2NDBpRm9vQjRVMytJbnJiaCtuNFVlZm9Ndi8vR3NaaVhNamNVUFAvN292L3hmLytMbi8rd1MxKy8zVnlsWEtCWWhKc1lybks2Y2duR2xrRUxFSWpZTExJVG9weXVGZU5LcENNei9JWnFYY2NlQStoRGFwZkFPbVpMMEpYZ0ZwM3lILy9SWkwvbEpIeFFxVFF2OXdDZFJPdU5aZW1Galcrb1FKbWt3bU1BcUcydTIvV3oxNVB5V3pwdGI0angranQrVC94ckZtZ29WYUZHa2hDajBpWktnQmtPdUdvdVZyQ2FGZ2p1RlEwbGsrM1ExWXBUa3crQnhrQ01DdDdNMXR1aU1sbkVVaUNkZGpQcXQwYk5MaUJVN2xsdGxzMGNPUVhFRFFwaTVXTGtScFJRYVVPYUhVZTduaDdHMktMa0lzenVZU3ZGT3RLc3l4VkxLWU1OeTRveGZDN2M5LzJ0Um90c1pIbHBQR1IwL2FDMmxTckMxZGJYT0RUVms4ZUxwazZLbnRDcVBHMEZkOGVFZXFQMG9FclJtZ2FDMVE1YXhpQkwyVUFTc1p6VHh0dmVjQWpkOFlJbE9uWklVeFZ3eUdMekYwMTNGbTZLTkNobjRZTW1mWDhuUFZFWmhOazdBQzR3aEM1TWNCZy84TlVrcExWZUtNYkM1OXBPbW4xWWF4UlBLcDh1bEhHQk56MUNRbEdMeUNHaXdwTFhqRUU1b2lNOTk4NEg4NVBIcXUrVlBQaDVLZCtReDRvK3g2NkVBZzBJMlk0U2J5emhrZUZqMXBhVGxrUWNjK09SVjMxWUVOVjFvU0lxMTZKMDRYVzdVS1J4WTdoSnlTY2NxTGJ6QXk0T1dHOU02YW5nNlR0UGFWdHV1ZTZWS2x4OE41QVVYY2YwMnFMV2VucGY4ZTRXQ2N5ZXVaU25pMjduQyswZWZmUEtqVDMvOTYwOEhBdC92djFWbkI3RnozdWJ6cDR1enJERjg3NzBjeHBzbE9XZlRtcnVOVEk1VW5IREdOanBkUG1PS3RWa2dCYWRVanRQZHJKT0dKbWFlWmoxaXpWaW53aHhrcHhmaDNnalJ3b0pTWnBaa0hVMG5SSmtzTzg3T0xNLzZkSDdzR05pT1VQYy8vY0s0ZExoVFVkUGF4NUxtY3h6SnplcWVkRE14UE9NenFXVGxwZ3JScHovMWpDWmh3VkJ2MnoweDBUMUJLZ3VMMGs0bFFsK1dXaW80SzhNam5nYm54Y1ZlV1R4S2tpdUF4aVBubkxNYTFSSExLMXVHMDYwNUtHbE1hWVBrN3BIakd6Y1cxMlBGdWpHVGNiOTNucnUwdG5LWDFPMWNwL0UwMXhCL25nb2ZoYlNXY1VYTGpRNUNtK2ZaN2JZYk9CY1J6S3RyV1d0NkhOcGx0dUNpdGd5bnpHa0l0dS9jQ0M5U3B0QmdTNnQvSjBvM2xEa2txT21pcnV5dmwvSjkvdlJGMHEza1VqdGpzeFJVSnJ1U1g2Q05TaE9rNExpVlhVb1hVYUp1TWNqcG9vdnJhVFNjczFsanBPbGVJdnBwdHRnNkgzWnRON3ZGYmwxYm5OelB1dWlMTkJnWlI3MlNOWTBxU0duUUtPUlVrZEl1Wnhsdmx0WWllbFpMMFRTS3hxMEVuTFdScFJqdDBMTVJKVHh3Y0l0RjdXZkI1U2piWU5lekpPd2ljRFFXR2ljTkRhZFNvb0VkUFJvMmo0WHpYQ2tud3g4SnJ6V2pRVWRJWGJjU0pJVWJ3aUVQa0hZMEhsNlhVcG5tR2NnTHBsbDF3WldpcEFBVU0rVk5pY3JmQVNaTzJnOERNajRjQ1E3ZzFVeUVnYmNSSHRZd1FWYU9tbnpVb0N1dkF5RXBuVG9JUEhUTnJwNktMNDlFQ3R4aFdVZkFxM2Uwa1dFejVMWGROVm91VDdpZE9pQ214anVtaCtBbERmcFFGUWFQSXFJVEJOVS9NYXNSeXpyVm9RTW94NWdIS1VPZEFSRGVVZDZBRzhkRmsxQjYwQ28walRUV2lva1VNYklic01GMUpiRHNWanV3UlRkbFFkOVY5RXQ2Vm0wS1hiell5RHByUGJ3RTU3Y2hpdVNWSWJUZG5FZXJRVjNMMmNXN2FmaFAxaEkvSjJnZHJoMW16SDlsOGU3dHEvLzQwMTh2ZmlxMzc3c3J5VVkwRm9GWjdCczN4dklmQ2liYXN3cU44RndKWE9JaUdNSlZDNVJCZlRPV0JNVzdkeURWclBiWU9IN0pPSlNNSXpnTlN6cHJNY0hrWDBKVnNWNyswL0dMQ1ZNOGFUaHBHc2Q1K2hLWVZMSzJCSVdSTGJDRVlUb1lLaXEvVXFwcEJFYThZUm1CcjJIZ0tJVWFrNnRmZ1pYM0dLTkxDeDdwcmJ6TktvT2RzTmdOTlltaDhxZnpHNUVlNVphM3JwZmRVdGRqdFpwQTJvb2xLaDJhRWtDS241S2pJSmQ3L1lPSDlkaUZuN3p6Sk9jaG1CUDlydWRnYWx1V2o1TE9UTGE3a3B4bXI0endPTWtpYmlzSUtGVmpaYXdxdVBac3I4VU4rN0UyZG1MbHJwM3RWSmMrVmFQeU9RNU9ZMUptZExQalhiaTQ0MHRkNTFvdTBKTkRYenhHVzg5S3lpQ01uN0E1RC9IV2IrSEtxSUZESzNUM2RGaW5BNk5Xb3lRTlhTcGQwUy81ZGhzTEIvN1NpSTlQbk44b0tIN0RFNDlCNE0zSm14ditZeEtwWUFRM1RqcnAwYkY0SDcvNWNKVTQwZ29UejVzTlFHSHhyeDVlRUpVYm5RbWUxUWJDMEdvb1Z3MVBKWnJ3R2NOQ0RCcUdCd1VMbmNwSFF6WnpqZFBNS3lDVDM0UVRYY2ZONDRIcmQvdDVkM3h4YThLNnlCUC9sTnNEei9KS3VOVUZuWWZKS1kxU1VoVmRBbldjSDVIODlUNFlOWDFiTGpsMmxvYllqdkpzZ09pd21RUGtuYkZoK096ZGQ5LytUeGVMdi9oM1E3a1NhSldPWWlVNHQ5KzhQYXkyRUhWMW1wbkVXek9BTFV3RXhWT1ZkVkt1dFNlY2RUS2FzS1hBaGxZbEtCUVVSbFVGeTF0NitWWEZpWElWUnBoMXJybG1LbUxYa0FJK2hWR1c4WWhUWGV3d1NhWHlXNWRFR3YvYWdXZXJweklxUXp2bDRHZXJvMGJsTUdXSEYrYmRURGNZVGlaU1dGY2MzQW1ZdUtiVlM1RWttOEl4ZVVaMC9LZzNXWkt2N0l3MWdYV1lsamxxT2J1M3hnTHd3ak1Sd2JIVGluTGR6cjFhWmxwWnppRk9KaVppZWViY2dMT0RqRm5HOG9lekdXVUYxc0xENTlTeGdxSGhxUjFocVhNcFVyNmppQkxmeElyVHArN2Z2YmQ0OHZCUjRiSWR5L1lvbG83akVsbDNYTkN1eW12Ym92eFAwaUR1NVhDVlhaWnJhbDhwazhUVDdZWVR5ODVRUUdXWU1qaDdVeU1oM21tc2JlZWhGcDBBUjR5NDJuZ1IrbGFQUVk4RDdvbFBCamhsSzVxRmJzS2FQeFdZUCtLU05VNGw5RlM4cFBjdUdjRFBQSDZQWi9CSEd2QTQvZzZ3NlRobHpTYk1iM0U4OXI5ejhNRW5EcDdJVlJac2ZsZjZ5UjkvZXhsYnBXSEdCYjl4UXRwbytJSkJ5UithTzUyTVFpcmxtUUdabW9Nb3ZNUGZHRE0xVzUrOHJKbGw5WmVzNUJ0c3pDcVpteHFJd2k5KzhLbmhnZVRNK1QxM0RZTmZMYitLcEZZY2lqRk8yYXIrb090VTdwRm1LT3R1RENydWhJUHdxa1BCdldVSnpPWmowM3lleG5mTnc0U2VxN21xZTJOdDlEUXN3U3M1QzB5SEUxRzhUa01EejVrVFZyV2cvYlgwVkQ1NDU5MGYvZkdQZnZjZi80dFAvK3A3ZjRoMmVMd2FSWkxEc0RQeFlTYVh0VUFZTU1FNG9pUEhFR3dJMzdpVFNYZVN3Q2s4Zjkvak1aZzlpTjZDaTZDdWYxQWhXN0VTU1BGVkdFVFZBczhGd0RmWGI5OGxESk9mNzg2em1TaHVDZUJVb2Z2M1VLd3F5aENvdGp5bGs0MjNkTXJkazNoZzg0ZGJsNzNoVmFLa2cyRXJjckplYW1KNkUyM3hDOC9BT01wUXdRa2h5U2JSOG9zRlNLRWZ2c2hXeUh3YlA5MkpjbDFONit5NkhIRjBOMWQxTGJNTitkakIwbEgwSjFmVENFVUphc0JxaldyU25nWU81VnNISUtlN2VaVGZ2UVNLa250NDczN042Rk5JeG1XdEhtQ3RKcVBDc2JZZXhwS3l1NnVVUitwVHVCbExsZ0tnN0tKWWdsT3R6VXdqZUpERHVDM3NQam1La2d5c252dzR5Wm1pK0RuV3p1YXFrUEMwYUJ1NlI0elN6YVRZU0ZiZ1JsRzdxdnM4ank0NXY2VkxYaXg0NDIyczk5cnBGNTYyUXRVZzRra1ZBWjJFNVRmY05ZS0dFTnFoWTlFeUh2M3R6ZUZQUEFjTm1sZmh1NzQrZU9TR3JDaERsU001VnI3U3haRlovZ1AreUVjYXlway9KNC9DTS9EazViR2UyZW9GWWxxeUdRVmJKNktsOFJHZjdGWCttV1NxelRod0sxUlR6c3FiOGg5bDBOVDRycTY3L1BLb3QzTlg1UlJXYWFVWURkaWdSOU5oS0czcHVveWxySmY1SllDRlhCRkduYkRTUUgwV0h3ZUxUbE85RWEzb2t2U1g4Q3AxaHRhMnF2RVZmdUtRcDlCcWtDZERUOUVMK0lndUYwNzlqaXlnVGQzTGwySnRodmUzY2szNEc3ZHYvemhaZlArVnEwTHFNbElrTExlZDNkd1lXYlV2aEdZbHBxQk5QSlduRkdNcUp2bVJsbXZHemQvQ3JJbjBOcFpIZ1ZCZ2hBY016OUlhQ1hXYkNjWENtWHpVMkZCK2ExMUxwaUk4OVM5d1dXM3VhQ0swOGhhSFVwL2owZmhwTWVGaUROWWJIcWRUUmFUNGxSMStadkdiSGhqZHNNQ3B5aHVlczVRcXovRXFCWUZLbGpjWlB5YkN3WGhZMk1HWHNxcHJsSU9naG9uU2N4OFp5L0lvU2xNK0RrZFp6N3JTNDFpaHVyb1hVU3hyR1h0Y3pjT0NaWTI2WDM3RlRRUXBnMHBDeVJrN3RWU0ZwVlJYdW1ROTVkdTUyMm9sL3ZKOG5GVUk3ckphallWcGFkTkY0c1pBQ3ZwVVd2N0ZqM1FyVzFXVzBGRTNsTVhnVVNWcU1tVFVnQnBxTU56QXNqQkVnSWNIdVpTUGdsL05pZ1V3VkJpOGFRdk51TjZRQi95Sy84U2pibXlyWWlyenhKK3V0Tlh3bHQrc1M0NjZ3VkZjRFJOSGRzaE5MZm5LOStEWmdDZmM3NHFUTU9uYVQrRks3aUxqNUtGa0l2anhHM0V1allmYWtSUi91SEZMR1V3NkRSVzRubDd2V3BHbVArcVFNbkk2OCtvVFI0NlVCZTRhT2Z3SUJNeXArR3NaSTgvL3dwOXNnVjlqclVuUjd0S3F4Q2x4SlI5bHZJelRZY2xCaE1uMXQwYkU5M2d1cmVWZ04ySWEyeTI4ODBLYlBNNFYxb2lqbFFiMVBMMVdEYXBHM3ZneFdJRlVxWlJQYXdJdnhwZXhjZlJ3VkdaU1IvN2RVcHU2a1FiYVdtYTlUZUhrem8wSStLcERRZGF2WmQ3ajFzM3JmeklWNFh2OVduZE5oSk52V0NuWGMrQUdKVVB4YWFsNnQ1RHJ0VlY2Y1ZYaUZEc0ZId0xlcFVQTW9iaUc1VFdVNkxRZ0dUUHlpTU8vbFRRQ2x2S2VySVdHNVkzWTgwZmFkdnkxME1XQWZMZnJPSTFML3hhUGNFakg4WWZIbU5rY1M1RGdBYTlIT1hDNkt6VmxDMisvdWNJVnJFWUZIb0ZMcVFkNndiWGx0UE9xaXBPODVGOG5CVVU1bnFYYldGWm9sSkdEb3ozdXBMLzl4cDNGbFp2WEY4ZVpWTlA5dnNpekd1RmJOOVFTbXNQQmtxYnp0T2dxT0lYc1hRS2N1SStuT0N2cGFtM21vanVMMjkzMnV1YzgxQ0RvTUc3NzZsT0l3aE1wV0gyVVJnTHFxRHdYTlc0RXptYjh6SFJTdk9jWmdqQUpaeWlCRlVzMldLK255UU05RHBQSHM0enBVakNySzdmVHJSc1ZJU21EVzVSWjZFRzJpZ1laeTNXNDh0aTFOY2JuVkJ4aHhROTVKaDlsNC9qaG1YendyUGcyOGNJRVQ2OWxOYzUzNmttWVExaTQ1clZ2NlZyK3dxWnlGUjdZRlJiNGFNblBLZ2R2c0VLZWN2Q0RzN0tUaVpLRDBMTWRQTnVaZVpkWE80MjlMcjdsWUM3emErVk13WUo3YmlJNDRmbFRTZlJNeW44Rzh3TE0vQk90ZGxzcFJPR1dmQUwvVWlCSHJzcWtERlhHQ1JGK0hJVmVTU2krZ2tGWHRtS05YK0tOdUZNWm9nY2FqdmdhRHowTEQ0U0FVQWRNYnRlVGxydG9tdkRHUVhrNDd5ZTVnSEE3bTFId21GSkdaL1FhaHpVNW9EOG54RmtIVFZiSWE1SXlJb3pQa28ycjJ5dUxkMjYvK2ZhLzk4RUhmL2l6TDcvOFhsKzlYVWNPRWhnM1QxS3NMQmhFUUJnRUpGREhhWTNHT3pPRnFRd1VDZVZtcktST1hNcjNJR2lFYUdyRkVRME04Rml0QkJJTU0vTEdkd2trb3BhZ1lsZ1k1VGRtU2RjNCtPYUVlK1p1K0EwZmFSdkdnTnRDUG9STVV1RnplUEwyeUl1MUNpZFdwWGo4dlRud3hLbEtaUGFVVWdwYUtUVVJIUk1UOVNYeWxGOStVM3k2d0ZwZ3U2UDIwMERkeUNUcFNmSndzK2xCaGdWZVBIdStlQ05EQWplalhHL2V1YjNZei9qb3FWa3JyYnJkTE16TWZGUDhOZ0NZb2RmMURFcXBidW1XUmVnTVo2QXQvTTR6WVpYTytlTHIrM2NYWDM3ejllSjVHc1RWaktVNlUwQTNVemxLTHdRc0M1VkZaS3pQM1ZqR1JtTnpMRll6MDN1YW9hSWpKeDVkSDdQNEtoRGx2cGNWSlFmUHN3NDZhMDNmdUhPcnJtY3hsTUZpWVhYQXMrZ0t3ZVFYREtzaW9UdDZhcHc1MzgyekRpdjZHb2FZd3EwV0VLYVJFcitHSmhKbVhhbTBWZDdBczB5VFJXeThlUzFEV3h5K1NOTVB2d0ZyVkhwMFlIbURBOTVTb2VlRXVJWnRWNkp2Q3BHaUpkUG9YQTJiY3hJU0JpYitnaWU4VnNSTVpXdVpxWHdUdDhxUXdsV2FLRlBoRlJiNnNVQXA0bzJrNWNmVjZvT2tjMlpGOXlLTlAzS2thN2dobytOYkhnTm01VEhCRVNadnJtR1A5MldkV3RLSmZFOXU5R0FITGcycUxQUEFva2oxaEtTekNjRm1rVHFQSUNzTktxY2tZTHdvWStmdDJ3bHM2RzZvRVAvSVMzUm02QmE2RjgrU2YyUkFJMEJlNFluT3h2WXZVcmFJY2c3UWZtL3h5WWNmL2pUSzlSODFydC9IZDBtaWJyRXhOMG93SlZzeVBWV2hDcTgxVVNrUVkwMUZuVnAzdjhjQkVra1ZpdXBlckVWUTI2bGtOWjVvdldTK1dXeVVLd1hXUkVONDdFTkFjVTVaYWpoSm1yM3pOSE84SXo0VnY5Smo0MlJCVUhQQ0FxaGdnVmZDbjg1S3U0WWpyVy9yNmNUQllKWEdleWMwcUhTSjR6Y0hMMDdsNmN2bXdPQUlFbGgrZVJNK2xjMjhCamlkSjFwWlFyU1NDWjNLTDdUWXk3Q0FpYk03Nzd4VkRadXJxaTMzY20vWmlpdkUwM2c1VlVnWFd4cHJWYTl2M1V4bFMrY3k5RGxQNjY1bFo2eHBJT0hrYm5qTHBMNisrKzNpNnh3aWRKQjh6b0ovVkVENFJoRUVyeVNnc0tvYmpXN0p5bE1LM1pCUXhucVBudTh0RHRNd3NxcVRNR1VmMWh5YzhlOTJGblcva3dNMXJOSEY0ejBUYUdtZ05KeVVrWEkzSFkydjZ0ZjVmWkJ5dE5McE9NbTVjSWUvQ29sV1lGQmk1WmY4dTVLNkJMSDVJVXlGcTdlMGliZVNoOU45TG40RUQwNGNybWZ6NVlHdVlMV3lscWY3cktTcjhNVHhMUTdad3YrU2dVa2U1dkRselhVKy9RMk9NREE4Nm9uZndTNE5KOW1NOGxhT1RQQndheWRaelpFMzJQVTc3OFlCZnZMWHE4VFBjbmxWM09xNkQ2L3YrdnNxWHZNNFhZNkNNK1g3Y3Z6TDJCVW5QN3RjUW1wWVFKbFNqbTRJZlN1bmVKMkdIL251dWhiTWwySGlLQjhMbG5KTjFCb3FxUjF1eWFQb0YvMFNFMkh4MWx0dkxUNysrSk1mLy81bjMvN2c1OS84K25NNGZCOWRHcEFJVnhTbXdwM3AvbVhScUJiVEJYb0hCN2xCTWhYVkxndENzQmxyaFRJN1RSeFdsRzJUaVphMGxBOEZZOUppdE9aREVDd3RHWHZmRVZxbDNNdE5zcjRUdlN3bkZhNSsweElFTG1NeU5TaWZjQVF1SXVkYnZLNnNVY01oOW1Cd0gxd2hEQU9DVEpWRmVUend4dFRCYkFwaXJHTzE1S1dzaFNnY3kzUHNsTUZZaHhGVFZKSVNHdW5HNEQxcktkMlZGSmdmL0F0K0lpcjNnRCtVb1R5UEkxU3NWc3U5ZEYvMzBqaHRwd0xzNTdLNDZ6bDBPdnFyR2h2bnFEb3MrMWFPOXJ0OTdkYmkyMWhlenlqNTdPV241MWdJRzhIdjZFVVVXdXpBOVhUN09WZWlSRXFMUUd0Uk1GdDFhMjNpeFNLNEgrdjM0WU1IRlFjRkxQT3hQdFJreWdVVE5mZ1o5N0kyZHlOS2FEWCt4emtUZGl0MzF4UDh6VHluRHEzZTJndTg5RGl5Uzh0NDhONWV6dmZOTUlCSnN5ZVA3bWVaMkllTEs3R2tiOSs0dW5odzc4dnNGa3YraDFuNXNCT1ptczRWclRZeXZOV0QyY3JheHJyMjQwVWFtb05wUEQ2S21SS3RSaW5JVWpxc05DUm15OWkxcEdIQmk4M3dhRDI4b1dCVTJ1SjV0djZ5ZlBLakpDaS9CbjhLUU1vcUxQQmFIdXBnbFF4aytnMEcyWTQwWlh3NWVHUnpodFVRemN0VWNkQ0tEelVibDdwUzE2SnIxR0l1YnlsamNMU3JUQm93TmFCVVp3OTMxREs2NEZZVkpUSnduRzIvTER6cFNsN3pwZW1yZThxU1Avd1UzcjFqUitucGlIUHViTjhVY3Eyc1JRV0tVaVpiZ1J2SnJUTEsvelJ5RWxzL2ZvR1o4UHJJOTlJbEtWa1FJSDZpNWgyWnpmcGxwM0VaMG1BOUczb1FyTVVsODdEdFliaFFMRGwyM1VwYTBWSnVSc2RHNGg1R3ppekZHZ0VKckd3QUN3eXlIRjFoTmNDTG5HdTdHUm0wQkZIdkYvODNjd1hPVHNxTEw4OWRDeDlhYmVkOFl1dmF6L2J3ZkxHNFlWVk5qS0xmLy9qOXhSZWYzUG52bzF6LzR3TCtQZnhUbGl2bGh0amR5b3p2NFVkZ01KRlQyWThqNklTN21CTy9ZbkNJaVh3WVVpMnJ5SEdHR1d5VEZKZGlWWEhGNzdUaStQYkFRVjZFWnU1ZlAyYnhWTkk2enpSKzhGMkxzcENlRUJCRVIreTFhOWgrOTdjOCtuazFuamdhQTdpQTdYZFhnS1pONFRqQjYvVGU0bkpkRHZGcVI0NndDSjRLNWNiUncxU3duWFNqck1kbjVabEFRNXZyeWZkMnprKzlmdVBXNHVuTzR4QTZqVmhBSHBvZ1NQajZ5VmE2VkZuOG4yOFRSQ3JQV1FSU1plbTFvM0E0WThtbjhsT0FoL3ZQdzY5WURxa1FkZ0pGVTZjOHdURVY0T2ppSUFxY0ZSZ1l3UlhlRnVwZmovQXFDWXQzZFMvVnlGS3I1TG1XV1Y3bHFUeENHemg3OEJOUE9EUlNKajBoUEVKTGFkQ3dLMlNkc3BUZWpiYzhxUWNQbFZDVzlHZ2ZFYlR5bXNnNkxPdmtJVTNSV0tNWTJPaXNjc09qZVRYNE8rU28rVlh4RWtkYThjclNUNlBuS25US3UvRUZoMnVydWVWVnVwYUpwZ0ZaSDNtRnRuRytoUm1mTmRic3UvM0Y4QnVjaUVGWjNPS0RDVTQxN0ptTVhObEkzWnJpTnJ6VmJCNDV4cmk0Sks5OHFrWGhOWlhkT3lSTUJMRkdYdVByOG0vRGE1L0dyMy9QMytJV3pNblRiMC8xY09RVDUxVXdZdTBQcGF4UklXRFRjRURLVzVjZ0JuZmwxdnM1RDIzQXdldUNKeDlKMENXeWZwNk5BcjRyTEx3QXYrc2VubTFtN1RlSnRtUHJ3L2MrK0pNZnZmZjFqejc5K3V2djVZNnR0WC93Z3pkKzBrUldJSXhXbUdxcHd1VkpQSXFVS1g1Vk9uRll0c2hiMno1bnlsVTFBYzhtZ2p0MzNpaUZZWWRXajdXV21aOTg1T1hwdkFOc3VDZ0h4T1YrS3l4K1E5aEhtSGpWMVUxK3ZjUktPbkE1NmZzcGovd1IxaFZ4R2EvZ3BIU0pUeUd3VGxubHRrSnVSQUhKdzdCSUhhd3hBZXEwM28ybjk3bWFFN3Jvd0t6WjZVSUVWWjZ5TmpLN0grRXpMb2V5Nm9iRjBkZHZ4R3A5NjgyNnArb2dsdUYreG1KampFWUJKUjU4WTQxR1NxUEVzdEhnU2hSaVlJNXh2bGpId2RINXFaU1k3dTFhVmhPc3BRYlFwWVk0M3J4emMvSFJSeDhzUG56LzNjVzc3N3k1dUpIelVYZGlpVklBUjliUTVzSkIzNnNaeTZOa2RtSXA0TE5IQmJhcnB1NmVENTU2TVhlLy9xYTYvNFlXN3FReFVKWVhHZHE0ZSsvYm9pdWNEUk9nRzZWckI1YUtoNjV3WlNtVi9JUW1YUGtuYkU1UHloSXRXYVFtVzFoOTBsR0tibllZNXlGTWZKd3FxUjVUTldhSkQxYit6MkNtL2lhZFIrVm1NWlh5RE4rZDFXQW9RbjlkdXFqUUtnY1o4YnZmeGR0SlR1RGRZZjA5OGt5bThKWjVIRVhrZStBMUxNM3pOSERvVWZFMEs4RTNtTWN2c2d5UDBNSjd5SGFFSUZHSkVGcmdVMTJFbWZUVi9TWm5nZC8vQnQzUTZsTHVmYytkOGZGTE4vQ2NyeFlZeHMzd0QvTDVQd3lueXpRcFgzNFkyNFdUY1NhNDFnMEZlbm9KeGF1YVBNMmJKVjdiYTVPdm5ySDVoc1NJaFo5TklTa1AyZ0JqNTU1RGdVNmlZTW1oZ3BNZjZac1c0QnhtbUV6dlFVL1RtdHpIVHgvZCtLdXZ2dm1ma3VCNzU5Yis0UDFiUCttV2dmQ05MaGdtcWw3SWtHTG1Ed1hEajBWVGhZM2ZFQ2hDT0N3QzhSQURRMVdnTjdNWG1QWDZJTjFVeXBWZjJGNUVhQUhzTnlIbWhMWndsTWNyZitSOVpod3lBamdxNlJCRWVVc0hUcWZ2OThEenNxS0lNNjgwUFNFaHZ1NU5NN01zcjlCa05EYWpjaGQrYzV3aWdPMG5mWlVuM1grS1ZZVW5mS0hjR0d1TG1la293SzEwODdhU3pqRi9XMUZPMTdKSzQ5YWJiOVE5VlphNFVIcTJpNnFjNkU2aHVFNmp1cy9abGd4M09CTEcyblNRYndwSWovL2tOTnRDTTN6ejVodTNGdSsvOSs3aWs0OC9Xdnp1NzN5eStMM2YrZUhpOTM3NGNaVHNoN1ZIZXozV2J5bnl2U3lwU2o1bVprdkFyVDBNeHJaa3drVlBKWHFuRHJyV0s3ajd6YmVEbDFuR2R1UDZqZlJNcmxkbHU1c3hYblRhU2hkdU54TnNicWhsYWRqcVdXUFFLWVBHS2NXdWVDMXpUZVBtVWROd0tOWU1DeXo1TWNidXRnT1hFNyt0bno2MGhULzVReCtTVkxJU25NZ2MyVVkvazFUZThxWEVOSnJ3YXdWVHh5QW1mY3ZJWEU3QWg5K0FQM0RvY0dHY2NFNERDS1ovOWM0M2ZLMGFTU1RvQ1VuWW1BQ1NydlJleWxWS05reFoxaFh4QUUyYU90MC9QOUNTc2hraGlRa2tHQUhTT0VneWQraEJIa3RHSzZDZ0R2eFM1dklQamswTGlqK2xsTzNTclVUSStJeDhLZGprSGJpMW9pUzBKRXkxckN6K1k2UFBVTHcydXZSRUxod1lMMjZYVHNxQ1paanJNUEpNTHRWcmNsTHlIbGJTU1VOZXlFNFVjeHI1NG1kV0hSd2VILytEd3hmUC9wZTdUNTU5dFVUeWUvS3hYZ3F2bURJc2lqbGVtT1JmS2RacU5ZZUFZMEpaRkNHTGxtNHNEeG5NYmNZaGpKWUhmRjFmM1VXdXRsbWlYRnpCVHg0dG9INnJDbitUSzhGSnZIYWRYNzlMZ0JKWThmTG1QMy9tNFJxTCtrM29wcmcxdmh6bGFBd09YbVpNMXpNRHZ4RlQwRy83OGpud08wL3Z6azhjNHllcWQrUm1WQmo0NmlabUxHQXYzMGZSVnVkbHhWbU1mMXBiVkI4L2Zyell5RjFsdDlJZ3ZmWGgrelgyL2VKdVZnNWtyUFVvMXRWNkdyWDlwM3VMMWVkWmsydnNPOHJDK1BWZWJuNk45QzEyZytQVjdQYmF1QnBMOXVycTRvb2htVmlwRWROU3prN0djcC9SVWJxWUw3SXU5UWNmZnJoNDk4MDNGei83eTMrOXVQdmwxNFVyYy9mKzh5ZUxFNW90U29yMkwrVVh5M1RueFZYRUxIcmg2WDV1R0hCUjRWdHZ2VkZEUHlhMlRGZ1NlbVBObEF0WEZwZnkwK0JwTFNnWXd4bzJIOEROQkNnL2NwWlgrRC9KV0xJM1hHRzhHNDlpMkNENkpTOERydmdhdjFvKzVQZmtKMS84VUNFOWRiVTRaUm80N2UvdFVUNjh3dWVTaFdMY2dJMlhuUVpNK1pGcDZkcmZ1M2llOFBxR2c3SUhEbnltejFJMGNERVJPVnhncEtGZGcxTzZ5MkN1NUd3QmE0akJROGRRc2dBWUo2ZkE2aW1ZVWRrNTJJSUZuNlVleVhlVUYxeERkL0FFdzV2cnNucVhwVHY1UTI0ZTVqc2VTVmZKTHRNV2pPRjNxYzZUYjhXUFA0VWV4VG9PYU1ra1lXZ3FiL1J3Zm11OUl6T1VwSHZtQ3Nta09Za3loV2ROZU9hM2NXVU5NbDFoQ0pGekFhTjBjS1AwcjJUaTNSYjcvUXgzWGN0azZ3OC8rbWp4cTg4Ly95LysvTmRmL2llVjRIdjBweXhYaXBBclFVeGhPWVRETzl2MXhwS3JDSGhaWVlONUtXb1Z0cnNSZUk1WldqVnVPN09DTjlMZE5TNTMvOEhEUWRnUXZFKzhhY1o3RXlUdllrZ1I4Wks3N2UvTkRRRzRWR2J5NUxxMXJSL1RIMmt3cngrL0szM0N2WWV3dGtDTnVJUWZQaW9SZWhBTUIwY2JPL1o5a0FtdmlIbFpjOGxVeHZYTnVsTnlWM1lRbnBwZmprZFpFbEVVeHVDTzA1VmF6K0V0VjJLNTdrYXBwSk5mcC9oYmdiR2V6UnRic2ZqV3N5UU8zVld5WTkxMnJiZ0Ivd2dsUzJEaldpNEt6SFpaTzdyMk1pbndiWTc4dS92VlY0c1hqM0liYStLYmROclA4cTc5YkZMUXhTcmJLVGlleGxJNHpqS1lhN2tZMGRJdE02NFVJMFVuemNGaGp2SUwvcWNSWm56V1RXWEZwNlN4SU1hWnNpeUxaMUcwZUVvUnVrcjdhaWJuV01yZjN2MW1IQUsrZmFWNkt5elh1aTQ3VUZtTHhrZExZZVNOamg2dWVWTS84a2REcnVFbWhlSlhUNmdhOWpHTVVGZWlUT2twWDA2RkI0ZWlITllXL280ODhGREJoSmNzVllvaDYyVWhKbkIwMjhNa0x1V3ZlQlBzeHJWbEFVNWdjUzFMdmpzZWhWcDRsMldwNFJnNGlnTlBjTWhkS1JoK1ViQWxwK0pGaUM3a1gvNGpIZHo2a1Q2MXNOTFVwSkU2R3RtdzZxSGhhbWphZFRtODJ6RkdsLzZWazVETDhLN1A0cERuWkZIdmptT25IUlBJY3FwcUtOTHErZGJyZ2NjcUpRbGszc05hVGU4cWl0SzJhTmJ0dU14eE5FNXVva1ZMY2hMaGpnR1R5eW16WmxzanphbUQ1QXd1SlRzczlhQnE0OUJoWkpDT2NxaFJOc3I4d2FOSFQvNjdKNnk0NzVITG1PdWJQNEY0S1J1VW5Kd3Y0enRPd0JvejVCT1JVN2lLT3pGRTk2VEhJaW00VUx3STVyNTc0MjRPaG42ZU1VU0NyMVd5ZmJFRkZCeUVhOEVmY0FjeG9iRVVnc1RwYjBLY0xHYjRkdGdRK0libDNkOVRrZXBWNlpQdmdETXFJTkhxK0lTMnJsTU9vNCtpNEpEa3cxaDVsSkVXOWVtTG5DODZ1Y2JKbS9PdU1TUUtHaHdXS3RHa3NHS0VaQ293ZmpsZEs4SzBtL0N0RkdTYllrMzNlODFTdU91WkNVMVh4M0lqQW5TUUdmc01lc1lxQ0d4S0oybTNydWRHZ096bTJvb1NwZ1QzSTA4dlF1UGpaOWxLNnl5Q1dOYkhUaVNpbEpNL2dhMHpTcVB3clo5ZHl3dzN5M0lyNDY1NGRQVmFycEFKYnlqTzV5OHlReHRjV2FZcWF5MDdTNzZLNTZRdUI4SlFyc0kyTTlHbEthVjRXY2lQSGoyc1pXVk81bklqNjBiR05mRmM3Uml3SWllVVpZQlJhaFJNMFQyL1dWTkY2QkNiYXFHUXlBS2VHRm9wWGtVTzBYYTl4c0JIZDdSb1BvbnNrbjlweEFaZmlpWFRueEdwWU1vcnpuY3AxOUFJM0ZaeWhnVXFqSnpCNTVXbmVUMlAwL0NVRXh6anptUWYzZlZlQWlJS2gyTElzcjhvbXVpZFVneVVKWG1yaVRuTk1kd2l4dlhPZDhsU2dQdnRHY3ZJTkVvQm1QL29ZZ1dJWWJMS0pCbjE3aWo0dFlNeitxaDNSZk44ajNJTU9vZEowKytrQ0Q3TDN4TmJ5a0tkNG1SZ0kvbU5JVG1IdjhPQllpVXpuaXg0THB3TzA2dmFUK04vSExrU1hzbzM3K00wbElZRUtGWjN0OEhieGcveXJyd1BINC9yZkhhbmRmYzE5REhocjlCV1ROVGtjT2pvTE4rTDZCOEhDajErY08vcFovY2YvbG1YK2Z2d2p1eU9kWjVGR0dSTlFkcTFZQ0Vncmd1cmZ4VkhwUnR4dllmQ0RMT0t6NnlkYkw4TUFhempKSFRXdDNsTWlzZ1R6SDVMMzhMUTN3MjcvUnVuYWdoZWlqOHNDY3VxS3UwVTBmY2NSc1BwTXRYdk1OWmIxMVJjK1BRRERKcFFFS3hXcCs3ZnYzKy9vRXRUZVUxdm5wMVhSY2lmcWpqZ2hpRG5HUTY0U010c2NralgvRGlDNUFpL2t5Z3NXempSeVJwUkxmWnFoUEZXbE5VVlYreGNTMWY4SU9jUVpIeS9kbXlwVUtHbERRamJzUVJNSEwyWnJ2MUoxcDQrTzd4WDF1NUtGdGhhSzR4bGptRThqVks5a3Q5Yk9jcVJncVJZN1g0NTNvc1ZrYVV2R2c2TkhyKzlMSDk1OU9CZUZIa3M4R2dBeTRyMmNuSStvWGE1b0hKcllKUVZYWFRYOEJmKzNYajIrRmhaTm1nN0VhVG9HK2xwMnZuOUtzMUVoVi9VM3BScXZDcHRlT05kL0EvY1VlSFZ6Y0ZEWVRWTG42R05qdDlBZWhLbytCbWVTTU5WV2hVMGFTa3ZaVGc0aU9LZndzSHBoMXo0QnNPM09LTmVqRnlFOFdPNStoYUhLb3NlbFZHRkNUZG1pSjdjV1dUV2FwZlY4SWg4VlBwU2JvR1JLT0IzNDFMMUpZcUpMQTA4TlB4VG5za0o3dnc5WE9NSEQ4N2IweFBLNVptbzRnZXRpbDkreWpDcEFEQVNZL0llT0VzZndVcURQeFNyeE9wMzhWc1BJNU5ONUtHNzl2S3NzZmU4eGR0TE9MaG9UdDV0Z1ozajdWdFp5RFplVzl2ZE5JZUlTVnNHaVJVcEYwbXJjWHI3N2JjV0gzenc0VC81NGRmMy90dGZQWTUyL3A2NHRYLzQ4ZHMvY1VDRzJmMHF4SXBLRklKVG8rbUtlaE1UUk1Sd0xVVW9FNW9QcGlHK0xwaUJkZ0xRaERBR3gvSmp1YktNRUl1Wlh5MTFDbzlseFRZd0NYaVVEcGt6RnNsU3J1NWhXbjQ3T1NxdjVLZmxYOHZZb3Qvd1ZjRll3bG95ZDlGYnJ3dHFDeGdhRHdFWjcvcFdEckhDUkE4L2NGaFZObExveHJQaUNCR3IzZmM3Nzc2emVQdWR0ek84Y1gveCtOSGRVa1QyODd2YjU4SU1hWjdvcmNCTlJVbmpQYnFDS1VPcVZvek4ydDdvM3F1c21VcHZjRDl4SW5CbldlK2FNMXJYTHJUc21ZVEtlT21OcTdlaThIWlNFekkrR01zd3Qyd3REdEsxM3d5UUd6bDJiU2NIWDYrYTBHSVZYY2xrVVZwM0NqTlFGam1aWUhFdDhRNXVackFod3c0WHNZWXZZbFVHbVZnR29WdVVqbTJvUm94RDdXeEJ6TEtXTklBc1RaYm5adWpLNHYzNk45OHVUcUo0ZFZ2UngybG5LbjdBaEZZWkg0NHlWUlRxN3lqMDJjNFFnOW4zRzFkdkx1NTllNytHSW5aeXhnQjZxa3dzV3lzaVNCUUZqa29Vc0tFRnNqSjNwVUFDSEgvSVNUSU1qRmc5NFMrTER0NXBTak1jUEJRaytQSUpvc1hEVWM0SVVmQ05seVRWR05rOWxnZ3BRMmlWY3Fka1E5NFN6cm9zWEJPdUlxL21QTm5vZ2ZDVDNJK3g0S0JSTkJUdktIV0ZIRzVtMk1PSiszU05GUkZXUXJEb1F1YjBGaUpMb1N2NlFaMXlOM0ZWYTBZajI5WGJpMkpOY1FvUHd6MWtoaUsxRHJaTzVncmdXcGZNekZYeXZOSFEraE0wcUNNdWszN1V4ZUNhT3FhZXFacGNLYkRBUmJ1aTMvQXUyaTVsUC9ESXVicGpIYkZEYjg0cCt2aWhuOEt4T0tNNWs1L3VmdkRBczVTbjR0TWI0ZU9KNGF2MHNvNnkwdVVnMjhkWFFvY29oRG91ODl4NndueWZwcnUvbjhuVHcraUVzeWhGSzJLU2NmUkNiczVJVnNabVhlOStKYko5TTBhRnpTQjdPVHplaEsxYk01eVRRZkEyYzE4UzBkaU1USnNRQTlzMTNORVRWKzkrL2ZYRHp4ODkvaitub3I3MlYrUjBqQytHcHVVSUxFZVFVNXJSMnFXZ1dxQWVvOFNjNnFZUW5uQ3ptSmZvM2xvZGNWVWNESzRXSnRRUXhqclRpa24vTnpucEs0KzhwV3VjK0ZkZVNUei9Ca3Y4Q2pOZ1BuTXRaTjdjZDZYakwzM2p4Y0oyRENBbDRESkIrV3RsUnh4V0x0VWlIOVpBQkxwZ3kxOUxHdS84YmxqNWxjcVFzTkNUSCtFbmI5U01RN1d2cEV6V3YrNUY2SjVGNEZaekF0Yk9iZzZSeWVUV2pWczNGMmVaMERyT2VRSm5wN24rT25BSk82djFOSXZ3RjJzWlYwMDZjSGV6WTJyejZ2VnNjODNlN0ltOGRlaHhGSnVsVkNhMEhBSlM0MkxKczJtTVp1N2crdUNERHhaLzlFZC9GSVY1c2ZqODg4L1NpRHlveW1hU3BmQk8zdWpoVVVoSEZPb0MrNDNYRzdHTWplVytTSVVEcytJcFkraFd3MEdSTTNsV0dSTGUvR2grb2hQWC9yNEhEUWRmS0VUcDJ3a2I0WmVLUk5yOHIzamttc0tyY3NZUEQ3c2NMNlVyT1I5NVZkeHdpMFBEbXNnTlQ4RzBVVUM1VGNSMWV1LytscmJHQ0VzWkRpem5aU21ZQVNSKzVaTjN1NEUzaFJXNnNHQW0xL0NGQzZ0NmtCUFd6alFJYUZIUFZNWUpGNFpDdyt2OG04YmUxcDNPNGNxcWYvdU8zbHlXeVcrdTRYZ2JvejgrejNCVkltWUVpVlFYWGtmSDQrUzIwL0NiNVdyampMZnQ4blJDckxJNnR5RW5zYVFSR3hOV3E5azBzUmw1WGNsNUFaVkhST3NzaDJYYkJhaW5aS2hNRDFnVFY4WlUwNkRxM2RoV2JWMjM1WTEzY3EzSEcyKys4ZVBGdi9ubGZ6MndmdjEvNjRKQ2pDS01tRmVMenNNb3doVmFsaE91OENVVWt5ZlJ3QlFSNThRSEIwSEFVdWtRMXVpYXlpYWVOUDJlTTdWSjBaV2d3d2lFcDNFRVJ4N2tDcHc2RW0rU1U2M3AyQzNXMEJKbi9pL3hOemN5VmhuY1d1REE1ZVo0VWE2R0FZVEJYemtzSlp1bjZmaWQwNXdHUmJiODBRQzFVMmY4MGhqRlBsZ2N4Q3JZeTdPYmJwNTYreUlUWlErelltRDcrczBvcVRFa1lDTHQ3RERXNG5Hc0toWlFMTTgwN09Yc29EckpvbjlYV3pzTXhmclV6ZHU3aSt1eGhQRXV1VmM4dEdmUnBGWlVyOERzcTg2SHgwRVlMTU9MaS9XVTkzWmdPUFRseXVMVFQzKysrT1ZmL1NLN3JyTHNLcWRxcVVURnl5UkNmMk85MittV1dXNm1Bbm5RaWhMZFM1bjlyZ29WREZpbytNVjU5MFJUMDRzL2ZuQVZENTBDbyttTDV2VzdxRGR3RGhXTC8xWVM0TEJ5ZVBPL21CcFhzRng1TWlybndLbmxMaEZmY2lPL2thOHl5Tk5qVEUvWllTZXRWUWVjTVBBcGJ3ZXlXT1BKaitQZk1sVWUrUU4rTzlaMVQrNkJXVStDMGRRUVVvM0phTHdyemZRN1phZm9hd3R5aEdWbEpmU09kVXc1NVg5K1UwQWNlQ01uY09IazNiUXMzRFQxZ1QzSGNaUi9vcmtXR0tRSjBQeGRaYVFuSTIram5nNzhuV1pGSWRhdzF0UzRIcWZPRkVrMDZxeUp1RFJUbVJkSWJ6QUtXQmpjOTg4enJCU0x0cFJwYUhlOEVRdVlCUnZyOVhycUlkYXlycXM4Z1cxT1lMUDRyZ2VUSGx3YU0xZTczN2w5Syt1NDMvNFBLNlB2eVorMVAzanY1azhnWGwzckNBbitjcVdVRkt5RWRtcWh3NVRsR1pNaldrS0hzaHdFMEppTys3Y0kwR0UyRDFSbERDVXhzTVpSQ0EzR3paNWlaMzVUUmxvOFlXVVpxMUQ1RnE0cjZDQVBxeGRlZFMwY3lsR1Rhck1JL09iUGxTZ1BqaDhuYmIvaEh0RXZDOFE0SzB1TUVQRVhqeFg3SkJNM2NEUDRqalNHTXp6dGw4L0NOeFJyeXBXeW8wQmxkWkp1WjJwa1ZWVEx1emJTYXE5bHlWTjFUM08xeGMxWXJXdFJDblg5c2pXZEJDNU1PUTROVHlOVTI2RUJMTjJrdXU4YzNpaDlKem1sNzUxZEErbW1KaE9UUGh1eFJwM2ZxcnRZVjVyUXBsSE9rZldBMU9xbmxxUUl0Z01iMHJFcHdDVFZkaXptS3hsdXNBTkdGOXFSaUVlWmVOQU5OVVN6bjFVRlZqQzRoTEN1N2c1K1YwUFRhM21lWmdob0w4TUdLaUVyam9KRnUxYTBnODVqN0UyY3BuMS9xL3pvVnFzRkpwb2o4dURmRUV4ZCsrTFRGQTVHNXlFOWllVkhxUnIycUx4TDNBYS9hMmdLN3laSFhxVEhOWGhjeVZBUDJSMXU4TkFRaFNFQjhNazBtV0RCeVVPWDN1OHhZNTV5aDY2bHhIVDd5NDI2STU5UjNtbjVWL0tRTDc4dVErRmZ3emVqTjhRS3JUU0p3L2syS1FsUDlkTkVrT0dIdXFZYmYxTkVmQlFiNXBVcU1QQjgxS2N4TkRLK0Uya21xL3c4M0lnL1lKUkNpUHdWSlNpNThONHdTeGsxU1g4Y2VYank2SEV0Snp6S2Q0Z3gxZm1CNzZvcm1lTFFxRTZHeXk1RGQ3R2hIMTdhZFdpYnI2RkhNa1lCQjNoNmI3dWxMNnh5SVcvS08zcGRLUmVZb2E5TkNEYUJIQnNhaU13L2VmSjQ4ZlQ1M3YvMjdhTkhuMWVtci9sUHJYT0Z3Nmo4S3Ztd1Vsa1lLZVlrMkFQTEVvSXdBSE1SWUFqOUxFd3JGU0lTbWw1RFduRVNoWkFUeGo3UGM2U1Z3M0JnODZzNDRNLzh3ZXVIQUpad0pXNjdUanRnRHVYTGJ6Z0M2bXU4V1NiaXdYUHUyazhsWUhsUnBHQ1V3Q2RpSDBwaVFvSmlZaUdQL0VDUkFSeWpDRE5tMWo1YTNZNGpSbjJIMENaMzkySmxQODdKU0x2Wm83NFJ5M0VybGVZd1kxY0hPVEJsZmZQcFlpY2JDNXpsUU1FZjNURzVGT0ZNeFR0L2ZsQ25hNTA5czlFZ1F3S3hTQjN6NXh6Wi9RaWhmb0tydFkyRHNsaHIwWFdzVXpSTER6OTRoNjhUN2ZqVnhNUHprOHJIaGc4dzMzZ3pTOCt1Wldna1N2WWtRem4vSnN1NkhEbEpnVkJPUnhrTEt5c2xGZ08rc2pUQXdqdDhxZ1oxb3UrcnZKTDNuSzc5MjF0YXJwWHJTRHZXcXZJZmNmRjk5R1RFRndmOThjbHpuTWs3OFZqYTdsNFNoMzhyK0pISGtMV0NOMVRRNEUzU2xWekFVU3NaUitGb3NPQk15VklJZFp0QTR0U3FCckJac0lFRGx5N0R3UFZTY1pJWFlaWmEyUTV0a0Y2Y0lUdjVHMXJ5RzBOT282eHdLVG51L0tXUDNNUXpKQ2gxVk9IZ1dQdkpMdG5jeUJwb2VJdXJIT0pPdi9sNTJvLy93QUhJeTNqOUxXeitpQjhCU2FLVU0rVzFNc1hZNmRQSDJTU1VIazdCaXJJZmI0MXFHdGpJaE4vWVJCbTZKZG45WnNVdkd5aHl2Z1hsUTJiUWJ5ME4vVTZXOTFIZ1R0RFNXVUFiK2Rud2NaNnpPY0NpcHd4N3VkRUFUc1pkMzc3OWhyTmUvNk5nK1dlRjYyditFL05sRUJadEViV1pvaHRTZmlsVWFQUFh1aUxrQkVPbDZISFpWckxWelFvTXhFUkFsQm5FdnF6a0RWeitPNVB5RThjRGpqZXIxYnBLcHlCUmRBMWZtakUwUUpCZlJsU1laKzVVTW1WczEzRWFKNDJNaW1raXpyc3JwdndvWGJaVjJWZm9FeUNzT1RDcWtxdVFLbzc2UGtObFZOUjRKTWhwV1ZJZVJVRDNvc2llbldUMk16dTNkaUpreDJuRm4rY3FhUWRkN3o3TmlvR3NFOTdPMkMrbFoxbVdDU1FIc0pnb3RNekZiUVhiV1IrN25ZcG1JVHFGdDZ0OCtjY3lXTSt5cTB3NVZEbDB6YzZ6ZDMxOWk2S2hjTkpWamxEdVowUEI4eWhMWi9WQy9DQnZrMnRYc283MjF1MmJ0Y1pYajhOaDNZNmVwRnd6MDFaS1dWblJoNEpHSHcyQmNFTW9UYzlXdE9KeDRxRlg4NkQ1ZzM1Rnc4VHA4RUhYb1JBTXAzUWFzSDBMOSszZGluMU16b3h1Sy81MW1zbzhmMFllSTEzN2VUZStSMW5PdG1SZDh1VFB3MmlEYjdSUUpvcTF5cEt3dG9ick9odGQrZ21ldC93OXRtdkMwNzlYWGNjUkxuZ01uYkJReVg1NEsxV1VlamhZT0l4NFV6MnlkTXlaaThHdHlwQ2JLaXNmOUpGLzB2bU4vdktwTVBuRVZkbnlMbmpUT3lVV0lzZnBuZkpFNFhXOWpqcFVxRFMwenEvSThyM2MvSHVRNVlCajdEOFdaSllTZ21mU1ZkMnZ1K0hTc0d4dXhqcE5EK2pDTHNYSUlxVUpuNTMxYThtSFhFUitVNzl5dEVBZHZMNDN5ZERXMVZpd09heEl2ZVRVUHJLd2xTR0JpL1hUWEpNVXZaSkxRd090VG1tN2VmUEduK1RIUHhQM2RidGFpb1VZeTNFTnpVS2NncU16UmVLRFVCYnpKaVpXcENsZUNTd0JUQmpsMWN4YWZxZGxCNDlTWEkwQ0txWW1iaktWcU1aVld1akU2d2RjVnBINHhrR3RRRGg3WmhaeHJ4UkdWWFRZZ1pFeWRMNzlQWDgzdmgxSEdvKzgrUFh2aHRYV3Ewb3I3MVlPZGM5OEdHbEZnL0laSHhYV2x1MUt1dmlqSWtZUUlqQUZkeEpZNVNXY0pvSlM4aWpMTEhYS0NXTUhNU2tQVDlQbFB0NWZQTjJpWERjWFY1NCtXK3hZVlpLNEtwYXlxdGhudVRIV3NKZ0RZQzZ5a3NIWTIxYVUza3FVd25rcTJmbDI4a3hZcll0TmZwWnVuUjluU0dHeURGZ1NGTkJKS29kdW1ncGJLeVFpK0h0N3NUeFRUMCt6VnRITS9sRXNCek95bEFoZUZEMG5oWXFlL0NrYS9LRFkwY0hUY2RGV0hBOTZEdi9MU3Q3MFIwZUtFQXdOazBhNmVkZXl3T0laOGFkYU5qRVV6T2FoTk9oVWpYakNoWGtvQnUvR0F6MHYzZUJSeDdYbnZlQ1ZYS0M5L1BLMGZJZEE5clREaFNVdnJqd3RFY3JvYzlHdWVUNHYzeGoyaVpMTkJDZzhsSGZlN1NjUG5zSjNrczNHRVE2Vlg4cXdXbUVwVStUUFRhMW4yWEhIR2ZvUlR5TUpKM3p3SG85eWtQVkVESDJiZ3VxY1BMMUxDZnRkNVIxMXFzcVIvTGhsL21RM3lsWmo2eXppdzlScGNyMlo0WlNONUVsR1RmS3l3dFdkclNqYlVySVo0bHBKZzM4NkRuVXJIcDJtZm15SGRvU09ESjFubVZibGxiSTVSSjVjR040eUhBQUxrNG1HekhxSUNtcldpTytsekVlSmN6dkd5TWNmdi8vSG43ejExdHUvdnBmek5sK3pXMXF1eGcweC9TSldVQWxVaUl4Qk5UelF6TTY3bVo5SXhUaXR5QkRBd1FBRXFVcEdxR09kaVkrWjdVOGc1a3libHg4Y09JaExZQWxnVnhSTU00UC9MQ2M5U1YrNDV0MTVnME9RNUZmaVVpMTJWOVI1THI4dE9BM0RtOURLSDN5SzNWdDVDRWdMYmVjUFI0cVhFSWtMM3d0amRrTWVsNW5XOEVERVE3cUkvZWhheGpPeVZlVTdpclZ6dUpxMXE4Y2JpNE9yMlpPZmJyZ0pndTNjM0dyQ1pDT1dKRXNKRHMraUVGbXdoMUVDRjdGOE41Tkd2cHZoWDNyQjQ4RHFLREpMV3pKWVVDZGcyUjFUdDhtR1YzM0dnelJybVpGVmhsclJNZEhVY2pZVGcwYzVidkpwckdqcldGa29jSGZFM21HdTBFYWZXdm9UM0RobFo3MFNmdkh3QUszRTg5dURqeDZWRFowOUpSdDVvNi92aXB0eWxMV1dOQjJ2NkI2NkNWOE9hNFIrL2prb2gzemxLOCtRTTdBOFhPZVBqeDcraG0rV3NDTW5IYWZmMHRXNEpPV1ViM3dTSmdOREFtQklMMzl2aXBWRFU4Z1VuTUltUHhQZWNsTnZhN1dtdUFXemZsMyttZVBlT0FvVlY1aWNUTEw1UGZLTGorRUV1QVlQZnZKcEI4YXJUdHIyN3p5OHBVTzE3OEtyWVVScUt3LzgxdXVSbjU3UXpsWW1PTVBISHY0QTU1TGVROUdxSnpaQ2tMbVNtZlRBREdIWlplWDhqTG8ySmdScy9PRUJocnlNZWV2QkpWSTFsdkppN1hxamgwWmw1OHAydG5WL3RIanZ2WnMvam5MOUh4cm4xL1d1Q2ExaUVvS0h1Rm9YQlZGQUxUeldFREVUT01hV01wQ1g4WTA4SVVnTmdLTmlLZ1JaRXUvcWxhczErVFFxRm1zaEZUd0sxYzJnRWZsYWphQkw0Q2tHSUdDVThOSXZ5aTNjVGI2cGZDSHNVVnBJaXY5S0JyakIxa1Y1bU1YOGRYZFU4REdHdTVWekFDakZhdEdDZzNNbHR6TGVZM2NTbkd2ZHJzeVNpU3R0UEpnMmRuOU15OFprbTN5c2IyUWhtNmtuREsyTWxBZVRhOVkyYVZQY210RHBLN0Z0eDNOWGxabk0vQS85Z244VWdESjcrMjM5NGtGb3V4RzZic1hQTlNxSHlmTWs2MTlYMXRPeUo0K3JXZitLdnRYOVNVVk9BVk9oWXhXdW4yVWNkRHVIV0QrcHMxUWZQOGg2MjR5elhVbTNTUmQrT3dlN0tPdEtsckpzNWlHWVpteFJXZjVPRWpvOWpUV1FTVE96L0VDangwcG9oWDAyTnVUSDR0cm1ib1lzTXNZY1JYanZ3ZjNGUWF6bnAvY2VCRXJLbkhOYVdTMTFpV0p3WjBWNTZvWUE1Y3VFMkl1bnVZOHR2TEJEeTFNSHQ2UTAvRXc2bEVXZGZJeS9lVXErVXJGTlhCeEdpY2ZXalZ5RmZ0TWp2T0tRcnFUelN3VWV5aUFWTW1VZVc3U0RGM3dpcHlvY1ovc3Z2NkpuOHFEY3oyUDJteFFpMjRaMDhOVVRZcVRDNXo2elNzOUFHRThwb2NCSXNRdEhWMEVYSHFGUnZDTWptWHlNVlVaaXJXZEZUTDBhemhtdEczYXlSZm5Vb2Q3R1cwUEptblN5U2lTOEhVTmE0bFArWXd6ZDJ1VkFLaVdrUEN4dlpaQWhhMWVQUTUzQkwxdW5lemRjM2ExVzUvMUtUL2tQV3JFazBVd05QY2t5S1ByVythMDFqQmQ4R0VFc0F1Uk5reXRWOG9sLzhsVy96a08zTURDOERsOURiM1ZTdmJERjJ1Nm9XbWVhRTl2V1V1ZDJrZythVzkrcVBuSFdlRmUzUHZsZXBCZkY0dDlJdzg3U3RiYTFsSE0ydEpUaHRUUE83MkFKYS9Tcm9VOGVsbVU1L25KakY3K2lnRk9JTFN0ZzFNWGtWN2Y2b2xQa2QzVmw4eDk5ODlsbi84MWpzNCt2MGRWU3JFR0EwRGNJRXlyT3Q4TXNDR3B3cmdJb2hFT2d1WHltb2hEU01FWGMrT2Yxa3VOZllZZ2RJR2ExNTEweThEaHh1R0pLR0tJTDZYdnVyd0h3d0lmU0kzUmFhdkVHanFQYkJ6Ni9TbDlRQjN6eE9UREtLMXFUbGdBQVFBQkpSRUZVQWdpYzRUZGF5dnl0MzA1aDByS3lFc1VGUjZVY3lwanlzcTF4V0FqOFRIeUJBMmV1OGtXUHBKdTcvazBadE5DcERHeFpkSEdGeW1rcTNOTWNubDJIckFUZGt3elFubVdNNm1wRS9rcmlVZ0pYTGRQSzJLYnY0MzFiRFUwd0pITEN5K29KVHZ4VVdrTUdoRlRKeFVkUFplSldFNCt0bHo1Qy9hNWpDeE9uTEpLTTR4Mm1RVVFIdlFYNUhlZXdZdkRSdnVreWVERG8zWFR0TVVsQXhXKzZLejk2V1I3bExVd2EzOEk4Y0xSM0hYMWJidmgzM0JFdjVRcTk0ZUhoVnEwRERweTVrNzdseHh0TTVYbVJDVUVPek03WGJ6Q0xyN0dBeEFjYlB1Snd0WjE0Z2lOZSsxZGcvdkNUeHE0MllTbFZ2VHZ2cHBWNFhNOFB3Q05nUjVxcERJMTNSY3lmZVY3U0YwM0Q3M29ubktMeERkOHpHbktaaG9LTERHRjVGS09WUGgyR1h2SnAyTjVGRS9FakdXSXlyUVl1K1JXTFFlTXRuZUdiN3MwNGRIM3BBa1A4Mm5KdDhqVTBhTGtNZFd1NTFjVlpESXdZSVNlSHlUODQ2L2xaZHRWbGVaSDEzRDJaV0JkUXBxRng1Q2E0dzU5TXFmL0xYQ3V0Y01OYlZ2bTgvOTQ3aTQ5KytORS8vZFcvZXZ6VHkxaC8rMSs1WVNJTUNLTWdwNEJkU0tnb3ZQRExGUVNwQUlsWGFjaGNwUnZDWjZ3bWNySk1qMUVlelBBVTQ2aVNDV2I5RHV4MllBNDNGSUJ3bGFIamR6amg0dTkzZCsvbWxhQ1g2b0FGUnIyWHNDOHJWYzAyRmk2ajNCcHZlVmtKQURabE9aVFVxQ1N0UE1DVW4wY2NnaUorQ1ZVcTF4Z0thVHBNRFEvZ2NkQW9JY25Id0Q5alVQbDNrRW1xakNKSGdXYm5paFkvMTV3ZlBqYjduMlBZVWxtdlpaLzJicnJudWtXMnhsNlBCWC9yMXAzRnM5TkhSVnVXVE5FVFAySVZqTHVzS0JSVnhMQkZLbjRxaHZLMVF1dEYyWVdZYm1YNFo0ZFFYWk1TUENrSzF2dG14b1MvdnZHYmJLL045UzdoSStWcG5TVkxhMWlRby9IdDYzNVlHL0lBcitudm0rTWYxVlBmeXU5aDVSMGxEN2pWV0d1RlUzeDROU3E4U3BOZjhSdDBiSGplSHJpMjBzSVhmcFgzWkRrTldnK0ZuS200eWw5K25ERE83K0twT2RlZ1d6UDY2Q0V3UEs4WjY5QjNKOTFTY2NFbjF5TjROQ0pMLzVRQkhjV2hZUGozVGFtR2Q3aGFteHIvNFVZWHY4b2x6OFJwdlByTnIrQ1VraHh4Q3BRZVFDemdsWlZ4Y2FLaktTdmY1QzF0UC93S1JyTDN6ZC92ZnRyUEtoOFlWc256TWVwdXJOTUoxOE5NcEZvZDhQaHhsaVFtWHMxSFJLR3JLM2J6bllaR2VyV1c2ZFdOdFFVc3NsZ3JXTktReHpyWHd5TUx6VGVUcjY0VHdzT1Y1NDhYUjBrUE5waHJsaTFTcmkwTFNSZGh6bTl5bHlZczVUY3NFSTdYWE1OdXhtZy9lditEeGUvOTd1LzlWLy83di9yejE2dGNMZUV4V1ZBRm13allERmxhV0JPVE1DQWNIdkl3KzF0TXoyK1ZBeHp4RU1hNGlyZmY0dFMyeFVodU0xSStjK2MzeXpIR1MyWGoxa2Rrd3dnV2pUM0ZxK24yV0RrQWJnMVRVQnFKNDNzalY2U0FUV0E0WFNpL1QvTzBNTEhRd01PUTlPT1Nzc1Fvbi9sT2ZBelhNaHRyRkE4c1pTSmtKcTB3a3dJWkEvZWo4UkdtZkI3M2pYSHpzb0hodDBlbmk1SW9mRkkrZS84ZElwelJxOFZPbHBYc3N1enllKzBnNDdDcE5EWWNPRnB3TXdldHlITS9seGh1cFd0L0s0UDNGOW11ZXBSdGhicG9ZMEY1ckxtMDZ1UHFtMWl3RXo5V1Y4ZmRhRFZ1RzBIbFdNdndIcmlINXNHOUtwcHlSTGczS2VTY2I3Q1dSZDhxVUZuWjRZSHVxSWVsYlNobkxjdklmRHN6Z3RWMk5aczBOSDc0QXpaWGNFTUR2OTN2aFo3bzNJMGtPdU1UdjVZTmNYMXpKVHZoRzlkMGxXYmdIdG10MVE5anVWWHpvZWdiSG9QUmNQaFJvSng0elpmK0RTODRlUXVidTFiYWRXRDVWSmFXYmJodzhyRk4weHY4YnZTVWdsRUM1aGlxQ1UwaWdIVUllZkpLcVhSVEpocEwyd3F3clhIQ1NxN3psOHlHRDR5WnNDRXlPOFpBVFVDZXhWcmNXc3ZXNHdCUTFpNjdmSmQwcWFHSUlZdE5neTZyK0pIMmt2SGlkL0p5c3BWNmtmK2hkemJUMUZydktOZHNjM1VqcXl0YkxBVTBpVnFOZWhTZk1XQUpiSmpRZTdKQllBeVJiR1VZWU93SVhGSGV4SEVZRUFlWDNjd3RuR1NvYXpOMTJZU1p1c2JhWGsvZWhpak1HNXdjQmNNSVhoMHFGUElNbkZPdm91QXAyUE1NQmQzTU9jTWY1Y3lNMSsyR3BPSGFrZ0ZEa1NqNDVUTVVJbUUrWFRJdXpJdFFwTXpsTUVpWFhKeUtGNEdUZnU3RWFaK0czWXdWcjc4Sk1nSDN6R0h3TjY2bkFyQWFXempxd09Qa0pSeXhPMDFLc0N4RDQ2RzdQeGpTWGVSaFdjQlpmaW80YTVSeUJaK2Z0d3FrTXRXTVpmeTZza25IZjRtL0xqb0ZHcVZaTktrUWVJUlF3VkhEMGZpWkROU05PNGt5MjgvZy9JdmtFWnM4QjJwblVpL3B0elBSdFhJUTVSWC8xUmRqdHZRZ2QxMjlmZWVOeFc3R3VOejNmcGhWQWdkUnNCc1pMOXdNOExvRFBrTEphZ2dqU3RHdVJ5Z3B3aTRQdkJpRGVLRlJxakZKbFNEZkp4SDJjeFcvMWhBT2E2NnN1TVJGQzVWUG1QSTVJTWJRQlZoN0x3NFdMM2IzRjl0WGgyV24yRjNPZnFPN3RaSGhWTVlwdzh0VVJQU3IxUTNrSi9sMjkxdGNOSWZ6VUhpdFhJZlZpT2ZDbGFVMlA2VGhhVmQwano4ZXRRS2M0OU93dlpzbVZiYWtNZDhRb0tNK2hDWndYN0hValNJTEx1S0QzL0RnQU03OHFiQkU0VWVaYnFTTU5VWWE2b25QamJNZWhweXp3TUFzMkZNdlFyNlZkL3k3UEVYSHhIVytSNjM0Y2pwNkxMbzZIQWdPYUpLeDljWVBsdU9peHFIdmducncwTGgzTFZUTUFiLzlLRksxbEp6YWFsMEdSM0RTTUIrbU1iZWUxYk9mNGF2VjNjaitVU1piUXh6anBmVkVKbXRUUy9BMGsxK1hnTVpxVFVabDdLd2FOejNQR1BWaEdwcU1zVE5rVHFNUThjcFNTMHN4clNnNno5ZzJvMGo1eUlRNDZHK1htdFV5SnhrdVc4MUhUNkE1RS9ZczZmY2l2MXZwNGIyVHcrZi82QS8vL28vLzViLytmLzduSXZocitKTkRpQ2FMSllWWGlRZ1pOeGpiR0ExaDhxc3FRekVlb3lpeUVSWXlGS01vdllvVEJoV3N3RjBLb0lwRVVHZk1IZmtNQm9OUENabG9ZQVdQN3VEdzQrLzMxZXhnMnMwRWdtdXBoeUNFL2xFZWxYWlM3aTB3WmlZSmJIVjNnd2QvN1pzSGJnYkQ2N2kyL0NaTWxFdFhNdkFhanZKVTJzQXkyVVVCYzhyVlpTdVAvQkdQNnpJMmpMay85WnVpRkwzUEF0TmhOWm5jWDd6SXdka1prRmhzcjJidGFwVFlXWVRIS1ZtSHAxRm9TVkJkKytUNU5OYjcyYzZ3N0NoVGdobXRrQUxrTXNRSTVZckZnbWlNdDlXZGdoSDZhVWhTMFdKSmJEbWdKL1NodUp3dHdOb29PSW0zcXR1VkNuR1duc2RwM21paU9yS1dhb1hCUmVnZml3YXZUY3JWL2ZLczY1eXF0UlBGTzZjaE9xQmZLeDk0b1FWL3RPdXdUdFAwRWk0TjUvdnlOK29OT3JmZmFUWmpnQ1h0S01Ob1NEcWV5Wm5sZDJBMjM4U1hyNGRyZUkwZjJmSEFzZm04a3RQTUdrZHBoTU96L2NwYWkxL0J6QnRNOVdRWkozVG03SzZLNWlzRGhZWGJrMVMyY2txVFZLV00rc1EyRFEvclRYNVZGMUx2eUhmUGVWQ3dMTXV6S0N0eG1wNWdkWG40K1YzNXAreU5jM25ranpBVGxKaE5LZnNOVGRhcE9aWERyQTZ3QTgvcWs1TGhLSE1XcGlXSGFNVFNMSXMzNlNyZmxGVmpKVWNLTjBaemhnY3lmQkZlUlhpV3ZTZnBUR3d4YWxaamZmdE5iajFNdUpQa29XZUpYaXRuV1VXVTlkcDZLeVpuVFM3U0ZiRVFZdVhHTUhKcmN2Sy9tYkhYZDk1NzV6OWJ2RmJsR2lJWHd5QStVUmxoeHROa3Yzeno1ekJHd1NqWHJqZ2Q1amVkVzNDbnBNSlVibkxlOFFUMXQ3Z2xGTEg4V0ljRk0wUW1FTVprS0QrdEZ5RlhnZVNQb1pWbXFoekN1TUl0OEFnNnAycTFJQm1xa0NjTDFudWMxRFJ3MWYwdDNPZGxEQno1Y0pTcS9EZ1dVUTNzVC9ENGozekhzSWc0d0hTK1FaZFA0RHVOZlFTcVVMVm1NdmlmeFJMY2p5VjRtZ3ZxampPZWRCeGFuVGpMTlFsZENaTzVyblQ1c2hvalN2VHgyYVBGeWJZcnJNZVk5RGpHTUVNbktrQWFHbm5XR2JFbGVCbEtTWDUxS2xjNDdPU2pxTlBxa2hwSFJBZmpZNFZuZnErdDdTN09vbHh0dFYzRng0UlR3TXFIRG1nZ3JvcEF1YUlYSHFFOWV1eXQ3ZFhZY0plNytLaGl4UG5XamNVUkUyNnNFSFFFOXp5TkxuOFZDcngyY3pqeVlLbmd2emlkTHo3MkkzN3hGY3c4WUZOS25EQkRLL0JzaTFaY2NKWFB1MmJJNFptNG01dWpVWlcyNFIrYjBVL1lkejFnb0UvUktQaFZuRWtHTzMrNGc1V29GZTY3WlU1ODRmRGd4L25kc2pYU1RlT2JVYVNyT1NTNGFCV2FGWXpRMGtsMmxza0ZWTUZQWnBWZlRXWmxNcW1zM2dSS0p6OXVqa01wdGdpb2xUY3M0UUF1UmJxWHJhMzN2cjFieS9OMHp4a2k4anpJaW9IVGpVblo1cmV4ZkVNZ3k4WjZLcjg4NklRendoOWRvMmRWalFyYVJ5N0owN2lDZlRKYVVoYTlJL3JDc3NPWTVOV3dyK1h6S0QyN0dLNFpCdFNyakJFUVdQaGN4bGI4bmRTMUdWbCs1NDIzZjF3RmZFMS9haE9CMW1hUWVWaW1FQzJCRDIwSEEwWUxqRUFsTUNHZUlZQVVIZTJMeUFqdG0yRFY5OVJhRjlPVGppc0J0bWh3NXNEa0dxN3hWQUpGK0RsQ0lKMEhMQldERTU4UWlzdDY0NFJWTjJTS2o0a052eUxrRCtVS0pvV2hqRWZwNm9qRGozSTlxcVZhSnk4Tk84aEwvbHluaHdzYzRjQjFuQzdIcS9ueXIzaFYvdUNWbjRvZStVbmFER2RFWU1ZMUxLbjRFY0NUS05pTDdFS3hiQ3ZJUmNIbUhZRisrdmpKWWo5bFBzejQxRzZzZU9WZnJHZC9kaXFiOGRrcmkxRzVpMjVSa2syN2lIYmhPS3pYb1FRb1YrbU5WOEdIWXF1cm9hUEFYTlBjbHBLakdJditFWEI4MTdNWXEwcUdISXdGOGhSaWRwNkZ2bFlYaUsvTTZJQkd2dEVzUkYveVJCZy9mQkRIbzFLa2xnQVZ5K3p5cVlZcEN0bVNHN0JmcFM4L1pWWWVNUHNwT2FZazRzU3g2YU5keXhoWWpZTTh5OG95TnB3bjluMXRMZGJJcFJDMWJyalRGNDBEYys3a1g0MVIzdUFXWFpPdStLK2VLVnArU3pZdngvQWIvQUt2MGlZOUo2elMrdzRONEZvN290YWltTkt6V0k5eVc0bmk1UHA2SXJDbFFZZUdWZDhockxDNW00ZnJodXZweWJtT0lBenRMRjIwN3ZyZXZYdGx1UTVjUTQvVThhT3NybkREd0JLLzFBbndLLzhKQjkxNEU4aG80NmFCWUZUeGxVTURYWG1TY1VaVnhqc01FeGtLcU9HbnBDVlRQYllzZXBxTzFKR00wVzVvQk1oWDRxZkhCdkpLNWdEb0FYQ3U1SnlNMStteVdpRFpSejljV1BkbUpqVGRVYnR5K0xPTWhnTFJXbzlXd3FRUzRsUzZFT2NveEt4TEMrTlhOekttVUV6N3FrZFpPNG1BYVZNaVpHRm82aFltbEYvOE1iVXJCTUlYVTVMZXBCQi9lK05kOSt4N1l6UExnZUovV0xpMW9oaVRJTVlNNFVteGovdmYwNW9GZmltKzVOR25Gc2xERjIwN0M5bTFzTlZsQ2ZPYzJYbzlnK0FxQWppWVEwRnd0YXNzUWtJdzI3SjE1M3BYVE5heGNwVEFoQVlHOTUycWJ1S2hoWmFGcjJzS3hsbk9aU1ZzZFp0Z1hodkdBeEFtN2lLeWtPbWpUR1NOK0NjWm43UmE0SHBtVW05bXY3V3pYRmVlbXpTeGZmWjA4VHpYWTV2RTI5cUtJSjFGRFdTOHlaa1dGeEg0dGMwMElPazJYZWdxQnErQ240cTV0UlY4WTczbWtOblFPNitrT1dPeHFxU2h6M0cwL2RaRnJOT3NSN3pJK3RzSHAwOFdqOE9ESjVuTXd3ZW5wbTNuekFHVzdXSGdiZVphRnhOODlvS3pHSTdUQUx5SWxXUDR4RVNHTW12a29GQVdYYW9BUzdvczFNaUpDY3c2L1QveHlGZ0lVN2hTVUsyazBSRS8rWTFWSHZnZm1XRHRScDYyWXNGc1pHZGNyZU5OR2JxQlA4NTR0RlB2aDY2T1hJY3ZSNnR1dUhVVnpmV3EyR04zbWZIN01YdHRIV3gxeFNPenA0Y1pvc3A3Ty92MU5YNFVnWWs3OEZsbThLcnhjSVNNbzVTdHZVUVBjZllqUnkwbkZYYzZIbExjbWdWUGQwUjlRRmZobkYxTHhyTFZCWDc0VnpjUUpPLzBiN0lUeVJyUk5DSlp6M25DWW8wZk9UZHhwTEU4eUtxT3MvTk1OT1VmZnZhd1haZ1E2Rmxad1U2TW9LTS91V1Axd2NFdlE0VFd3YnF0UWg5ZXIyNDdPdUVvdTZlKytPVXZGMC92VXE3WjNCTHJ2M2lwTG9kdis4RU52clZOKzlCNXY4RXhtMXZXajZNd1YwT0w4TTNhODVRMGpWUG1NeklwNXRBaFBMVk5GbDMzUTV1TGJLVFpqSHdkbU1oMXpUaEZQdzM1bmVkUW9nZFBqaGMzajYrT2VwZ2hnTU9OYkpaSnZVSXppcDR5dXdpUDlZcXNvYzFtN01YdmYvTHVEMzcrNjI4K1QvSCsxbDBzZUlxUXNweWVxU0orRnliaUltSXRnZWo0ZVhQU3EwaGxoZVhkdjcybDZ6aSsrK0hYM3gxbjd0YzQ4U3ZGRkdhb0lBUldHS0hrMzEwMVF1MDBLZUhkYlJXSGEzejZ0M1FlNVduRkxoNkdkMTdDQ0pFM2YwTGdUWmc3ZjJFYy9IM3pmOVg5dHQ5UXBpL0Zvd0hpeWlwTWNFMFlSWUZhL3BSenFOTFZ5a1JUOVBCbWpnWGtaSE1jeGJpSUliKzVzVC9LRXZIZDNVbERrL2RoY0NtUXB4SHNsRUc1by9lTEx1c1VidUN1QjZBR0xLcXBGR0R6UXZtYUh5eDdrd1RXTjI4R0JpdUMwaXhGT0hYNTROUHhtMzd0aHlib3lRb1d0akhKZ25CaDhQSTAvZmh6YU5aMEV5YU8rSGpWZVoxbUxMcktNU25VT2YxOTk4TXlzdklGUEJPVkdra1B1bEFVOE1OYmo5L2dpOHZmMDA1ZTdWOEtEeE5lY1kxckRUdE5lRk5hNEtDckJxSWRXQjV3T1dueHJDYTdZb0VKYTF4c1F1QmFzY25abFNtNjFsekZuZDd5V3NJTWR4c245RUNMeWlkNWNWMCtLMnM0WWVxUGNYVDBjWUxWL2J0MzZ4WU90S3RKczBuKzUzQ2tsZWRwRkhKRzlPc01nUlFoYlhqd2l4elRmN2xUTWZtTklROTExcXFZU0VieVRJOHBNbm1hM1pkV3ArUXMrY1daY1RDYlBUTHBCY2VWV0I1aDgySi9JNFpmQkhudEpBM3Q4VmgrcHVmRmVuYUMyK3JPOVpSNDRFSUhIRnhzdmJadHNFSDNzbUw0eGlRTzRYdzM4VnRRN1NKeTdiT2o2akNCWmRCQzBNVDJHNkY3cDBxQUZid0NuSW92WGpFNkhrdTRzemhkMmNCb2ZPQkJPQzA5cWdvZVBGeUNKLzFCRGp3QlU0VzVuVmxDUW9DdzBqUjhjS1JYT1RuZm5pNmZ2RmlzS2xqakoyMlhyZE0wVGczWG14UFBBMTUvVjhBc2pIL0VxNzB2dnlmRktxQVc5VWNnVFZvRXZWZ0dKZ0t5dXkzU2VaQmxMRnMzN01TS2t0SEZqSlYxRVdWM25nWFpHMnV4WWlOa1c5SkVRZFR1cWREYVRHNk5SYVdpMkp5d3VubUpyL0tuc0pIOVBLbHJSWVB3RnYyM2N6NHNxOFltaVdkUFl3MVpmNXUwK3ptNWF6MFRZT0xvMlNpVDZtMVhrZk5PbTY3OFd4N1FxRTQwQ20weVV2RVNuWnJXNkRiNGRhblV4dStwaXhrOHVWYXlyOElIaDVOL040amRhUGJFcUhEcHhNSG41dThveStqdE5NNVZya24rR2paOEdvYngzUEtmOGhXL0gzSEFoZ2MvQ3FUOXZDc1BFMVRDOERkdytSR2w4eWdpM3lXbmsrS3NjZXJ3dHZHVnJuWlJCbXdrdFB5RkZUNzVQZUFPbUpHU29sbm5tMUNmNVNwZTVFUCtmS1d2SFZrcG0ya29CL2k4ZUxHLytPYWJiK3FtWC9XRElsUHZ5UXJYdEVaRDhKd3hmR0pMZGl6OG82elhkbHV5Q2R2cUZhZDNkSkp0MVljNVErTW92VkQzaVZVSlVrNnJYcXI3bjk1Q3hnZFNFYUlpeVhaV29hZ3ptMWtaWVl4MUpUSm8yRXp2cjFmazdHUjNJMFhzZ3M2bzB5allyQWdLTG5xZG4zMzIyUmhIaE96ZnNpdkxOV1JkTWtoTktTSlB3bzVnM0ZLb3d3Q0VSUWdDZXBKS0w0NXVKVUp6Zm92RElpNDNXVGpnUmdTcSs5RXFobEJZNXFIS2orb3g4cGV1OC9aTkFNREVXSldEQlhEcjFxMktjM3J5cE1MRUwwR1pjSmFmWis1TWpwR2t1ajZDa0tSeGtNYXNwMVlkRXF3RDVaVmZLNHVHQVY4UEI3WTgrK0VuYkk2Mzc0NVg0Uk5KWWhyNEdWVGkwWDRSSWwyaDZzcGxZc0xLQ3JqWkltc1B2VFdpWjJ1UE05YTBsV3VGZDdLbU5Jb1dEckV1OE9ONTRxMWJxaEw2V0FlSUg5WUt3NG4rZGdQdEt2TTFYWC9sU2dhVmRieVhDdUFnZEJpVFhPbmVwK3YyN2JmM2NrWm1UcmxLcGNvTTRVU1A0Qm5oQjkrUUR6cXQ2ZEtIejFadXdCbDgvazJyS3V0RUsrSEN6a3l3eEs5L2V3OW5pSWpNamVFbFZuTHpVYnBYWGVlSEJwb25pb2w4U0ZPVjNoRE5sQWh2T1hMRWRaeFdEbzB6bUMwNTRuVCtyNVlIREhGYkJxU0hSOGxQeW9ZT2hvN2doRjZhb29DYjZOS3l3NDhWdjVraHFwd2VsY0xqaWNuT2FMdkFEcDU1MUJQOGtRZHJHTzAxaWlsbDVXTTMxa2FXNkRXT1EvWUdmbjJVb2ZvM2QrSzA4eTF0VFFEbTIyK253MUd1dzJxTnpFUlJsdXdrRVpvb2w3SjZwRjNQc0YyT1djdDFRbEcyTVlTYzhHWVNyWlJoM3RTcDliQU95RG5JY0p4R1NodHlFRVZvaU9ac2ozSTE3SktJMHVjME9NYkVsdE8wTXZTVDBhKzZpdzV1ZFNVNTJ1OWVMK1ZxclBaSmpJR3I2emN6ZkpVVDN3NzJYK3Q5V2t2THRRblVoQ3ZrVmI2SjRBaUhtSmhQcVlyWFlaalQ0U1BkcURDVWF3bmxCRU04TFNrLzhibG1Tc1Vybi9HbjRYUzhybmgrQ3hPL1d2Y0poc3BDcUwvODhzc1N2aHJVbm9RZXhIbWUwck9xQ2Fudnh0M3ZuUXlDKzYxOGZudmt6YStmZ2VITGxlcFZ2Lzd0TFkrbG01VHErTjMrclZRQ3M4YVlSc1VlRTQzcEhpYXlJd296SWhJck1yY1ZaQnpzNXRIdTRzN08xUWhTdHVxcVhvbmtwS3dYQkRUNGFxM2tlM0tTWlYxUktOWVAycW5sTGlQZGVoVzlGR1NVMEdhV1ZxMmRqMjZvdTRuTTJqcExFeTNUOHBmbGFtMnFFY2cwUTlVVlhVbEZNZEZWVjRESGFsaVBSV0ZmUGhxaEYzNlFrK1pSMDk5Wm5oemNtaTdlMG5qUVcxeHkwWDZWWUVvalBmL21oWGpTNDVjOExjdnhMWndEYXp4RFJxVnRmM0U2dkhGcHVPSkVwVmU0YitIaTFqclkvSTdrOEg2cEhNTGxUZllxTEw4clhSckpTanZMTDBFalRock5obTI1bFNWVkZHRHRQa3hZclVzbGc0bnRmaXR3U2k1VFZzcVZVYk1hbVhKNHVqSGZtN09EY2NUdGZBdWZsQ0VlVTc2alBNTG5qbHpZN0pNV3VqYW5mUFhWVjR1N0dSWndRbG9FcXpZT05BM1JYbncwNnpMc3BCZTBra3NlVDg2eU1EczlyYlVNMDExRW5xeVFzdG5rV2RpQ1JqYSt2TWlOeGVxc0szU1V5ZmRSN20rN09Fcis0V09VVGVacU00NnRjYXAxcmFkWkxYT2ErOXF1SlRpMFpRZ3lSakkvc0tuaFI1Tzh3YjZiUnVIdXZYdi80N3hzZjl2ZnBWeGJ5R1ErRjJpRVIwQ1BiMkZwRFlwSTBpQXNVZUIvdVpidjVVcFRSSjhxVkRHeStEc1k2bmMvWFhEeEd3ZGg4dWI0Kzk3Y0hJcDVMc1MrcGNFYzQ0TXFkT01uamJSYzVSOEJrVHVVVkI3TFZzUjMrSVJ3Vmh0NGhoVXd2Tk9Ed1I5Y1QrUHA3WGZCRGx4cDJ2SHJ2TDA5SmhPR0d6aUY0aDA5YndwRzJ4NVh0RW01aTBNOG92RHo5emdXamlNQnoxOUUyV1l5N0RoREk5ZHpjTTFhM3B1eFpQZU9zNUUyRnhtcWVudXhESFppQlJndWNWdkFkZzdIV010Mmw4MU1lS0NYd2EzYUJodVVWak4reWMrVzErTjA3ZTdkZjdqNHhTOStzZmppTjE5bFlzWTRhOWJXQm4rbTBuSFc0NjVuZ3NFMUc4ZlpDa3VKYnFVQ3diVnBVOHJWdWhtWVR6UkREK3NudWFhWGIrSG9QTkpTTnVpbVVkUEFrWWRCeDBIcmtaNWxpbThEenFVUjBEUlhsa2pYRW5ZQUZ2MWZ2VzIwK2RMdlRnK1hYdmVNcHdVditKdFFHN0JoUHVxTHRQQzNkUnBQeUVrcCt1QlhjWkxlYjI1ak5peUQzNTB2aS9ZaUYweFdvNWQ4cW9PUmNtc2lMS09xZUptSVpNWEwzNk0zQWQraVEvQ3E5Y2FKM3pDRk5lMTdxM2oxWUlxUHNMbmtROEdMZiszWVREcFMrampYRGxHdVRrZFRWenpLb1h3Y1hOVTUvRmYrR3N0T0Y3M21SVXhLcFNHTzlvakNTNk9mU2RiOXhQMG1qVDhZaGh1ZVplWExHR29ZZFJDK083RzhYZW9aekdyT056V3RWdEdjcUk5WnhuaWFGUkpya1FuYmtOZHpsdXRldnNtakNTeGxXN21XaXpJZjNGLzhQQk53WDN6NTlVOUJlbDJ1dU44QzFVSlJ3cE9DSXRpbDBJK3VWSWV0cDF1SXFZNExrNjd1LzZFQVl1NWo3dHk5eE93UVRhaW5oTi9mS1hxbEMxZmwwWXBOL3I2RjFYZDBRdVdiMzIxQkMxY0did3d2cFQ4SllQczNQbkFGaC8rb3pKZmw1SWZ4NEJiVEV3OHNjRG5oMG5lbDduSTFiTyttajdqdHFsejlvOTR2MDJjRURTVzc1bVIyRFZhU2l6VnVqUTJOVXBIbzVRM2puTEZ1VDlMOWQ0NWx0R082U3FQaW5vY25XN0ZlNmhTeVdBMEg0Y1h6N0lUWlNZTllpallIYTk4d0hsV1FBei9XZ2RudXFsQkpxNXluS2Z2alZLWmYvdXF6eGFlLy9GVXFWaVl4d2lPN3lUTDZrRVpwTkR3N3NZSlpUU3NIbVlYUERMRDF1ZWVaK1ZWdTVXMVpRbU0wN00wcWJrZ1ZaOUIrMEVGOHYwZmFFWVltYU1rMXpBRjMycVNTTkpiYTRJVWxRK0pRdUtzV2xrK3d5QmRlajhYdGx4WXZQM0U0Wlc3K05FN3lGYWZscE9oQ3h2RjBZbDNqVkVEeVIxeFgzNFJ6NVZWeU1KVXJhQ3lkdlBveGtTT2VjZGF6bk1VckgzUHF0YjAxK2FnWGpjY1NibkxneDRJdXl6VnZOTkNMMkk2Q0hlZTZYamIyOG9LcnArZ1NtSlZuOHEweVJBYkU0U2QvWThDc1FqMFkzZlJIang2VkFuVkFpenhmTGJmNjRtbWFQOG1LRnF2Q05KQTJHMWphOXp4SzllR3pKNjVnU2MvS2x2Z2hRM3BIdG1xRHVaSFpmekJ1MzdtZTc1d0JHME1nR2pNTnhzQlh2S2p4eFdyT2N6NUlIZGgzQ2xkNkJDZkY2NXhtbHNZZFhZNnpyUEdMTDc1WWZQcUxUMy82ODIrKytYeEorTmZ3TVkyNUlzYWN3SFpKRFdRVm1GTzRWaXlzMUxCK0VEcGZJdzdtT2N4a25QMkpZQnk0K1ZQZjdlZUg3L2xUOFNyV0pmUGhBRGFtYzRnWHM3bHdtNktXVVBnR0N3eXp1QVFGcnQ3U04yenY5b08vMzFBRDMzNTZNQTR6eGlPT3A1UkMvTUFDNTFWRjIzazJmR2w4ODIvWFlmME9NVG9vS0lTTzlYTlVTQUd1N0hhbkZSSlRnbWxTcWdGamFvUExrdU4wZjQxM3Y4alNtZE5ZbG5BOHpKanNXem1EUUVOWGk4QURnN1VKRG1WOWxNbUZzeWpEcTZmWHFrSVlGckJhWURQeEtVcjQzOC80MnJmMzdpOCsvYXRmTHI1OThEQUlaVnczU29QQ1J5Y0hiUituQW02ZVJiRk40NW9SalZTaUxDSkwrdVhTdEh3M1BRcmgvSUUvUEpzK2FTL3FXenlPdnpXekhZNW13dnEzT0JvK0R6OFhLalovUjFxS1p2UkFDdDRrbytKWTl5Z09tT1NveDJUaEE1NThHbDl2YVR4Y2xYdVN3U1IveVRWZndTeDVDZS9BTEJpSkxFOHlLVXllcDJmR2haVjFoQTJMZFpSVEkyR3MzT1FsWjR4VkhXREZ0bHQxa0lueUJMWmxXZW9pL014MmxKS05FbngxOVE5Y2hzSk9JNGJvY2ZBdTNQTmJPQmp3M3RGZ1RyRDRzMHo1bjJZWUtOczVxd2ZEbjZ2Nm1EZmxxcHhnUExMSnd2QlJzbkVjNGRPTXdkNk5CZnpOL1FlTFJ6bGMrMFlVcDNoMTVUWmJPRHBENDVkTnNGWHVzOXhSZCswOHl5SlhyeTl5ZU9EQWl3S1BDc2dJd2VKcWxoS1M5OE5zWGxpUElpWERpVHpvbTRuV1J3OGVaSjdnMjhPSEQrNi90bTJ2Ulp6OHlmQ0tidk1sc1Ewd0c5QjJ1VnRabENaSndtRGpKV2tQYSthNmRqNmxRRFVMbTdKWjEwcjVIaDR5K2NkaExYNXpoRXI2RW14V1ZieDlFNUFTdk5KRGhJbXdSWkJqa1NXMHhnaUxZYUdxZzNpTkd6ckEyYmhLZDljd0ZVRDBkZldKZk1BMTAxN2JaK0diUERrVEJLbGFZMEluNmliaVZISEVEVmJKZDhUemkxTnhDWitLQjY3VXhtbWRkMHYyeDBxSUFJM1FWVWtWSWNMbmdKbGtnNkI1K1JpdWlybjhNV2d6ZnZiM2VCdGJMYnFrVEJHOVJPRWZQOW94enBJaWZGQkY0RTFwbUN5d0puRXZodXg1K09Kd0dydmNMTXF1SjdGUHMyMXpJN1E4eVNxQTU3bmxZRE5MWEhUaldIOTJkam40dU1hcXZ2MW04ZURobzhYenJPWGRpcUlPbFdRYVpFSVhYZldVYXpOZE1xc1FWc05qNDJGdXBWWEpEek9rb1dJUmV1VmZDMjgyUWpQcmZrMTI2VkliMWlnK1JTNktkb20zeUxyYWNzSGRLaFRkNjdFRmVsUjhmR2laT1RuUEVZOVpjaEMxTXBhVjRYbHlyZkY5OVN6MDk0OWNyMlhScjRYbzUweXByRyt0alM4cnh1YnRMaHNuM1lPdHNuTmtSemZVTVkzU3N5aUpUMjJmVGVOV1NpWFdPL3hOSkRvbjE1amZmb1pmMUJsNzQyMFZMYm1GTXpJWURBOWVKeGtyWkwyYm5MR2NxVllGQk84eHhqcG9aVkI5TlhKT3J1WHZBT2s2ZENnTnYzckVvYVUxclNZUU4zUEdMOFV5bHNaRlBqTWtjWkp5VlRtU0R6eXN6OFdMa3NmNG5hUnhiRnA2TzVpRmpLT0RydlVMY3BIR2REL0hXYjc1OWx0MTVmcVhuMzFlMXd0dDNSanIzZzJkc1VnZloxVk9qZC9ucmpld25vZU96OGhCbGxROWk1WDZKRnZVbjZVN2Y1aTZHYTBTZWNwOWNNRTdFaHFCSlJjWmRndHE2ck1iakt1aHkxRFRYbnBiRnhsU09vdXkzRXJYUHdPcU5SUjJrVHdQWHVnZHFMdHBFUFh5c3BGZ0s2ZkVyV1hkOHYzZzh5OC8vL3pQZnZuRlYzLzY1dytmL1lzaTJHdjhVOE1DMzVYL0VHZzhTZW5qRUsrWlVydFZDUFRFdEhuNmtXNG96N24vSll4SmlDZm1pOTk1ZEJ4QzdMbFVscU95bEdXUWRKWll0SFVnTFdFUzltcEQwYmk4aXNkci81MEtVVmJyZHlCUzYwZG4vbWcrZDJaOXc0bjhpNXQ0NHBOMVNrazhNYnVheXU4dzhUcktMWmFCWFc4bXFRanhqbk1LUWkrMGNranhxTFRwYXFVU29PdmpKdzlyVWl4Y3FzTlZJZ0hGSHljVFZhV2x6SkllYmZHb2VlZWJWVTNoMTdiWmhMZk05SHVnUE9USU4zeUxmeWxId1E1YzZ4WDV6Uit3Tzg5V012MjdyS0RncGp6dDEva05lV0FjeUdkWTV1SkkwM25MQjN4T1dPMU9pdDkzdVFGMzFJbnFWU1FlcGNGZld2eWdiS0xSeTVLdlpWYUpveWxzM0lJSVRsWDU1TEhrcmw1TTRzRUZQSzVwMFBEOVprbHlKaWZ4T2JiK3JMdU9Id09HT0ExbjhJWkMwckNOOE02bjZTQitPM1hMa2l2ajc1Lzh6ZzhYbi8zcVZ6bWcva0hHTWg4c3JtY3p5L1dVejNVclc0R250NHJPZWszTyszZ1VHWHFXUTEyZVBudVIxUzNwRlFUbnpEZFZ3MkxJeTRZZnZaUGFuZzE3alczZXJGZU55bWE2L0VXcjBJQkJsN1lySlVTenlFM1NPU251Tk1OY3g5YjA3ZWJXam8ycmFRQlBGcy9TMi9yTlYxOCsvY3ZQZnZXZmYvcjFnMCs3TEsvelhjb1ZFeWpLWnFZMzU5ME1VbUJFWE10b2M0MEgxcCtScHVQTTA3QlM1dW5GQVlQWWVIczRUTzc4eWlOL3hGV0pxb1djV2xXQ1pPblZVWDRUc082S1NBUFdHRyt6QnMrWTVjRGR1M0dUUitQemFuNGQvK1c0ZkwvRGxUbi9IZjcvMWw3b01DcldBREZvMzdnMDJQNjlHdnI3TGpUeXpvK1VpeFU3S3FSTEI5blNOZ2c0dW8zd1Z2Y3kzN3AxMlc5UUxwL2pQWlZIajRNRlk3ZlVlZWk1a3dteXRlMVlKSkh1R0t5RDl5cEJlaW5vemFJN2N5TFcwRXRGV3hYMU5NalVUTzVFNzFHYWtWYzF4dm1VSGcrNllyT3VXeDY4Uzg0aWEzUFgvQ01IY3o2Q1VUVndDUmRDYUpLY3F5RWFzcmFXZFpKMS8xa204NVN6eWlwdFhNTW1pM1VWZVhENGExMWdHdnN1K0lra2FwMmJ5N0lON2RiWHgzVW5ibms5eWtUTGFTWmhRdmxZc1htaUxEUStYZTVhYmhVWXZZNFZYN3RzdnF0c3d2UGR2NXRPWXpFK25zY1N6VW9QZEJsME5hYmQrQStaUUkvaE4rUk1PVDJjL0tyY3N6S0RZL2pBRHJuZitYdS90M2dReGZWLy8reG5pNisvL0NxS2N5L2x6OUtvckFLd1c2L0c2OU9UVVNjZjVtcnJCNEdKckNqclFTdjB1UWcvNjl5QlRPaGRHRXROL1RiSlZob2g1WE1TMXNacHlwQ2RaNk0rQkVkS05aYndLVDRDRkt0WDN5aUR1YkZ1bzJDekttQTlqZkg1MDVYRFI0OGYvZk5mL09ielAvMzB3ZlB2aFdKTkljTDFtVVBrRmhyZUdOcHYzeVg0RVJYZXRXMk9FQ2VDTkoxdU1CakQ1b3k3dER4MSs4VUJyOVAwVzE1d0lDZ1VhNjlKVkJGVU9Gc3F0OU9xUHN4WmtnUVBqQllNTUxuR2VRNnovY1R0NzRvOC9SbHhKM3hHa1N1ay9YODc3dHpubGU5WitsZENYdmtKWCtMRDVic3NsN3dJejh5OWlpK2NVbThWdE1weWtVYU1mdVJGZVoxa2RRQWxlcGJ3YW1haUJaMU10eEs2Z2JXYVdhazVUR1FyZmtBbkFuOFJTOFFReEVvVTYzcTZlN3B0SyttS2xuREh1bkJtcUx4VXFvdU1SNUNEdWdNcFNMSGk4TjEyUk5mRzFEQkVoaFBXVkk0Z2FhblczTEdRT0V0MWxBdFA2d3FVcVd6dzVELzRNRksyak1MWmQ3bFV6UFp2aGNSZitnR2p2OGNhNW9iYmNjR1h2bUc4blBZeS8wcVhRSTJIYi9aRkRRK2szR0JvOEoxSFNsYko4RW1zT2IxeVhmL2VobHpIS3BMZCtHbkVEQ09oSng3YTdBR0hsdVhHeVJ1dTRCdXFBZDl3eHhodmxjYUUyS0RWYXJyVmNQT0EwMDhyMzNtWnhXblhOTUFoT3gxWmt0YUtYcjk1WS9HSC8vQS9xQzNQMTNMUzFGZGZmRlVOYUIwWG1HVjloa1JZc1Z6YWtvemg2N1FyUXliRjBtaFNqb2JMak4zWlZxek1KOHFKQnA3d3JuQ2Q1TjUwNjhDZEVZZXVVY2FSWVJPcVZwRDBxVnU1K2ZoUEgrZTZweHpxOG5rMkpIeis1MTgrZk8zREFFV0UyWjlwUWl1SVQ4SWxiTWtZUkpsK0wvMmlDSWhEaldsT2hDRWM3VnJvRVpWUWNOSzJ3anlKdFBuTnZWcHB5blB5NzI1L2R3T0ZhUjNsMVVMWFFpaHNEZ3Q4RDcvT1M1ejI5NTNBZXIzNlp3NW5STHVNTjJCTkZmclZoTXZmbHdLNzlIcnBvOFBCUmQ4cVVWNkQxaTlGclI4ZGZ3cUpRS3JVNkUvaFZXaStEZFhVa3AxMGwwN3pUY0ZHVGlQWEtsOGF0MGx0T3h5R0c3U1lCRHR4M2U5VkNpRU4yWGttSmRaMTBYSXFsSTBLbXhrRFhRdTlyQ1F3MmNhWkRjWUh3eGlzUXZCTUNrSUlEU21DbzY3Y1U5NFhkZXJ4VUVUZFV3SkxoZTgwdEpIZllNT0hhejdMZzF5SVcwb2pTdGw3bEdYUXFiZFhTZzhPNjZoZ1JCbUpXM2ZCQlM0RjlTcXZXL0UwUFBIQmVjbWxvYWdUcHVKWlNpNUtJemxGc2VSTWl1dzYyamdZUFM3OEVjNmFMV1VjWlZWM2p3VWRpb1VMOUlKRnFVYkxsaCtjK3BHM0J5MzVrZjgwUXhWdlBidVlOckxzU2JqR2JKUmxySEpvL0VYazczZVZIVDZKMzcrOWhmUHJONXhyNGkxblJWaldlRFVON0R2dnZWdkhVdDU4ODg3aTVsLytWWTNOSys5Snl1UmNrUnJMRGgxWXB2c2hsd25SeDNzNWJENndOb3pQaDAvV3VSNGZIMzE4OFBERjNjWEhLZnZUVzJNZmQzQThmL3k0eGpwV2I5M2F1blo0L0tPenRiWERqRGZmekZ4TzdmaUl4c2srbW92RHMrUHNSVnpiZTNwNHRubTR2WGE2L2JwWEE2RHYzK1JLdVlhK1MrS0szTVN2KzU0bTV2QnI1OXZQOFI3K0hlN2RqQnJDUFlSZlJhRW9iVmxyMTR5WHBpdFVDN1F4UUU0cnlvSlZxVmlzS3VWM3JVRnRXQTI3OFpuN3Q1ODRoV2RIemx1OGNwZm96VUxIcHpqKy9VMXVqRWYvRFRHV3lSR3dvVkdzb3hKcnlibkd0ZkhxMzZGbWtKM3dMVDZBYy9tNENOQXdnTjFZallzVkNLVmMrV2NhdDhxaHZNa2ZQYzFPeTlXemtiTmtNNzJSQ2lkZTRNYVNOWTVJdWVLUmd6R3F6UVdyOG8yVmttVTBOZnRObWJJMEFpZXhNdmxZV3c2aTZGbkxVV2JodmNYZ0pSZEoyMldDVDhITzJ5V0JaUUdXY2gvbklwQWRjVDNpVWdhY3lUenk0bWxZL01XeEpQQTgzZVhWREYyby9QUjAwYVVzb0pSM0JxZlRlamU4VXB3ejVTcCt1Y1JKNHNJaEtpbjB5dTgwVExvSjhOcFBkMVVEVkJOYmFkaWN3U3N0eXpXSWxMVXBIb3YxWE1NRVhoNXhTdG42TzVXdnk5dTBxUVlyNWRKZ1VJQ1dmdG1DYklLNXh6NkpCMDZDMFRqWDJLOGVUSlJkTXF0aU5NMDZyL0xNSDNXMDhpdTBNblpzSWp1TjY0M2NnTEdUdW5qajZodDFNMGJ4TUVwVEQ0YUZhOGtnZkEvU00vMzhOMThzZnBZMTByLzh6VytTVzQ3K2UrLzltblQ5MVJlLzJmNHMwOTZMeitUMitMZTNwVDR1disrZEJRcmJmeHUzdEZ3bFJ1Z1dzQkt1RUF5RCtMVXJodVYzeDh0SFZWRGh3c0RvaDEvSGEySEZ2SGs0L3psODN5b1Q1bW1wRFE5SVE3bWF6VGJtNnJ2VDlidjlXcUFhcHQ5enYvNkcyMS9uUnBxL0x2UVZTK2Ezb3YxMUZtaEg3UERBb2J4S0ZRbHJCVHZDZzNhNXkzS00zeXBXbFNIaFU1UlN5eUFWbDZMQVJwcjhDaTJkZnpIL2JYenVJdFpVWWtVcFVvU1RwWmhLUWluc1p1blZhdTVqMmpRUmx0bDJFendxWXEycUNHcGdTYWY3emxIQU5ja1cvOG9ueXNhd2hXL3RLRnp4eGhGeHVwb2J1OFBpYmR5N2tvdnZPYzE2VDJrb0VrNTR5NDdmNUVFWUdXclhhZjMyZmVuRVFjOGhBNE92bmZPd21NVWxiL0xncEpmbkhLOEttUDBwMlV5WEg3eXRuQkRXOGJIVFFTb3JrZEhvempxQWhWWGFpdFd5dDFwbFlsdzcrUmdQN3c0THhWb05VT0lyVytNQkwvbVV3c3NiazJNQjFwangrbFEvYlBCQUZ6YzdVSFJ6R2tnTFhpbkRsTXNxREg1dzVueHowc2dMbkI2R2M0aTZ0RTZpUTZQTnJDejU0QWNmRmF5VCtDdlBTdUJaSzQwbkpweDJzMnZ3Ny8zOUh5M2VlT2ZkeGZHZi9SK0xiek1PZS92MjdjVjJoaFJPMTlmK3lhY1AvdUtmVm9aL0IvNHN4MXdSMlVNMG03RXFVVFA2dTJnaFhqMVRHbkVhVGpPdEJVODh6dThPVzZaUG1IdzhuRmJadDBxNUZLb0tHZXNjQ1lFNDdUcHRDMHpEN1h5OE8vOStCNGxPUHVFejhGdDY1bU9rLzIzL2Vaei9yNy9udUlMZFpXaThtMzc4L1VNeEdMS2l2QjN0cHRLeWNFdkp4UkllSi9HUDM1U2t0T0RVUFVUVlhaNHFWeXlwMHpyZmxwVmpLZDdnRmZyS3FmSUlyNlFsRzJYNUZzOG14UW9YNFIxblZvR2JqeTdtQXcrdStDaCtwUUVUVHV0WHFxTGlQVHdyN3htdjhKMi95dXpOTll6NlRxR2JSb1huaElNNHI4WXRqL3dSQmhmeGsrRVMzaHh1eDFWbWpSQUxHMjRoZGlra053c1ljdWdEb0ZueU96bXlNZWI2Z0psR01kUU1MMGE1d0t2eHlGaDJGR3NBVlJiSzFBK2MrbHNnL0Z4ejVDM3ZiaFRnaWI0MVVaZTdxWVIzZWJyYzRFZ2pYanRoVGQ5T0F5YmFWMTc1cm9rL2RFNWFQWld0WE50dW5ObUJRVmFIR0VldnVxaDgwL2RISC93ZzEvMWN5OXJWaThYLzliTy9xTWtzbkxweDdjWWZkOTUvRjk1ci8vN0g3L3prTUMydGJZR0laNUg0ZXRiNWhWSnBYVU9TdkJOUzYrT01zWmdvMGMwcVpvWG9XbVpkRzFkTXVIT0h2OU51bklxVGFsYnJaVjJuYkFtR3grbElYRE85bVNvZHBxN25yTXFEalBVNFpjbmQ1cjVWN0t2WGNqcGpCT3NnNi9DazRiekJrWGJwbDF6OVU4RVRPSXhEK0NVKzVVRHBlRXNqc1BidkoxeHZuS0Faa0FjVDdnUDJVSEF0aEVrWWp3Q2JQU1AyVURpR0pBdURoTXRyL3EvU1ZCMGZ5bjdRSUI2Sk94WitHeXROSlVzZW9ubU02Sm44eUtFRFpRR3RSWGxZMDdwaGdpQzRubVoxQkl2SnVtUmRmQlU4cFVyZThoOVZsbzl1UFhpVzRsQUU1K2t1TzNGTDVjOTVHTFdzSnNmQ1poWTNNOEdCWmJmUGJ2aTFFOHVrY0JJMU1GaGFsRHBnZFpRZXl6ZHcrTEZtdHpSODJWMVR3d1NKdjVQbE11S1NqZTNzSXRwS0YzTktuRGpCQlEvZ2w4cTVFVG14ZnJOb21EVGt4alhONk9Fd0dtdVJhM3RrS25YSWtsU0pwUERTazYvRXpWZDlvNmVuRlZBaWxZd1lQemJSWkQydDlzRTQ4ZUJ0T0I0Y05FUjJJaVdIbENzTkNycVJ0NUtSMERjejNjWVdLVkZ4T0h3Y2RBOHUyYWhoOXI4czFpalNmQlM5MDZZVTdkejc1UFN3ZXBKT0k4VUNkTUxiVHNZMzR4RThVcktFbFd6bU96V3JoaFBRL2poTDdRd0RpTHNkSzNNdHd3S1Z0elRLUGkxbDZub0Zqdkp4VlY5U0huVUQ3dmtzOGludnVOVWlQSWg4MUhCZ1lramx2RlUzMTlaT3pPUVFzdFh4ay9id255ZmRjZWlWRXRma2FXNDRYeHprcWgvanNNcmxvc0RkYkx0K2xxMnV5Y0RaeEMreWRmdWZQM3p5UEx0VC92L3ZNbStSWGVpRU5hNkVKQVF6ZnNPcFRLMVV6UEpUZm5aZXRNV0JROEtyMVl6QWp1N0VXQllpclVYY3V2UUV2SlVmdUw2cm9rN3dPNjlpZnBTSE5DVmNDZmZkUXdQOExIeVhUM2NONTdEQXJBb0hkM1V1K0RXY29GMWRNWDZsZmdJcmdmNlhLeXN1WCtLWG05NzlrOEFQbkVmd2QvMFZIZ2dWYndsbmlqakNRcnNBck8vRTdiY2NhK3pOT3hWSFYxdFlMZEVKdkhqRmpYRkhYV3VWdzI2ZTFhemRIR0VqdmtrcCtZSlhmNmZ5Qjlnb2Evekg3anEwNE9mM1VNUVcvQnMzVTdFb2Jlc04wYjc1MXVPYjdLdFJGbVVGZHRCcnlFRndqb0tUTGdYSkhWeGpIM3BaMHZES1l3eXZaNGdyN1pTK2dPVlB5OXZJbzMwdjMyVkpSYm1ST2VsYnRqcCt2Nlh3RFo1NC9mVHZ0Z28xcWgzbXZTeHYwdmtXajVPdTVEOHd3VzMvZVpqNGhsSGE3emdyTThRanZ4UjNXWVdUeFczbTJ3eS8wODdPcCtWMWxUU05CRHpLVFc5d0c3ZWk1WlFIRGpoa3BUYjE1RnNiM09YdmQ2Y0RyM0JPT1Y1MTRsU2VKWHVnanQrK0drNzdpYWR1NVcvK0RUejlGVGNGR1lwWTY1aEk1a3ZlZi8vOXhkTVlBRSt5TnZYSmkyYy9FdTN2aXN2aDNaTUNEWVdHTUcwdkJYYTVvSDBhR0JweHhmUG96aGkzb2x6SEUxQUZvd1ErM1UzTTFDSzJvelJhVVBoMVJlcHdZUTRGcmp2UFdRZDVWTlQxUEdWQkpPSzFHOWRyTE5hQ2Qvdi9XY3dqM2JBMHl2SUJNTGlVWU9YZEV6dFZUU0FaUjdja1FuWEduSE5LNXNvQ0lEZ0VLSUlEdjdsU1ZmNy9sNzE3OS9Vc1NmTERmdXRXM1Z1dnJxcnU2Y2YwUEhaZUsybEJTcnZPTG5abFU2Sms4VStRSVlPbTVORWZRNGIrQUJvMEZoQUJHakpreUpBaFlBMEpXRUNFc0FTNEdtSjNvQm5PZE0rcmUvcmQxZlcrajZyUzkvUE5FN2QrZmJ0Nmx3UkZTT2p1clByZGMwNmV6TWpJaU1qSXlNakhDVXJQRGQ0MVh5UjhYVnZBYzlLS2Y5WnBTU0Q5WE9kRGRMNTcvelNqQ0FLcnlLeUFXclJGMDl3N2haNFYra0tXVEVYTmJKTUtpemVGRlh6Z250YVJSdzBCcUUyaGIvZktuVU9mdldNaHhTQXV6VTJXWE03SVFlTU5kOWZ5ckRTK0x2TUtFVXlTcUxNQURscFpZM3dhNVlEdnJLSFRmZ2tnRmlMck4vSFNVRGp5dGFFbnIvV1BGQVlsNzljajZKSnV3cFF4MXlxNHZGKzhXY3BQK1pTdG53YnRHWHhwWFZ0UGRkM3duUGZLY0pLVTV3a09xa2J4MDhnVndvL3lOcHgzY01qajBCMHV1M0xzV1ZtQzgzSXJqK29EeGhhbWJIN29ZRnFPV0tHanM3Uk1UdWRsYmV4QmRpT3BXM0ZLMnNGTlBmcUxKZW45bVdJTDdvTUxxazJKRktCZkE2dFcvY08veWtBaXZmSys4ZXFmZDRQM3hGVnlVZy8xb3d1S1MzQk1pY0VYa056blJrY0JtSFJ3d3dkeWV4QnIvTld2dmJ6M2JUN2JuRkwxOXZ2djd0MDZ2UFlIeWZuL203V293ZVhmVzdqVU5ZcVcwcUFQc3FWMTlaTVJVWTRsSmpzdld0VDM2UStlNXNTb1dLZ1QxdnZGSUVLSStaSFZEQzJ5eXFMRzcvSU5hVkJyTnRPd2UvbmNWbU5ZUW9TcFNnOUg4dU4wNS9oZjUxWmV6cElUU3RsaHVwam5jeXpYczkzdFNnN3kvU0E3Umh3dWNTa05Zc0ZZZnNGS0RvRUp5TWhzRkdpVXRuK2JvQ3lWa0hjcVFqakZTKzl4U3hOUnJJVVlXVm1vZ1pWL3N3d0hyQW51MGFKWDBkdnpncmhTVGZyeGVmYmRCc0o5YVpubld2L0J0WEY1NWhKZ3FYWVhaZUQ2bHBiUEUwdnhRdFlndnZ6NjY1M2tleXZiVnU4Yk1yWSt5YWRCUVNWL1hKT2hBUjdpV3QvV09YWEt5eGhScThOSktyVDBLUkd6eEliM2xFekQ2cEcyaHkxS2VVbVBueHBXbDh1bERCMWk1WUhpb0F6U0tDbWdDOWwrQ29jcXlZTjBwSm5Ba2c0TTZab1dqdjY1NWpmeFNwUk9IWGQvMG5SQ1pZc0hiL0xLTTdpNVduc3BGTGN5TjFLWGErbWYrQU1LQ0I1YmZad1JTaDRUMlk3bEpOdUlOK3pxdW9LUHNwWTg4M3V1QTJUS2g3eFR6cFJWQmJ3cDUxV2VmS1crM2JsTlp4d0JYdXNaeVpWT0NzOStSaFlSaUZxcDZzRTlZV2V5cmJKK1Ztc0kwazRBRHh4WHdSVk1naUFkV1JqNDJtQnhTMXdTTnExY0hoc2YrcXl3M210Z0prM0p0YmFUYnFudzhyYkJKTnV0R3pleitlUmc3NXV2ZlppVkJPL3d1LzUvZWhUZ2h0cS85OHVaVzJBdDU0aGdVYklzbnZDUVVzdmZFSldRV0VxVnhyOEpSdzl5U1dJdWhWcWtKa1pDK09Qc0w2OFFaRUtFTVBIbG5zWVBKYzZSZUk1Y0k0aHRYQVIyVThyVEFLaEhjUmdwejl4clBQTHd5NWw5OUwwZUIvbUtrNVlBdTlLRkFoR29NS1FLZEFJQjhhdWVTQjBhNTkwV243YWZlaEF0cWR3dndWb3BHdFUvaGZuc3Nla216dldwWGtySWZYL3JLWDgzdUN5VnZPc1BuUnU4MndRNVRxMmN6UkUvYUN6VTBKTzdRaXJyRytVNUNNMnVaNC8yMVFpc21kdnYvT0FIZTdlenB2QW9CN2pjdS9lYktvQXpiYnFLVEljUTJNcUhVdjZWcllHbG93QXp6YmFFWWNIYm9jV3lFdW8zemZ1MlYwZ2tvN01OZGtQemgwOTRGYmFXSHQ0YkN1OWRpeldiaVErMHByRDQ3Qy9tV3g5VlprblRSaDdaR2g2VFFiN2gwajc0U29lL0dtN3pCSmZodHpLVUtReXZ5SkFWSmVBVmR2SkxRM1pHK2Q1SXh6d3JMaWJmdW9iemxFUGtlZVJPbVpOR1BSZmN6VDJRZHdLNWszN2hxZFBJMlJjcDMyOFVxN3dzZlRpQXgvWERramR1cWtjMWRDdmRRL3NMK2FLcjlCT2tUNkxHZ1djMHB6eHRqWXRIdWM0Zk9FeWVUaXlsSFJibkFKZ0Y5K3hrdnVTMjUxNERFOWpRWGkzcXFrb1o1R0pKMjZMcDRPQmFuRkxHcmhFaTljSXZNdDJsSVJ0UHdwWk9lS1lNbzVMck9hZkQxeXRlZiszcmU5ZXZYV1c1ZmluQ0pWOWpSRGdUQnhTbzlZSGMrWWlEY05aQVRpTnpuTmxCRGtwZ25manBOUW1nMEo0emNNd3lsL2tSZ0hXL2hBSG5wSlVjazVmaVpvVlFpdEVtdUoxR0R1WitHbUdrSjhPS0NHbVdtVmppd1lJSUMvYysvUGlUV05ickxNOHN1WXlBUlRuazEwT0ZBOGZ3VFgyQzlWS3dWV0I1MGltMERMQlgzWXFIVXBNZWJQV2xaQVV5M1o4SDhMYjRzVnhYbXFYd1ZwTFZJT1N2SUxwNmNSYldrMkdsRjJOWk51MldSaEg5ZmxMcVRxbXlDUFIyWUFiakN1b0wyZHY5U3BhMXZCeEIvZmEzdjdYM3ZkLzVuYjBQN24yeTkrWXZmN0czLzZ0ZlZaRUJGNUtzWHhDZmYrSTdDZFYzQzU4V2tmZ25tWXhDUnp5aXBPdzBpbDFaUlZCWFN4SmF3dFZEV01BcFRXQzg3cWNlZUkrT2xNdGhkdFFkNWVvckQvaTNtMVk1WEI4KzJmRTBLOHpsOTd1Uy9ONnhyZUFCMXBtMW4vY3NlM0VValRKR3FVMjVSakpjU1dDSm8zQmNCZm5rTi9FbHRKekVMZHdYUFF6bGZSR2dmdU10ejZSZGVNRXZja2RHdzBodG85czdRN3Z1MjQvL1ZEblNic1dlMVdmRlc0bXhPcVB1MXNva3hqb3lVUnRZQWI3cTVzU241c0g3MU5jUC9pbTBaVkpvTm9Xc2tWZnlSbVpZdHNxZTRONXY2RHNqTSsvSmlObitNYXlhWnN1bzNISTNaUzM2TFBvOXpoQktad21IK0VqNkxoQVNnV2ZoVDJURTdyRVVtdWZNQzZSK3pyamdKcm9XTjFNT0ZYcDlLK0lMZittcFdKUVhobUlKb1RyTVdZa2p1TE1DZ0FJa0ZMNWFpVmw2WVQwbmhzdHJUL2E2WDB4QU9hY2JpWHRzNFhtWWdXSFBldTlsYVM2Qlc4SUFqb1lNdm51NHVKYlJtOERLNzR4SmNEVXNGaExZWjVadlpIVEVkSVNsVFN2OEp4UHE1V0NSYnQrTWRCR3dCbFlYZ2FtZ2lGbEN0VHFDaUUyVk5DVzM4R21lYzM4cWhKVzgxV0FMYmt1akRvTERvc1V2ZFo0eXRuTDZNdkg3ZUpHNDJqWFJyczY1dkpKR1pxKy9oZW5mZXVXMXZWdGZlNmt1Z2V1SmMyZ0Y1ZHVEV2tKdlByV0dYTlJOdWQyaU91V0hHRlZkNFoyZ1FhaWF1b3VSM241NGRINXlpRzg2dUxnaGpGQjhPUzZwV3Mva216cUJNMEUrQ3U1RzlxWGZ6S2UvbXlPS1ZhZlMwNCtjNUJTbG9ORVZqdktDeTRYa0U3Z1Q4TlZ3VTFobEREM1hlYnQ0YldKVDBNbURnNjhqQTU3OVJzbnV2bHZ5RnpwSHJrYnBlRSsrbFhVaHcvN2NoSzdMS09DSG43VExTb3g4UmZZbWdGRjhFd0dPVFJ4REYvbWs5ZHdWRmJsT29GaGIvMUo5eGRZRmsxdng4cllqREh6NERNeThiT0krczRDbGpYd29SNzdLY0s3d0VwUklKdVNpV0dFdUhVT1RQLzBzYjhvRFd6cG9nbDlzRTdId3pJc3RrQ3V3R3A5eXlHdEhRZkxrWno2Y1RIWjFrYzBja1IzdVFDNlpyQUQ1K3NENW9sOHZFZEtJOW1wY0lkVGwrRElwckFwY3lJWXcrSVRaZnNhSWR0ckVvQXFGSXp4WkVWRHJZRk9rQkcwSjhCSjRKL3dqZUJ0cjRMaUM3VGVOd1ZVZ0lBUmhCRU41N3Yza203eDJhSWtEWTNadjZkR2JMNXJDOEphUVRLalFZVHBwVVljRVg2SzByRXhvbjV2YmlGcnZ4YzF5czl4VmlEWmRWR2s5TDJ6Uzc0Ym52UjhjNWwwYng1WkpYQnRUcmlhVk5Ed0NlemtIUDcrUTRkVFhjcHphMStKZnZSbFh5TXMzc3J3bGl1dXhocHpqNVQ3TzhZRDNjK2hLYWwxbGNyUWRYQU8wTWpRaVNQZGZuaSt3ckxaL2hvc0dwcEpRNXVwcVltVm9iaWE3ZkxkMEt5bFBOajdCZCtqRHFoU1U1ZmNnQnlETEExZVRiWGpxT1RkZFdwVVZvazJQOUtWSitJai82NnlDTE5kSzJzckRwbHdsbnJTRmsrZVJGKy9JaEFDV2UybEcyWWtmQzFRZVAzM2ZNOXdwaUhGTGJNbzFnaTBkR0dDUzdiRit3ZGJKdUhwM1JxZlVRZHdvVXVVS0krZlNEY3o5TE9YaWYyNW5GbnJoZ2JxbjFoM0dEOHpLUjk3M09lOG5YamtUNEtBekdnVXBmdmd3YVFwbkhuSXQzcUc5MFJwWXV6L3ZlZzdDeHNzMkYzSDVDWVVOaG52OGM5OTNTOEdLTS9yVkpyazhuanpNRnVoMHJQSTV4WXRNWFBreUtkZVhiOTdvVExOWlU1TmJWOUo0RVl4YjRISVBnY2k2MHlpekNtYmkxNGs0bVpFTkVhVWp2SVRJUFFFdzVEck1Gc295SWtxdUFvY1JmRVFSMnBoRjdaRXhydXNITndHUzMvTis4anZCdkI5bkk0akpkeHpYaFVGcXhoZXg3TEkwSzVaVVE4clRvSlE3UXFLSWJpRk4yZnJyTkljbXRiYVROS3llblZYQU9sd0NRK24ySE5CY256emVjQjhCMjdrQ2RIQng3Vm81amVMcFFSSjVQeGFIOS9zSFY5dUExYjhZQkNiVlZMZEU0aDZsb1V6SEFqVm5nS3E3TlpXR2RKY3V4azJUK0JnamV6ZGV1TGIzV2s0Q2UrWFdTM3N2UjduNkd1ZXRXSzhtbXF3UXVPQzh5MnVIZTBlZlpNdG9Kck5PWWpGZVRmbENRRFNOemdwc0ZuZ3dMczU4YkhCenV0QmhhQjZCMzdPSiswSXNWdXRPSFUvb20wU0hzVnA5cjh0NjB4eFBuRnJFb2t6WjZsMjZSNUYzV0J4NFhad2FHTDcwNlREamU3ZnY1Rk1jOXBabjlCSkN1M2FuVW1lV3c4dmtJV1BvK0NTVHBQam42eFozODVrYWFmRlVEMzQxdThXV2JGSDBvVTl3WVFYN3VGMGJjeVl6S2NLSCtkS29CbXl0N1VuMitIZENLdWZFN3NjSGp0NzlPa1B3dW5EUlZ1cUhsY3MxTW9wSTVpd0Zja3FKK3FLdWN0VFBSb0duVHgzRXN0d2MreGxKb0kxQWxyVVpzaU12SER2elgzZEJsR21ZK0RpVy9ra1NMTVVZNmtjdlN0OUpwOGlwK2gvdVo1U1ljZ3NqL3RiVGZEWUhUVS9UQ2FhUThnMHYrVnA5blBCQytQRkVHVm1uZkJEK2ROSVJ2ZEJkT3dnZVBvdER5WUdaN3FmMFFOL0RiQUJ3OW9Keld5dWZpVU1ENmZDMGJzRnNXUmJVSjVIbFFkQk1pQXh6QTJRU2N2RW05VTA1NlZKYXBvclpkSExCV3ZUSUZkbXlQbFo1QVJaYVpkN2w4b1c5R3krdEQwU0MrRVVQbDA3NVJ6SXp6Q0hPYjRxMGhocWhXSmwvS1F1L3N5Y214Rm91QU5NZHF5RXNoVXB3UFdNV2dWcysydFdRdTdRcHluR0N4bURRT3dHVE1MR01UQ1FZSkZDdmgyMnVsY2lKSzcrSjJoYVNYdDRSYnJHc01nSkdHQVJXS2VieUoxS2dxWmpIaEdWcHVmcE4zT0RTRlBEWndzUVh4OFJWUVVYcWxHY0k2NzJmby9zMElDRmkyRm9vVm9OUnhyWDRrYVZ6T3BDclRRRmQwSjZ5ckl5NGNmT2xUQUJjTFQ4bzB4ZlQyMTkzdmtLVUNub0s4dkdSSHlUZHRiejNZVUlISEpzOG1GQThrMjd3bmZqZGEvSFlhQXBsWkpGK25iYjB6SUpEWDRwWmVtaWlsQ2tBQUVBQVNVUkJWR0g1eTFkYWxpditHMWJieDY5QlNRZE8vWU01ck1YWm5iVVdrM2ZlZVY4M0U1bUx3aDZhbFplUkdUV1JwZzFab1FsY0I2eDI4U2NaYmxLcWRQQ0NwWXpndVkyMElzeExmbkpkUE05MVU5cEwyYTNoTzl6OWhGcXI4Ym1PVExmZWxGcU1pek1MT0FwMTZpQ1ArMVgvVldjS3VncGxnNmtzN2FLLzBJcHkzcTNYMUErYzg3QW9YNG8rTDNwVkRoZFAwMjU0cjN4UmpzR2w3NjN5VDBpeS9ramhRb1g3WXEzMFVTOXA1N3JTYjdUZWFFNVJnOTFBaVNZOUdyQ3lKMzB3WHZ4Wnc2TW9WMWdzZmtCSVBmM2FDbnRkSTZYdnYzYjk2MisrZC8vZEp2NEMvN20wZi9sNmh1SlJBNm44T0xiUmdZVmFVaEhTT0ZFMG9zaHR0dCtsZDQrRmtRV3laOEtBUG9RbnVhakQ2TU5sRlpieG0zS3RsZEVrMDBBUm5xQSthM0RnWUlaOG1Da1F2c1dnSlR6akEyMDZUTmM1eExLSXZHeDU5ZlpjQUJTK0FnMzFJeEFWbE1BY2dWRzU3VWRJQ2k5WCtYWUZ2dkhKTTlkUW9jcWJzdWlFaE40OE9MWWhKSjI0RHBXTFE0b0wzZGIrL0RieDlQWndXblhoazFaUG4wMUp5dXpydjdqM3Rlek5mdlhWVjd0cjZpQmxYSXZTdk1KQ2liWG11K3ozTDJUTjRHa1ViU2I2TGtYNVduZDZMYjVYSHlDa2xCL2xOUHJ5TFJEaFBPRlo3S3IyYWlMcnJYUjhacXRUV25FNkpYVHdNOGtvR0g1R3E1VS9hdE44SmxSQ1h6d3pnWmxtMjN2NUtLV24vTFlaeVpqc0tUNVJGdHdOK2ROUkNXdlZNajN5ZzdkMlROWHRsSHYvc25mbHpPcW50SzYvc0RwVGg3TG9sQVFUU3VoSU9TckR6L1BJRUNvcy9GaDM2LzFTek0vbURGWmR3cXRZNTVPWDhwSE9lbXJYV3NDaHk4Q2RhK1U4OVJjR1RsQXY3Vmh6SzkxUy91NmxHVndITC9HRkV3cXFQOWNCR291dkgzNTd6MXh2dWlocDE1QjV0YjIwdVZBbVpGMmpnSlpQRWFialQ5SlZacFkzWG95cmFjb2M1VG80Rnk3Y0FuVFNhTGR3RFdNcWs1N3hycDFsYWJua1NkME5Eb044eTBvTmtpejV3dXVrTG80RDgvb2h2K3VYUUxrK3pwZERaMDBmOXZSWXRCRFlXWXNONGJIdmpvZmNGWExNYlFOQU1nTGxmZEt6V1BHeVg2VEVXU0VNb1RRbzdtV0Jhc1JMdVBPMy9rQ0tPRHdDNWl4VW9DSk1na1lLZmhtZjhqQjFHbjJoTjI2Vko1MXk3R3hhQWxNSXVVK2VDT3V5SUo4cFNtL0JIZmk5N3BRN1pVNjZYb1BwMmZaRUxaOHc1Y1YrcnRxRDQvY2FYR0lGU2VzOFUwTXh3bXkyWFNQbGwrTHZadWtvZHhyYjVTaVhsNjVlajBKT1hhTzRLVStLMVNlM0grY1l1SDc4TFl1eTl3K3lEamp2TGtiNTZ2UWNqTzJ3bFFjRU9vRXh3UVdDSkV1eDVqN3hmbzMwdnZ6UlZoWlB1b0poaDU2dFF1cGw5MWJhZWZIdmR0RkFGS1poTzhCYkF4YlVFZDN3eUdSVHVGSExGVzE4MXNNS2tQSUczVkt1V2VUSlE4R2VSR0ZXcnl4d25YUnhLODc3KzRiR2dhOU9Ka3gwWlBIZzUza3BXbXVzMi9HRk51aXlsZ3FxQ2JubDYxK3lCTC9kQUxZNDlYQXZLS2M4U3p4Yy9VYTBueWNiM2crYzgra0NLdkFXekpGZlpad3AxYngwdjVaTWhkOUlIbmlKUGFPUDlPWTRHcEplbi9mRXhvYmd5MTIyT2hrd3BkQXhCdCtFdFpwQjJxVTBCM2ZYcWRkYzhWazcwZW5OWnA3NzZkUjlRcVlyS1hKUWpZb2dCZmtxakpUaHVtbU1HaHZzbVc2TVNFSlkrRVNMa1JYck41T2tMOExyaXg0dXZmZnhuZnI5TlBMTHNZYU9IbnhjUXFtNGdSV2kyZnZjNVI2RUo0Mjh4TXI3RVFTTW9XS21WM012WU5JMFhNT0pwdEVyaTIrdmwvczg2M0ZEL28zUlN3QWlJa2tqWGQ0VU1JblJ1Ni9HRzdSR2ZtSFp2QUFmcFB1Y1R6R256dzNEdlZ1OUorVlJmeGZGQW9sY1Y5andCYk5sVFh5ZVU5QnVReVM0U3lkdEZrenpSQmp6UWtQczk2TlNGMG9sbnNiRUwzL2psWnpYUUxDdVg3N1JDVU9LZFJRc1pXdUczYWVNYmVxNUdCeDhxaG9CS2RsUXZ3MkdIMXI1YW9NUHZwNzU4TzY5K3R1ZVpxTkdISE90RjhXS0JjUzY5VnlQWi9kOW43ZzJqTkNoRFV1ZWxJVVM4NzU4RFFOc1dVMmk4cGNDMEhBOExDWGhNUjFMTEVud09obVhOUHlQYStmZThzOWFpdFd0dS9ISjJXWUxOaXN5THJ3cUZZcFBZMzJZOWJxRDh6cXVML1hYdWVlZGVEdnowTXY5K052ZFg4b21GOWZMY1hHNVVxd3BZTzhveXFlejRzRnA2cnVyMFBETVQ1RFBDVitVbFh2cGxEWHY1ZWN5S1EyU2Z1Q05mTWhYR3BRT3F6elBnalQ0eG9MZkRXQU5QdUtYcksrNnBxakNXK2tYemZCVTZPYTlhTmZWUVViMjRudHVYYllSZ3ZMVVFSajRjT242Mmx5OW16U1RidFY1dFhrNW0yYVRvYm9EVWw1V1lyWWV3YXl3Vi9sTGJuUUZqbExVdllmRjRYZm9rYmFuZzRnNEZNZHJHVzFkdTN6NDNXYitndis1OVBNMzMreVE4bGJXVHQ2OGVUUFZEUUVqekJoaU5wMlM2Q1JRbURFVEl3aExabGdONjBjSWxwQmFIemtDdFZpN21ISEdRUGxTQ2gzVzl6UlZiaXhPSDBXTTVzUDR1Y3J2cDF6d0t6REpJK3d1YktjY3ZaUFBtcERVSW5BeFB6MXYwbzVWQk1iZ2RJWnY0UzhoblRMQWNUOTRFT0NJZVg1Q0puOHl6TklqSDBhb1RjUzhrSlBpVGFwUUNQeHJEc0t3aE1vSEQ2K2tBN3QrN1ZhdFZZMFdubFptK1BrMlBPdjBRVDQ5ZkJTbEdkdTJmS0R3RE1jdDRjck1VbkEyaVpKNzlJWlhsQllOam1lWERhL054aU5MOHFIbktOcWl1L01IL1Z0dmFaSmgwZlpaUGVXVHB0dERmUVFKNFFMVHFWWndLRDBTdldpNHE1eFc0MHhDVXRJU1dlVllSWmJLbDhTQ1R4a2RaVElMM2RDaWJnZDFTcnpnME8rblJnZnBaNnBndzR2c1VXbVp5clZCaGF0Z2VJVTM2OFI2QmVCNDNFWFJza1NCL3NRblN3dGJsdksyMy9BQ3pQMFU0THJMNy9HM3JyaEZOMm5tQjFmdjVpYytMNHRYYVp6M3lxSVl2Uk8zaTdOM3dzQmI3NWR5WHZGa2RTbkx0c1ZRa21FamFIZndQNHhoMUFtNVRMcVYzcUZMOFVnYTlWY0dhOVNrS2ZqZURiN2d6TE1PL2JTYU94TmhRd3Nqci9qTjVTL01BRVRiamhMNXg5RzFkUXVOVTQ0MUwxSDM3WWlVMVJDWU5nRDVMdGRMWDN2cDcrL3R2ZlhQMW9zdjd0OUw3MlRiSk9HK1llSWtrd1czWHNweWlUQktneWVzaHJNSXBCRmpta2E4bUI4R2hTN3pRNklLYXl5UUVqUU5FU013d1dKbjd6VDI1QzVUYzd1VGU2RElneG5TclBmU2lYTVZaejkyeXcvN3lDUUJtZEJ5azI0VWJBV21UQ2VZRVl4Z280a0xGWktVc3h2SXdjaUN1a3RUbUdmcHZZZVF1cklDc3JvaVA1TkpWNTNZSHlYM3RaZWlQRU5QYS9wTTVLRHQxU2pGYTdGVXU4U05HeVk0RjdkY2xhTmh2SkFqMmw1NjZXdUIvY25hMHN1QkZiamNMZkx4VTE0TW5KekdYcFJuRGFSSm80UFFoL3ZnU3NvY25IZnJWNUtpMzFiZHZtdGRRMWQ4U2huRkozSHdNVktoVVB6d2piV21jWmVQb1FtU1Q4TkVIMmswOHNRMi8rSTFaYmJlVWFKR0ttamlYcENQNG41eUZLVVU4NVhNS2U5cVhDSjhuS3hjZENZek03Um5yZnZTY0hyOThwNUxJWURhc0ZGRncxNXBOeVYyVm1mUEtRZnJVNzZ5MVhkd1VlZFZoNlgwdlBkdUxHUHZwSmtnNys1dk4zN0JYdksxK0x5VUpCakVyVjg4UmVQdE4rV0NJYjM4M0JwVDVxSnI0SVY1S2JZeUlLMnE4RldiLytqT3g5Q09rb1dYaEcwblcxdGpGTmtpUGxhci9GT1dlOEd6NEV5RjhpdkV2M0NhTW9NUFhJcC8zb1BiOTVLbmZHUWhYeDd4dUpzUzVFa2RLTm11SmdFWDdwSHAxMTU1WmU4YlgzLzl2L3IrYTIvK295LzZwRmEzdno3TU41bnZaOXNnNGI1NTUzcTNsckppcitkWXM3b0xFbzlwSmpZc0tSckdoMmFOTDBOTDNOVzRFSnVRclBlTGFScEpmVWlJbm5meURFTW52NnQvSzkrbnIrS2FIcHdkWmhmV2xxZGw1bjFEa0lBQ2wwTktxd0JvWFdaYi82WkFJVXlZT293Z0RwNnBRdXRBbUIzNzVsTVlOL0xCTnZSN0tiUDlGR3A3ZXRZcjRZOVM2UXFBV0s0NWoyL3Riak5KRUdWditKcUJaajc0ZG4zdnBaZGZ6Ykt6MDcwN2QrNVVZY3dFb3cwYUVmVW82L2lyREFWVEI1LzJPTWtuaTFYc0pKOWpjVC9LZ2hXUjJyY2F4VG0zVmF6UFNMTzluWnF1cS9xYTdlOUtCTmY4Yk1IbHF5amRRdmNuV2FxREhxUEUxb3oyYW53NlFVcWpkSXVsdXpaTTZDaFQ4TVkzdDJsNmZWNSsraWlVUFB1NnRwbHhyaEx3NjRPT2dxWGdCSEg4c2JZRkw4VzBkdW0xb2RzNXRqWDZlbU0zSG12ZWNFRUQ3MTJ0aE5tTkV5OTRKejY3c3d2Zk05aCtvMWpGK1UzNjNXZHh6Ujk1T0kxU21vNXN5azBKalp1UkU1amtaM0FadUJkQ2cybGZydDVQa0VaN0ZFTGRwcU5jZDYxUmFuY1pJK3FaeWlTb0F5VzNESmRWVjdEQUh2aWU0V3BabXFBTkM3UHpzdThpZTVkalBDMjZKSCtVNVlYNnNKTXdaQ0YzU2x4d0YvekNVSWZBVngvZndYc2xSc1NMMTIvbWhLd3Y5cVRXeGYwckJ6OThtc01WVG1QQlBJcDE5RENUSm5kelp1cTlUQnhZQUd6U0pBUFJmZ01uL2REMnVWeXI1OUtvd3pCMmlEVjlSSlNWK2pod2VzcVVxMFl0TGxZRHhkeFo1N1F1KzZ6TERaUnZXQUpiT1VxK1hhYWZ2MStmTDhFclphNWYxN0FtWCthdEdsZ29KczU2VFV4eEMzQzljRlJTWnFuRGVHa3BnUHpVb29jWUd3NUZNZGFQRktYU1hWbUJXeUdIRitXeVBFb2RKYWRwdExHeVlBMWIxY21CSjFmaVY3eG02VlRxNm91ZlBZWXVRNnVqbkxGd3dBS05NcmdtSFQ5WnlyNlVkNGZCdy8zdEQyL3YzWXVMNEpGZFRsMEJjQ1grMVF4Vm8yaWNrdVhUS1pTVkZSeEhhVFFQc3diWUdzY0htZVI2THp2WGJoOC9DRzJTSmorU1hqOHpoWWRXaVVNckhRaHNUWlNaZjJQMWRvdHJXcFFKTmNNM1gvYzhpSitZQXVBblBBeU1xN252SkVYd3NKYjAxRnJHOE5pcWgzNW5DODN5U1JmNzNsbjJIY0p1MTI0YlRybk9kTzJKVThsM0tmbmdReTdDZ1NBVUdrY1VLQkEvY09BLzhvUGZWb1ljNUx4WXZPNm5sOVVMNWRVQnpWTnAxanlsWE9zcFpUb0xsbkxBeDJQbnJlWWFnbFJaTzN0NEtaL3dPZUFmeGExMWtRSkxmWjF6ZkpTODFtNmIzSkhQTjZHUXRxamtXUmtrVEgzUndKcGdaNjA2MDVhbHBwejk0S3gxMlBubWt6dGtlazBZY1lmRWxWSEZueVFKVDFLZWpxeEQrelNUU3hrUlhiMzhRc3JQd3Z6dzVtbHBsbHBTcXJsWEoyV29vM05xSDJhZHNIQTVhNkJ0NE9sUm9iWVhaMmZsSmV2Vzk3TFdOYk9pbCtMT3NyeHZIKzN6YVpyOXg0K3kvSThySWZ6YjVEYklwRE5UNStRMU1va1ArLzY5TzBuakFKeWNRUnNjbnNMWCtjdkIrV3JLdS9zMFo3ZHFVNUVOTHBpTElSWXlrSEhsUEFrdXpuajl6WHZ2di9MVFg3MzlQeGJaTCtpZmJZNTNLYXVwSTJaM0YxUUlad0tCQmN0bHdLcHdxQy9ocUhJelBOTWF3ckxJVnVQZHk3OEV4cnRuc09VamxKTy9ML09uOFpNdVNRVHdKK3plVDl6dTlYbnZGOHdGWTVXNzdpdU15UndSWHlCMnk5bWl2SkRIMGlTd0o0azRQbFoxNnd4KzBwL0VndFNZY3g1VkdrUStjM0g0TU1mdXBYRm0xcm9LVjMwRHozQkswT2dMTzQxaXJoVFlXRWNtdXJnQkhrVmd3VDA5elFFb0NhMWpCRjFqbE05QytnNWJveEFwQis5Wm1oT2FQbkZkWHBYMDhwejlrcWp4R3RGazJLN0RPekNIaHoxb0pPWHFKR3cwb2VpTFE4dGRsaDE0N1lUU2t0UWx0U3RPaHVyZ0NCUVBuT0UybHB0M3loSXY3RWVKZUY5WWdlbDk2NW5yOEk3aUVRWS82ZEdRUXU3UXYyK2pjSFFtNmVHbGF3ZVhlT1hDUFg4V3ZMUUFjV0NZdEtITTNmdE5VSDdybExwWW9TREF4YTlwVThiUWRxelJtZXhGNEhrbkgxeVNiZUVnSXNIN1dmUDdhTnRRWVlKdlJpNnVGdmdyNzk1OGNrVUhrREM0Z2lzb1AweXFjazV2R3VEa0FqL1VFYTFENXlnNkpPd1cxaWo5VGpxVkpnc2VGNVNkZnZqaWdLWkx1U3BiRVk0RVZWYVZmNFVuOUZWSmFmZXpEQ3gwMDNtMyswNjZSS2ZjR0FWUnRBN0t2NVJkZXc1ZCt0NzN2dmNQZnUvOUQzN3ZKejk1OHd0Ny9HQTYrNHMvSEFaaFRnVXZQRUZZSjRvL3lDbmlqMkxGVG1QejNtNFJWZ1RhaHRTb1Z6N1dXckxzS1V6MUk1OUxSZ2tzd1VKNFRHNUpTdXR2cFd0a29INWFzSGR4azJ1bGVuWlR3ZlZpQzZ5UGdzM0Y3ZG12Z3BCR2taZHJZWFlrUEVMWVdxd3FiTTluMlJHalNvakZNc05mWHpDbFNGcHVFT2NtMGI4UU9CTXhsL0xjWGozS2FGa0FhYnhKcjk0ZHBza1R2QXBqUTNYdHpJcUNUVG1FMG9uN1I2RTlRczFhV0hTQUxkdzFJTXFWWlNYVzBPMUIxcFRlelRmbFA3alBzbERyb0E5ZWYrelVSWXRhc3BSMGNBSi9jSms2R1RZdnhjZGZIQXNuc0pkbGFtZGNHblR5Z2s4ZUxBMXpYN3pCUzRneFV5VXZueUFXYmREckFONXBaSUk2akNJYTJSSnYwbW53OTZ5RDBkRnJ6R0R3czY2T1pUVldLeEtPb3dpVXhIY3RmeTNoS0pJcStMenBoR2Z5b2tXcVZFVlJXSWxUMTY2R3liMXkyY0ZuOVNQbndYMW9JODl4bHBkNVQ5bFFpT0xrS2J6RVhVbm5JRGhMb0NPMEVJQlZpL3J3QW91aTFCR01JZ1J2NGxpa09zbDFWa2VXVjJYcFZiODJFRHd0Zzd1ZkxjK1Z4NVNGRmxNdWw5R3lybGNjZXBFamRPSDdYL3pZZUpWWTYyRjkwZUp4M0FBMjF3U3RqbXlDYks3YWJ6bzhNaDA2ZGdUU2VvYnZyZGVxeTFyeWxveWh1WExVd3dTakZUa0hLYnFiQ3FLYytjcFBzNXJsSlBKeWFrSVVqeUxINzc3MzRlMDNmLzNXLzU3TVg4aVF2UUNJZ3ZsNllsZkVSSzhJVG9ocnVZd0pCdUZSQk11UmJpd3JsdXpWREIwdlo4aGsrVTBOMktTeDQwakE5T250Q1dnLzA1SHJOTG9tZXM0ZnVSY0ViZitab25VdnpEczNGZXpFdTA3by9mYm8wdHN0YjlPd1ROeWtYdjZsRURYdVZSa2FmMWRKcFA2ZFhZNEFzM282MUUwNVpsTFJKbU1rcEVyMjBDaU5jQlRzeWRIKzNvTlA3dTVkelBEOWV1aDAxVVJOQk1sblBqVDIxYXNIcXlnRjJ4aVZpV1JKVVhxOUVvZS9PSmFySXhYdjM4K2U3UGkvejZ5a3ZLdENTTm5pb2xtckFNYTZVelg1MVhFamc2aW1oWFZhYUhFdGJaSy9EU0I4YVI3NThxUHNOTTcrVXY4bmFaekRUMnRlRCtNdWVDR2ZiM21TeGxtL0w3QWFJVGVTb2VJR1oyREJ6YjE2RWpINFQ1cWloTDc1aWE4TElIQU1WOFhoVGVNbzVlS2V1TkFOanNOM2VISkJYWTVQRmgrNnFpV0F1YWtvQi9YdTVvMk10SFF1aHF0UmJTMlBQSUpUZkFMM05MaUNKdzZONE9EZWxUSTh5ZlpVWlV1ZkxxSngzZ2tyYmwzYjJZWldDMGVRbHJ3T3JMTzJBY3hPVUVaWFBHdzhhVWVSOHB3T1I0Rm1ESG1HRHc1VHlwV0gxS09CZkFaZk9EckdNTmcwalNWOWpCc1RXNGIxSnhtZW44UkZFdXJXangxeHFoeEZRRXR2OUl4b0pmdEtmN3BaNStwMUdyZ1g0eVJYMytxSnBMV051WDc0bEl0d2x0dFJzdnNtRlRLYjlUUXJPeTZFci9kUGNqeG0zam1JS0NQaDd4Ym5MK2lmV1B4NnQ4WDRDbk9JTnoxMVA2bThLWUR4WTkyLy83REsxUUp4Q3RZT0lqMXRoU1hNOE9sbWNKYWlKbFRydDNxNTFYZ3J5RnNEYk9GYitSWEU4TUoxQkhYZXo3VU16ZnZuaGNsLy9wMzR5WkcyMXRDMlVlV29NV3hEbTZRak9JNzZReGRMZ1E1OExUVUMzKzNCeW0zZEFxTGp6d3l4OGg5T0dvSE5DbnlpRDU2bU13cmRMcVRYUG93ZnF1VlhVa09YWklXTldXT0MyaENocDNndlhZa2lEeTB0VjZGUUhRWis5Kzdkcy9Xd0thbTBYZkJXZzAvV3dnRnI2QXJtM0pkZXE1UkYxOXpMajhmZ0pYT2YzZTdtVVg5SzhTVDFQWW5QTlYvdTNNdjM1S3VNZFRhVWdJbTZ1Z2dnQVpyR0Zyano4enh3NEtjRENXZWJ0emdFanVCK3J1N0ltbERMTGxmeUJCWjg3S1YzajNSa1RGNzNHcmFsV2VqdWZXVXdlWnMyejZWNWxDcjRBKythK2dRMldzQ1RJaCtlZ01zaVg3TDg3TXF3WUVtVC95NkxTeHByVEFWbFVjeXVFOXpQWTJHbVRERGQreVZYMDFmZWtqYzZiOE1oWlViUnBWK09zbHM0TzYzdUt1VUgxMVFhSERUUzl0b1JKdjkrZUNWZTNPTmN6U1U4eWZrSU9oWCszdjNjcnhGbWpnek5POG9WQWEyd0FmY29Hd1lHTjIzMmFSb0QxOWZVTlhldGozeGNCRW1TYStxUk5OMlJGZm83L2hPZnVSZE1nSjZ5V0gzeUovUS9RYVBnSlgwbzhZVSthQ0FPbWhGd1Z3MVd6eGxoak1DVytWRUtDSlYrcVJaRGJJNEtBK1lTOWtmeHcxS3dzOXZvUXZhWEw0RmFnanFNSW15WS9qalNROWlXd0MyaDdPeEU0ckRFSXU3ellZUzExeTNMcE5tRnYrN3paa3ZqMHR0VldMUG9rVGZqdWhhNklXT0szZ1I5NGFpY09XaUYwblNZeDBrRXFPdExEUVh6cjVNVTZoRWhJWlJQbzBnalZudEhlVi9CVDVxcmg3SCtRaWZXUDB1TWxkdmNnU1hOTkJENS9ZVFR6UHF6ZEc5bFZ0VVNyM3VaUUxoLzUyNG5uVXdzN1Y5NU5teldnT1o4VmJROUg0WVB1L1JUVjc5VWVPUHZkazJkSi8zZ3BzRlNyc2RwbE4weGxqU0s4ZDRoTEJxY1NZK3VCTWtMVmprOHBuRVhYdEo2SGh5TWdneUoyeGtuSHM4S0w3QmRxeFRJRzVvc1RMdmNLQzJ5STRTTGlaY0gvcTNIVmhmV3FzOUsyOEhtUGN0MFRqMExnbEoxSkZZL283d3A3eVFkbWMwSG5VQUtYSDd4V282NURpMEdiN2pCQ1g2RHMrZmlIRFVoM1c2YTFURlFOQ3NOM2hlSHJXeDVGMTAyK3VlbC9MUVZ5elhKVmptSmwvYVk1YmQvbEVOUjFsZG5TK1BOTDhzbml4VmsxV2x2OE90bURzWk81VE9LTFVvU1RrYWZnMmNvMERaQVB1R3BuS01jZ0dPeVZGcS9jTHh5N2VoSkl3ZEtrVklOVXhZTms0Y2MxTGhJNDRxWmxVbkRrMnc4Q2QvVGJzalFVV1RhaEd2eHU1S0RvbEtuZXpFYUhqMTgrSVUrWHlBdXRtZk1YWUswQkRIOEhRM1lxM1FZYWdBYmNka21XeEF1MzFEUEpBeEZxMWYzK1JVQ2lERXJmYklrdUMrTThHVUVWdnlVNzlyNE1MQlh6NXZpZzFHeGdxdE1DWk52UGEzbnVUOS9iZHF6eU1BbHVHMXdnUnJGc2U1WEFyZ3Jud0JPdkh0Q0FnNWxhYW1WN2FiRjJUVnhQUlFtZ0FrVlMvaGhoc3dIOFZYdkgyUUhWY3JJdnBScy9jelpyQkhjOFpWTlExV2UzU3dwdE5ZRTJ0blV3VVh3NE1HOWJqQlExclVNeFowcG9CSHd3NWxndkJCZlZwcGQ2VHM0d3JjMEJIZjdxVjNybGVmNm5EZDZnTHNiQ2pzMGNMWHlBMHlHWktwUS9Dd3Rrd2MvelNLelpwV24weEIyeTFPL1JGU1pnbWVKbDg4RU5UNXB4WjBQRTZlTXMzb2swZkRGMmxqMEVkcFoxYnBLMnBSelpLbFdPNEtjYXBYVHNDam5ZTnUwMDZtcGp3Qi9aYzBIRTkwcjcybzJnU2piczEvckV4Njd5Z3VPZS9oTVBlU2JNTytXL09lODJSems0OXRiVmE0YnFjRXBYSERpVTExdFkzVktZWENVbTlHRTFRRFdtbFArYTRKWkczT2tibmtXMG9ZVUhTbk5Mc2ZEcktFK3pma0I4S2tWbVhacUNSYi82a2srdVcycjdFbE8rbXJkS1B2UVFGdXc2c0pFbXZqNDd4SzlhTWNRWWZNTE90ZW5WYkNSbjR6UUl2U2hYVTd3Q2hLV0JhWXF4ZXRKM0FVT1IzLzh5QWd3WmVlZGtjaWpUS1JKZHlsblRmaUM4NXR2dnJuMzN2dnYvaTlEdHkvaU5TTThDbk0xaWpJbFJHTTVpYThBUkZuVWtrMmF4cEdqRUxjbWY1aG9lWkI4Qk9ZZ2pMdVYzb3FTN1d6bkpvaEwrREI2TGZVQmQwSUZaWHVZZTFkcDVuazMvZVNicXpUekU1ZkhDTVNDMy93N1phMzNTMWcyK1NnWVE2WUpuYVRJUTJtaDBhaC9ydFBRampXTW1BYytPZXlUMUtVZkdxWklEVS9qRnk3R1FyLzM5SDZGWE9OSUs0cmZOWFJOR3I3Y1RXYUxPOXB4RTNEOE95dEFvN1VlOE9XWFg5Nzc3Vy9mcW5LZHh0b0RXNkpjWGpCRWpBVzRmekVkWFBLcTZ3eW5pMEQrbEgrcC85Q3Z6Nmh6amlhVDNuWHErbVE3RkgyZWwySlpTaFl1ZnZnTWxtSGYwQXVkNWg1T280VGN5K01EZ3VMUVRUcjUzVTg2ZFpoOEEwdWFpZk5oeGlHZS9DWDhSa3crUlV2d1dLeFdDUWhTV0dyV3pSS0o2bkY5NHBOM2ZuajhUT0dONGw0ZExCaUM4dUhCT25aZE5GZ2R6Y0pqeWNMZzZmUDBGTnR4T2xucCt3c2NWN1BtNmlidGxaeTFzT2l4bFBWUjY3ZGdkWjF4T3FTZ1YxeTVQYTdldW42R2ozSjdma1BvQng5dzdHaXJQUEdMcHI3S1FCZW5pRDJPV1c4U3EzV3Q3R2FVR2pxQjhTQSsvcFBJNFdIYUF0SmRURWQxY21JQ013K2g3MEdXZHZuY09scDZWbysxeEMyam00emF1QkNVVDRFK2ltdmhKQXFVZTgxcGROcEVEODZPN0QxT3ZHM2V2L2o1RzMvNm81KzkrV2V0ekJmMHo4WEwrL3MvTk56dEVvcFVNaXdxUVRvNkQ2RklwMG1DN3JuM2VDWW9PQmVoamJvd2pEa09nUi9GaXFLY09rVEF2REFCYzdGbmRuYWdvK2FoeDhRNFY4L3VEVzg4ZFdZK3NPWDBiMmJUV1Q0RVFHT3M5WmVyOTBHcGVMbytpUkQ0bnZxakNPOUpoaXNIckRzK3d6eExkaUYxNG1PVGN4ckZSZFpZWU0xRUNJdFpQUW1sMldoNU5ZWk9YS1hqTWVsbDRtTWRuQnpCaTErVmYweVZuR0RFY3VWYkFxL1dScXdDOVc5UG5vbXRad3UvRnoyUGcrZHhmQldzRXA4OElhU0hXUSs2R2t3bXlMSWN6dlpZcDBBNVUvUnFGSlNkU21aMEgyYjIrTkZSWnRPRDA3MnNGUGd3bnpEV09PYmtlM1UyeTJ4Q2pnOFJiZ1FlVTB0bmxNQ0RKSlJXZytTYnEvSklRK3ZxZ1NSdzdxczFqekduVXYrbDdBNUN0OUxSOHA2VTMwbVRRRm1yQjJKVkJWOTRXYzk2N2JxMW41ZXJuUEFURDlGYzJ0WTNkRE1pc0FXWXRWbGxGRndtM2NNTUsrOW03ZS9wUnRmS1MvSldIb04zMUhUNVV6OWxGQTNZZFZ1a1kzTWVLOUdpN1BpTEN6dHc4RjM1ZkpERnRmVE5wRldVR0lzTGZaeVo2cE03WFhFUUdYOThHcVVST002SHZacjZXTnRxbFVoeGo5SkV4eXRaNDNvNWN1ZmV4Z2RmNGlEb2dSajZSbGJDRDE5RjdxNmw0TG9mOXdUWHhFRTZxd3RaNm1kdDdVbDhsZHJPOHFHbURVUlpYOGtXYW5EaGJDTE9GM29wWVB3ZU9xU0l0ai9sZHExM2NOVzVuMFRac3RMdjVDd0txeTN3Z0NJK3ZuTi83L2lqR0FGM0grMWR5bTQ1bzlLVEIxbmpudWZqYkM1S3hxek5Ubmt4bXZhTytMVXpRc2dXN2VNSGtlbmpkQnJaOVBMWWZmSTh6VWRFVDIvSHlETHZrZ0hDYWQ0L0NpM3Y1ZmNnZU1SM3VQZFdaUFQvL01zZi9mbVBmL0hXZi8yeFpVaGY0TEM2NmVkVWtBQk93T1I1ZGo5aDRrWkplWGZ2d2YyOXkxRTg0azZ2NURNc1VZaTFUQ0lRM3ZQSGFFeFZrRldncXdHQlJjaFpRNEw4ZnBUYXJnVmpDK2dNOVpvdytjQ3R3dFJ3QWxOakp1eDJtMUJxUFpvdUFrVWc3WmVlTVBqUEZaeXp1bXpWRitmbjBCUStSWTBnYUtheHhEK1ZldzJOb3JQSXZqdXBIS0NTeGtqcEpHVWFVRHFkS0l6N1VaQ0ZsZUZjMW1ydlBjbHNLZGNDV2tnZEtxWGhwMjVwZUFLY3JBZjh4amUrMFIxYnJBdnFqOVhCYjBtWmNBM28vOEJGei9GbGRqLytCbU80UmJhci9YT1pzT3E5VW9BaFdJdHE4ZnM4dDhOSjQ1SzIzVlA0NFYwLzZ4R2dRNi95TXpqTWhJcDRlY1JUQVBpcXJrOHVzNGlpZEZNUFNxSmtUZ2VXYzZMN251L2Vld3BwOHNLQmNnVVBQMGN1cGg1emxiN0Q2WlRUclo2MlBFZWgxS2NmbnZnWGFRbmNsWU1GZVlJWkNjcHJSeHE4bElNYXBZSE9GTVBYLzZiMWZvSTZDY3FHMTlETnZaLzRaZUZIYWFVenBLVGxLUzN5M0U0N1pVcFgvT00ydW5qS0RiSHdBSU5yQUEyNWdTeTVrMDduMTg1SlhkMXZNdUIwTE0vV3RoNW5vOGVqTE54LytEQ2RVc3JRb1dvRE9nN1daUXJKMHJJc2RjdUk4L2poK3BMSGszdUxienBoT0Y3STZwZnNMdG83dVpnUlJWcGVJc3VEOGpZZEQ3a0tpaDNob2NOcDFuZWI2TzdjVFF5Qko5eGcrZmNvdnR4MzM3Mno5L1BmdlBYbzdYZmUvdE0zUHM3SDhMN2c0WE9WNitmVkcyTXI1QVF3REozN1NlOTBwK09EdFVPR1FyQVVTYVB2RUFlemtnZlR3RGtmMW5BRnAzWkNHMFhLeE1Fd1Vua1J1MTdUQlMrQlRqeDRoWm1lOVhFRVFWRFcyaldUNFVvKzZTeGNqc0lDZzFCcnhOTUl2TnU5OTB4d0dIbmdUbDMzbzFRcGxnNHZBeWVkZWNPRkN5ek5OQnJLaVJCSHlXdDJkbWhSc05ZbmRwRTZGV1hkMytXY2loV0ZZMCs5dFkzQU9HTHdjWHlGaHNaMlB4bEM4NzM2MnUzNzc3L2Z5YTI3TnVCRVlLOEU3dUcxeUhvVXJFQUJ3Qk90MVc4L2pZa3lOSUV6alp6RnFoNytsWmorNXYxU3E0dGUxc3lDQXg5S1RSM2tEOFFWRC9aR0R6Q0duMGxXdm5aM0c3ckpBelk2NlBDaXBLcTRRMzhySURLWlVZdFBmbnpFRDBHbnVQSWwzcnN0VERsMkVyWmV4WENWTC8ycVJ5enRkc1lzVkoyMTk4RkZaeGRGRUJTWWRlSHBrdHNxbkVUQkQ1L0I1YmZ0a3JIVUVWL0tzNWlHTXlHRnQwTHgzcTVWUW9HSkxuNEMyT1JMb0JUUktwb3NhNFB0K0ZyclhLUFIrMTdkUjhteVRLZVR0QnBDdlRwUzJ1QUJiMkt6cDJ0bGVGbUx0WFFLWGFLc283dGJkbUhHTW1XRnN6WjFKSEN1TWczdEg2YXpwMUFmM28veXZmZXdKNnl4d0MvblN4c3JyUHF3c09FN3Z1SEhtMFhOMEVBMHlybzd2L0tNNXcveVpReEdnZlp1dDZjak1JK2o2RC9JeE93N0g3ejNreCsvOFl2LzlrZS8vdWdMN1E3WUNPak02eVVzRTFFaGVQWndkamZDUkZyZGowQ2ZKY2lOZUxQWGRuWGtveU5wbEJpZFlXeCtoM0ZrSXpoQjdwbVVHYWRKdi80UnlEUUU5dGltVzZlOGxoUGhqdHhFeUFJN0NacFBXZEltWGhxZlpCWWNUczN2UXlFd054NmY2TlhYczdpTG1WU1NudkJWYWV6VUg5dzJ4SUJxdWRxMisxeVhRa3BEVEF1VmppcGdGY0duWDZaOW1vT0k4MnhMb1FXQ3RlQ1NKdVpGMnREamZpM2c1TEhUcnBiU2NVU2dSZmhQcnE0SkdnMlprckdEUlFQbDIxT09OYVdVTElHOWUvZVRLbDcrc1NDU1ZzYmVEUjJDby9vNEYrQXd2MUVhN1J6VUwzQ2ZkSkpFeHhZbGt5Z1RFcTFiNjYrU0lwY1ZZdVlZTnlTd0t1SkpZTUtsQjRVRU44cWsxbTJ5dUxkVWJTYnBERDFId1N4NG0yc2t5a0VqWmNWMUxXbnFweE9CUytrZUhCMmgrQ0E4cXB4WWNoVUFyUFNqcEpOV1BMWXVtUW1OVGJBa2NJOXc0Y0QzdUV1TktKWDRoYU9jYk9nWWF4ckF1Z3FhaTU2TkxJVnUrOW4rRGFhNlZHN1VNZlVWbHF3c25sV3ZobzZyL2l2dCtJalZXVDNVVWFCWUdSY0dJdUlvU3JTeHRFbmF3bWdOZzM5b1AzQzRCZFJESGorMWd0TnhKc2JDaWIyYnQxNXNYakM0M3lyRHNOL3c5V2thNVlMbm5YYkRjcmZsbFl3WXp0L1BjUC9Pblh0NzkrSVNzQkpGWjNlU3BWTHFlbkRwYXE2cmZTZG5jRjJiR2t5V3dmbmFwZlh4VXVYeGExKytuUG1CK1A4dElWeTBzeVU3WldURWZ6dEsvUDI3dC9mZWZYanZMejU0ZU9kLyt1ajJ2VC83cTk5OC9LL0EvVEtFZjJ2THRRMGhUQ2h4TjRZaTFEQVhBOXdicGtjazI5QWY1VjV6eGR3Mm5Hd1RwVXdJaUdGU1p4OERneEt6cDMzS3dPeGFzK21CK2ZuYTVLTlVDSjAxbHZKWFVTU3ZjajFmdnBodldDVlNYZ0ptU0RTQ0JrOUM3NTB5NERKbHdjMnZPT1Y5L2tkNGNsMDZwbldKREVmU05XNk5nOHhHd1VVcGROaXExY2NpWlNrY3BxZSsvR1NiOEJLdmpwRnlYY2c5RzYraWNLMy9rMWE5Q0NiOExiZTVubUVkWmFvaHdWVVJobGxXRG56eXljZFpoYkROOW1vb2VjOGk1RU5ESjRxTDFhTnhEZjJWblNiV0JkenFaQ0lPelZLei9Na3ZBVDNjdStLWkR1NGlDMTIrWUgwWTJGWkJIT0FmaEhieXVFZXpWS1Q1d2ZCY3haQjdlUG5oZ2JpREtES1dIRnFqbmNCNmw0OGlsUTR0bEFOSHozek9odFNMTjgzUzlKN3hyd29tK1FWdUFaM3drOHlhUHc1dEtvL3BVQ3hxNy9HRW15TENTbmt4dUFxb3VTTlA0U3RmNjlrRVdIQ2d2Q3NMNnBaMFlQcnR5a3h4M3Zpb0xueWVyVXZxNjVuVUNNcEVENEd5bFMrUmhTVzlrUitmUE5scy9WckhWYmVwNTF5QkxFMVk1a25uZHh6cmVHUjYwVDNXSXg5cVpLTDRwbFBmejRxRUYyKzl2SGZ6eGt0N3g2OHUzbERBZHREZDJYRHJDb1RncFVPRkM5NzUwc1RMMTEvc1BibGlEVHRPOCtiTkZ5dDNqSXlUckV5dzNPc29FOTNYNC8rLzg2dlR2WGZmK3ZVLyt6OSsvdlkvYnFXL1JILytyWlhyRXBSbkZNTEkzUjhHQ09MR0txRmZXTENzaHNzWkRtc0FFWXM4RTdSTUZHVUdrMkFRdE81bGJpTmN3NUZkMk82dnZYQzlTa1FEeGRqbWk1VEo2M2YxY3NiS29LY1ZFQzR6a3g5KzlQN2VoeDkrMkVtaG8vaWhDSmw2Z0Vkd2R1dkU3N3VhUVhRaVV5VkM1Tjlabk1va0xMeHlrNGJ3bUdXOStjZ005Unhja3c4K2RZSUtnZE8ra3Q0SFJMSkRKYnRpMHU2TDJ6U3lnOU0wcEZocWg2RlBKTGZLSisyN2VLRVpIQ25YOTk1N1orL3UrL2NLTytvb2g4UEVENWVKb2tleEZJNHpVUUdlNHc3UlJLaWxGVlFNMXhnd3dub0RIemk2VnE5dVpXMmRadEsxT1djU2c0LzVKQTN5NUNDV0dLUVNORzZIOWRpVGpqN0ozREtVRDI2NjF6TmYrOG4rOHE5MjkxWXM5Y3h4OUIxMzBlbGgvSGg1MXBrVURsZ0orQWlPRG1JYTlrbFB3by9DRHgwN3VaUzA2Um83a3RpbXBadkg1Q1dsM1pVRHJjVXpuSFZtRGhMQmIyWFk0S0hFR2I2am00NnVSRW04ZERwTy9uV2huZEpDc2ZuSkVWcE1BRk9lMG1kN1o0QWdIWXA2dC91K1M4ZFNudTIzcFZ2eVUrNkkwckpORkdiVnh1TFZ0aFRRUkZYS0xLNlpmM0JkTVBGdTBRN05wTkcyam8vOFlqRUhqcU1KcjE1Zi91OFg4a1ZoYlVpbjAvcW5MVktnOS9FVkQ0T0x0bHlsbXJtQTRoRFVyc2FDVmFZUktvVjlNZnpnSnpjYXhlT0R0R1hic3NuSGZXM3A1Z3Q3UC8vb28vOWk3eXZsdWdScWhNVjFpRHB4bTJ6TjQ2ZXVaWEtFeU5BZkEvcmJNb0JUZ2NsN1EybkxtUGdvdy9YOER6TWpLSWErRjZPSk1JdTE1a2NBL0dhVHdxMThEWldGNWdnL1FxUnhDck44N0RDSHpDeUxqOUE5N21UUUJ4KzhseVZOdjQxRC9kMjlEOTkvdDhNZzIzaVgwRlBFMnpBdEFtVWRJSkJ3blZBYVVFU0pxcU0rZ3N1YVNldXZRRnZsY0NFN3VmckpqYVJMeVZFaUdlNzNQTXc4UjNFYVJyUFE5ZWo5ZkRFTE9nM1BWM1N2Qk43RktDYW5YRGx5anZWcDFuc3BtYWRkbHZWUzZ1MzM5b2Z2dEg3cUNDOTA2VGVXTWovQXltNWR6cnFDVlFNTnJkdGM4OWhQdHFRZVhXU2UvUG1mZTdSYWRUYlpRWWZ1aHlmaFdHR3ladEdLOVhqUmNYcUJaeUtQLzNGNFRYMklSemM0YUpUNGhFZUNlSmFaRlJPVXI4RHFGdCt6Vy9OY2haZTZUL0JjTjBMS25wRlBNQ2d1eW9LVC9HamhYcm5IbWZHbW9BenJRL0hpUkRHckw1K2lUMzhMck9WTDEwUG5wRHVPRW1PWkhtNWZNZkRlVUowZnU1c09jdTNrVytDdm5ZZUx6bE5YZFZRK25IUXdNNnlHdi9RTHo2V0VGMC9SZlhOQkZlWlNrRU96N25pQ1JJTHhXbzV4UThEQVgrdksxVmRhMzF4VFo4L0tCanVZOTM2NVNiU3hTMmxITjFLMzFZWmV2SEd6Y1lkT1BZcy8xUnJYQi9seThBT2podFRoaGVzK2s3TU1GZlVhZDRBNDlRVkhPMUFuY3VxZVgxYkhZL1hEcFpNTE9URCtlaVlLMC9tbExYLy8rNys3OTRQZi9QSWYvT0RkWDl4NjQ0MHYvaVJXbWJiOStiZTJYSGN6dTBmd3VSSVlSSS84UjZ6WGtJM3dWamtsa2FzaG5qUVlwK0VRQ0V5eTNkUEV6ZlViMTg1OGpDeWFVYTRVYmROamVOTGJ2VVN3WmhzcDJKNHp5RlpRQmNpekxieTNYbnB4NzNzLytINkhuZSsrOVp1OXQ5NTZhKytOTjk3b0pKR2hLSHpPOHFjKzZxUld2VkpZZVdnZGN1L29OZWxaQlFRNjFVd2pqc0xKTzgzSDhxd0xtWlN5ZnBBeTZscllRRFBVcXcwVlJXeFZDNHZJc05EcWlZWkVPbzd3NXZWOHpUVTRVYTdxQzZwNkRIMTBRUGZ1UGlnZEwyZllkV09IbGxYeW0vS0FjNC81eTdYMVNKM1VZZFUxdkZtbHJucDV5anVoQ3JTS05ROWI1Nkg4T1dlMGRjNnJHckhKVWhvSDF3QXVMQTFkZVkxUHc5YTQ4WmpTOGM1eXJra2puZmhIbThVS3Q0NGNObHdHUmh0NWFLbHNXNHdwYWZmUys0SG5LajJha2crZjFSSEFQeUlIS1RmcXFXZGo5TVcxSEpIWGptbFQ4S3FQTjNEUHJ3Ri84NU9UY2gwWldTKzN1cWQrK0lSbmNGSWVvZWgyMDd6cklDMHh3NE11b1FwK2NEd003MXVINUpNWGZOZFVwSFhwWm8vd1FMMTZHbG53MG43VVgvNGVDNW4yTUhTRWw0a3VNS1Z4M09DVitQQVBZckZleTNuQjZ0dDVndEQ3Y1JUcTBhVTFML0l3RnVpakxLT2lhQi96N1c3MXB6UzFQd29XRHNMVEt6cDFTandoY054ZnlBcWNGTm5PNnpTYkJ5N21FOXBIc1dCUG5CS1hWVEd2dnZyMUhKLzU0cC9zN1gzOHBaaklXc1FKTDRqT3AwS0VySXBraXlSbXU4K1U1ZDhVMm13eEwvL2tNL3NjbGxSb01GM1A5eUJEMklmeFQzNDd1N2wrOElNZjlHdW5CRlQ2cXhHR3NWUkhBUk1LRFpSQzRsTTFPL2trdlRuaFlTV3NjejgxZ2JSeDFrYUVLUmtpa0ZHeWxvSVEzQWo5dFlNY2RmYTd0L1plKzhiMzkvN2pQL2lqV3JQLzE0Lys1ZDZ2ZnZXck5nb2JJMTRJVGdJaG40a0I1U3JmNzJSYm11ZmVHdEFKTEVLKzFBeUNvL0ExNDlWSW93dTZZb0Q3UUgweSs5TjFqRWF2MTZMNHJaMDl6SEQ1T2tHTzlYc3hRN2pEbkx4MS9TQkhEMlp5bzFzSmN6TFpKOHFLbFh2cCtrdDdSL2ZpbDB6OW85LzNQdjdvZGkzYTczenpHM1Y5M0VuYXg0ZjVwU3lMdTA5alFWaWRVS3ZXSHZoa2VweXhxak1nK0l6ck44N1F6b1NYT2g4R1llcEI5OUsxelJwdkd0ZUZOSktZT3FsRDFtZkdyMGQ1WDJvL3VrNEJ1eFQrT1Fqa3lvWFY2YUdNMVE4aFV5ZExIcWV4NCt0bE81Q1NGMjgwMkZwamNhbTRVcExYcm1YMEVqcjZqdGpUUjVaa0dkS2E0SWwxR0p3T2o5T1lRN2M3OGFYZnl5dzNDK3p3TUR5cmdqVVpGZ25rWTZVU0E0ZFZieEl2d2hWOHd0ZVl0U2JVSHVSM05iUy80aGsrY0EyOTRpNnZhNEFzVWxENEEwODRzd2J2aDFaWFFvc0hzU0Jzb0FtRDluU0JuUU1nREpwVGxQUVlGVHFYbmdFYmhlVjgzN0M0NzU4bXpXRm01bjNtNWpUbE9KdlZxTVladjZ4ZFA3U3pibHl3TkF0L0xJZ0tjZnF6OCtza0k0a0lYUEJMNXhQOGcwNmZIZEJDcVRJdXVBUEFPdDNQV3RiREZ6cUp4NHEzSzdCZlJnaU5MOXBjb0lNSTNZMHNLLzlSbkVlUnBTNS9aSjJHRHZjZTNnc3YxdXFmOWJYZkFFNmVVYmhYK0xvano0L3NUSXY4N3FjOVhiOStOWnRlRHY2allQYmxVcTRZdHh0MkZhbjQ4OCs3YWYrbSsrbXBNV2xndU9yWjlicmkrVUcvK2MxdjduM3JXOS9xYmlTemxoR3JDTUxtWjBvQjBvMVZncmtVSGpnVitPM3FYbERteEUvNWZaRS9FMzgxRGR6dXA4dFpOV0FONmEwWGIzUXJIbXVXNitCZWZMVHQ5ZHVvWXBWa3FBam5XaGg2OU0yU2dJTXl4TU54QWdVcXZtUCtXTEhjQjZkcHZmbnNYdUdZTkdqNk5IaFdrczZBdGVWVExZOGl6QTlpUVZ5cVpXTXg5cHJvTXRrdzFwN0dDajQ2T0VCRWVmQWRtdHlJaGUrWlVyNGY2K1JrczBTQzBTcDM0NGYwRTNacEJiZSt5MnZLekhQcms4VGkvZHJSNURuTktzK3JFN1hCUXlkNEhJVlloUks4S0ZQM2RwN0JIMTZIYlpqTHFzUVRhY3g2SDJmbzdoazkyelU5UTYvbEJhdVVsVHBrMW50dHQ0eWJJWFI3U2g3eTFUekpsV1VpYTlWbitZdkRnbmJLTEU5Y1FpLzhoQTlya3p0QW1ZSzZIbVdpa1RKZVNvMGxxUU5QemxqbkRwOVdmK25wTU80ZEFUeXVEblFCWTJnNHRJTlBZUWZYSjFHTVovUU1UdU1TVWZlUis2RXoyR2RwTjdvZlJrYWlTdXRTWWNqNDZZejRRdVREZDFmZmE5dmZsS0FPWm1CUitsMlB2ZUdLMm1GUDFxZW1ydGt0NWxoQTlhdXZtWWtVTjB0Nm8vREdUR3h3ektjYUxtVWpSSGtjUDJ0aVVyNnlHUnY3ZTdmTmFlUjZ4NGxiVDhMYndEQkpkL0xvNUF0OWprQUpmTzVQTnFsYyt1RnVITVlJdXd6ZWZaNzR6NytHM1lIaDk3eGczZU1vVjU4ekllU0cvRndDVG9OS3lXVXVZWlJ1ckZiUG1BNXVHL2VPQXQ0dHo2NmJDU09ZbmtkNCswWEt3R0NCT1RMeDVzMWJlNisrOWtyTDVvYlFzQ2c5UGloTngvS21aTzY5WjNkZ1RmMm1BU2xEaUk3VUl0WjkwaTR5Uk9ubmhqVzRHbXVlZzM4dEtsWkNKbHJtaytaNi9lVURYUTIzdTdsaTFiUkJCUGI5S0NoME16eUVBMXdvRFBjYXVkVUFDbVZ4SFFWV093cjRKQTVxUGJFbzkyaTRXNCtoVlJ0cllLWVBrU1gxelM4ODYyNnNXbHZCSmZFMlRiRGMweVFES3cwdU9QclpmWVJ2Y0hMK0svNVozenI4QTZzZnVndGNPRi9PVGpSMGNZcStnQ2J3WkswT1R0d2I2Tm9Pd21LMjFNZGVlRlpmRlVGb3lNZHE0NEQxd1dpckRIRFdMekxGclVCcG9EZVRQNEdDUUd2RDRhNmpWcDlZZ0xQN1R4dzZLcGdGNkx4VWRWVVhQQzVIYzNXRUljc1dQU25pVVpMU0RZL2dTZFpQZ3AvM3c3UFdNVEM2Z3c3ZUtVZWVnUUhQZ1FIZjd1OVBuUGVlVjVtTFZ1NnRVaGo0bDBKMzk3TjgwUHVZN3VGUjVDYjFjQjVHenhVSVRzZXhqR01iZHdWS2R3eW1UblpESG9mR0oya0xKMWtUZTl4cnRyWm1BdlUwUnNBVFg4RXd1c2c3TzdXZTV2bmpCMW5hbFpITnZYVHFkd1BqL2J0Mzl2NzY1ei9iKyt0Zi8rdC8rUEhIWCt3ZFdYaTFHeklhT2ZnaDVwMy9TYlFiTjgrN21aOTN2M3NveVBQZUc5NFJzaEU4MnpwWmpKUUFpL0o2Zkk2VWhQZnRIU20zQk04RWthVXpnaWx1NEF5dWhFYVE5aXd1UWtXdzFpOUQrelF1UFR3bGFnLzRyUmRmMm52NWxaZjN2djc2NjN1dnYvYjFLbHBsQzdzd0txaFJEanFJYWJicU84OEIxeUdtMWtnUnJEOExCbndzbWFMY0tRcitVZkRrNlM2aXR0ZjRhVTJ1YU1BWnBqbzd0alBKR2FzYXZ0dnUrRFJLZ3lVd0UzTHFCQTQ4VzJkTDFITFBKL3d3c3Z3b2dnNlB2ZzlLbE92a2tjKzlNUFhza0Z5RGpOK2lieUJJUXlVc3BScXJMamVVYTd1eEtDTUt4VERXb2N5R3pBT1R0VWk1K2pqanFpdEZ0SjA4MVR4Mkw2M1B2anlNL3hnT0R2NXBjZWlTc3ZHWGRjVzZaVTNackdFbW1wS2srTHJXTXpBUmtyK1c0dTBFWDhyR2w3VUdOc3ZhS0lyUW9zUGhGR0FyTHA4bFpROU9MYldVYjVQSTBDSW9GSmNxNnlqdW9SZWNsTmRKcmx3dDhtZUJxbmRBVkQ2SEo2N2sxYnRWbjdWODZjRDI1cnlEYi9tV2tpaDZkUzhQY28rUHloRm44ay82ZGRJWHpNaTMxNHdPN1dYeElWQmFKeSs1ZGJpbjFFTDVjSGxNR2Vwb0lsdmt5eFp4bng4M3FYZWNaelNpb0k5c3E0NzhIR2VDbHl2c0pGYjNhWDZPSkhUd3RXM0tUMng5elQyRHdKR0NqNk4wUDhxdVNKK0xlaEJadngxbC9PYmJiKy85cTUvKzlMLzd5eC8vOG44TklsK3FFSGZLd1E5SG1QNjI2NzhaWmNKVVhFOXdKVGh6ditMWFFSR1l6V0oxcFNoR1lid1lSVWVCemdIUmxDNFlsQjNobU41NkZ6WVlmbzFyYWF0c3o3dnZQRjlONHgxaGJ1OGQ5QWdtaThtM2ZUaitYOHdIMUZpMGgveU1teUk5VGVPaGxKMEtwU0cyZ3lENFd4bWRYZGI0bzJEcWY0cG15cXVJOXVvQVdLeVBJN3lzb1RUTnpUcXE3Wk80cE5VSWtvSHY3bUoraXRXc2JDS2dKUGpCV09XSFdYcUZYcXhYdEZHL29RMzZSRE8za2NLeGkrOVpHYm12eFJZbDBrT01rMGRhdjZHYmV2aWhqVWJOUXFOTUtWanhuZEFKUmxabHVMY08xY1JQRzJrYW8rNEV6bGU2MU01d092VlVYcTdTVDNtR25SUXhoYWJzdzFocTF1dFNyb0x2VHdXSjVLVzBLQXlyUzNJZitPcjBORU5TZFVHckFDNTg1eGV3Um4wUHE2ZnF3eTE0b21BU0pzMVNuanJ0Y0xzVzZKVW9mSloxZVpuNFZlZlFvenlURlQxQ1d6NTdzSEtQSHo3WTJCRlVrbEIyYU9Pa0w4cTFkTXA3bHJ2NlZzN3lmdGNZNkZrTGtXWHVvVldZVG1ISlVVcHNCN0hndE90S0tTc01yMHhzU1RmL0ZxMUNGN1NKak9rSUt2T1lrVitxazZwc3lqVjBZWFYyRFc1d3BseTczREQwMUtrL1puQkVnZnBtR3l2VmQ5d2V4bFgzME5kSU1sTHlzN0xBRVlKb2Jja1ZCWHd2OFhmam9ycWJyZSszNHliNk9KT3FIOTIvdC9mYmp6N2MrOWxidi9uem43eng2MzkwV3dQL2tvVWVPYmhiWjR6ZERlZWZDY3kvU1hoZVBuRUVrL0FSQUFxSzBMQllEWE4vOUtNZjdkM056cEUvK3FNLzJ2dURQL2lES3Q5ZEg2dUdLbys4STJ4Z2VoYUtXM1hVcW9OMzh4dWNqOU1JOWVhc1E4S24xMytVWHZkU0prTGdkZVBHclNqV0Z6dkQrYnUvK3g5V2lmRU5tL1I2TzczdzI3OTZzeDJCOWJoamdhL3k0UkI0R21WNmJoclVqUEhzYWxwNzNEWEVOT1EwQWtQYUpPMkJLQTVGc2NUSTNJUmVmei9XZy9wZGlsSndJSTRUaWl4OVltMnB6MWp2bEN3RkN3K0tReU5HQTVhUHBXcm9ha0czejNVOGZoUllMTHkwV1hURUIyVU1IZVVUMzJGd2FzSVhhY3hnTVQyTHFuWGNGSXNUczZwZ2tsNmpMaDNnSGIvZHJzSjNObTA3Z1RUQWNlL0FYeG9XNSs3b0FCNEN1UEFZT1hPdHhJVTJjSEFxV1ZSQ0ZldVZpL3kxcS9OeVpnUUYrelErMlgwMHkybGgvWng2OEhkWVN4NnFaR2liV29pSmcwTmRBbmtYVGRrVkhkRzJaeU9ueStKRDA2alhNNXhPTXBNSHh5Q1R1R2NLRUo3aWZmblZGYTU0b3I1VFQvR1VNQjgwR2h6QUNYMVRiNy9XTmJnL2NlUmZUajdwWktOM2dVRk4rbDJJenpOWm1pUFJDVlIrNEtDWng4eVlyY2t3SFFVM1FxdmVOYWlXK29XeHFlSTYzeUdBdTB3d3FmYXVKSE9WUEJtQlB4NmxUZHJCZFpSTkNIQ0czOFhMK1JKQ09oeDFNam1ZTGlVeUwrL3FtQisrbjQwSUpodVBqdi9zL3FNSC8rcWRPL2YrMlp2dnZmZWw4N2RpeFdlVXEwZ0JRM2ZEK2VmZGQ4KzduL1FWbURERnMzdldnSWJrbm9DNXA5UTBLQk1NZi9tWGYxbEZhN0xtNy95ZHY5T0pMbWtJS3VHVUZxeUJ2MXQyNFJPMXJiemRkNU1lREphbExiSGkrRjdIc3ZCOEVpR2ErTmRmLzhiZTcvek9kenA1OU4zdmZxL3JaTjk4NDV2OS9BcFh4bnZ2dlZmbG9RTmdtVnJQMm1FcUJSdXhZOW1CMVIwL0tUTVNXT1dxcnRIblVhaHgrcHNraWFDdUlXQXN4T1M1bThNMnV2MHk2UzlkV3VmQmhrSjdoMUdpMldYYmhxdnhVbW9DdXFrRE9uVjlyQm5pME9sVzFqU3lDbnZLVXVoM01jcWtWcUJHbGdER05IelA2TVlhRk9ESUhxWDQxVUdMN25WTFY4V2hmaHAycnZQYjVTblluczkza0o0MWV2RDhwTk5oNE0ydVlvVkg0ZmFhUDBucnZXUDhxZ3o1ZVpPM1MvUWlWNmY1Qk11RldQcFZiTkVSS0d6elJyczlHaWtyTEo3a29CYWpBTFRyU2YyQnA2T0ZEOTVsMGNUaUpTVVRQNlFkZE9EWm5JSEdpOWRSWktHMUZXamVDWFAxSHUwRlpZaFhMMWQxeFNOQlI2RDhRRmtkZmVMVTFYdFg5QlVtcmcvNVF3R0N0WDVCUUtCVjh5dXRJdGRvdEIvOGZlV1lOY3Y5SmM0UDBneUt1aklTZnlFZE43eWNSWEVscjA4c25jZ3Ywd0RaenAzT0lPM2hLUEs0RHRsT0dWd0JJWlpWS0k4Q3I3L0hULzQwcDhDOTQrTWNKL2Vmdm52djRaMi91UHZrNGsrK0RJZXpsUDZmODJjNUZuZGVJdlQ1OEx5NDgybm1HWU9sMzgwamJnS2hvQXhjV1RPdWJXeEpZMExwMFlXanZiLys2Ny91SjA2TUpQN3dELyt3aDVlQXB4SDVqVUlnTEJXbzVCVUhsblFUTjJVT1B1dGRCQ25wcERHa1hVcHBLU3A0R1FaNnR4L0JZaFdkYkEzajYxbFo0UGY3LzhudlZhbis5S2MvM2Z2eGozL2M5YkkreDBLSkNOWVpzazRpMDdGZ2M2M3l5ZDgwMHU1clR5TW43Skh1dkdHdlJzR25RYkduK2NqMjB6QlA0OWZxeHdjMUVHL0NrcXVQczE1UngySU5WSUk2YUxSd25RYU5CaXh3Q3RMRUNQcHl2VnlOQmFKeFNIdVhkYWY4aEZGbTA2REZnOEZxaFd0OW1Fa25mdktjMFM1eEdqcGRQUFFkblBBRkhPY2N3SUVpRVZjK2h3NW9OZHVmNVdsYTlXNEh1blZJb2RQd1Z6bHA5eW1JaGI4c3hHQVVHaXc1TStuSUozbWE5L3RaQlFJZkRHZ2RVaTc2TGQ0bmJ4U28rNlA4WmplYmprMzk0R1hHVzduSnNmQUpUbkM4Y0lVRkhCelRLMHByYzBIR0hrdCtRZ05wL0J4SXM2dFVsVFYxUk8vcDFBdHplNWNFaFFudUtOL2hqVGo0REh5akVHblF6THNKUXl1NjIzMlZNNU15NFZQS2RiUENLenUxOU5tZXdUOUpjOUJJRlNzcjlITG80TlMyZzlCWTJZTDI4dEdkMjJrWGUva2l3c25lbmVPVGYzanY4ZWxmM1B2NCtLZS9TQjh2elE5ZTJydjF4c2Q3WC9nVHI5VDFid3NYTHg5ZS9TRnJjbjZFeW0rZVo4TEc4L0pqUFh2M3ZEUVlYK0hlS1hrRWV3bks2bmtKaHlCdUJBZkRUWWg0eDAxZ2VkUkhIMzFVQmZIYWE2KzFvVXJqSjQyeTNBdGdFQ3ArVWpMQ2t0eXRoemg3emtkNG15bjFyQytVTW96QUdNTHpkNW9Rc1dnZWlQSEo4YmY2M1lqUDgycDhzNjk5UFpOZnNXejVhZFBVK3M0MlZCTkpyQUswc2dOR21iYkhKaUxXVVNRL3YvMzZWRE9zQ2hMV29oNGxmZXlISE9zV1JmTTRsbno4dm1tMUdjWm5HVXVHMUw3Q3l6ZjVZdHdWKzFrdW8rNHMrM2ZmZjIvdjlpZjNNbFNMNVJlOFdHVFdYRjRPSE5aeXp5K05wVUpwUE1oUXpheTI5dGFWQ1ZFeS9KTVVsSU5OVEdDWmtOcE1Tb3lwQWtuN3p6dFdXOG9OdmFPNlVsK1lCMUR5KytTSGxRUlh6VXdudG9mSG9KOFVxYnZ0bnpvUU1ZNmZOQUhEWCtjNFNCTmorZm93bzFqaVd0MEIyVFJ0MEdua3JPNm5vV1VxblFtWHZhemlpSElyYjFOOGtQT1A4azJxV3JQWFlnRlhGbElPMmx2cmFqMW0xQk9EclB5K2tDVkVrdGNxM2VvWGl0VkhiS0t1blVCUXNsYlUydWQwaDdsZjlDU3ZmTmw4OVBoZ2F6QzZYTXY2YlBLbXpsMVhHbG5xYnJmQTlXeUVGRXFIL2t0R3BmVWpJOHJXK1ZvUGU1aXpZTW5vYmp0eXI2enlQV1dyOThSTnV0SWk4ZUhvV1ZxVmROd21mdXZvZTk0dTkwbXMwU2ZnUkZZdlpua1ZublpIWHVoS0tWYzVwMEdRellleFZCOWtOY0JSVEZsMGU1VG5Pem40NWVQN1IvL2xoL3VQL3V3bkh6LysxZTJvNUZTbTRlTzRaT2YreTM2TmNyMzh3K2NSQWJNbW5MOGZSaExpdVovcjVKbnJidThxYmlsa0N2clpUL3lrbzV3TXExaW9tT3hzQUFxV0VEbVozeFpRQ3BYQ0dDVXJ2VitGTDRvSWJQZnlUQkMzK3p6eGN4MThwazdpeGMxMTNuUDBVOVJtdFYvS3hOZlhvMlJmZmZXMUtsTmJLMnZ0UlVnN2UwdGpFL2ZRcVo4VXA1U2lTVFRBZGlwUmZHdVpUT2k0bGZkQ0ZwWmIwcVJvaXFpRnVUWkZyUHZzMVJhY3dka2xXVGtucy9CVFYwcm1zSjFnVGFrb3pWanpVYlMrUVgvblhpWW1vcENmcHRGUHZWS05sVGZLRVF6aFRIRUZiOHJQQkU2VmF0SjR2cXdEU2h4cnU2NExTckZOR3IzeVM3emFvUFhLbC9SZ3B6QjFOaW5uNmg4ZUJkM3l1VU5WOUpwMHlzbXZRT1ZQbVd5czQ2eERYZm1EN01ZZjlyMjZDSFh4NUVwMjBLTldLZUp1aW9QbGI4a1d1dXNjZEtoWE1uUGZDYWJBNHhhQUMveXR5ZFg1U0s5ekExdkhBTGE2Z1czU0RqM3d0Wi9kamlKYm82RWxlNFVUMlVSeitVeHFDdXJRNStRZkYwQmx6OGdIZmJaZkUrZlA4TWZoN3lQSDVML3VqVnpCRis4ODE1SFY0Yk55d0JOTWJsbXhNU3NyUW9TRlMrTFdKR1BhWmVpTmRqbzJrMVgzOC9VQU1NaVRMMkhjemZQYnQrLy9OMjg4K3NwQ0xWRS81OC9GV0lvLzNHWEczTyttSHlhSmMxOGh5SFhTN2o1UHZsM2htUHpyK2l6ZnBIVWQ1clA0TkxvUkpxNEJ2azFMdGloVW13NU0xSEFoRUVwV3hnaVoremtFWS9MdndoNDhwdHg1ZGozNzFmN0tjMVZFR2szdTV0NzFhWVpEY0ZVbWdUUHNmVDFMdUY1OTlkWDF6YXNvWDhlKzNjbEV3R085ZmVuRmRnT0pHakkwalhEbjJWQzJJNFBFRVdZRzJjV1lWNnliZmdxNlZ0YzJFa2djcTlPUmlmTHJoQWk5MlZwTHZDeHhZeDM1U2kzeEVONXNBQUJBQUVsRVFWVDhLQ0pENzRNb0JjTkNqY1JvSUpyN2pMYmdDSE1xVjNtV0tEaFRuUDJsb1ZGRWxDeGxrdHhWSm1mS1ZVbUJiOUpvS1JrZFNkS2U1VnNXYi9WYnlzT2Y4aVlSNktlUkw5NmpUUEJPSlpYUG92Tkw0Z3pyVTZjb3IrNkF5M3Y1S0lJWXRnMnU4cGJXS1Z1OTZvWUpYWEJQaDQ2K25VMlBjdVd1U0dUS1dxc0VqSlowSE9DYUdBcW8xZ1d1NGltYkt1VFF3STR4K0hzdXh1cE9xU1d1eTk0U1d4bUVkK28yazJmdTF4S281WmFCcTNxVFdYSmN4Wmc4M1RWWFBiandYaFl5bmkxWjZXNnBsTmVPYVlNQkRuaCtsMk5CbDY2cEI1ejhQSk5YNlpac3JXY0VUSTN6UGhacjNpKzVUT0g0SFJwMTgwSEtPb3hDdlprMTZBNFB1dm5hcXo1T3NQZmJ1NS84MHcrUEgzKzRPUERWMytkUklNcVZXMkF4eG5YQzgrSzh3Nnpkc0p0SC9EeXZCdk1zcFh6cjNTcnIyWnRuZC9MWTZVTVlxaWpEV0h2cFBiTmczM25ublNZV04yNkNFWjdtalVCY3NaUW5ZWlNmZTJtOEIyZndFeTk0L3RRdnltTTNmT3BkMGo3TlVoTytUNHJMMmtrL3kzcGVpZEI5ODF2ZnFtWE5WVUQ1V1JQb2NHSkN6SG9MQ21tY3NYUllaYkZRVWpEakNSWk5VeUhQTUpQN3dlU0t3MTRPbzB4bndiZWsxaUpxQkg1V0hOekxraGVuOVBPeFh1TmZUY05RMS9yWmtsNGpzUjNVdWw0MFBZNXlHbm9vUS8xWXltTU53YlYxRG96VWxrR1dIMld5bEt1SkV0WWM1V3FZeWZVUU5Qdk1kVENXcTFxcE1JVk0rU1RsaXNyZmxwOTgrTkZoZDlLQWlSNDloRHhwS0hSMG9oUzdRaURLU2FNM21ZSzNsalIxU1paaThsc3JNekwwajVYdXZYZEtySExMVlpDdW5VQmtERzdTVXFhVUlSNmNvQ01jcE5SQnlKUGIxZEhKdjZ6REt0M1VhU25pcDEzU3hmSkY5MFRXY2kwUE5vVTJzdWVhVVhqaDEzOGVtdUtMT3M3emZNOE5qZkNFRlV5UmpzRnhJYmhUdUpRdG5QMTBIdE81T2s3dzJMclR5TkM0N1V6UytpMFgyS0pQV0wvd0xRdzRxWGZnaFE5MkNGN05ZUy9YTXlINjRrc3Y3NzBTdzRFQjhmclh2N24zOGplL2xkSFRpM3YzajA3KzRQOSsrNTEvR2dTK0NwOURnWXRaOS9uRDh3cGs5L2x6OG9WeEdQc3N6TE5yaGV6WnE2WWRtRXNZdGdhY3RKTnZrdk9URVNTOXVVYkNQV0RJNzU1eTRJZTFUVllaYzVpSjk1N1hzR2dKK1NqU1orV3VFZ2l0TVBHNzE4YWZVNjVOdlAwcHJtazhoRnR2VG5ncnlCRmN3cTVqNElmMSs5clhYcTVpdVorVDNnbTZjcVZuM2ZUYlI0SEJTcXYxNUYxK0ZHYVZiVWpMMHVtUU5EQlpTTXQvR0hvWnphWUJVQlFQWWlIZmprVi9MOWE5L09DK0VPc1ZMVHBwbG5RYXJjWmlZZzc5N21kbmpTQU5HUEJpM2FLZCtsR2tEU20vdnJxa0d1VktTZWJZZzZSTldScDg4bG9pUnNtNkp4TEs2bkE1ZFpsekFYUXNWYkJKb0k2MXVxS1JGdzZwYytWQW5ZTlRkQ2plVWZKa1JlZjFvSjFDVm5HRVpoY3k3Q1VMVmtIVUNvTnN5a2NUZGJEVk9HQ1NYL2JnbEgrZUtSWXc5K3NXaUdKTVBIK2tzcGZ5VDhlWGN0Vis1UW4reFlkRkZ6N0YvOGhOYzNsb2xYVE9LS2hpVEtkU2Q0UjY1dWRlM2RRRGZWdlBQS3QzdnhLY3ZPUjYwdVd4OTlMcVNCYzk0THJ4SXU4SGh1OXR1VWVEY1FsSVo3V0ZVWlJsaGR3L1JubVR6djI0MGZpWjBWaG9SNmk4ZEdKZEh4dUQ0ZkNGSzFuci9VS1A5cnlScjJEWVlITXJCM1MvY1AxbTRWL0pBVXUzSXR2NUFzZDMzM3ZubC8vMGczdVB2cHE4V3VUOHpOOG8xMnMvSEdaKzNyV01hQU9JMkczWGdmUzg1M2wzUHQ5NlhzSXo3M2F2N2lrUlFxS2hFSWdSVU9VSTFuYU9INWJ3MkRiTEYwdkF2Tk5BQklMY1JweDgwc2tQNW9UQmU2N2lXMGFXNjFDQ210ajh4Z0x3ZkpDVDF5M0NaamxSVDFVSVVxWng5emtXZ1YxbTMwd1AvMXA2ZkozRUJ4Kzh2L2ZKYll2K3MzUXFlSFJ5SStsOXQwbCtLeFJXbVVzeFBJM2lxVElJWEFvMkRvamNwUTRSZm9HZTBPRHR3THJyRUp5NEJ6U1VneWo4cTV0eVhJb29qVDJOMFlmdldHT1VLMzhabW1xY2NFRVRmdEEyYkkyYjloYVdsa3VOMDJtbDQvQzVIRXJJM25iS2xSTHh5MjNkQndHYS81bjRvY3lUSGkxWm9iVU1tMjd4SFkyVU9Vb0VtYVh0VHFQa3A4anhTOGVUUzYxV0xvMStmaVU4dFY4ZTdvditHNnE1b0g5NXVYV095Vm9Pb20rM3ZTYlBvalU4L0x4UC9aT3Zad2JBT2JnRmVHQ2xVZ0Q0ay92RjJkQS9hZm9GaHNTQXhUZXJqZ0ZSR3FFaFdxTDVVdmc2cnJVZEdUaTdza0tsZ2xiLyt0YkJoM3QrNHJvdWVwTy9aV25pMVhJRDlScFJFSTgyYTVTQkIzaVRFVTU0ODlEcFZ1bnMyeGxMbDUvUjB2S2xwNzRicjAwOGxnLzh5bG0rNXVDWVN5YVQ3UnpyQnhhdFRuRW9UbjdwNEFPbU5MZFcrbExrN0RnbStCdS9mUHZEWDd6Ly9wK2oxRmZoc3hTNGVPM3FwNVVyQWFtU1Nkb0tLeW5jdVo4NDEwazdjWjRuN1Z5OTJ3MUxpYXlZZWJkNzlSN1R4V2xrRTlyZzBvQlpxWlFEUlhyNzl1M2VPNVBBdDZZb1V4Wk5GY1lHWS9MRGJmQVRCLzZVTzgrOTF1ZnFicVZaZDgvdURlY0pManpYR2xtVGFaYUhzU2pTTmluTVNPSUxPZFQ3dFZkZTI3dWVVNTQwd3FNb1FwM0ZoUWd4M3h0L2JGcFVGZFkwNEZBMGlqVHhHbStib0FhZHg5UlhtdTRvU3YxS2k3eG51ZmpraS8zZjZtTEM0VXFRbVB0bC9Pa1FzdE1zK1NuNnV6M001ZGtpOG5aQUduYmV1OTlWcm55cHJFNUQzbDNsU3Vud3h5NHJMVXFkaGcyTzZxa2NaNlhpRXd0V05Wejl3N2RjRnQyMzZ5aEZDZjJqS05TUGJrY1BGdmNvVjRyN1lqNkFSN2xTYmdFTVdHazFrc0pQU0tHUDdManlKeG9SbEM3cHVKSXJENXVDelpWaVg1TThpYVk4S0tESXo5bEVGc1dWc3RESGNpVEtkN2t0QWtuQkM5bldFNnpTY2FNbkM3VTRoUGJpMWZHc2MwdFdzanE0ZWovdFE1eDA4NE83WDZValYyblJlTndHM2trN1IwT092QTlmcGV0djhsQ3VUc3VLUEZxZmZTbDBkZDNQaWhIcHJHZ0pOWXBiU0xMVzVhYkRlNVRWR2tkWk1mQWtpdnk5ano3NXd4Kzk4YlAvUGdtL0NzK2hRSlRyOVI4TzQzYXYwbnJldmJvZnhiZWJGZ1BuZVFSbG5zL0Q2QVJPNEU3OExueHhMSmZkNGM3QVZ1NElyWFFVbFoxVERzRFcyRml3ZmdFTTVHcUFoQTNNNENkVStQSThaWisvTmxFYTlNUjdudnU1YWx6cUNCOEJIcFFXMlBESTZvdml6M3F3UklsditIdmYrKzdlcld5bkJlUDlEei9vSkJUL0hpRTJDOTJHcFBFYktodG1CM1pyb2RHMmdVVmhwbEhXZjVxcmhnOFduNm0xdVN6U3VnR0N6NDAwT3JocEhONXIrNGRtbUZNV0hEL0pWa1k0KzFGT3JVZGdvWkhHU3FHQlRiSFNYY3V5ZTJhNU9qYVBBa0ZSVzRHZExzYi9LbjB0dWNRN2Vjd3d0VlpvMHErNkxHVkJ1VlJHRXFuTU13dTI5VXJaYWhwWXFrN1JVNHozTXN6dHFmM3BKUGdVMWVOTXVhWThveFhQOHRrMDBORkxsU21sSDkySENKRXJiaHR1akRORkd4eFlkTGF2anErMjlZcHJoWUpGN3l2WkZjZS9icldIT0tlTWxXOTVoNy9xWmh1cHE3cjArRUQwVDkwV2YrT1NTU2VJM3VKMEp1U2s5RThlTkJmVXFjb1hybHNvSFlLOGZONkJ4MnAwWHg2algzN3U1K2V3bHFaTG1ubW5EUHlnNk50cHlPODlOMHRoVUthcEMyczYvTHdjYTdXck9xSk03Y3pxQ0NSYUhUNUJNMjZvZklFMmFUNisvK0RLYjkvOTdULzVNbTV0SFI3OVRkZUwxNjh0NVZyR3AxRWg0SVM1bjZ0NDZYYkRLSjN6Y1cyZ0d1bk9UOTVkNVRydkpxOXlOSzdCWmQ2TDl5T0FoazFnc0I1WmlQWTV2LzEyamdxOGR6L1c0bzBNeFYrSklydVpSaE9mVkFUYU1odVdER1htQUJGREtRMXFmc3ByNjFNR3ljazFOMEZwS1plZ254UWE3Ym9xdTBtU1RPUDNtMmRXbDBYWE01TU9YNEo5SXhNRHI3enk2dDUzdi9mOWZpYmpvMnc2dUpmUHVEcmI5SkRGa0NHV3RZZlgrb21hTmFzTHFNbVAweXgxT3NsMlJXdFlzL2lNQmpaTDFZYWc3a2MrVnBqNmRJYmVtc3dzQnJXLzN3U1g4aldZZ3d6N1NvOG9FY1BHK3cvdUJYenFXRG9FUnppa1h1cHlPVDhxZzI5VnZkSEJmMHJoYWZ5VjlpaDAyVkswbGlIeXphemF1RXBCQkI2L0pFdVhNcUVtV2JCb29SeUhleHpIZXJjdUZrRGJUb2VmckRYbjhscVB5cGVMRDhtU3IvaGFteHJsUjBEQ0FKOE1mNXFSdzRNc1B6UFVwZEJoMkVOTnNnWnpIVlNlZkNsZnAzREd4OXc3ZFN0UXN6QmVmUllPMFJySmt5RjAzcVVxVlpiRW03L2JDS2l6L1lGL0d2cnJPTkRTa1k3SzhVeForMUhXNnQ3aGQxamtITldlNEIrRnRXUmorVjdia1dYRnIvT0lLVWdVOXB0bFhwU3VFUkNacWFMTld6U3lVcUliSmNKVG95VnhEalczZW9LeVBYUWd0bzRuK2JTWnVoZENkNzUwSFVSUEs2T0FnODloR0FpMkR0ekI1WWVoMjVYUVBaemFpMU1nL0lyaXhZc0lYMnJXVHZRQ0hOS0JwT0xaUE1CVmM3SjM5LzdkSHZieXExLy84cy9mdnYzSlQ0UHFWK0VjQldxNWlzT1U4MkhpUnNsNS83Y3AxMG43ZVZmQ2RQN2RsQ3VldFROaDBubDJMeEJXd2pIdlhGbHUvTEFtdTI3ZXZORmxVYXhZVmgzbnZ2UjY4NldnTmNjVkJzWTh1MUl5d3BRMzkvUHNDbzZ3UzR1QnhYS1pkOUpSTkJxRHBXT3MyRmRlZnFXV3djTnNLZnpvZ3crRCs2TmFGYXFuSGozNEpTcWpKZVJQeXcyY3BSelgwaUVLelBBdjFBZ3U4RmtOK3pnSytrcnE2dlBNdFhMVEtDa0VWZ3ByanNKNG1OVUk5OU1SOFJ1M0dpbTRIVWJLMS9qdFVDcitvQWR1bFhEd01DejJ5aTRlbkRETGIyYmRCRStQSXd3ZWxDNWZxR0JJN2RkQ2toL082S1hEcUpKSjNpcU93SE5Wejg2WXAwNHM3cDRnbHBKMG9EMFBRcmxCd0xaVGsxemNMK2hyM1NiZW1tU3MwcUVzbzZTR044T3ZpWXZraEtoYko2NUNGRzF3cDVEZ0QwKzBIeDZMazZ3VGhoUlYzaXUveHd3bUhWcUVBL210VVlDRGdWaUo2aGpVV3E5Rng3RkFBeU13TFRQanUxNzRVZllyTGVXNkc3eFg5c2l3VGtkWUZ1aUM1VjNycThEUVJKQnZydTY5ZCsycUR4MnBaLzlTdWY2aVJndERMN055WXZLaVEwQU9QZUlScUJ6WjRQSWc4dmF2Zi9Hci8rM1hIMzc0TDdkTVgxMTJLS0Q3L0V6QWhDSG1NTW56M011d2U3LzdQUGsrQTNTTGtPOTgzczlMdXhzLzVWTldoR25LY2E5UnZmLysrOTFzWU11amh2VEhmL3pIM2RrRmh2SUlqblFhNitCd0hvL3p6N3Zsei8zZzRYbnVKNStyR1h1aGdwcXJNcmtOQk85LzhCLzhib2RnQjFjVzZYLzV5MTlXcVVwL05mN1pvNmNQMGxRcElSSzl5bUN0c3h5Y1ZjckhDazcwUWYyZ0RuTVIxTmxLQlBHc3dvTW9LRDVZVGFWRDBPU0JpMTFZemQ5R1NDbGs4MEZnNTV5UUtLNzRNbG11RkVNYlhzb0p2ZGJrVGVERmFqbGxSZVc5TXhEczRERTczVzJTVVJTc3RlbE1la0IyUGlQQ044dnFkWHE5TlpvNXY2NldHWWNGdW5SSUg3ekFSQVBmVTNQMW8walc1clkxOU9XTW1QVHFLMXlNdGNiU00rTXQ3bjdvNDdxVTJ5aUtSVWZwZTdwWVBxbkRCWk1pU21zYkM5Wkpab2JiZk9xeHNpTm4rSHQ4bUM4TjVDUXVoOUtrNXdmaUxJd01GdC9RdWhZMHk2K0tkY201ZDhuWVBPaGVPcVJzY2l2NGVvTVBKK0tOZXJnTy9oUW9XR2dseU0vZEpLL09reFhyL1lTbUhZVzRwWmZIVDNBTm1jcHp6NCt6WThMcWdZaEtlYlJjQkVNcmVaWnluWHJLczN1dlU3dDY3Y3J2aWY4cWZKWUNuMnU1RGxNKzd6cWc1djA4LzIxWEZzYmttYXM4N2xkNEpnaGJ4TTQ3eW1wWkFQTnVobER6L052ZnZsMGxTMGp0NW1MQkVrYU4zazh2UFkxM3lpUXc3bGRER0R3RzRzSnQwaVpoMDg3ejd0WDlXaXdlaFVwaUtTS1RCR2tBZkljUFlrWEgzdHE3bm5XNkwyZjk0STNzdHFLNFB2cm80d3l6OHZtTUNPdmpkQTZhRXJ0Q20rVHZxcVVWcFVleE1MVFlPV3VQZWl5YXdOZW94S256UHUzS3FrMWMxMi9tM3J2a3FBVjBuRFIzN253U3hlYlFGM1VCS3dYbFdqOWorSU1PSFZZSEUvV0IwRXFYSVcvZ0dncFRKQlJSUDdXZE9sQWY4RTlGaXpOYXdDdGdDMC9EVlM5NThHeldpaTZhYjQwMmVaUkR1WFJtUEhEVnVhZDZsVWNtL1BJK3RMVzhyZlVOYjYwdTRUL0VYNTJQK0pZZFlIanJOM0Y1YUdXc3JraHBnU1pOOEZLZjFDdlJ0WW9wc2VSY1NqREpldTVEZU1CbmE0TE9FSnR5ZzcrNnNuQjFyTDFQSjdMcWh6OFpNWVVETEhxODlrMnJXb3FCS2EreXVSZ1dXcDdWRFcrc2ZjV0xKVlBvZ2o5R0t1aW5VMVUrdW81TXc0bTh3RUZ3VmNiOFBIUGxjRitKVTNmdHFUMHlha2dmdDR0M3hURXBTcitrd1JNMFBFN0hkQlE2MjcxMWxQZzMzL3J0ei8vMVcyLzl6OHI3S255YUFzKzFYQ1VaQm4wNitiT244Ky9QUHo5TCtkbTc1NlVkQllmaGYxT1lSck9FWXpYRVdrQmhQaVZLQ1A3cXIvNnF4d0phRC9zbmYvSW5lOS8rOXJjN0xKZUhsWEMrZk0vbjQrQXdPTTFWbW9oaVErKzFpSVRCUlRxNHdNTjdqUjArVlNacHRZU1RydlFGaE5lLzljMjkvelRuQWJ6NlNqN2VsaDFuZi9FWGY5Rk5FdGR1clBObUw4ZkNURk9PM0Vlb28rQ3FBS01BNkU2SzIrZGdIQ3p6OU1LMWZHSThQck5yeVplRytEaEhOaDduL1lXNEo2eE1PSXd5NDBPRGoySDYvdE44R3FhS01kQ0RMOTJwblhtL1MzblBhQjMxMHBsaWpiMzFDMnpxbjVJMWxMYnZQOFpQY0VrRDFFNVQzMVMwRml2L0tldFpQZzJTbStaR3ZxZlVocHJDMEFQdFdrN1NlTmFSMUZKT0daN2RGN2ZnazdkVXdOa3oyb1B0bHo4ZUMwOCtjY3FSZDRMNzlhRS9DanF3b2tqYmlhVnpTY29vOGRRcnlzUDYyVzVDeUpHQ1hXbVFmSS9EQi9WK0dyMkhuMWV6WEFrOStYMmZzTUJ6VlNaZnBqcE51YTJEZXVRM2NVdGV1VFBXS01MUmdEN052Z3dBdFZ6MUFPODhyR3ZYZk1rMVpXY3VnYlVOdjdONjVyakQxakg1QlBkK0k1K05UQjEyM3kyY1Z0ekV1eTczMk9xYytLcmhEKytuK1FhY29FejRaZVBJMXh2eDFaL1BVT0F6bHVzd1pGTE84L25yK2Zmbm44K25uK2Z4YVU1NlYrK2VoZDM3WjdGengvSVZKZytCTk96VlFGa3duWGdJUEV1MTdPaXkvMTY4N2FtczJLNEozWVJ1WUE1dXJwdGNWbkNtak4zckNQeHUzdDBHb09mbjgyUzVVSXJFbGtWQmMvSFZzWmc4SytmS3RTdjkrc0dyK2ZxQnVQdkJtUkxpTzAwRkNXN3g0QWRrQVZXeFJLRUJSc0V1SmJLc05IUkJnMzR5Sm5uVE92SWM1ZFo0bG9xR3ZCK2ZxeTJ6Y1Mza1g3RkwwaXJkRHBQVEVOTmcxYmZEK2JLQzY4Qk5FSTdpNHlib3NZWkp4M3FkeVRzNFdpcDJtazBUSm5aTXBqaVJhOXdremtLNG0vTU5MTnZTTUEyNzIxaEJEakZLMTd6cndkWVVSc294bWNXeW9tQU41OUdNNm1HNTZtWEtsOVpUSjdCT3NhSnMwR1VVaWpSK1p3b29lQzlyRFltOVE4OVZSL2Y3bVhEcmhKVUpuTHkzZnBUUGRDbkhkTTZoWHkzWEtFWmxnRFYrNmVrSTVGc2pHREJBUjdQMW1mQjloMzF2T0hxWnBQa3R1WFB1QVBrRjE1Q2JEN3IxZ0Vma1NaenpodHQ1bDFiTHNvZWJvQnlqaWduZ3l1L25YdUJ1VWx0eTZkZXMzbTAvYjFjSWJuMmZqaWI4WEIxQ3J1bnlMWSs3bi9tQjR5Ujk2NE1QN3YvNHpWLzhreTNUVjVjZENueEd1ZTY4TzJQSUVzSWxwUE4rNGo3dmVlTFBYNWN3cjloaCtHNGE3NThYUDJtOEowd2pVT0lKMit4NE1TdHNRa0ZndVRxWHdIcFl2VDNsdXBUTTZwR2wyYTJIZXczNGZKZzBmYitUaDBJUU44SmJKVUZsSlg3ZUtWZWprRTQ0em93M3NUMktmMVJkV0xGZmV6a0h3THoyZWo4MWN5OG44cmRoeHA4cHJFWWRaVGUrVXVvbEZpbzhOY1FKQlo4L25TUkpZNUpHZzE0VE1oVElzamE2eHBhU1QxU1ZTQlJITGJDdHdTVlgwL29MWnRlaE5vYVNpMzJYY3BzbU56eTZ5a3RSYmRTdGF6cUdIbHFkUEpSREo2bVNoaCs0TS9CUnFxV0ZUQW5JdlN3aUNtZ3BWMzVXbG1EMFZxMUZWckYvRkZrdFpKWjU4RVIzRTFxTEw0YTR5K0ljbW9uWDRRaFRocE9kZkZXQ0VqZDVxbFBnRXVqd091bDg1cVdkRGpJSFIvUXJsb0hGS25XMkJNSlFUMnJRamk5NE53YmZnd084QkVwMzhYM0pDVG5nVTE1aFpEQTFTVG5rUmYwdXhMR3RVL1g1R3gydWR6NUZaRW5ZWmRaeVZuYW9uNDY2cnBIa1U1NTY2dERoS0l6OGpXeE9YQmxZek1YQUJmMjB1ZFh1bkpVTGZqdU4wbWtwVjNGZ2Nndm9SQjdFb0tGYzMvLzQ0eXN4WVA2SHI1WmpvZWVudzkvcUZsakNzVEpWaUVQWTNUaHZ6ajkvdW9qUGY4S3N6d3RUMXZuMzh2aU4wQkFxYWV0dnkwNmVXN2R1OU41N00vUVU3RC8vNS8vOGJKM2hILzNSSHpjL3VPQU03bk05WDk3em5wK1hkdUlvK2hGRWNkUGp3N01MeW1NNTZQbm5BSkFIRDVZNzR6dld3Z2IzKzBjUG0rNk5uLzBzbHV5ZFRTbndOUG9raVFtaVZYZjFlNUtHYXQvOXhaUFZZSlZ4TTB0elRqTTdCWWZkd0ZxcTlaWURsT0hJdmNEaXYyQnloNkpOOGphcTJvWkxxV2x3ckZUMVFDdnZMZVN2YXlMbE9oUDE4bWtzMkN6YWFkN0E4QVVFY1BIRFNnMUxpT3hNVW5mOGVKQ09UdWRIRVF0amFjS05sZzdJaHNYZnhaL2VwNjQ5MFNsS2NmRnRLVmZseWh1cTdPUmJPTXZuSi8zZzc5Z3JlVHo3SFBwQkxNbVdtOXpnNTI5K1ViQzV0VVJPWFNseXIzUlcrWHhyODZzankvMXkvSjZVcG1BU1QzbjRnTVpKM0hMNFVKVkpGcTVkdWRuM2FFckJpMSs3c2phY2t4YzgrVWVtd0VNdk5GU3VQSlppQmFPbFVHT3ROazlHQ3pxLzU0V2hnUm9LbnNGZjlNSGZ4V000aXVmVE42ZXFMRDlCdkh4RFYyNmxqS2h1WllUQ05mQ2wvTnBBQ2ZNNWY2cGNoL0RTSU56endqQjYzc3N6WVJqbGVkTE51OCs3VHJvcGUrRE45ZlB6VWFiZVRpTWhaQWtzcVlPMUxJdGdqcVhDSmNEWDk1T2YvS1JYYXhCLy8vZC92eDhoNURvZ3JCcm41REhoWUVuVU5KQlJqbE52Ulkyd2ladDZpSmZIc0RuMlV1TjMzejEyMmxVYW1UTkN0YnVuKyt2a2ZjY0JSajlsSWlKcktHKytzdmYzLzdQL1BHczlEL1p1WjVLTG0rREFaelhTa0piUVo3ZlBhUTcwanJJNmVYSzBHbVVzTGZWcldWbmdIbHVKS2tqRFgxWWJ0V1A1Vk9OaVlUMktNcjE4eWF6K2d3elJzOUpnMjNHV1ZsTWY3TjdUS056Z0g2MllHdEc2dEV0Z1ptMW05dC91SGNheGVqWXBGWGdzU2ZUUXFQZmp6M1l1cmVWU09nOTB2QllMblVMYmoxdmd3RXFCS0tSK01xU2ZZYkZVemJtdUdRWkhjZUREVVdiUEhkWmNOOEJtVFVHQkljOFBlaFE4MVZIajU1Snd3bFZudklNRDJlblFQUENXQ3liS05Ya0tLNVovMzhmeXJFVVpmTU9SMERWNzhGTk5aODNhYWVmcnFJOTlieWZ3eGFNNzN5aTNqRWsrWiswK0RSKzdkanJyako4bW4xRkZTT0VMSy9rVGVpZjdDejUraUE2cDA4bmo5VkZPOURnNXZsTjNpWTVHUHJUckdRbDZONTJMU2F6ZzRjZWE1aGdtRzhpSVI1bEthaDUxcVp6aGt0VU1jV2V3dXRuMDJFWWV1RlY4RzB0UDBmWGh3VWNkMEVnaU1tRkozL3E4K09xa3JoNWV6VWFJdUd5TVFBSkRCMEpHcUZjVGk1Y3VaR0k0TkhuaTA5bVI2UnRYSXhmcFNMOEtuNlZBVDhVU2pSbnptK2ZuWGNVOUw3UnhQKy9GdVRqV2tIQSsvVHpQOEdSd09YOTkxc3RIUEtyY0J2Y05wa2FlZU1KWGl5YlhOcW9JQm12cTV6OS9veGFVbFFRc0FXRXNBMlhOYWdaQ1g2WFJ1QWhZUXA5YlpnUTQ0VHh1RXpkSzkveDd6NXIwQ3Mvb3pWVWhqOEJOY092V09pVGpYaWFuUHN5T3JwTXNkekpUTEkyMXBZYUtacTlaS3hxSW1lakdsYmFwUStEWlBOR1BIU2E5Zi95RXpqQ3cwd2xkK3BrUkRUcGhNSEkvT0N0cjZyRWJmeVZsR3JZcVcwUGxtN1Zpb0I4c1pPbW1pcDNVU3FZT2IyTnhVY1lXOXV2SUh1YWtNQ3NBd0VaM3JvQmFhWGxHMzZVWm90U0NGS1ZqMG81MXpnOXRiYTRQTEJZZnlpRjVCTHFpeWlhNEpMTDNmYUh1alVPejVjZnNOdGNNZCtIQVhFYy9PRnM4RDQ5RVJwbWx3ODQ3UlMwbFJwR3p3S09BZ3pPQ3BRdHBQdUNUSVQrMFMvRlJobU9aZytkSHlZSWptSVE2Y3hXbFlQRm5YMHdJVGlZd3dTR0h5NEpkTHFYbDkrVjdYanNFNVRQclh4cUczMmhYUXlEeDdsdGVBSldIcFJORWtXZlJwS09TSXAvbm9yYmlwZGR4akZGUmV1VjV6bWR3M0NDWHpTTkdRYWp3Y1F5QU4zNzFtMy95M3AwN1gxbXVwZkN6UHpGcTF2QmdHdFc4bXZqejEzbi83M29kdU9BbzIvTy9TV2hqYVo3VnNJaTV3RGNvV0Z4T2VRaGd1aWVBQk01YTJMZmUrbTNQTmYzTmIzNno5L2YrM3QvYis4NTN2dFBoSzhWTDZJK3p5SjZBK1FselA3Qmd1WXQ3RTIxL2RtbTRlejlwNUR1YjlFaWtOS3RCTDRWQW9OTU05NzcxcmQ4SkxsZXFBRm1sdjNqajV4SDJ0ZXJnOVBSaDd1Vk5nMC9qZWhLbGUrRTRzOGIxMFpxMVhvM2srRFFONzhDcy9lb1lXSCtzMk5XUVZyMnNHbmdTcTlLYVZRRitBcnlLYTJnMjlaZ3JXbXJVNjNsTDI3eHIwa2daU1JDbHRkSXNxeXoxVHZsK0ZLenl3RmYzcUlIeWFKWldXYnBXZjJqQThBbFgvYW1ERC9aRjJ4bTY5NW95VzFZcTFvbERGUlJTUVR5RDUwU2x0TWExdk96eGVCeS9waDFWcDBFb2xBdU40bkxaOEtCVWwveXc1Rk51NEsxSnErQnJjaXVUVHVvQnZ1Mi9RU2VUa01tZCtseTVZSHZwb3VFb09JcDJQNTNmaklZdXhvMUF6aHdsaVliV0dNOEhINjJ2UGNtenRPcXdsS3RKemVGSEdMK0p2Ynh3cVBKT1d1V1RuMzc5WVhzblRlVTQxMVNrYVVxaVBOZklpWlV0WC83MEdieFJxdHFEZS9KU2VqYVBmSXZueXMxQWNiMnp1ZXVyOEJrS1pFTHIwd2UzN0tiQUhHR3U1Ky83Y3Z1em0yWTMvclAzcS9GL05uNlY4N2Racmwzc25jd2Jhcmxid2p6UDNkWWFZU0VvY0NJOGhKa3dFQmhuclZLc3Z1YnF2VWt1czlvRXlQUGxiQ04wOVN5dlBCcWJ1QW51NXpmNTVsbWE4L2VmenJlZUF2cXNuRmxCb1R5TjBoclBXemt6OHhzNVE5TVhEKzdGYit6b1F1K0RWUnU3TWdTV1JaWEh0THBZUE92THRCbXlia040dEdDNVVrTEJ2TjJSUE9EbFQ1VVFlTklzaTNTektyYzRkZlJPbWtCS2VqUlArWjV6ZXluS2o4MW5qVzIvZkx2eFJCbTFibG5kVFg1aDc1T1A3elNmVVFPK3NDQTFZclVvRHNIMVRIbWlSOHJwWjE0bzF2dzczUlJOY1E4dXBWZk1YRmRoK1hDWHNsaTcyTlRiRy9XREIzTTBNRVhXT2sxbmtjNGdiNXZPc2lvd3BPdlpBY0ZidVQ1eDdzeUVEcGRqcVpvRXZKcmxiMWRURDV4UXYwNTRaV2h1TzZ0Y2h2MUdJa1lXUGgydTAxZ1c2V2I1VzNPYStxN2ZvdS9qRExkYmhoVVhvZHVodGJTQnJaUHM1QnFmd3hiSURibTJxd3VQaEVXRkxjSEdzMWtMVy9vRzJFcTdhTkJ0NURWR1Z2azlyakRLbllLdnl5eDR5RGRMekk1RE42NGd5OVppaHV4OWtDTXYzL2oxci83MDNkdDMzdHBLL2VxeVVTQm5DN3p3UThRN0h5YnU4NjZmbC81OC9HZWZWMWtEZDk3UE02RjIvL20vWllrUlh1RVo2dk84bE9JSXJVWkhtQ2dOVjRLb1lmTzMvdUlYdjZpLzhodjU4S0N0cWZJUU5nSW1lSmEvU2kxNUtRRnhBbGh3ZE4zOVNUdTRTK2QrTnhpV0NmU2FzTkp1NWtpZmZiQXhreVhCaytKM2xpYS9sMCtPdi8vZUIybGd5bDMxVVpZR1VFVVFIeDIvWUd5eTRyd3N3YVVrZWpRZ1M0Ti9jTU1YRnBSRzhRMHVHcUI2b0kwNlRwMm1Mbk9GUHR3TlUvMUFjWmlMSXdPNkpWUTg1ZHY2cFROSWVzckxqRGY4anZNOXByNUtUb0Z5TFE2czNaVHZpNmh3TWZab0EwN2k4Y0VhZlorMFhCQVd6Zml5bDdXbEx0S3VTYUlxM2NEV01WS1c4QWVmNVZodG1MVEtXYlA5MWowc0M3cnN5anRMNnJvbnY4cVkxUnFhUktIYVoyKzFnZWdyVWFLVTIySXhtVjMxMVdtZ29mcWlKeDhsbVZxeXNXZ3JyZWNWRnA1d1BUcCtkaGFyVFFJVTlYSWJCZjhvWTJ1WWRmajRicU9EUE1CTS9WYUhnais0dStJWGI2ZmNyY2pVV01kY09kbGdlRU9wOHBlUDVkcE9LUEhUdVI3SkUzNDdlcEJiNEowY252U3pOMy96ajc5eUN3eGRuMTNyRm5qMnVKaXgrL3ovOXYwU3NLVmd3Q1lVSTJUVGdQOWR5dFNBTkN3L3daV2dER3pQTEZWbCttcnJ2L2dYLzZKZk95QlVmL2Z2L3QwMkZvMWpjS29sdHlsVWVjRVJYSGNWa1B1Sjc4MldaamR1NnI1Z1RNTmFEZUgvWWU5TllqVExydnZPRnhrWlUyYmtWUE5Bc2xnY1lBT0cySklGcUdXSmtHQWJVQU5hdUlIV3FqZTk4TTRHRExRWFhBaG9BaWxBQkN4QUJyd2cwQWFhQ3dFeUlBRzFFQm8wWUlOcWdUUXBTMVRKSkYwRGl6Vm5adVVZbVpFWjh6ejE3M2ZPTy9IZCtESXlLeW1TWXRINmJzVDc3bnQzUFBlOGUvL3YzSE9uQ21kRFVicVJIZ2NXenN5ZTYzN2xWejZQTjNOVTBWZSsvOTZic1FuSzdCbjMyOHdCRXh1cTBoaFVBYTBBQnRLTkFHeDMxbFZoZWdzQzBVV2xPMnhES1ZQbHNHeDJkejBSVlRyck9neEgycmJXMk1BRlI3djdNZmhESGxDS0x5Qm1QdXgzS3hoR2x4WWFIRXdLVlFBMENUUit5SmFReEMyZmwrZ3JiYUtwNzJtY0FjZzRKQkorU29QQXFiVGs0Zy8xeGE3ZkRCVlEwR2g1QVFJYWVyd2JDbUMrRlU4VmpQZVdLMTlQdmlQNU96YUp1NkJybVFBdGpjK2gwMGNjVjI5dGQxeFdDVTdPOEJBZ1QvZkxqZTBkdVBUWCtER0RJMUpRNHZmalNuelNkQ0NNVklWdGdERjVsOENiK1VtYnFnRGZnVE5CWE43c01kYm1Td0x3bTNJaE9WS0RZeEJ3aDZQRFZ4enc4MTF4T2EwcjMrdDJqQ09ZOW1SL0VvZHBrMUJRVlQrNnhXQmUvLzRqalQ1YzhBLzNFQjdnWWZrNStDaUFPMlNscmM0NzdLRGhjRGJNYU1Qc1luSmpvK0thdUJndm9uZk1ocDhQZGQvYWRkK2tFYmNQY2g4T1J4V0x5cVM3Y2VxcWNLRUxxb2RqYk5VQ0djY0dveFJYNmZTMklOQ2JLbGNCbncxVktTQXJXZXI4REhyejVzM1F4OXI0M2VUYUZWTldNcytjTXF6MzVtbEZ0cnA2WDhCYWRybVpYdDIzZHJuYkdrMlRGSFNLc0cyWlhhMlQwaTBWbDRydFFOYVQ3S2gxNGNMNW9Pdm1UVTVpWUttcys4RktWeXl6aEE4MnpBQVQrVUVaUTBBR2xOVEJpWXF4SVRmdUV6M1BqZXRBUzBna3dVY2FGblpycEY5VHR2Y3hIWW4wYkpONjIrMFBsUUIrU2puamlMQzZ1NkJna2tFMTcyTXpGNERDUEdmWStjczA1S1c4aXdVQnhIVlJSTXg2UUZvem5DdXBkamlNY0p0eTZyZERoZ0VBQWlPSmxuckltUUsrMXdLRFNCTVFpSGR2NXBvSW4zVXRSOHFoVlRlOFlrQk55VnBlOUh3STFZSHZpVCtCWEpXQVlHczVZdUNPbUlhdmhSYmFNVmVZK0NlSlo5bXNTeTRtMFRnUUp5Qko5d3pnVjJWM0lDc01QTlBmYTVOVGVuMy96bHlJM2xZUFptN3c0d0tZZFdlRUFHd2EzMEVDM1FCRVhhUlMvaTJmSzJ6Mk5qSnVTcVh3Z2VpMkMrbVRCNWExZUFFTGtyZUNPWW5zRWNZWkxrcXdYdGVZUi83MmU1Y3VMbmlZMjhnYzRRQnRZL3lpTGxsaGs3a1ZRcmZ5RzNhcjU3SXJiRDAvMkI2a1dYbTJZZXNsbDkvOWRsV0NiQ3lTYUpnYUJiV3JZOFd3SW5oWmtiMjhWekt5eXkxNFd2bERPcVJodW9yTDFWeWVNdXVKcm02K3JaUm5veldjOGIyMzBVY0RqL3lPcWdPS1RzdFNGYlBzMWsrOW0wWndMWGRJT3pTMm02aW4xUGljWm9RRHdLU3UrQ2xXY3Uwd25lbnUzWHZkdllWN09EdUZMSFdHcWpNSXlEU28xS1hsS0cvbVZaQ3BGRFNEVkNKZEFhN1kwbUFEa2dUdkxhZEdmcFdKTUR3VXZUSFpuV2dDcXl1dUprbG5JdlNabEFyQVVBMGcvOVEzbXZJMjg0Z0VVUnU3YWdFL0NQWWU1S3Z1QVl4WkxhTHhDaW9FUm1JRlhHVUlBQk5ncU4zVFhCOGthZkc5QnFDRTlKN3YzZkxGOUNsc25mV1BmSnhmQlUwaHZWTkU2MDNzbFZCcUNjb3ZLYUgySUk1Nnp4bTNjTVEvV0FMQU91am14Mk1LVzNmemttWjFvZ2NjR1M1L0xmOFVVcTU1eHVJSnk0RnhXMFY1cThRcU1IcHZYdDViamozaW0xYk9EckVYb0YvMnZnUllaNG5KTit1bEVuaWFiTGZTSWEvTVV4b3N2MkdWdk9XVDd6WS8zTVlpb1hqRmZGU0prNnFIckNtbG1qT1VBR3g2Rmo3b0ptek0zb0Ftd2ZVR2c4VHZMYS8rRGd0MXN1SVlhV1NDQXpURnNZdmV5VUJmY0FHQ0wyclFtUEtyWlRqZFpISXdYQWVNY2JLU1VHbnB0c1dMNCtVUjdQQyszQ3JOc2lPRURkeVEyRllDamVscGRDdTc3dnRhRWU2VmJvNm9tbWRXWXNOS2w2Wm9qY29YZEdYYVBodkc3cFJHQ2ZiMjdia0FoZWRaKysvMmhhNkNpcjFBQVFGdEczVTBmc0pMWTlLYzZnSXJ2RzZtVzJrWHplYmo1VWtHdXNGQlU3QXRjRUZQU0h6eVQyazB3OWl3YkFOT2ZmRnlNdjZUSEdremUrWjBkd2VWeG0xMHNPUHNOalhCdkZYWjVselVDVURaZVl0QWFPeU5hbDd1WlJ2U0kwQndVbW1LUEdoMXRIVG9JSDMzaklWSnlYTWFETGtIK0FpYXFnbE0weEYrNTl2R1hnVXFXTDE2K3RYcEJtYVJGNXFLbUxha3ZwSW9OR2oxaUhSNTJXZldIZXczQVFqTEZWSTI4VzM4WGtyWW9ldGpxbEVNMEFCcUFvRm5ZcmxadGtzd3A1bGp1bzlrNzR3T0FVZWRaTDJMZU1lVVpSOWE1RlVzQ09DZVJJSU8rUkR2WDU3YTFlYkNpUStFTHlEcmc3OG42SHE3em44L2VnS0VFWFNoaGNnQjdBZW9BMVI3R0RZR3B4Z0E5UWh1M2x5b0RtTE9yY04rektkMlh2RFdOdlZHZlFuM1hyNHY1NjRxa2J2cHRCdk43Q3A5YzIxUkx0K0Yra3k0SGVGdER3Zk9XaUI5ajc0NXlidW1GdkVSNHkyUnJPVTRjSVlMNFlEUitCanNBOUxxaHYxb1RBbXV2aXJiTm55WlpFYkRIalM1VEpwVW9pNEt1dHVVMTAyL1QxSStxa1c4ajAxNmJ1dWN6K1pVUVBtZjEzNnN6bHFsWFd6RGw5ZmVlLytyTDcveStoK1N3OGdNY2VCa0FVS0JhMzdkVXE5U3dGQVZNOENCU2lZSWF3b0FqVnRoeTYzTnAveGF0N292UCswQ0svM0svV0gzbFVacnQvR0c0NXErNWRVb0pSaldCcWR0bVN5SG03NzRiQmYxbDMvNWwyTlBnbWk0eEZIYVdtRW5mM2xrbUxwTXc3U05JMUJvOUd0TlBkc29OZlhjM2hmdjlHdDVFUkg2bnhkZWVDRm9kVURPdVprZmZIQ0Ywd1ZjczI5WDBpM3JVc0lnQjNERjdxeE5FVm9CYzh2aFVlVjdBT3dzN25aM0JRMXAxczhtN0lJbDh4YnZBenpqMTN1Q2tvcGxkOE5yTjRrSmxRTDVrVEkrTkg5QXgyNDJtWWIrRlNhSHZ0V0QvQUpFR1p6WkIraFZ0OGdyRjNnNG1WNHBUeU1OMjBodUljWGhIMHRkKy9jU3UxUUJzdnVDRTBZYURTK3ZySmVtYnp6Skx2NFpwaTdkdkN4REZKUndnbmQrOUhEbmd4TnBIY0FBakhOMWpWdjFRNy9XUkZyd1RuQVhaTjF3VzJDMVoyQThlMFhTWlB5NmdoWUJEUllKL3VweDVZTzYyOVRQTXFERTNnVUtDaFFOcVZINjBKVlA4TEVFckFWdzB6RE9PbkdEWHQ5akw4SDY3UHVSTDRZN0FRM1JaaFY0S0d1VlFRbmJqNXRoUFVGWW5iamhmVytUMDZlRDlpMW8wbDBqL1JyRHJQRU9sTVR0VVN3eEJyQ3lzdnh5ZUk1Kzd1UEFPRk4rTHZvQ1pKeVYwMHVtZTNudmk5TEk0QXBuV0YrVWwrNzEwdExPU2xqK3czWlIwTG9mY2FQeXQzN2VhOHBOMEhpWVVYS3RzQlczd3Z1c3RHT1p2TEpoVWRNeCt0a1lkSFBqN1NXbW1BaFdIbjdvK1Z6Nk82RGgxS2lLVituN2JGeWZ2Vy90U3J2Y3FLS1JYLzFVK0hvdVhXS2xyVjFYaEVGY21hSzcvUmc2V05lZXo5K1pqNFVHam1TZjRUamtmVmR1MFhwcFMwRkxqTlFESExpUU05M0xhakJJbG5aNVMyY2IrUkhKYVZVMjFuemZ4ZXNFVzhPRVRLV3dwMFJIV2RVM2hzNVJIcENQayt3ZGFSZXNsQ0NkMm1SRHRrSExUNEhJQlFGZVNtY2VTNklkeDRrcnNaRTJlQjFkejVoV0JkMnVEUEp3UjhNNG9GTGdFWUFBVTRxSDBoY1NhODlNL2Rzd1VTYkNCTjNRNllmbnNBdytTenZVU0tOVG4reWx4UFF0eWtKUzVJdWZicVFmVWl0QUdyd2lIUWZEbkh4L2tyTEhDaVlpMkIwbmtiQjk2NVlITlhLNFdjWk5WRlFPT0NyWk8wQ28xeWF6QmR3blY1NUlPMUdpVEtvVFJHVktGT0JxWFN4MWlCSnNoczJaRWJaZFRlaE9TY2U4N043SDVRY1F1dVRWRm5WaGd3K2R0dkZ4alkrcWFhdWFHclNSRkI0TTQxUTRGeEtvWUoxbkJzc2JiMS8rblZ1TGkxY2l3OUhQRVE3UVMwemRvcTR5M0srdlROVEkzQVJjWDNKK3hYR05seU9ZRkJnWjFqaUdONDB5N1gyNWFlditNTDhLVzJIS3JyamxmNXhkYVZlY3NpdXM1WkhXQkk5c3FMcjVyRlFyUDVUdTNuenp6WkN3ckdpLzhSdS9FVk8xckxSV1RDdDFOZERpVWNVdmlYZzQzNktMbnZWaCtZZkRSUG1vNE1PbXdrbTNJS08wOVBFWFhveDAzSlRHeTVWY0hyVXR1TkVHNlRMNlB1ektvUUdJTms2NmRDOWROcXRVcGZUb2lQWXNBeXp1RFNyOTBqN09vZ0pObEl1QkdFZUpYVUtxTGxjREJBR0ExQStBT0tSWHdZaG1LY2k0dERYNm9DQ2tZQkZsZHZvWFFPd2dtMU9ZY29WWFNvZW1KMytyZk5MZ01USjJtWDBucWk4czZ5VDF5cE51VlFld3h0Wm84UTU5SHhHSE1LVWVpS1djTUNEcmJmYXdURDlCVWFETHVwZWFBT282TkVGcFNLcUdxelRoNG1FZTNNVDdsdi9XZVZVUGZqQ1U3TmFJdmJkRFc0aXlqN0UzUko2cHhsQWVpenVVOElpTGJkcEJFOHRyL2NpSXUzYi9uVzdtTzkzZ01nbFZFdVlUYzBrdDdwaXpJU3d2SHl6NEl5K2RxV0E5Q3JVSmFMM0JEQUpua3BqSDdDenZrL1ExRTJ4V3Z1UEhnSHowMC9oK0QzamZRVThQd3E3azgxZ2c2L1E2ODZtdEI5WGVkZk9qVXZ4MGtZcnprQ0doVzFoYzZoWU9Ea2FTYTNEMi9wL3h4eTQ4ZGpGZlduNjVIVGdSWUxLN2s5MEJHNXFWemtzZHBNOVdnUGFxcEd1Z3daZFhsMzZHTFZQdTJzT21sT210MzlGN2F1VkRUZWJUNXRIZVY3ZFpOeXVPUnRycTJVcGtBN0tDdWFKTEtkYks2anhZcHhGNVZwZDhNRTU5WElvUHBsZHBtWjZtOHE1N3BjZTZMNzhLbSs3WkUyajkydnNadXRHeTBrWTJ5OWxjcDlGRGJyTFp5K0xDWWl3MGlHbEJOaWl5ajNna3lwdmdXV2tsR3lSdkxnYVNhQ2F4YTVVbnU4WU9US1E1UVNNV0tKVHFCQ0pCeG5pQ1UwaENncmRBSy84aVpjRVZDWlR3eHBPbHpsMVZNbFhQRzNIaHAybjVabFFseE5KVGJDVTdhVkVIYS81dVQrZ0tKYmNidE1zY285MnNWSE9OdkNQbHBxbmthcm5rcys5S1kvM1Z6WHBwbkhvUGh0SDRYR0VFVmZtaDhUZmVGL2xySWswK0tJYTNiRmxYQ0NlZ0VDK1N3eGJVbkgwUjRhSEp1bUtQU1NrM2RhZ0tJTFlkcFVPNzE0SVZnRWhjanpiZjhPUEd4MklUY043RXo0L2llcmdwUVFLNFNPaUNsNE9TMitoSGpZc1Q4ZFI5ZW5JQllFM3EwcWxSN1pLQWlKQUFIK1J4dkQ5Q2hmUnYzbHhLMXVwNzVZRzZXbWRoYUt6SHpuN3dCVG45TDRHMEJDdDdzbDdaazExWTIreldvSHVCai9NN0gxeDc2ZVhYMy9palNHVDBjeDhIeGkrY2YreWlGZE1YSmFEYWJaYlozZ2ZUdWJkaStpekkxR2ozVWNCTmFUQlR6NHBiT1psMmErcFplL2d5WElGekcrZm8vZEgwanZvWjMrdit0Q3RmZktNUlNyOXUwWkFvZXpRVUczVFBCOHV1bStvQlp4SjQvOFFUVDNTblRzOEdIM3oyTXJ6cFZIclMwK1p2bU5ZdGFuQzRaRGpqbDRuMEdQUW9XdHQwS2gvakt6R3BnM1EwL2duMnFUMDdlellPakhPUWE1ZHVKWVFCRHFvcUJFbkFSbjZRU1l3SXU4SUhmK2tWNk1NUFVBMUE5VDJIbmkvTFpFT1ZobWl3MEJrMGtCTDRaaElodlVtUFFPUktMZk1RaEFVSGRZZmJnZ0VOT0ZRUFNMWUdtSEZERXRKTS9sbHk0cEp2Z3A4cUFFZitsZHg0UCtUcGxDeEJhSDNkZ1I5b3BqekdEL29iM3Zyc0ZSOFJrOVdQeTVMSHRDbmZrMy9FMWVRdjlIcVhZcXdGb293SjFwYkRzRjdCUStOejd4NEo4dEZOWTB3cWhBMkF4N2orSFo2YVFCakIxUDE1TFl1N2czbHR3Vi9Mc3diSXhxWTk4TWN6d3R6bFNvaDM4Q3l4bnJ6NDBNWDJpTGlyaDFYZHNNMVVMWUdVckE1TDRVbzgyMDJvTTZDLzZ0UXVJbStFSldIZnI2cWNreDdrR09ueEs4MHlBajZGeW9KMDNYaGQ0NndhZXpmMmNtU2x2QlYwVndEN1RlaTlzN0xhdlhucDB1OWR2N2Y0YWtRWS9kekhBWFN1NXk3cWFzWHhwZmd4aTBySXJ4WFZpaVhnZW1UMGRDd05WYmx1VnkrbFdodEpNVjdtVy9FS1VBb1FxcEpxbDNtZzIyRzFyNUFEMjNRL0RIek40cmkwVFVWM0swclJaWHJlMTdQMCs0VzJQRkVwaWVPOVU3UTh4dHZ0QzUwT1ZWTzVCRG5UbEJkSlc1YXY4aDlRUHFEcHNDSGpXZmtlQ1VkejExUWFGYVpzcFFoNW9QUmtZNXFoaTNmNkRNZkZJT3FzTXJDMXlzZkFEMkNPaGlmQUJuWUU3MlJPU3VuSkN5VWFQNHdBbVEyUGNrelNvRFdDVHVUUjUyVjRnVGdNYWRoQWZZNk5aR2locWlGQVVoeHRzMHFqOGc1YTRhKzZYZmQxZFhHQXA4VmFGbzM4MXZoOFdKK0NQdW9oN3ViaEtMcFMzU2FYYVpJSVArS0JEMmw4UjFVSGxkQTArdGM3TWUzSzB4TEVCZTNPV2RYUDJSa0ZwczVYZGJhQzlkNlExdWM4RmtVdzlaUFZxOGRNSk1xTkhjWUNVMjdTOWVOUStsYmZsNlJHdXlEY0pncEw5YXpxTkFYTzBMWDJaZkVqWktuOWNPb1hzd2dBU0djbm1LYTZVWWI2cytkRW1hdU9tRUdWTjJaMThDNzFjeTYwZkxFc1RzdUs1Yk44ckF3dmZjRnp3L0Vldk9Ub2FkUkV4bkc1dFlPbXVsdlBUTitCdEMzaWIxSFhidEltWHJ0eTlWK005bkdObDMvc1Q2elFrcGxXdnJ5eWNSdGFobXJxSldvN3VxdHRIQUhJTDV0WGdaS0tkOU14VEZYdXF0aW1WUTNLKzBjeFJVT0ZIWDR1OTdJRmhOWkloNmJpU2JjZkIybVNacTlvWURReXBWWHBVeTFTWlhLR2dQZWVMUHYxcjMrOU8zdnVRdmY1ejMrZXpWV2VQeXhuOGNOOFRNdThLai9kamhqSUtacDBiKy9iY09XdTNkNHJhUWdFamk1TDYvcjZUcXd3Kzl6blBvZGtzOVhkdTNXOVc3Z25JTEdHSDBNNzYwZitrdy9aV0FBYnk4cDJlNTRRb0FSYlBSTUgxRlNwbWs5K3lNeWZqeEIweUN2Qk5GS0NqNXFBUWZ1dy9VZkpWVlNoZndWTTkxQWZSRmdhdDJXUU53S3ZYZmNBRXNBaTZERWQzWHJlT2VzQVdaQXQ3UUFIZElybUt6OGpQdS9OZDFoR2Q1K0w1ODc5Tlp4R3Q2cUw1dTl6eTB2OURDdVBLZzMxMEJYR05MeXZ5L2lUREdpTzhUR0swMmZSU0h1VXVuR3FqZ3RSOWdtMHJZb0lxaUc5SDhEbk1XWktyR3l5aTcvVG0yZzdEbjVGbVZDRkdIOFNWWU5IcGZ2UlZsS0Y3VkxBZEtxYysycXhwMDduekk3WWZBYUhvQnZnbFVmZWo4L2t2T3g5M3EvYzF5M0Q5QjhnOGpYUDZwV09VWWQyMGVzR0gzQXZmaGtuM2pmcDZPYTkrdkVOeXI1Q1dSWVdGMTY5NUx6RmtYa2dCMUFMUEhIUnJ5cFZKRnBVemhlMVlockhpaVhvNWxmYmU4OWNINlBycWxUcjhjRHF5VnhORWw5N2F5bHhmQkVGdWpZZWpTL0lxeVJDM2FyU1ZtWE95cDlTamY2YTFpK2YwMS8zcWdnVkp1MzdhWlltTDh0a0pTcFRhWmhPR1NlSXAwNlFHTGpuWEZQeUlwNXpOTjk0NS9zdTlPeGVlUEdGN3V5RnN5SHhBUUdoUjV1a216NUd0L3VFd09kOFJjQXJUaG50bjczUEJnTS9uUGZZMCtWQWsveDMybzA4S0ZQbHF1Znd3OStHWVZ5bEl0b0FVZ2tEVWx6VE03UGREcFAwYjgzZFJ0Sm10Z05TaUtlaU9uVUdSaElHdFE3dkk0RFVLVTAwNEgwSGlmaVB2VkVCMWtsMXVwVFZxWldXWFQyZGV3YkV1ZlVDQmdNdXpwZFVRaHBIdW5MOEsrZlVJaGtCcUVwSGJuNWpuY241cUlJaUljaVAwQUFadklZbTNrVGtQdzRmM0VOVSt3QWdqWkZ5TnFRV2xRNTBvNTZsWGhMQUVhaDY5bFI5S3Q3NExGOWl3QXBVOHlQcnRERGZQQm5GeDBGSjFWVmpsai9BcFFkOXZJTmVKVFJ5akk5WDlOZ2M2T25yUzRHVWsvOTNVVjFBWGFTdjdwdE1HWnh5V2hNQUI2K2oxeUNkMEdBOHBlNEFadmh6d0lDVzlXcVhzbTd5cmpiaFB6bFNOdWFmeG54VzRzVjh1SnlzYi9mY0dSQ2UydXVlRGZZQzVBbHZCY2xXaVJONnlOdnJ3TUV3eWdURFF3VVI4M09KbS9PS0JWZnFpM09hTWZZOW5Oc2FORXNCNzJlTVFhMERCZ3o5T0t3Z3RhNnNNRzJQc0R1OGgwVjBzY3VVYloxNmRuTnBvWHZ6OHVWL2RYMXg2WTFJYlBSekxBZkd6NTk3N0dMNlpEVzAwWmF4Y1E4MzhNRnpTZ0haUFZWMW9MNVcvV3pxREsxVUFtdGRWVGtOSjhBVm9KVzc2YWJiMGZ5bHBmTFVGdURiNStOb1BjNi9EZGVtT1h4dnBTdUF5L3lTQjk1TDM4THlRamMzTjBjbG40aEJMZ2NBMVVWYmJzdHFCVForWFRaaXkyeGMzUXBjU2Uyd0hQSzhhRzd6SHFiWjUwZ0RXalQxNFRML0FveHpxQWcyMEUvT00zdkFIZkNuYURBT1dMbGRYZ0FCalV2Z2MzV1YwbWpaeWxzT1p1am5sQjMxdFFKdVZBZmVwUktoSnMrOVQ5cU5IM3pwYmU5REZZQXRiVXBndmwvTG5oOEVraU9kZU0vd29xWXZ4Y0NaUUVlNFRYUzFaTThvdTU4c3drT0RtN1U0TUtUT2NZeHlGSzhpYitKVSt0cEt4QUs4K2NVemJvYno4K1d6Z0JQaHFVZmFWZHNxVEVtVEVaZThLNjhvdkQvUUV1K0xlc0xMaUZrRzhkNlIzdVYzOFNuU0JuaDlMMWsvY25YZkpNdC9YWGszeVFmSWRoQXFGSGprQUptQ3l0blowK2pTVDNXbjJYRkxnY1g4RE9kK3NoU0REMUJLKzc2amJlNVZMN2k0SmFaWlVScDVxaW42aXcrV1F6cjlFQWR0UEt0dTBDMzB1dEFnV1B2aDNLVCtyREhOYW9kRkgzNmMzYnRoQmYzcnlqcm5vQkhtZyt2WHYvYisycHVzeW9vT1J1UTMrcm1mQS9lQmE0RlhXNm04YjY5TXhrK3pMNUdLeTh1UEN0Q0RxL2VITDVDWFZrQmIzUXpqVmZvRkpvYjNzcEtVWCtWWjRmTjVJTG1XZjRVM25LYmM2ejRjKzUraXEzVnI0d3V1bWtwRHUyZ0wra0JIbDh2ZXZIRXp3T1BwcDU5aEpkZFpLbW1XVS8zbGdCOEpxaFZmUHJUZ1dqVEk4OHF6QmMraVlSQXVhU24rR3RZMEs0N2huMzdxaWVoSmJEQ0RZSW5hNzVKSkFSTlJNRWJiSnh6UTBoQlh1bXkwQXF6MDcvUWp4WExBRDZXbnQ1cVhVaG9Sc05GVEF0WktjMEdiNzR3OGxkQUthRVBTSjdSMCtiNmx6UWJ1WlZydVh4cHhpR2ZEemxGMlFUN3IwQlpyNTgzSmtleVlzd29kRUlxZUQ4bFFsUU5MVWV1ZGxCMDBrcDdQOVNHemJLcFBOTGtnd2lJcm9VRUw3aFZIUGdTTlBkZ09xd1gwOHlxanYvdmd5bE9MN2t3Q0FWQ3UraDZuL1pESk96NTRNd0RvRENmOG5tS3hSTlFkMHBsbWtyNXFwMWtIUmdGVDY3czlKWHQvWnpoeS9mUnBsdzNQaEwvdlFOYWJWM3d3ZUZkS3FybDNCTHlFZnp0SXZ2dXNBSE43UXovNE5iTkJIVzNFalhMNURnVmUxRC8wRW1MdUxzSUFYeXFKTmhoaExRenZFVDN0OWlZRFo1dk9nTEQzZ0k2VjdzSUcrZURTM1ZoY1ducjN5cFhmL3NHVmxaSFVXcFhpQWZheDRGcGhvd0ZaZ3hxalc1cXFkR21udThDWVVvcVZ5OHRHTllpamFpNzFuQVVLQlR5RE1KbSt6K1ZXOS9sODFMMUlxN0ErSHcxZklRYnVBNWRqN3FLT0RmS1F2a3BiK3pSSFE3dXZwNVAzNTVoRm9NUnhscjBLWmsvTmNyRThrL0lwRDFtS0dFQ3c4ZEJkak81dzAwaXB4cEY1cGozSVQ4ZVcvdlkrSXZCalk4OTRlUzlJcVc3UmR0WFdoY2ZZNUlVRkJVc3J5OUE0aDY1c1BicXdncUFiaXdUdm8vSHhJYkR4MFlCOHJZS2U2OGFsM1h1NzFRSnNycDlYSlNRQVVqcDVJbmh4R1RGS2kyMzdKSXVnN1NnZzBmQ1IxZ0w0Q0Vma0hwUUk3NS9QcGtVQ3UrN0VENWlZcm5wWDVVUWJmeXdCQm9TbU9JYW4zb2s4cUh2enMxekZMMUlNUG9YK0dML2dHZWxJczhBYTRHcmErQm1tM1B6MldKNmNkYUF0OEZ0VzlKVHcxdEYwUVU4K1R3SjI4c2ZCWG1kdXhKeGgvS2Y1QUFpZXM5U0xHWFMwcWtXTXEzdm90TW5mUWVKcHdOV3lrbVdvVW1JOGczdHlEYUMwYlBKRWxZQ0R5Y1lKcVpmcGFXNEtNNGtVYW5tVmd2TTUxWFF3SmZsbHVTMk50QlBYSzBCWG5rTkR2VWZickNxcEFHMkFXaERlWVZiQUJrdVcxNm03Njl5djRlWjZyZmR1enYySFAzL3puZC9uZG1RK2hBUE1Gcmh3TWNMRTU4czZuWTFldDJyQTRkLy9EQnBOMzhEN3hwVGVWbkMrb3J3NFFkWEdWSlZXMitjQ0FXMGJneFVvS2hFSkNBNVdyZGJjVHdPVmhRcWxLYnNOUCt3K0hHYjRlVGh1Nk9sSTMzRERZUzM3RG5wVTZiWjg2cFZ2M1p5TEQ4YXp6ejRYVTdVQ2ZJanJ5R3JGOTROaUdZdDNrVFlWdkV6eHZQSXN1L3hiV3g1NUZaQzBIeS96VUhLMHNUMzJHTWZZSUdVdU1LcDdiK0d1d2hYOFIxcUJGbmtzYU5pSTR5L2VJZUJKQTdNNVdoV1VNT1d5Z0RyQk1sbjNGVFV2M25ER0pUNEZqSHNER2xZanVHcXFyUGxFT3NUMThsUlQ5YmlPa2t0djFBL3B4czF1cWNKVXFDYVFFSjJpdE00ZzBDWVNxM05kTlhaVHd6WnY0aFd2S2o5N0JwS2d1eEtxSmo0VWhBMytXT2Z3TTkvd003elBoQlZFK1k5d1JWdlJYUjhIZFo3eXlTNjdRRGNGMEowQ1dNOHhIZTRNODQ0Rlp5WFNXYVRRV1FaREpjWlZVSGIvbFVoajVCK2drdnVod2dCMFl6QVBBSlFtVlF2T0ZuRDJoM1Q1NFZOSUVjRGxpenBqVitNcDZZWUFBOEM2K01YbHNSU05GNmQrMmZZbm9OdHo0aDViWVBaeVdhdXN0TTdGaHd2d2RsNnhjYlhIT1dOTllGMWJaL0NOaFFtcjlHWldvV1dlS1dCejkrNWQrY0VIMS8vbDNaV1Z1OEc4MGM5RE9ZRGsyb05yVk1saytuQU1YM0laSzNHOGRMdUNVUm5MdHFIWVNMSVJHSDRRZHFCN3lqalptR3hRMVNpMHZaUVlXdFBtbmU1SmkrNnRYNlZUY1ZzLzNlclovSWZqVmh6dEF0ZldyYjNQd1Iwa1BpcXR0ZFQ1bHg3ZnZVVkZ2TUJ1V3M4ODgzUjBBK04wVjJpMFVVcXhEY2R1WE9VTjE1cGtzeXhGWTRVeFFOMlhuNDNkTXJUZzZyTkdQeHZRK3ZwYXpNZDk5cGxuYWNEajNjTGRoUURZTmZaRm1PcEh0bVBLRVRRcDRaRUxGN3pISHA4Q1FIbUhIcVpvbDEyQVV2OGEwbXZrcTJScG84LzM3dHVPTjJJZDBjMlU0RXNaNzZWVkd1V0JVOGRpZVNpOGlIT3JBQXJqMnpVV2RBK1lNT3ZPVjc2SExjQjFGV0JhNTBPbDVHcjY3dXRxbXZMRE5LdnNsWjlmQnQzc3VwdGZTdHVDRGNBTzRJUmVzWTlYNENzZ0d5ZDRUTGtEb0tBcVFOanlDMUNtUnhpQjFhSXFiOGFzRGVnL2hYU3E1S29hSUFIWHdjVlRsUFZVelBWZFpDWFRCcHUwT0I5VkNUUEthcDRtNUFXL25RdWJIODFjc2VVbUtmTEZNc1E0QnB5TnRnVU5IbE11T0k3M2MxYXI1K0hBMlRielp3MnYzdGFsMm9Ld3o0SnNmc1NoMi9jTzRDcXBCdGpEejloMEhORGYyMkxQQUtaaExUTXpZSTFCdDIzeVkwSVdnMWlMYjcxLzY5WnZ2M3I1eWpjUGVUMjZlU2dIN2dQWHZxbEVwR3JRd3lsa1JiUmVXRG5TTnl1N0lKR1Z0QVZPdzhjTHhmWnJLK0FVU05oUXFqRkdHc1N2eGxQNWwyMU8yY2I2VEljSkczcXVlTnJ0L1ZDd2VDd2FiTlFQTTA2QmtuNGJndEszSStQT0I3ejZ3YldZQi92NDQ0K3hiV0VlZmxqbE5tM3ZDeENEbm9DaDVHRlcrc3gxbU5haVcxL3Z6VnRlMXJQcG1uNmxUWXVOMlFIcXdzK2RQOHYyaVJ6bEREaXVzTEpzZ1cwS3B3aHZmbmh6YVNkSStTTFZ2am5UUWU1NkwrREd1NUQrZEV3LytZbERkSjI1RjNTSzdnSlhuNHZPQWxkcEZ3aVV6T3p1T3UvVmVoQ2dnZVFrQUhDc0FabERsKzdrNWh6WERhY21jVythZ3F1MjVhNDhwZEVyZUVJNFFWUC91cVJEc0RVdmRibjFIT24wNlViY0tQSWdmY1BWVldsWkJya0QwWkdmWlZmOW8rNWFuaXZaR2xiVmtVQnFIczdXcU5relUwaXZRVGYwU0xNZm11akZBV3g4V2tKcTNOcDBnS3JtaktjdTM3MTlZNENRU1UrUzdnQUFRQUJKUkVGVXJMY1p4SklmSkJTcnMyTGFscnh4OWdqaEJGTWwxME5BeGMrd3NtamlKR0RMQjhKNjd1Y1V6bEdYczljbzZHOGdzUzd6RVY1RHd0MGkyZ29mbTl2VW5VdHpjNy96N2UrLytRZFI2TkhQSTNIZ1BuQnRHM3FsWUdVb0V4V0RaNTJzSEs3QU9hell1UGxTSzd5MkZVM2JNRjVXY0N1b1hSbjlkRHNLeEg1aE16L3R1aXIvcU5nOERMc1BhRGhLcS9IYXNONC96QWdhclJrTzc0Q0M5SjVHcDVaNXVnSHlUQnpEY3VuU0pjcDJrZzIzM2E3dzdHSFpCR0liYWFVVjlEVGdhcG5Lci9JZWZpNTM4MjdUa29lNlZSNUtadkxYeHJuTEtQSTV0azE4NHNrbjRxdTBzc1paWEN6bjFjU29ObzFOY0QyVTd1eDVDR253SU1Bendna2lnVG9SMWduM0JjZ0pzUERMOTBRb2FYWTFsMGE2cEZOVE5QdGh0YjRvbFJsSEtjKzBRcUszNFV1M2M3c0FSNmQxalFFU0d3SVRsMjZtNzdyNlNydnFqMlgzTWgvbFlNTjVtWGJRaEp0aHZleWVsMVRyczVRYlJ1bFJNKzBKcitROWZFbWJkZGZML1F1eWgrWkhSM0FGVUxFaE1vN2RqandJZjVwcGJhZFFEVGpRcEpzMENvcW1JY0RKQzBFM1prRVFYK25ZajZBZ0tzc0Y2emhJRVlETG8xZVFXT2w1Q0tMMm5DUjdsNEVtUDRTZXRXWCtPZS9XZ2NPU2hGTzk0THNJZnNGZXZPS05DcWFxQWxSYnVaZUFTNDYzNFc5c0prT3ZaUlAvT1FaRjM3MTUvWGUvOWNwcnZ5ZC9SdWJST2ZCUWNLMUsydHE1ZS9xZ1d4WmRGaXFHWFVsZld1eWxHZlUwbWh2dk8rMVNua2VYa0xEVXRkUTVVWkhWUGZrYzh6WlZ1MUpKL09xR0pHUFZ3Yy9LckUxN3dIRERaYmRWMnl6cU1xNG1Ha3hqbDF1ZVhaVHhLaDF0SzdKcGhFVFF4R3ZUOGI2NldMVlNTamNialhwSmdmWEtsVXR1dzhadVdrK0VCT3U4WUJ1UzBock5pa2FXRzNCTHAvR003d2ROb0k3S2o2MWJOSHpzOXFQUmdsVzVheWRkQ2Q1YjlIRURBT0NmUmtsdjl0VFo3cWtubitLSWt0UGRIQ3FNTy9OSXNBNjBBQXByREhZNVNDUFhIS252R0ZCeU9wVkcwQVUxb2dIS2NTS2dWckNibWRJemNBVWdPTW05MXorU252U1l2MkNrcVJrRDBxNmJ2SEJrVzNBUVhGejRRSTZoRGhDZnRzaklCci9Od0lyQTZwNENtM1JSN1ZJTHhuc01zamlRSkJBSmpYYk5mZllrWEFGeUlnWjZVcjhZbTJVVExnWnE0bU1Hclc2QTRpQVJ6eEhQTHJQcEVNNDB4L2g0VERoQUJYL3NWdWRzaWdSUEpXS0JyTVlMbk9LbWZsWGoxbjF1eHdkY0JjL3M1cnZNVlZBTlBhbkFiZ094RHNNTDNuQjhaT1JyZk54QzBzU05PQzZ4ZFRHQkg2RUNZdXNseFl2THVMNGpad3JRNEJpUXMxRkFOMlhaUm9WQ2x0RmVyS084TlBpT1huYlN6Y21oMVcwbXJYUDRPT1YxRytEZW9HNnVJelJzNHJDOHVkWnRVZ2VXMlZieSt1cFM5L2ExYTEvNEw2KysvaVdDajh3UHlZRVBCVmZUcy9FTzdHek1DUXI5Vno5ODgyZFk4bXRCd0hzcldCdFh0d29qb05qOUVYUnNsQm9yVjRCRlQwUEFuNVhqOE5tS0pGaW1LY203L0lmdEJHUlNhZklkeEtXY1RickRjWDB1TitNVTNSVmYyK2h1K0tJdTFnTUduM3YyK1poNlk0TVVtSGNaRU5Qa29FTk9UeUpXbE1IMGh2TXdiT1haK2xlNFlYdUxnU2gzT2JLRnFSOVdLclRiYWpmVktVRnVBcjJBTkxMQkFBV2NCNXl5SWJvVm9TUFN6aFdUaDVaRFhhUzhEVjdSc2wxSDc4NVhBWlJNT284UEVrQlZQRFc4OFh5UEd1TzI0S28wR0I4bjBzK1BHVERSaDFkZm4rQ1dLNURjcEVWcExkYm1PMEZlT0ZMNllrSjc4Y004Qkd6VExjblNjdXNmSHlmbzBTaHBIaHE2MzFHZWh0ZUd0MHltYzVMZHZ2MVlXT2RNbzFRZXRiK0M1Yk5jd3F5RGZER1kxSWMzanZtVEk3eFNjclJMcjJTb0NzbFpNaWxkRzBLNVFEcGttSG43QWZBNUpkU2MrV0grUlVmUkg2bGJQdjk4Ui96NUhzM1hqOUxXRmtjVEVYamZSUmo0T1VMb0FCaXZpUStaaWdkZEU2aDlkamN0MVM1S3JWNnU3THJMSE5kTE4yOWR1WHo5eHBlKytkb2JvNWtCeGZ3ZjBuNGd1RllGSHJadFNMcTFWK1VaWWExOXZZbkt3MzFWNW5vZWp1dnpRTExKTGsxMlZWS0NNcm1vZUx4ODdueU0vTFVyYmRPSUJtVjlDaEpzWkJIaTBEWnVnWVUrWlZwNnF2THFwM3RyeDhPSC9CaEZjSjJmdnhzU0RnT0dzZUcyamNUR05UM3RkQmhiVnQrb0lvK2tYUjYwNWFtOGl3Nzk2djVCWkxqQ1RIQTFqenlOVlprR2lZMTgzUlBod3Zsek1mbmNRWlpGVkFRMlpxVnUyNkVnN09HRzBxR0VhZk5NZ0ZFS0ZseHBuRFJncGJsSnVzK0dnYU42UVJlQVNobzU0Q080K3NFUTROUC9jTTArYWRkN3NneUNoTUFxNkNvOXluL1BuTXBkdGVqdUIyalE2UEV3clZQVHM0Q0tKZklEWlpjOHAwTFZBSjFoMGgrZVNoZFg4STN3OGs1SnQvaVlkQ1R2ZlQ4QjFFclZSYVBFWUVJdUJPaVM5OVI5M3AwZkI2ZFdPVUFuS0UveHNYRW1SQjdQVW1FemIvUFRCUGg2UTl5WVY4d0hWeC9wVU8yaHNhdGVLNjRzcEwyTFV0Tm9XM1hrZGFwbWVDK1d4emhjQXJpYmpidS9nY05oMm1QVWhUSEs1bjFzRk1QN05td2VzTWdBbU0ra3NZVWt2SWFLWXA2RkF1OWR2L255MjVmZi8rY3Z2M3Y1cFNCcTlQTTM0c0FQRGE2MkpDdFpOZkxXRG5jcVFPdldVbVVsc3lMVlZYNkdyOHJ0a2xyOUJRY0JWb2xQU1ZhanU5SlQzY2NOUDhZUFFPakJxWFgzdnVqeFBvQ3RjZFBQeTdRMWZ0ZGIwOFp0N3l2TXNKc2ZIeHVwMjh4ZHUzYXRXMlVKb1J0dUs4VTZjbnVLU2VLV3l4MkxOUElrUUlqeVdrN0xVZTdhdytsTHAyNFB1bFN4YU94YXVwbUt0TmlBWS80dGFULzcvTE5zdFAwWStaem9idHk4QWNEZUM2bFdIYWY3RERodk05UXhpanJFdHlIWElJMjA3akxRb1FTcEhsRXdWTExUemg0TDc2RjUvNGIza3RaRHdPSSt5Mng1SGRoQ2VsWlZBRDFDcGwxcHQ5QUx5UTgvZVNOZlFncmtlWGFHd3lQSk0yY2EwSldIRnVPRjFFdzVKVHQwcXRBZHZLdjhlUlowUGZ0S0hucTFORlg5VWFjY2hueURkdUpyVE10OC9MaG9IRnVZQmt3ZDBJeERDeU5ONk9uQnVkSXpyT2xvek5ONnJvcXN3RFhWWkNCbVgrOGNuUElqN0tWYkFLbjhsWDVzTlRZRnJnR3N2RjAvUUFHWTlGcFlYWXZlbW84ZWVTUzQwdk9EVGtZcTQza2JYcXF6VlZyZFlqYkFIbW51OFdGYlJwMXdsdy91ZjcvOHdSZXUzTHo1TzYvZnVEVmFKT0JMK3hGTXRzUW1nYWlRL1hQZGw2Mno5L1U4YkVlMHZ2R1VYNTlVVmxUOHJIVERmcFd1bGM4alJGekJVcFhmYmM4RUkrTWRmdm43UkUybktxNTJYQTdJNEs2SkxwRDMrUmh1NWRmYTN0ZXpqZWZ3dm1sWWtWNy9IQW54WXpqenJQRGxyaVFEVnNadVduLzVsMzhaNWJFTXYvQUx2MGczREYwYUZidytIcFpKcVUyamUvQ0FOUFUzYlo5TnY2N0s0MEcySUdvOFJUMTVacmZWdkxkWnNRVXF3ZCt4N29YUGZLb2JwMHNyTGQvNCtwK3gxSEdKOUpuSWpvNVJQVjlNaWJJQTBCTWdJZjk0dEdITG4wMUdzMWRQc0UzMHFZT1k0Nm1PY2d4OW5SOUMwL0dpTmZPK2lFTzhFeWR5ME5QNzZ2a29WY2Q3QlRUTTQ0RDlCUEJHajlndjc2UU1ibVJ0R0hraEg3eFVjOGl6NUZ2MmN2VDMwcmhwakZKZDFBWFQ2RjkrelNBd1hzdlRDbGZwdXk5dDhONlk4cEcwQXJqRlI4cmx3STgzQXExVG9hak5oSmZmV1VZM0V2ZGRPU2svVFM0RGpxV3hwQmRINi9BQnlnOHdSNnpVKzZMN0xoOHNoZS9JUzMydG9PbDc4RGxVRStRYzc0Sm5TQXo2M0d0QTV6MEpsWDdUNENOL1FxU0ZoeWZkUFlid2xoRThaVEVBa2kxUzdnNDY5bDEwN203WWZXZHA4ZFU3UzNkZit1WTc3NDNVQVBuaWZ1VGZCMHF1cGx5ZzBkcSswekxsWHMvYXZ1L1dWQmh0THl2UXNDay8zUW1WM1RNQXFzSlc0MG5KTGh1WmNhcGhWSG8rdHpwZnc3UW1uNU9PY2orU04rRnRKMldPaTI4ZW12SWJ0dTB1Q2dqT041Vis1NWE2WmFGdXpqQTRkKzRNdHZzUnNGR0hqWWIwY3RwTVNqWFJzUHM4S3A4Mmo4by9pRGp1Qi9LVTdBU1I5bTI0a1l6U3FaczVDd1llMVgyZWxWeGJBT3kxNjllZ2M0MjVtV3pBZytSa2Z2NHA2U2t0UmY1UmJCczRRRWdqVnZMeVpkZTh6aGl3TkE2T0JWN3hQa2lybm90YzAxUG42Q1lpQXFHMFlnVnd1bDdlZU5Mb1lFdnlDRWtSMnBVNkQ1ZzRVQktvejBxdUlVMFNSNXBkZW1yNmR2OU5XL0R6UGdhTkNCdGxnUkJwOHYxb2V3bDJjZGtOSng2d2xHR0NCNzBVREUzdWhtV3Q4b01ZcHo0UU1qOFV2c3UrVEgyYVVVNGNMWThmSG1jQmVCSXVoUEdmK1FpZ1ljaEg0MkdHOW5xVVhOUEwzSHduMGdDdGJPNml1NHRGQ0JFQUhHb0FudTNUN2ZKdThobnBtT2Q5M3hmMDZPWk1nRlhBMnZPdjNMVDd6dUp5ZCszTy9GY3UzN3o1Zjc5emRmNkwvLzNXdGY5RWxKSDVNWEhnZ2VCYWxmQitPNEdsM0lzT243MXlnblJXcVBKcmJjTlkyWVliWHJtcEZ2QmVZNlV2U2NOR0ZsTlVxRkFWdHRKdGFTSDVNT1UyYkZ0Ump6T1ZwK0E2SEtlZWpXZTRlbTd0dW0vQlZkb0ZFU1ZFOTRLOWQyK2hlK3JwSjBJSGUrN2MrVU9wVEtDS09ZeTk5R1ZhWHBaL09NOXdlTWlQRXBYZ295N1MxV1R5TFhaSEV2UUVFN3E5QXJnZklkVURybWVYdGp2emQ1amp5S0dCOEY4ZUNVd0NaM3pnQkZ6ZGlLTSsxOWNqelU3blVzYzZnZjQxMUFUa2E2L2FPTkpmdkNvUWsyeVhmL294Y1ZFQ0tZWXRxR2xVQit3Q1FBS083eUVNUElqOUFJamozTXh4ZG95U0w2WlpBMW1WbCtIamcxRDg2OStsWlRGT2hNdFVqL0JYZDlPVGp0aGJvSzkvVVNkSVE5dWRydVJsZ3B4VG5wUTArWUFKY3ZJQzIzUW9GSGxSZnY2aUYyUXBlZmJldlJ1Mm5aRUJIeTI3NlZwTTR6bWdwZkVFV0lIWWozSGtINjc1WXpqZ05la2hvaDlNZWVWcXQ5aWtHenIyNGdWUTc2QXRUc0lsamh2ZnVNck5vMlR1c2NEa0h1OTc3dDdkMzcweGYvdjNyMTErLzh1dkx5Kzl2TGpEUG9najgyUGxRUFZkZnFSRW8xS1JncllOVitPOWxhUDh5cTM4STFBZnJzS1cxQ2JRV01FRUo3dTFLZGxrMnJrUnlVRFMwSzhhYzZicDk5b0dVVFFNYk4yZGhGT1Z0dWhyN2RCajlYUzM3bTA1am5Ndk44dmdKZjNTcFlyRFo2WFg3M3puTzBpUEthbDk3dWQrUGhxODVaTmxMcGMxRGNNV2VKaG5wYWVmcHV4NE9PYkhMcjJqdmhvYnFHa0lRbnNzYTFUU0dXZmFqcW9YNTFOZVlJRHI1My94SHdJY0xMbGtONnBYWG5tbDIxckw3ZkhVYWNhdVdIQk1Ha3hYdWs3RWZFcjBvang3QnRRbWt0ZzJ1eWRONFM2SU93eVdSaUF5RHNBQkRYbndZZ0o3dkU4a3NBQThPckh5U1ZyTkowQWw0dlNqOStTcFR0R2RtVndBY0ZiVmhSOE0yQ0dFeFFHQjJPNzlhaGo1RXdOWjVFbW1oOVNFRzRRZEFOQWFhVExzOEdYUFdrNEhud0ZFd1N2TzJZSTI4NTFoUU0yazlaZGVTeHMyTjlMajFvT21iZGlnRS9vdGI0Rzc5OGExZmhqUDlQVlQ3dGJkTXNZRzJyaW9QellEbjMxd0g5a0pQbUFDdVZLL2NmYVlGeHp6VllNLzdtSEJ4aXgraUVqVG83ak53MWtCTG1kbUR2VExjeXNyZjhoeDJhOHVYTDM2OG1XcUhUbU16RStJQXdHdVVmbXAwR0g2bmVoRGo0U0RGVWwvMzNLRW84RTh5Rmc1ckp3UnpscWhzYWFXd1Y5bi9hdXloYjhWTE5MUFRYbjFFM1FNWndYVnhGcHRwS3pidDI5RnhSU0E5Yk95ZXNXSUxYRjIyT25keHFxcHVQVnNSZFBMZElQV0lUc2lVV24xbHk3dCtJdm4va05CNVQ1aUxKL2wwdUxQeGhKSGFkalFpVTFSa003TUQ2bGtjN1g3TDEvL1JraEJrOHc1L0xtZis3a29pOU9OM0FHKzZMWGh4VVJ4aUpVWDhpWkdrUUVnWndPVXFUTDRITFJDNXlUNXFHSVRES2NtcGdFVFRxMTFQVGx1ZGczNURRbHRlbll5dW9lN0xNdjhCei8zdWY0ak50bjl0ei85L3lMNVUrZFlYY1RkRHJwYXB5WWhOcXF5Wlo3ck5DQUdiMG5uQUZCMmU3cFZQRTVTTDJMamtYRUduRTQ2U0pVYjJLalhreUIzVjNLTisrNWt2czg5OWtRTlFnVUw2ZlVpblFNR2lIeFBQanRIMkc2KzgxSVI3UUdMYlk2dTVrUEJVZE5oWUdxK1UzVExidEczeDhJREFGRys2QzQvRFNrUFBXSWw2Z25sME4xalZiU2RMU0Z2NVovMXhEMU5yZUdCWi93SXJDZGlMcWtmSmlSVzZrK29HK0RGQ2VhRGVscnUyQVFmSUFCc2w3S2VPRDNWZCt0UkRaRlhnS2wxQVIyblIrSHd5UVVnNWFjRjVzMmFoN0JNL3FrbkJYVDMvTUNsdnB2YzRUZkFTRnhxRm5wVTlkcmtwMm9HRjZYWFBmZHg1ZG05aFBlWWlrVXRpRmtDVzhSYlhsdjcvWVhWNVQvbDRNRzNOcVlXNXk1ZkhnRnFWcDZmL0crb0JhcGhabllKVEsxYjNXdmJPQjltck5pYU5rN0d5MWhXOU5hMGZubHZIbWxhdjNKelZOazhvdUZnRzZZdTNiMHFYdEVTQUVXKzVWNXBsZit3ZXoxcjEyV2NkQi9RVittMDlvUGlHc2I4M0lYZXFWckx5eXR4WlBmVFR6OU5PMk5iTjZiQmxBU25iYU0wcmFMUitNRzdKdnMyTC8xOXRnR0xSU0tqYnlMdmVmQ1p5OG5uN3ZTdnJ3TWtYak9NSnJ2NWlCdU4zT0hqNVNEaUpnQWZSMlRiOWVXVm1aWkxVbmUyVkRNNDZrNlBBdkFReEJ4a0l2UDRDRXdBNktIdmRBSXQ0cUs2VGplUzhZTmpRcTdBa2s2LzBiRllJYXBUZ21FTVlJbHFHbWxENVJBVDdnRmc0MWorYVNmQ3c4ZVE1aUpZZ3FLU3N5ZVlUbXNMa29RUDNoSFdlS0dIeGoxb05aNGZCTXBUSDk2Z3lUaTk4R0RabE41RHpSQ2ZtZVNCY1NvOWdvZVA1WkEvY25VWCt1UGpZRDNFMFhycTNPMllGWUJielhSSSt2RDNRNktFTE9DSDlFNWFQUXRVaDZndVVJV1RNeXFnbnpTYzlRdWtCZy8yNExIeTh4NWxqTmVLV21lVGorbmQ1WlhmdmIxdzcwczM1eGIvNkkwYmQ5NllYOTEwQjhxY2FnT2RJL09UNThBeDRKb05MNnRTTkUvcitaSHJ3OGlxaW1xNDRYc3JwbTVsQ2p3R2JnTy9nVnVGZG1zMnZzbzJBaXBaU1NjRnRJYXE5SStMcTMvRjliNU1oVDNPMXUybys0QytpdC9hRlZhM05tNkZVVTNnWGdRTG5OWXEzYzQ5UFh2bVhJUlZOVkFOM3ZMWlJUYU01ZFFFRUJ5VGZlVVpOdkZDS2lKOHZEM0RXd1l0MDRndU40M1Zld0RHVDUwUzkrenNtZTdwcDUvcXBwRUE3ekY3NEJZZzYwajJTWG9EN2dHZzFLdStjWjhkazF5SjVuSkxSOWJWTnlwcFM2Zmhwd0hYazh5Ym5lSnlOWnd0UHNDSU5BUUlSN1NWOW9RRVNWVnZHMkRTZzZ6SGRjZkhCU2szNHJsb2dIeThkd0dCMHFEbFZIbzhkQWMwalNNWWxwNDR3dmQxelh2alJKMkpnU0tBajdJWHNBcFlod1pKTUNSVHlxb3RrVkZIc2MzUG5mN2pvMFIrNmxKbEt0aG9RUUw0N0lNSnlBNzgyZnR6WUVyUWRJSy92QkJjdlVKTm9odnFtcUJMNlpadmxDdTlRa1VpMzh6REQ1THBrNCtuTld3RC9nTDRGdExxcnVTNUtzN2VER0gzVDR4Lzg5N0sybGNXVmxiKzNhMTVRUFhtblRjVzNFMTdaSDRxSERnRTE4cWRWMXEzWVI5cHVPSGltMzY0dVQrTzdUdEJxdnlpd3BKTTYrNTlXODhyYkp1Yk9qd0JxQVpCVkEvVVlKRGhTN0t3UVduTXg2dEFxbld2ZEN1ZjQyemRqcnBUb3g5aUttd0ZxZWV5cGMvTFJwY1M3SEwzNUJOUHhabGNxa0pLRnhlNlIrZytCSUMrNjNvYzl5dHQ3YUl1c0VvZzdRbko5aWtvQ1FxMjFmU0xEeFNES0VBRCt1R1o3a25td1hyczh3M0FkWVVUUGlkWmZPQUdKTWFYaDZIakpJR2dJL0lqSGV3NHRvUXBXaWNCZ0JsbUhjd3duNWNrQVZ5NzgzNzB5QmNBNEkzMFFDbHM1RHVLRGFjalJmWERUTXBIK25McHF0SnVBR2g4Q2hJZ2dkeVlXSjhqK3dBdklLbXBEMjJWMS9jczc3eWtMd0JNSGtKNDFBZkJrT2VxRjRZeHJJc1I1SkVjeXE0K3ZISDZsV0RMZTlNQXMrQ2s0T2VBbk5LMTZpdUFGSUJVYWc1UWJ2STBuN2dnMVY1RDFIRitYRVdWNlZtRzVLTWdiQnRVWW8wQk05STNiMSthdk5pWmdQZmtPd1oveGhBMEJGWTZFeTh0cmE3KzhiM1YxZi8wWDMvdzlyOW5RK3UzUjZBYXJQMnAvaHpPRnJCeWhjazNUNFhrbllZVEw3dTNyVmFQWWt5cjBpdTc0dmxzNVI0MkZhZjFHbzVySFBWUzBRaW82UHBiYWF2aDJGQUVya3EvZ0xUQ0dML2N2QzlUK1J4bjYzYlV2ZWRUUlI2eUsyelIwTWJYVGVsVUdpem5JdjAwQWRaZGtNNmRPNGZrK1BSaFh0SnNPWlYwVFVPd2piUzUxMVQ2bFgzbEczNzY5MlJHL2p3YlRhZHdCdlJpRGllODlHUGxGU2VSZ29JVDdweVBGQ3ZJTHkwdE0xaUYvZy9nSUdqb1A2ZVJLT1B0V1FEbVVRb3VTbFNRR3lEa3hqWk9RM01qNkJQb0FITTFFK0NndEFxWTJOVlZxc3R1T3ZkS2YxQVY2LzJSYkYzYmI3a24zSlBCc0xyQnI1UW1BUzZ5Tlk2eklVSmxRR3hWQk9xWVphb0RXM1d2ZWlKVUZNSVZEQUNTZ20veXpqSVV6M3d1TUZhbmF4ejVGSUJvL2VMUHJybjV1YTlDVElQQzNSVFZDYnU4VkNsZDl6RjRaUmZmRFhSS0lsWWFOejlWQU9sbmo4U3V2ZXFOcEQvOEtNSW1lbElIOEpCQ1l3b1ZoTWM5bWZCTzZUbk13RXVrMVgzZkdSU3dxdXJMdHhmdi9jbGZ2dkhXVjY3ZnZUZWErQStmUHlybUVGeUxJSnBEM0VhanBFSldCZFRSU3RnK1Y1eGh1K0lPdXgvM2ZIOTZtYjloNy9mVExWTXBXa29TMUxXa3ZiSmJPcngvRUxDMjRVeW44aTMzOWhsZmd6eVNNYitLYTRTaVdmQXdIZjNVYjE2N2RqMk9qbkZRN3VNZi8zZ01MaG0rSlBMNk9CanZzTUh5TG80MU1taUl4Q2dIZ1hWMnFwdDJkR214NVovelgrMmV4NVFpYUg3bTZXZTdHWFowV21kR3dmejhmTGZJUmk4T0ZKMWhucTRvR3NtSEJHejVrQXdaYUlrSjlRRFBOcXU4NHJSWWltZ1hYVFhETkJ0S203dlN1bElwbklqOG5jWVYzV1RCVENBRXBQd29KSWdCWklDMmttbm9QUTBydUFGQVNvekJWMWdnUHdJNEEvZ0FJTHZYdU5WbHVBSk95K3BISTl5YzJTQjRFeS80UXpqdGlTaVByU0QvY0lSMDd1R0xaWmhHTjIyZWJqcGorSmdtQmowRUVJSzdYYmJzYy9XZGVsYlZBbkZVQ3U2UUhaZVNxYk1hSEZCakRDd0ExNEVuWjNqWTNWOVZ4U0tITENPcWxESGVqVE0wbEZSUGNLM3ZNYTF2YytQTExGMytmK2JtNS8vdDNQVzVQM3JqMm8xWGlUSXlIekVPWkQrbklZcHZabFFhNm9OMUthOURmeHUwamc4M1ZteU5sYTgxNVY1KzVWOTIraCtOMDhadjd3MXJQTHZTZ2xLQUJKV3ZWa0FweFJwR3YycEFOcktXaGphOUgrZDkwV2FhVmJZQ1NHbkkrMXdzNGJQelRMLzN2ZTlGdzdlNys1blBmQ1owc1g0a0JBUExZRHFtVy9TWFhlNUZ2K0JVZWRvRjFwVHR2VktaQXpEdUp5QVkyQk9JZEpHRUJBZ2J2WUQyd2dzdmRyLzZxNzhLV0d4MjMxMWhsUndiZk95aWJ6MkJmNENWWUFqNDhadjVBYVluQll0ZGRyRkNyYkN3c0VRNHdSdHBjMHBKMVExV2xQeXlIQ0JVK25QcXFiQmxtcnFKcmtHUDFTQkcwd0V5NlBIZ1BOM0pNbm5SVjVPVWZIczN5dURJZnZFR2VBcHBWWERXNkY3OEo1RUJueHJlN25EYWF2QlBmbWl3SW82UGhCTUFLUXdiMkRoRk1GVWR5cmFDcmJacUFVZU5CRmFsMFpwRzVYdUpsVmZFTmF4U2EwaTdoalgvWUlLcWlWTmttQjhFVDEwd25EcGJCaGkveHN5R3BibDdOMTVhV2w5LzlhMGI4MjhSZFdRK3doeTREMXhiV3F1UjZsWVZ0dlgvWWU0cnZuYWJidDJYUC9Yc1E0MXhEaHNKb1FYUFhQWEU5S0oraXBZQUpqanBweW5iKzBGZWo1Q1pFWDRJVTJrYnBjcFcwYXZzemd5Z0JVV1gzNCtDWFg4QjlydmYvVzZVNnpkLzh6ZTd6MzN1YzNGdlhNSFY4bGcyRzE1cktzMnlsWkFFb2pidjhyUDlxcGFRTCs3b0pBKzk1enRrVXc5ZHBudDUzdDY2MDUxaGhOKzV1RHNBNnpLUzY5VjNMM1VicXl2c1VacUxQSUN3NkNxSHpoRmtjT1dTRWwzb2pkbEcwSHhXVjdQN3JrVHNsbmVXMDJXWFl3ekdwQVF1TUR1Q2pvVEdhM0xwNktUZGEwSEpick5BSnJxUlZ4ank4WFZhTmk4QlN5T29HUWZVaXZkYzVmV2RXMGFmVzkycWNlcmpHL2ZHeFppbUh6UEQxMGVxQnI3R0FGTDl0emk0YjVMVEdpYlpzTVdaQ1RqRmRDNzU2SFdPTWtxTGh5bHVNampsS2pOMXRxYmpTYmJPNVlwdE8vZDRHN2o1c1NOQzVPK1NXUWVwUWwyd3R6ZTN1YlZ4WlhWdDQ5WEZ0YVcvV2xwWitkTWYzTHg1SlFLT2ZuNG1PSEN5S21wUmEzM09EaEZ2dWErOWhqbXM0Qlh3QVhhR3ZkK3ozSzNzcmJFaXQ2YWVEVi8zK2xkOFFjbTZxTVJWN25hOXJKalQweFBzdlA5WUFKVWo4bTZuWmxqQmFYSVM2UWRnaXJtRWZZTXpmZE10b0xaeEZBZ1A4ak92cExIc3lyZTF5NjlzL1d6QVpVelB5NFpYZzNGTzdKWStkNkxTN0I5c0I4Q1dOQzdBU3BPcUErZjVCaWozN0tvdXJyYnA2aWQ0SFpDblhkaDRZejNkQXBudjFHV1FzY3NTMHFPTjNsTVZQTzVqRTJuTmZXWk41OXdaNXR1U3A4QndlbXEyKzhWLzlJOEpPOVg5eC8vM1AzWnZ2ZlVPODF5VlZzbGpnaDRPRWltUnlGc3dvZ2ZCSVkzZEx0TFdMbnVDN2l4MG13czMyU3QwdGZ2a3h6N2JuWnM2aC9RTHI4ZFdVVTI0RndFMDhRN2xsL09BUlZmdnh3ODRadzI5N1RaWEFDWmU3aGxyc2ZlWVo2WSswaG9VT2xnZGtSREhWUVhBU09QdmtWYXBGWUxmdUptT0FPeUhhVnN4bmpSakpGOFZnV25CbDloN2dDZjNxL1c5dVJoQXZhYThWTThhZWxYQnNLKytrV2E5Uzk2ZnA2YXFUM1gzZmhVbjIxQzVnNTUwbDZsbnJwQXlVOS9LK0s2cndMaWNHeHYrc0l3eWJPM3RMREdmOWRiMU83ZS93djYxVis0c0xIenowdTNiYzBRY21aOVJEb1RrYXFXMEl2NnNHR2x0NlpWK0w0MGdwUEZaRllHZ0kwRFpHSXhqdDFUanZXNEZnRDRYOExmOGFPK05OL3lzMjNHbURUZE1xK0YxcXpDdExVM2YvdmEzQTFEOUtMalF3TENXeFdkWFJGVjR3MW8yQVZhajFHVVo5Qzh6Zkc5NXE1eWxmL1NENHZRaXc1cVd5MUNMWnJkSS9QbC8rQXQ4c05qL0ZmOWJWOThEeUpnS0R5MGdEbE9IbkxyRUFYbEl1bTdNSGFlTWRteUF2Y2NvTnJNUTNJeDdaV1dwT3pWMW5uQk05Ty9waXdFMTFRQWFKTklESjhKTE4vZlNKMDBPcHZPR3d0M0JJbDVZcUNLTUVqTU1DQTdaQVlEQ3A1S3JTMHlkN0R2T1pSa0VWZE10S1hlU2diSjlwalBKTzRIWk1OSlVQTEdyRDFPN01aS2hFQkV1RmhMQVltVFg0SlA1NjdhNXQzbW9odkk5eUZ0WFdKbW1nMWo3Zkx6Y0gzYU12R0xSQXJTNHViYkh2cXl5dG45bGZmM2xwZFdWbDVmVzE3NjV0RUpYZi83R3FLc3ZjLzhITVlkcUFTdGdOYWlmaGJKSmExUmlHMDV6S2ZXNVVraWp2NVAyQzBSOGRwcFF4VFZNTkRKc0c1ZVh6NVd1L25WZk5pNDZINW9BaE1PbkJGOGZLN3gyYTRyUHg5bUc4OGlZcTFldmRuLzJaMzhXNVJCa1B2YXhqd1Z0Tmw0QnRnQlNlcjAzajZML1FmUVVEZm9iVnRzdC80d3J6eHdrQ25BQUpEejkwejFiQlF3T0llbWUrOWhUM2VkLzdWZVJZTGU2YjM1dHVidDc3dzVnQmI4WW5ITGdadXdFYzF2SGthenBNcCtjWUdVUk85K2YzRmNpSG85dERPOHRMVEI3NEJ3TEZkVEJKbStJVGJ5ZU4wanc5SmZ6UGFyVDVWNFJjUXlFMndGaGdTd0F5ckQ5QnhCUXpITGlCdjNnY1lCdEFKcmJQdlhKV3JhUVdDMjhVcWhoZXlsWHdKTVA4dGNGQTk3cnZ3Y0trd0kwK0pNOUQwS0IxNndDZzY3NmdKRmFxQzFjQmh3RFYwamVMbUpZMldGRktiVEhnQ0ZwbXY4NjZweGxlMUtiR3k5dGJIendGa2V6TE5HcmVtdDFmZm5WSHl3dVhqR3JrZmtmandPSDRHclJEaXZzejBBNWs5WUJvVFlNalhwSkc0b2dwWnYzZHFzRnpad0dSVE5tMEtpNjA5SGdlbkN1MUV5NzBtdmQ2bDc3UVdIS3ZldzJqdmVWN29QczlZM1Y3dnlGczkzZHUzZTdyLzNwZjFZNDdIN3J0MzZyKy9TblB4M2dwN0JYSDRRcVEzMFFUTjk4V3pQOGJMNFYzM0ErRzhabzN1K3dUNEMyUUdGUGVwMWpQOVFYbm4veWZQY3J2Lzc1Ym5OdHNYdmxlOThGWU9jQlBVQUp2V04zd0FrSEhUTUNBR1FnRzlEMW5Lb3ozVFFqMnh2cnk5M3E1bnEzd0pFaDNRa0dIdmZzRmlQTmtXYXRwSExBU1oyclpoOWRyZWlJdmdvQVYrTHM2Uk9JZVlmT0ZnZ3dFOVR3TXkwSURpbFhYV1U4QjdnbFdCSTcwaTNKdGJaa0RKQkZnblhxbE9vR3l5OGYxdW5aaENSTEd1NnRZSzJhaERobkVaQWlHOXVnVTQxUzVzZkplOVVIVkxRWTRkK0ZIZmFXTmxkWDN1Slk4Q3VjWFBzMnAvRyt0YlM2K00zVmE3ZmZ2anhhengvdjQrL0N6eEZ3L1ZrcGNBR0d0a0JRbC9RcmJRbW9YalZIVkJCU2dyWFMxMndDL1FSWkcyT0JUWUpNcGxsNURQT0U3S0lSbW1kckt2eUQzQTNiMGxuaGhtMC9CRTg4OFVSSWs3ZHUzZXIrNGkvK0lqYmF0anhPMDNMS2toS21FbFNWb1oyeVpiaEtzK2hyYWRPdndMakEyZlFjMlM1ZXhBYlE4S2I0c2JLK0VoTHo4NTk4cnZ1MWYvSlBZekw5eTMvOTdXNTVZUmtRWkU0ckk5eDdleXhMQlpBTzNGT0FydmVKY1dpY1h1OU9RcWM3NER0UWRtcUdEWG5jWTlTSjhFcVNkclFCVU85Q0ZRcHR6b0VOR25tM25nMmxCRW53MU04U2FOOTlFZ0RZaUFVdjFMZHI4b2hvd1piQk1icjJBYks2QzRTVXI4cWlCT3E5ZXRHY2swb0l6dVdTSitITzRvYzk2SWhGRDBybmh1TUw1MkNVYmhHRytFNnBpaVduZ0xGNWJMTzh5ajFibDdydEt3dExTOSs4ZS92MlMzLzk3cnRmRGVKR1AzOG5PVEIrN3V5RmkwY2JJNVdKeWxXWFhEbnEvM0ErdFdIYis0ZkhHdmdLSHByaHVQVmN0cFc4akc3RFYvblp5QVFjdzl2SW5JWlVZS3E3MTNHbVRhLzFINmF2NkduRGVIK2N1elMwK1ZXWTFvNjVub1RMUWJqSkdKeTdlZk5tMFB5SlQzeUNMUXVmQ2IvU0pWZDZiUnJlZTVsZjhhbmN0QWZnbWtBVzRDUGM0QmZuWlBXcUI4Tk5va2JacGR1K3ViMkJZSHFpZS9yQ1U3SEZvUHZVM3IwTGxPd2c2YkZaUzNkd21vbnpuQ25semlhQUxMUDU0WUk2U0hTUmR0WHBVcCtjbk9sT3haYUJPWXZBbVFaUUtsSUdZSG96RHZnS1hCN1hFdnl5UGxnZXc1R01CL2dKcDlJYTdwWkhMOTh2OFYxa0VJc08rdmVxdStVNHZBQm5nWnlTUTJZL2tFVWEzc2RHS3l5aWlJTUl6VFBTd3ZiZU1uRzVha3RwbWtMSEZMRXRrUDdlK21wM2MrSHUxNjdmdmYxSFgvM3pQLzlmMzcxNjlVOXUzTHYzTm1TT3pOOWhEaHhaUkJBVjFtcHNaZW92ZVpQdWo4YWxObXg3LzJpeHpTdkJiamh1UGJlMndGTFBwbTlqOU5tclFNVXdBbXlGRXp5cW9lbFdhYlR4S216UmZQVDVLRzhxVE5tVlRqMXJGeTNsVnMvSDIyNUh4K2k5dXNmUUUzWXNNRmhDNGw1SEJ6dkRrVEZQeG1vdTZWWjZyVFI4VmhMMXVXaG82UzYzOHM5eUowVVJUaVRCMk9WV1FsTUtjeXFVK3c4SVd1cGJYY282UFhFcTV1Qk9zWXVYSnhLc3J3R2V6Q1k0MkdPbXdqNjlBU1E1SUoyNHFHZE1FNGxPWGF5N2xZRkkzUm02MVphclRsV052QUhON0w0RGN2eTVJc3pkbm5nN3lRUHVuTTdsUU51Qk0rOXhkd0ZDak9CRGE2aEtURjRwRnUrVWhmMmdabmxLMGpXWFBXaHhlV3VjSUF1NE8wL1dWV0F1cnBoQ1YreEUvVmpWUlQwTTZSZC9wVlluOWF1QmRYbXZ0bnJVTzB0TDNRZHpONy82enZYclgvakdHNjk4OGRMdHVhL2pOVElqRGdRSGpvQ3JMa0RIZlkyemJhUWZ4cmMyYkh0ZjhRb002bm5ZZmhSd05kMFdGRTNEZEFzMGZUYU1WMG11dW1rRVZ5VTExUWNhMDJtdkFwK0tyOTBhNlN1M3NvLzZaNzdsVnVVdHUrTFVjMnQ3cjMvTmVGQ1ZvZTVZMEZRSE96YzN4eGxjWjdxbm5ucXFPM3YyN0NHd1d1NUsxM3k5UCs1Wk44dGU2b0RZellrOGZSWkVUYWVtaVkwQmtvYmZCZVNjTWhiek5BSEZqZFd0T01YZ3d2a0xBWmozN3E1MHk0dWVlMFYzSEJVQklpZDBPY2ptVkMrQUdyM21PZ3NSTmpZNFlRQ1dYd0NVQlcvUDZqSmZnZGF1ZDNURHZYY0FDenJjS1VxZHE5T3E3TVE3ZGN3ZCtpRW1wTXo0WUVJekdZWGtLdS9FVmlWWDNhcjhNUTNOWjlQMlE4dmVmYTRjQzVVUXo1WlovV3Nnc1ZGeE03N3B1N1RWUFE3NEVvalpTT0hNWDEzZDZCYVkvWEQxMXEyWDM3N3kvci8rK3Z0dmZQSG0wa2hLaFQwak04U0JJK0NhRlhKUU1hdmhEOFY1NU1lbzhGYjY1cXBLYnlMZTMzK2w1TnBtMHNiUnZkS3IrMG9qQWRlUkVRSFJWbVpiVkZKRkNzVFpFMHNGUitQWDFKa1drSTJ2TWIxeTEwMFEwS1ErMS9RelRObW05eUJUdEIxblY1enlNeTlKVUhJMVNmT2xQWWZVcHVSMmQzNlJnYVM3SVRrKzgweXFCd0ljZXY0S0NEVWFiamZYdWFET1dZWExzUmJmUkFXUG9qYy9GQ25odWU1ZmlYRDNZSk81c0g1QUxDOWRjT0pNT1dtZWJyRDMwL3NBemhqN0hlelAwSTArejNVV2Zlb1dvK0VMNkZFM29QODBuQ2VzbXphUG53YVVaZ0JGWmgzc2JuU2IrK3Zkakp0a1E2ZmJFTnE5M2tQZnFkVG9YZ0k3cWc4b1oyenlMRUNEbHM1THJtbFhzUnNWUEZHS0ZPeGlkUm0yNTNlNWViVE00bTFiakFCbVBQaUhrYVJ4Z25TZElYQ2VwYmlUd1J1REUwOTlMT0djY1dBODlhdnVpK0FpQWRVQXU3NFAvTyt1ZWlUSzNLdmZ1WFB0LzNodDZkYS8rcTl2di83bDYrdExvN1g4c0cxa2p1ZkFJYmphd05NTXdOWG5hdmk5NTQ5c0RmTEpwTzUvdHBZZk5XMlk0KzViTnlqdUl4ZmdKYmdYMkpaa1hEbWtIallsUDhISnEwQzJRTWl3bFljU1ZqMlhXOW5sSGdFZThOT0dyU0M2MVZXTEl5eEhnbTNTRTVJVWd6V0Nxd3NrQk43bm5uc3VCcnNjMEhJbVJORGVmenlNNjNNWjA0L3k5Tys1OHRNdTQ3M3dwQlNyRVpmMHpzMVRCQ1BtQkREaXJ4UUtKckZhaTQyeG9jbDVyS3ZPQnFERFBPMCtyeXl0blJobnRvYlRxNUJXZVFQRWRWbnNlamROb2hQTVJEaU5pc1BaQXZIaEl5YUNaWUNsa3FkMDJ0VVBYbEFPVTRnalh0eDdBQXFsMkxlYjRPcWRuNC84Y0lRVUhNL1FqUmU0aURTY0lRemxZQmU3L0RIQmpBOHNucnV3YUorUGlZc1BYRFNsdW1PY2ovQWVCSzJ5VDhJODA4aXV6dDE2K1lQckgvejc2emR1L0x2dlhYMy9td3NMQzZOdC9PRDZ5RHljQXlHU3RRM3M0Y0YvZE44Q3JNcHorUGxIeitGb0NwVisyWFlIelZ2Z3NkdnRGY3RLaVpaZ2xxRGt2WEVFRk1PWG42a1g3VzFPdWxVZXJmdHg5MjI0TnExMEZ5eDZZTUdXVHNPRXpiTzcwci94eGh0Qmorb0QxLzg3VDFWd2pSa0VnSnZHdEl3bjNmVUI4YjY2eWNNMCtPeUYzRWlaMWJzVzRQZEFpMlNyZE9zTytGdnNIK0J4MjJmUHpIVFBmZUxKN3UrdmZicGIzMXJ1TGwxK3YxdTV1NERjZWpZV0RZd2ZUQk9Xd3hoWnpYVmluQlZiV3h6bHZiTUVnQUhRdTJmcG1sTTIrTHRGVnoxNytNSm1xbDJrMVhzRjZqSDNNQUIxTFkrWEUvV1pNeForeUo3aEJvTUlUejdDYkY4V1FaMUhtTWlGbTJhUmt4TTh6Y0ZMclM1N3ljVE1oU2syWkhHQ3YvTjNtWVRLWnRPTDNhMjc4MSs5dlRELzB1MjdhMSs3dERaYUxSVU1IUDA4TWdkaStlc2poMzZFZ0cyalBTNjRqZU5ITVpXKzZYamYycVpiejk1WDJMRDdiRzIwQmJBQ3A0Q2tiWmZmYVZERzExL0pVRURUei9oZTJlQk4rWGhqM0E4elJkUER3bVYrTmNJOUNDbTR1VURDNldTdnYvNTYwT21zZ2wvNnBWOWlvT3Z4K0ZDRVNFY1U2UlpVaTNacEMvcjZzbmgvSEMxT2JSSzdDQzB6U2Nsd1h2TFRaYk9iN0F6RmZGV2t5RTJtdHFsbStQUm5ubWZXd0RKell1ZlJ2MjR4Z01XWldod0hNelA5REFmbXNTSnFmUkZRejBHaFRjN3FXdDVZNjg3eFVmUDRHT2VQbmlSeDZkWEVjZEJBcEZpWk5LWnVuSXg0UnVyMTQrZ0NmRDRBVFBZaXBPNEprS0xvaENLdnp4S01FWnk5ci9kNGpzM0ozWUdLdDhwRzRKUGRMUHc3UUhKMWM1UU5Wci9kUTdxK2RlZjJWeis0ZnUzTHI5eTQrclZJWlBRejRzRGZnQU9vQlI2N2VEUmUzd2g3eDhOR2VUVFFBNThxL0lmWmJRS0dMVFBjYmRlOTlSK0V5empsVjNhMHJBaVV3RXZUaXZobUVXRnNlMzErMmdXWUFsR052dHNZQlZZQnR2eUxqcUxQdUpWTzBXUzhZYmZ5ZXhRNzR5WW85TmhBdEFSQjAzYlVXMzJsTkFtdzdnV3I3YnpZSjU5OE1vQW5SdFFOMjE5RmozYm9jRTNFVkJzZWhFUHZwclJYdXRnSVYrQUZXYWJwcGpEcVN4MnA5MlBrK1UyelowOEJ1RXlyWWx1c3JRMVBXbUF4eHhaYkRVNDhIcExnNXZZaWEvVVh3VWVXeGJJb2dSeWd4V2xickhuQ2pwRjd0N3NpRHplVHRueXhsU0hDcTJIdC9pdHhCeStZU2VCZ1Z6RERkeEN1L09xUCt3UjlmbFVCbGlFV0p4aS9MNnZ4UFVIQkpiSnVJT1BtNEdjY0dNVC9Kbk9LMzN2dnZaZGVuL3ZnWDM3cis2LzltN21WNWZjcy84aU1PUEEzNWNBUmNJMEdGeFV6Z2N0RWRhdUcrRGZOcEkzWHBqV2Nkdm9OOHE1NGJaeHkweTczc3RNdHU3SFJVaU5NbFNGdHU3eUdyNnVWVUFWWUpkZ0NTUnQ1QzY2bVR5cUhjZlA1Nkc5THkxR2ZCejhWTFJtWEZ4QW04OGxSOUtSRHdFandTK2xhVmNEdDI3ZmpvK0FBMTdQUFBvdlVtR2R4RmJoS3Z4OEtqZW1iZWt0amU1K0JCTGE4TWs0L0FOWkxyKzRFcFdTN1MxY2VDdUVQdjNUWkhmUjY4cW56SGFmWHNBazRlNDR1ZVhvdm9Cc0RWeDVkQWhBVGNYZHpJUWFzb0NxT2hQRlltRGg1QUhBZFkxU0pUMGVDb2twWTBsZE5JVzZtOU15SG9UYkQ1alkycHlhTXlnd0xKdWlPOSsvWDZWU1FqQVlaWHhPZzdDcDIzYTNLL1d0bnpuS0tLNnFCdStpTDMvdmc4dElQM252M0MrOWZudnZkdHhadmp1YW5Sa1VZL2Z5b0hEZ0UxOE5HRnZWd0FIQzZIL285UW00Vi9sRnNrMnZEWmZLRHZDdTdCK1ZmN21WWC9Id3VFS1ZOS1FuMU9rVGJXVHozNVJKNHZDb05wZGZTVWVwVzdxYWRRSHVVdnZJWHpEVDFIQThQK1duRHQvbUlBWnFRdkFMY0J3TnN1SUl0MlUwdXVwVmMzYTVRZFlGN0VJUWtDSGdVSFg0OHZNelBjdFZHMDIyZW1XUCs1b0FkUkFRZC9sZ3U3YnlmWUxxVm8vcHVNVGpoSGdMb1huY0FMQWV6enA1amZ3RkdpTnliWUkwanV2ZVJJajJxUlFEZXdtMXJnd0VrOUs1eFFpK0xDYVluVHlHMUlyMHlTS1lhWWR6bHNiMXVsUUpFM2tKNEw0cHlCL0FLbnZqNG8yVHFESUtheGhVTEFRaGplUjI0RWt4RFRzZDJrR3FDR1FDN3A1bVp3TTVmdSt5U2RtUHBidmZhZSs5OCtaWExiLzJ6VisvYy9KWmFZWk1lbVJFSGZod2MrTEVQYUZXamZoaHh4NFVwdHg2akhoaGRrS2l3RHdxVVlkTFhzQkhlTm1xRDdlZHY2bHQ2UG9IS3BhUWF3VXFBclQwS0JGVDFmSWJSVlA2dEhSNjlYOTAvekRidXc0eDBWaEREMXFYRUtCME9ZQ2xobDI3WVpiTGYrdGEzUWpYd1QvL3hQMGx3SVEzTFZ5QnMrQUJYUWVjaEpuaWtmNCtwU296NUlQOU94QzVZMnVveW5jL3ZzU3pPLzl4anFsVzNlZEQ5dmIvL0FoSWtLZ05VQTFmZVdtU2dhejJPa3A0NGNRSGdSd28xTGlsNnJNdzJYZk50Vmt6dG5HUUNGWE5pM2RYZmViRXRmNlFudS9mSmV3ODNkSHBkZkFDRFNHUmJTY1RkZUJPTWpQbk9YTy92VGxRbm5LTkxHaFBvVjlXeExoeHNkTmNYNXJ1ck42Ni85TUhORzcvL3lyVkxMeE43WkVZYytMRnpZUHpDK2Njdm1xb1ZNQ295VTQzcXZ1dzJWOGNkYlBqWitJMlRYVWlYYmNhQmFsVDRpcWM5YklZYnpyQi9ObVJiOXZHWCtaVTVMdjBKR3BZbm5EckhFMElJeW9VYlAxTEdJL2U0bTdyOXhsQVRVQ2FhWk9qalBJUk9TY2dqU1p5MFhpdVdMSnQ1dTJiZWJ2Q1ltMzZRajRNc3dIUTBiSFdEam14SG5pRmZaZjdGTDIzWCtaaTdsMytXMDY2dlhkem81cEkzd2xudlk1YzIzYVByUzU0QmtBSkhzNHByYzNNRFBlZEtkNDlwV2s4OTgzajN4Sk9QeGViaG14NjVJaThBWk05MHNqc3M4SmlHbC96enVkNko5NW14QlBpaUxRbGxnc3JnSi9mZHdSUTg2WXZJcmxIUzVRRjlMakp3ZzJ1UDNqNTdacFpWWkxQZDR1cTk3dWFkbTBpTmJKUTkrMHkzdEFib2JyM0t3TkVleTJuZEF3SzlLMHRpUXkzQVBGY2w0YkZwUUJyOEY0VEhjQXRwRnR2QnIwa3VqL1YyWHF4N3ZCSUNHMG5WYmYzbzRqc3dkWm8vWENHWWNFeXJtcjF3cnB2a3lQRGxyWTN1NXZ4Yzk5cU5ENzc2OW52dmZlSHIzLy9lbCthV0Y2OVRrcEVaY2VBbndnSDJGamgvMFpTcmdiWGdkVnlPQ2FycDA0Sm8zVWVMYkNLV2U5bm1VL2ROc0VlK2Jla3puV0VUTzd2anFGOElYZHdMWWNlRkRRLzl1RFNHaVJWQjBGZ0FOT0JMaGpyWmIyd2Q2Wk53U2I4Q2NuYS9LN1VCVHpQMS9JMGxvYjJEZElVWlJPSHh5RU1mWUdBSkxBV1EyczRXa0FhbmxDMnhIRk9nYzREclk4OS9QTUl0THkvSGgwSnB0OElXemNNOHlXZnpUOHA4bHNYaDdzZkVaK2F1NWdjRi9PcDdBVGx0SzJrOFNmYytscEp5OHNBNFI2RnNzNUgyNW9iN3JDcEZNLzFwNTNLM3RZNjB1ckdIS21DaU84TUt0R25LTk1tK0JWTUE1SWt4OTlxaUMwODZreE1BTDJGaW5pMDBTVm5TeEVjT0VzVi9QeDVLclU3QzhnT0N5TXJtVzlBSTREcjVmNUZOWno2NGZiTjc1L0w3Vjk2OWN2a3IvL243Zi8zUGJ5ek9qL1NxZ3lvMXV2c0pjZUFRWEUxZklFbWQyNE56ZXhpNEdxc2FZellDRytmUnExTFdQY09uZitzK0hLZDlKb2NLR21rZlB2UTNCYTQrQ2hHUnp5REswVGdFaUxUN3VONExybmFsdlJkZ3Q1RVFWUk9ZbUdCMkVoQ0ljTnpMQzNsV2ZET2VjVEpuYzcvL0Vndks2QnVtZFd2U1BQVHVlZVd6TzFacHpLZTYvYW9ITkc3bWN2ZnVmQ3lmL2NUSFg0ZzlDS1JkNmJ2Q0dLZjlZRmlXMWh4OVZFVEZBS3lIaGlsVnhrbnBQUVRFNEV0MkNISStycWRDbkpvWmovekh4azUxQy9lVzBRc3ZFMDZoMU1HdUxhNTFkQU1IM1F3ZmgybUFjQnFkNkJTMjUzQUZ1TElId1FRcndlQTR6K1RIbnp0bUtjbjc3UGxkdWJqQkZWdWN5QXFCN05YTk1qeDZHRXdWMjBXU3ZyRTAzNzMrL3J0WFhubjNCMTk0ODhiMUwzeDMvdktmSEpaamREUGl3RStZQTRjRFd1WVRvR0VyZVlocHdkVmcwZEQ2RnBrTk5TWFRCeVh4c0laZDZUMG9icm9Qd0NEek94cmFycUpHditNazEzRHZDMkdEMWJSeEhGa1dpSlR5Tkk2K3U0bklIbW9Dd2RYSjdBR3lxQStVeEN4UFNJSTlVaDdIbjBpby8za1VjSzF5dGJiM1hnSmxTWjdhWHFXSFZUcDFreGNCOWZ5NUM1MjdhRjI0Y0lHY0dRanJkYTZWcHVUVWZhWGR1cW5xaUdkRnhFT2ppaUQ1VW1CYXN3V1VacjEzTnl0NWhlZ0lXTElzZjJLV0JRNDczU0xUQ0ZiWkMvYnM5RG4wMmtqYW5NMjF3OGVBMDA2NjB3RHg2VlB3bkEvWDVENlN1VHRuc1RXMVd3NHFuVkpJMGdaMDZSMU1BTUt4TFNHVXVIdldGb3BmTUpwWkFlaUR1Ujg3eTFRd0ZoaGNRUjNCWU5WTDMzdjN6Zi90OVh0WHY3VzRnMmcvTWlNTy9DMXlBSEROTFFjSERXd0FYc2ZSVWVCUkRkTXdGVGZkQm8zeHVEQ0NVYm1YWFdtMHR2Zkhtd0Y5YmZ3S203ckJmSktTQ0RPSVVzSDZBRW1yM29ienNtdFpnMENDcUViQUVNUkNWY0FSSjVvY2hjL1ZYajQ3RFNoQnp6VHpJcm00TDF2M1lmb00wV044M05aRDBWTjJCQ09oTFhhaWtvZVpQMGV5QUpvaFdSTkFldFg3T250QUVIWjU3UFBQUDgrSElnZkFUS1A0WCtrTzJ3bXF5WmVTV0FWT3kyQlk1Y3E4OXpuZlpUMmIvN1k3OFFOMDdvV3c1eGFFTEJpYm5qN05MdnlyVE5PYUIwd2ZBM3dCUlhiNTJnTmNUNHp0QXF5Y2Y4WjVYR09zVXozTjlvWHFZa3NxRGYyMHIwSHdKcU10bHRIYW0vQXNMVThOc090L3dzRklybjNVQ25mV0Y3cjNibDdkZlBXdE4vL0ZuNzM5MTc4OUFsVjROekkvRlE0d29KV0xDTExoMkxRREVSNUlUSUdyQWFwaHR2YzI3bm8rem00YmR3UnNmb3FHeHVtWTJ3Rjl4NFV2WC8yT2sxek4zMHR6R05aN3dsZWNZWWxRU1ZaZzNXSUZ6dzRybE1ST3crWVVJS1ZaWmQ4K2ZxV05mK1F4Yklkci92UVFGbEJjenVxVVRWc3piT3RXYWh2empId0pXenoxbzNDU0phWHFXWmNXbCtNam9mNzF3b1hISXF4QWJGakRHYmVNK1F6eTZublJTNnlsWDgwd3hEaUlDU2FFTnh6UG9UTG85YkU4N3g5d3ZoWmRjano0S0RHSXhpRFVtVE4yNFRuNEQyQzhlMHY5S3p2MW93dmQzbG9oK2dhNlZ0UWRIaURKWU4rcGliT2tTem5ZWUdVYzNhazdVNEhub1liWUI0aFh0MWRqZHNEVTZabk9hNC95N3FEN1hXT1RHZWVzL3JlM1h2L0srOWV1L083TFYxNzc0eXJmeUI1eDRLZkJnZGdzdTgyNEhUQnEzZXUreDQ1NHJFWlp0bzQ1WW40OE9CaXVnTUI3VFJ1M2ZTNzNZZHRHVzZiU3FHZnQ2dUo3TDNoRm1FR1V5RisvTUQxSTZuMllWaytqZEFwQUFxdGdKT0RxdG8va3FwMzNDWThKY2dtS2V6SDF4OVJUMmlzN2dVanFCOFFVdURaTzBERUF2YURSbFByOHRDY1pVZGRVTjkrOFM5S1dWbmVIMHMvTnJObGdKTzdQblRzZmV0aEs1emh3TGJDVlR2V3BtdVJKOVRUU1BnaWQ2OEFQamhCU1hpVkFxelp4VnlzL0FtN3E0bUNUZzRCVDA2ZllQbkc2VzdvSGpmQndneVd4TzV0STJDd3U2UGEzQVdFWElreXdKOEVaOGljdHAxUXgraDliSDU1RXplQjVWdXpFTW5FR3dDV2N4OUJza3M0dFpraGNtYnZSdlhYbDBwWHZ2L3ZtdjMzM2phdGYvTUhTTzI5RUFVWS9Jdzc4RkRrd2Z2Yk11WXZtYjhQVE9LZndZYVlQRmtGc2ZIWHBVSTF4Y0o5dTZSNVJEbi9LcmV6eUdINHU5NEU5QUtmandoNEJWNEVpMEdJUTIzSld2QUk2NDVTYlhQQStBVE0vQnRuZFQxWEEzdDUySkpaUzRDQ3NZR0k4ZDNuU1ZIcmFSKzRiSkQwT1hJa1o4WS83a1hhNzJ4cno5eXBRckFFdXAyZzVaOWYzTkQvUFduK2tXTUZWRmNGcHBpUVpyc0MxM25uUjUvTUp0NUxDcEZ0S3BQbUI2T25xQjdSU2ZXREkvSWdFbS9rWkJ5UTM0aHdzUDB5dTV2S0RoSzRVbkoyWk9jMlVxcWQ0WmgrSFZaYkVicUlmUm5vOTRLeXRTWlN2N3BRMWl3b0JqVVpxZk9ueUs3V0ducHQ1c001eU8zbjZKSWNlcm5kTERKQ3hwMnIzNXZ2dmR1OWV1L0xsOTI5OThLV1hyNzM2aDR2ZFlyOFpnYlNOeklnRFB6ME9ISUtySkVUajZzRzFHbHhMV2paR0cxODJxTEp0V041N0tjbGtRNk9CT25yVCt5blJPdEo3K0J4aEswN2FtVWJmaUUwU00weEhkWnZMWGZ2SWxkSGl0OVFDUVZEckRvaFlsdGlRR2RzY0s0MDJyR0VLV0FVa0I0d0VWOTNWYzdwYnZ6UXJ0VGt0eVo1MjBaZTh5a3hOdTlKU0tuUXRlOUFXUlUySUp6WjAxTDBmdVh5cVg3SUozL3I0eFJFbDBHVGFKQjRaSFNCZHE3ZU00NkZ4ZGwvV083Zm5ZNlQrczUvOVRQZkNDNThrblBwak4zVFpwenhPNDNMV2dhZktLbEg2WWZEZGtxczBrbXdPb0ptK2JuNTRuYXlQeFhOZTBPQzhVcTREUU5SalhjYWRqOHFNZ1RpdWhYeXNFKzZaT2pGMWdJb0NQazV5clBUS25lNGU0SzhPMlRtcjB3eHFUYkY2Nmd4VHNOeWZkUUpKZFhJU216Z0hESFJ0ZzZ4cnJQanlQSzZydCs5MjMzbm43ZTQ3Ny82Z2UzLytabmRyZlBYWDM3N3gvbnRTTlRJakRueFVPQUM0NWp6WGFLUkJWUUtCdHdVUTJuWGZFbDZOc09LbVBXaWM1VjV4SHUwNUVLZWlKSGdjUG5sejFEOWNCSmplRE82Z3Z4NGEvelo4QUJkK3c1SnJHNmJTTGJkY1Bzb0tvQmpBa2k5UUJPaDRlUzhJYTRiNVpkbnppcFFpVFA0Y0V0bTRtV2E1SDNHT2ZGcVg0WERpbjFPeWxLU1ZWQzNkNGlJTC9qSFBQZmM4UzJTZmo3VGRkS1ZtUmJoSGdSK1JuS2RiMG1xYlM5S1RlV1g1c2l4VnBvWldRREg0UWI1OEl2cVg0TDBTcU5zVWNuRGsxQ3p1ME1rQXZyclh2WjExK0laYUFQM3BKRHJjM1gyV3puS285ejVIeFd3eDhyK00rdUF1KzZyT0w5M3J2di9tOTd0TE55NnpIZUFjQ3dQVzNKUDFrL3RySjNiUFBYTnVqSEtPcE5iZzlPam5vOENCSEoyQWtnS0RrQzU1cmtaYmR2bFhvenFPZU1PRXRIcWNaK05XYVpaVCs5em1vLzl4ejIzNFN1TlI3WXFyYmE5VG8xMzVVUEIwN0g4akhHN2w3eHArM1FiZGNFNDNCY3cwcFovMTNqQVZSN3ZTQ1ZReHdFL0lWSjRtN3hKZXBXM0I5UnZmK0VaMHk4K2NPUjB6Q0R3K3B2VElxaGE4anRJNXFBT1ZadmozZEpkYmxWTTdEYmJiK29lVVcwNEF0djE3SUhNVGFmL2NFeFBkUC9pZlBvVytkWTFwcWR2ZGpjdEl3OXpQVHJzaWkzV3pTTkJibklpdzZXSURlZ3ByVzlzQTdCWmJHbTUzSzh3NldHZndhbTJQTTczRzJTVDg1TW5OU3pmZlgrb1crcnhHMW9nREh4RU9qSitaVFoxcjBhUDBWV2JRWU1wbDBPQUtMQ3JNd002dzlUeUkrV0QzSTJHYi9JMXh4QytTcUVaOHY1OWhCNzYwOFhvNGJQZ1pKOEpGMkY3eWF2TjhVRmpEYzluMTF3Z3VYZ0pVZ1pUUEpia2U1dEdrMThmRUtzSk1LRjNMelhpYXNzdTM3T3lhMTlQOTRYYjNkZ0pRbllQclBnbHU3YWRFNnVEV3JWdHowZjMvNUNjL0dmc1FxTE0xak1EcXh0dFpwcFJjVy9xTGxyUlRjcFdDbys1SlV4eVhZaGtDWEFIc2tPajdaNnlOblFVazZobm00VTR4di9VMFU3TUl3OENVeDlIc1FQdUpzWlU0YW1ZYnNOM1lXZTNXdHRjNUVVQ2I1ejJtWVpIOUxxb1B0Z2IvWC9iR1RueHg1K0RnN2toaUhkU0gwZDFIaHdPQTY5bUxSVTQybGg1d2FDQnQ0Mm52RFYvUGRWL1BQVFpVa21HWFgrczQ3RmJQc1ZjbkFldTU0Z3llYWFHTkdiaW5vMTM4TWc4QzEvS3ZrRzBjTWk3dm9NSDAyMHNBd2lVRy9yUUZSK2ZCdWhmQkR2cEExUWFHS1duUXhJeXZXOTdIYjl6blQrV1hkcFduN0NaZzNENEt1Q3BCQzZyU29QcWk2RjluRi83RnhZVTQ0TkR0Q2Mrd2NiUjBLWVVyNFFyQ0h1Qlk0WWZ0S0R1NnoySDNJOCtVUDJoTWxJWG12dHh5alNMdWoyM2hndjdWcGE4Y1kzMzZ0Q3ZPV0taNjcxNDNkK3MyZXRxRm1PN21wdHlDZjV3Nml3NTJSNTA5NFRZQTFpMzB1bXZkK3BmZWZQZnFleU5nSGE0aG8rZVBDZ2ZHWjA4bnVOcEFOQUxHa2NiU3U0ZGZjMS9QRmJhZXF6SDVQR3dxajliOVByZERTUzVERGZzUGc0dWgyakF0VUQ0TVhBUHMrcnlNWXhwZUZhZE44eWk5bVYrQlo4UUJvR0wwM21sWUJFNFF5dlFNMTZhVkxFeGVaN3AxMy9PLzUzRWI1MmordmVqY093Nkh5d0ZGODJiaEtHQlo0SnBxQUVBTWNGV040ZW14bi9yVXB6aUQ2eXpTSy9OTzBic3FkUnRmWTdydGRlaEc5NzdjRDkyYXNJcjJvY1VPeWRVUXB1V1BPbGY0Qy9tYm5NRzFUVmQvaWxWd0Y4NmRZUWtzVTdUWUYyRnU3bmEzdlQ0Zmh5em1TaS9VQW55ME5sRnZlQlNNV3gyaVhrV0MzZnIxOWMzeE4wYkFHdXdkL1h4RU9YQkVjazBhVThvYWJyUXQvZVZYamF5ZURXTkRDdURpdnV4MFQvRHd2a3dicjl4NkFTOGFjTGxwRDhKbW96L2V6eUdVUVQ0RmxObTYyeGc5YlFXdVBUZ0loTVlaNUhVMGprOEo3Z2xlT1pjemQ4dVNiaWREMkMwZkJ0Y1dpQWxsS2szQ2RaOTI1VjEyRXpCdWh6OHV3K0VFUjBGVktUcW5ham5QTktWTjNYdy85NUFTbFZZOUd1YkpKNThPWGJIZ3FuRUJnR2tPdjd2S1I5MnA5dys2UEprMU1qRU4wZ3NXazJkZ0xmYjRoS2ZENWdmQ0VrOGpaVThEcm9MdEdqdDdiUzB2NEF2STB4dUlVMk54MzJUVGwxMk9kdGxqVTVaRkJySFdkc2YrOWFWTGwwYkxXWDFoSS9PUjVRQ1M2NW1MMVhDa3NycmwzcmZ1eDkxWEF6c2FOcHJUa2NhcHY4YndCVHpwa3I5dDJ0a2FqM0h2NDVOS2VCNkpjK2ozYU9BcURRRWVrQnBsNk9NTGduWTlXOU9DVExtWGp0VzRTbnZHMC9qc0NhZGxkTmUvd3ZpY0s5aXlEQm11N28rV2E3aDhsZWFIZ2VzZStrdjNSVWcxaGFjQmNBSXI1WFFCdjhvQUFFQUFTVVJCVkJVOGpYdUc3UURkUVN1T2FBRmduM3JxcVpnREs0Mld5eWxseFIvdDRBL2xLbm9LWEtYbjBLMzM5L2tBNmJTTlUvd3J0MjAyMDQ1WkNzd2MyRU1pSFdNZTdDazJzWjVnUHdGUEt0aG42YTRueUI0b3NiSkVkblYxZzZPN04xa2R4OG91cE5mdHNaMy9lZlBnNE1aSWFxMGFNYkkvcWh4QWNqMXpVZm1DZHBFWEFPQjlZQmkyK2pIdnk4NjdkTk05VnRQWW9LSlJEWXBaRFUrWGFxeEtTM1labGZMc3JzWjZmQ1NVV0x1UDdZWWZTamptNWF5RmFHdzJPSzZZSjR0dDVKcWJXZTdsRjdiNW1TbjBhQ0p2UUNNY0JRdmM4aHFBUUlRVkdDS0szV0pUeVBoeGxoTkVDVXc1bjFNZzlUbEIwNEdqbEdDekcrNWNVOHV6elR4WWswbmRKd0Jzd1VnaEFkYXkrK1J6U2I2NUtVdStoNlNOQ09Rem9OUDdBOCtxN3J2dVppQXZpNzhlWU9qeVYzbGJ3SjdkZkRlajRiaHIvTmJYMXpnM2FwYUovdXVjRzNVajVzSysrS2xQeGg2d0c0Q1p3T3dzQS9NU0JDdHR3VGZvd2NyNXltNXVEUitvTHo1TGgvZngzbVZmRWthNUtTTmw5N0s4VzV3OG9IUjdBbHIybUJlN3Q4M09XTkEyaTBRN3c1NENFL3VjYXpYOWVIZisxRk5oYjdQMzY5TGFDcHV4TEhXYkp6YTZyUk03WDNyMzhyVzdRY3pvWjhTQmp6QUhrRnhuTDFZRGxrN2JSQmtiVnBrS28zVHpNRk9Oc2V5Uzhzb1djUFNyNStIN0JNcWpJL0J0bUFCaWFLaXBVTU4ydG1sQlozQVZ2UUtPeHJKNDM5cTZHNGRmYnpFSnJnTWJwMTdQa09GTUo5TXlIZW5XVHVCUGdCMkVTd2xYc0twaldzeks4Q1dKRnQybVdVYi9ZYU5UeFR0cUMxMlVqM21pNlo2Z2JQeEtSMXNhTlBKTkNYYVYwd1NkWHZiTU04OTI1OCtmN3pkOThRaVhIQkJ6c1VSOEZJbHJlWEsvVy9QSTZWdmF1a3VYSDVtNGlSenlaNWdXTnd3Yzk4TkNuQU0rbHVQTWc1dG1tMEF5NlZZNXZ1QVVSNy9Nc01MczdPeVo3c0w1czl4enJBekxZNWRYbDloWmE2SGJPQmo3TjRzU1BqSWpEbnpFT1hDb0ZxaEdvTlF6Yk1wUHV3RERNTVAzQlppdDdmMlJDeEFLQU5MbUN1bTB2L2U1d2habzFyTjVlYTkwcTE5ZDZoWGJlK2szWE5GWE5GWVp3b09mZXRhdXNPbFg1UzlnSzF2ZjlwNG5zWXo0ZWRWOXBoSzBRbWZScDk1VHdMTHNrWktTWE9SZGFhYmRrM09ZYnFZMjRIV3Q0UTlKT3ZMT2RJSUdld1dlZElCN2ZUd3FmdWFWaXh6a1NkS3lIL3BYcDJNOTl0aGovUTVhekRYdHBWVERsUVNzbTJVb0k1MkNhZEtiUEpDMllFb0Z3ZzY2Z3M0c0h6czFJTmt6NVlvWkFHNGNIcWRHSU1XNnNtdU4wd0oyMko3UW5vRUFlKzcwYkhmKzdMbnVIS29NeTd2UDZRVzNUdXg4Y2FRU2FCZzh1djNJY21EODlLblppMGVweTBaUWJ0VTQyc1phRGRYRzUxVUFlSnhkd0ZkZ2MxeVlEM09yUE5JK21xZHU1bEZoYU01eDc3TkcrOE11dzFXWkJJc3NjNEZXMlNrWkh1VkRoUlZjQkJ0MXJLbG45ZDU4QzF3cmozSE9zR3JUNzhtVWdoNFFNNTBNVThDZDcwUzNEd05YWk9mRExuakVVa0tPMUtVZjN2Q1hkTElhQ2hXQWFRSldvUXB3cnV1TEw3NFkwN0trMjFrRmhoR0lMWXZneXVlTlZJb25sdC83c2sxL1FMTnBWN21yUERNc2szVzZGeU5XL2FZc0VNaEhhZ2RkOGVZdXN4WldObU02VzJ5UnpYZG9DclZMQU96cE0rdzljTHE3ZGZQNjBwVjdjMzhSQ1k5K1JoejRDSE1BY0QxOThTaDkyVGgwcXdaUmphVGN0QXV3UGd3WVczL2p0TS9lVnpwbHQybnJWczl4RXovSFM4OUY0MENpeTNDVlIyc1g0R3ZyWGliTGUvaVV1ZlVTWnZpQkFrcHdnN3hhSG1VOHdhK2tQRzNUTDREVmRtY280OWNlQWFSd21JK2dWK0RwZmRKVC9tbVgvNkNjZzNDQ1h2Yk1NMnpMMDhoVHdPZFBJM0RxSm5EYXl4WmduUTdsL3E5dXNPM1VyUXBqZU5VRDhUNUlPbWhRd3hKcUVzRzZKTmlBYm9NZkd2UFFWRm1tT2VIVm1RRDc3TEhnemxjd0l0SjFIMTE3TVNmMkdQQkNEejNCZk5xVHpBNFlSNDg4elU1Z1oxaksrL2o1SjdySjgyZCs0OEwwbWQ5Yy8yRG5QNHcyYVRsazgram1JOGlCOFZNekEzRE54amlnc2hxR0x0VlF0UVdNaDEwVjFqQjFYNmtlSUxHb255VEZ1THh2bnd0c2pGZjVWOFBNNTZQZ2I3b3RFR1ZESDRTcC9GdTdRTFZzMHhpWUF2UnlHYVFsb0ptWEptaXA5YlBoa3ZTS0pZWlJ5dk15WE11ckNjOTN3czFkOWFzOG1WNkNwTURWbGlmRDlQbEZ2cEdaZC8xTjJUNHlvR1grU284V1F4VVBmUFRaalY3aUNCeTc3bnIxSDVYNkVEaWI0TnExYS9HK25FSHdzWTg5Qy8wVEFhcjFIbzNueGpORkh6VkJGNTdsVVVycTV0WWE2YTlMOTRrRE5vc1JVQ0VqVm04WkQvZllQWXViU1pJY1kxYUFJRHg3a3FYR2dPc3U2Z0MzTHp5Rm11Q3BUenpmZmZJVEx6NC84OWowLzdWOGQvNFA1bGNYbDlyOFJ2Y2pEbnhVT0FDNG5yb284SlJwYnFPaEZTZ1ZFSlVVWm9QVFRmKzI4ZFY5eFd2VHpqd0dlUlZ3NkQ2NGI4RWkzZHZHMlF0ZWtXL1JYUDVwMTBETElKMmlwY0xYYzltNmV5L3RnbjY2cDV2Z29RbjZRSVN3dzhXZnRpeFZob3l2citBcWVKVXhyaHR1YTUra3U1dCtKWWxuMnJuUmRNVVkyTktrSVdwdjZxYnM4SVhhb3dOYVJhKzJsMU9sTkhiM0JVblRkWFdXOTU1ZzRCeFkvWjU5OXJtUVlPdTlLK0VheHYxaUQ4RTFhS3FQZ2Z3aVlXWlJ0S2J5TFRvNExzQ3ZEd0RMZ1lKUkpJQ2ZQejhFekttSXMxdWRsblVLY0dXQ1ZuZXdnOXFINDF1MmVUZmI2TnRQY2Fyc004OC9GOVBIMlByNy81eGJ2dk43SXgxc3kvSFIvVWVGQStNejA2Y3VIbFo4cURwdVFFdlFxVXR3cmZzRW9RSEFXS2dDQWUvYmRLdVJIUVdrYk9odHVCNURqSDZmTVp6K3czbFUvTXhqMEUwZVRxREN0ZTdsWnBxV1N5a3N5MVdoV2tCdDd3ZEFsL2xtZVd1MmdHa0luZ0pSR2NNdHgwRjluQkRGWEU0QnF5UStZa2UrNWo5c2twN2tNMG4wcG03SzFobjZHbkN0a0sxZDRDcndtNjdUcmpTbFc3MXo1MDdNaVgzeXlTZVJYajhXNzlCM3JyL0d6Y0NyVE1aWFJEN1JBMnIwUUxndm5yWjIzUi9zSWMxVHhuMEs0cWRNbWtPeTV0Y3pzeVk0em54S1lQWEVnMjNLeGp6WXFla1pwbTZkN0RiWnEzWnpoLzBTb09YeFo1N29wcytjNm03ZnV2VnJiNzczMWg5RVVxT2ZFUWMrUWh3QVhHY3VWdU5OdTZTM2dXMmpTZERJTG4wOXQ5MzVjc3ZSY0tXM1FYZS93cVZiU1lZRENhLzRZUVBNZWFNSmtLMTczUWVBRU02d052S1NvbnhPTjhGR0lCcGNlQkV1dTY4VmY1RGVBS3l6L000S0dueE1pbmJUY3lRK090MTlYcVpsL3phMUhFaUJkR0hIQVMwRllDL0RUcUF2bkpwaUdJZmpvNzFjK3JuTE1zNU5kbmdTekZOOVlIbFZLeVRmaWw1dEwvT3UrK3lLODZ4emxERnRjUzVwSkFRUGUvSy9ENUZkY0I0aUVjTkpYeEI0S0ZuWFIxTjYxTUc2MFl0SHhMejQ0b3NCck9wZnZaeTM2dnhrejhFNlNWZDlab29WVi9ITS9yQ1RNL0hlL1Q3ay9GYnQ0QkwwU2pOblorR3d5M1F4K1RyR2RSSTZUa0R2T09uRzZyRDlLVlFZZkhUNFV5VTdPWVdFUDgyS0xUYlRIdWNFZ3AyOUpmU3g3SVZBK0dmT1grZ3VuRG43d3IyNTJ5Y3Z6VjM3ZXBaczlEdml3RWVEQStQVFV6TVhQNHlVRm53ZkZ0WndaUVE2emJCZC9zTitCWTVLY21YS3JYM09wbnAvdXNQNUZDMlZSdmxYL0VxejdJRi91ZHh2UjVwUkxJQUNNaTFpRkZOUURJa3g0N1I1bDFwQXQvYks3blpPeTBxYUJORDhRQlF0MnBYV2dKcmtzZUNUWnRqdS9ZT3dRYXhLVTkvS1I5L2grNkxSQVM3MXNBS3NnMXpPaFJWMDNWUTc0K1I3OHBVYngvTGt4alZIMVFJREN2THVBRjJ6Z0dzbzU3clcvZUV6MHFzZ1RJSjhBSnlaQU4vSUtrN2dCWlE5ek5CTnVPWC8rY2N1ZEk4LytiaDdQZjdhM2R2M3ZudGovdWJidy9tTm5rY2MrR2x4QUhDZHZ0aG1ic09wQnRhNnQvZlY0RnU3NGhoZjg4UFkyVmdUV0dwQXFzMnY3alBOaDZkZlljdXV0SDJ1K0MzZEEvZnlUN0NvK0ZXdWdaMCtiYnFWWHB1Vzk2MVVYYzhoM1NFMDdyQW5xVXRVQlJEaks3Rjdna0IxdVEwL2JDS2ZIa3NmQnE1WnprSHM5dG5QUUd1cUhCWEdqNEdYdWxjSHVKUndCVmRCMW52cHpSNUR6b1JRaldUNDFPRUNrZERYcGpsOHoyN1laQzlvSXJWeTYxWXhKMEtLaFYvd1FWV0pnMi9SMDJBcDdoaW5FSGg1R3NFWTgyRlB6VXl5SEhhRFk3clhRMEkvZStGODk5Z1RUM2IzVmhiLzkyOS85NjkrcHkzYjZIN0VnWjhtQjBMbk9reUFqYmk2amZwVkEybkR0WUNpZXoxWEk5V3Q3aDlrVjVnV2hBVFhjbytiL3FmU2lOYUxXejAveUphZThxdjA4dG5HZmRSVXVMS1ArdWFUNldVWk03NWhCMjRESHRGNUpWL0FRZDBqYWdIcEpXcmM2K1lVSjAyZUxlVmlpT3dpQzFDT3pwZkFtWGtOeWhtUi9PbkpmeEM0VnZ3S1AxeW1GbHJMcjdWOUZ6VVE1d0RYN2R1M2c0K2V3ZlhzczgvMGV4VFloYzhGQlpaRFdrMGo5UFhEQkJRaFpiTmxvRE5HQk5JRVY3akV4MmFNRDgwNCtvc1RQUS9pZ0VMMUFpeXhQZWl2TVZaeXVRaGhoM215dXp1dTZCSmd1KzdDRTQramptRnA3L0xtTDc1OStlMC9xcXhHOW9nRFAwME9oTTYxR3BlRUZHQlU0OVpOLzdvcWpPRGJoaW4zTmx5bFczYWxwYTJwc05vRnNBV3VHV0lRcHA0RHFQb0dYT21XWFdGYSszNi9SS2RoMml0YzBWSFBaVmVhbWJXQWtxQllPbG5kdlU0d1A3UFNNRTd4MDNUeUVuQ3pYUHpHQUpFU3JPa1lUNzJqY1NyOElHeEVNMHFZUndIWFlkcU5XT0RhK2xWZTJyNVh1L2grQkpRaVZRK29mM1ZwN0djLys5bVFYQ09kUGlIZmwzU25WSXNVS2lBK3hPeVBJN1dTaCtjZ25pVHVTYzdGMnR0aTNCODlOQ2RuWS9nWWdaaWVNNFlpTnFadDRSdksyd09mMld0QW5jQTA5RW12ZW1DbDVwbFRzOTJaVTZmLzN1M3JIMXkvTmovMzNZZVFNUElhY2VCdmhRTkhCclRNc2NDZ2NyZmhGRmhZbWN0ZmU5aFVJOVhkKzRmWjVWZHBEK3lVWENQeWNULzNaM3NrVk9WYkFGWDVER2pyMGVsSXJBRzlSVWQ1VjNvVnY1NzFydzlNNWFYZkNRWmpOQlV1K1dTZWVUbHdwQ2xRQWxOUkQ3aCtYMUJ6VFgrV3Y2V2plSjFwSmdNK0RGd3IvOGlzL3drM3lCajJxMmR0QVZVYXpUTzcraWNDWEYwaTYrYmFMNzc0eVppNlpYbGNXS0EwcnRSdFhLWFpEM2s5M1o0SWlvUjYwazFhUE5TUWpWdDIxampzY1FOM0FIYWNhVmhqS2xsZHlZWnc3R0FjbngyeTQ4T0Rtd3NNWElDUjREK0ZKTTJxTG5iTlVvMXc5dXg1WmhPcy83TTdOMi8vOGQyVnhkSG1MdTNMSDkzL3JYT0F3ZHFVUUtzQlMwSGQyMkRxT280eXd6M00vN2c0NWRiRzg3NU1lMTl1UlkvUDdYMzV0M2JyWC9TVmZ6NGZuMGFGYmVNYnI5d0hhVGdJbFVBcHJYNWo1T0V1Y3pIM1dWRTAxdVdTMHVQS1VlbHBaOWY3ZEh5NGZGN2ZXSTFwVVRzN2dBNEFwekdOZWovMUhCNGY4bk5jM3VVbWFGdW11a3pLUEhUWE5wejVaNWwyQTBnZDJIcnR0ZGZpeU81bm5ubXErOHhuUHNNQTEyeUFxMUt1YVJuZWlmNGZlb1lhd09uZk9NZzVmZ0NRTTcxcVo1M0JzUFZ0WGZsalB3YkVXZ0YyREg3S2JaSm1oZ0FmSk80bnA1VHVtWnFGMnpqQTdvZGduUTFmZ09mdWlRdFQzZWYvMGE5ME4yN2MrS3UzYnZ6LzdMM0xqMmZKZGVkMzgvMnNySGQzVnpmWjNTVHRJZVVSSk1BTEd2QkNBd3hnTFF4bzRjVXNaakVMQS81RFNrdnZabUhBQTFpQXRSQXdBMmdBUVRBZ1VpQmt6dEFEQ1JwRGxFaEpUYkxaYkhhelgvWE95dmM3MDkvUE9mZjd1K2QzODJaV05kbmttTlcvcUxvWkVTZk9LK0xlT0w5ejQ4YmpwOWVvMnlSTVd1Qy9WQXZNek0vTjMzVkhJNjdCM3BNN0ptVVZselJsOVRLOWFSd0ROMTVORzliSmVzWnJKWU5zTGEvTDRrRHEvVWxaSFgvWDF6bzZybVRuWVozOGZobjhwdVY1MVFDT0wrQk14eElvakJsR2pLMEFvVHZVS2FkNGdyTWFYOHp4MTF6ZFJSa1hQTUl3dHI2aHVMWml4dU9oZWJKamVpSzhGMm81eGhLUGxRdDlNSnJJWjZZQXkyTVBEdmJiVGJaZlNyMWs4cUFIaHpIajhTZW9KMGhaVm1leFVtd096L1ZNNDZkN1J4b3IzZE1KQk5xd1JlTzNXRk1XQ3h6S2l6L1V2ZDdUNnF6REErbWh4UVRhcTFDSEZtcGZXc2ExVlhZcXc4cmVyNHNzS2RZLzlpeFl2REtuc2RpZHhaMm5XNDgvZVBEeGZ6NnZ3UVF5YVlGZlRRdkViQUYzWERxdmd6czBIZDJHanpKM0pEcWg4NVRUQ2UzRlJNSEFIL09zUmZDckY2L0xOUTh1ZFBBUEdkcmdJNE1NampwcS9BdURRU2ZQS3ozTDFqdUxxZW9ZSnhrMDNyZ1Z4NXhTa3BGTzQ4RCtyQlRtVkRCaXlvbGxNQ1VIMnB5TDJyVVJlb0RqT1BCVkxNbjYwQkkrbDNTbnRETTVaOW9SYWw0R2xTL2lKNW94SU5hYUg2b1haTVlUWlJ6MnRmTSt3d1BvZ2JHaVBmaFFCQjkvUktMTzZjZlZXRkkwenhZZGE3QitJMWlxRzNwbi9WcUFFR2huN2pmQjl3b2NmZ1JZeFlXeC9maWorODJSeGozWHJseHQ3cnp5YWp3YjNIZU84VDZTRjhwQmd5Y2E1cEM1alRyQy9WaDBVcTZaMHh6YStUUE5pOTJUWWRXbTJUTWFDZGk2ZjlDc2Y2SnpzM2Iwa1V1d25RT0dKV1psVUtlYTNhMmpaay93SXhuV3ZZTXo3ZXNxTDNmeldFYitvTm5ZMU9tdkxFaVFYak9hQzN1cTQxK096M1FTcjNqY3V2bHk4L0dEVC83SDcvN0QzLzUrVkdieVo5SUMvd1ZhUUo3cnd0MitYRG9XZ1k2RjRSd3lydlpvM0hrZG00NTgvNnBscE0yMzRtRkFLaS93SEZJdmRFdmVDVS9qa0VheE0zYnF6UzFaNS9XbEhiUXhHWTR0TzNIaGx6eWQ1Mk5MUDFoLzRCakQvTWpWNmhVdnM2YVF6eVZyU2owd1NMbmdJdHNCQTg1UXdVRzdZcXIrVUxtZGFQUE9NKzMwNzNTV1pkZGNVQWZEeC9JbU03QVhRMk41TGlKUFFPK2Q3ZDM0eUlXeC9jcFh2aEpiRmJMS2k5ZHpqeWQ3T1MxMU1MOFJMdzJiOEVNeUw1WTYyTFY1L09CeHM3MnU0N1FaaXRZd3dLRVdKNXhxSmdDRy9JQVRDT1NwN21sV3dJNnUzYTBkSFFPalV4UTBEV3R2VjhaVjNyN0dENXE1ZVJscXhtaTE3OEdXOEdZMGJXdGZ6TmNmUDNqM28vdjN2bS9aazNqU0FyL0tGcGlabTUyN1M2ZnhWWVhUcVR3dGgwN2l5MTZrY1lIM1ErMmdMaWQyUnpVdjhyNkEyYmk2SEw3bzVtRERSWG1HOGJpalN4clFEQ005WWpWaWVaNGV2bWJmMGFlMHZuSHRlTnZnbXg4Q1NNdTR0d2FXZXVDeHVxM2g3WGJDYVBJcWZ0ek9lOFZnWVdEd0pJRVRYMlpjMFlPUFN6TGJvL3FteGwzOUkyLzFYTmlMYTMxcUVYRENnczY3WXZiQTV1Wm1EQSs4L3Zycm8zRlpqQ3Q2TG1vdlZ1cmxwYlU4UTRRb2w0YUxMRVJRODZ3LzNHZ2VmZnhBMnd6cTVJTlQ0Y2k0OHZwL3h2aTFyaVBOQkRpU0o4LzVXc2RhMFhhazFXMDdUN2Uxa1l2R1phTjljaW51b3VhK3ptb3NsaC9ZUGUwSk82Y3BXMHNyQzgyRFIvZi9wKy8rL2ZkK1A0UlAva3hhNEZmY0FtRmMrekxwL0hRbU9ncVhEUUI0d0cwY2lBMXpiTnBuZFZMS2JWUWRwOHowWEUwZkF2VEhzdExicXhZaTljR1FXWGJxa3JxR2NaT3M1QmNsTFV2ekdJL0JNNzNqamphTnMzVnp1emhPV2h0VjVIUGhUU2FNY2xJc1QrVklsQm5OREdBK0p3YVY3ZllZSS9ESExCdFhlTnU0anV1VDNxU1lBODc2WWNTTDV4b0ZiWm5UREZsY0ZtcGRzajdKR3hyS1dQSUsvTjY5ZStIQk12LzFpMS84WXVoWWFjSG54d0R2MWM4UXhuV2FwYXZpY2JoL0xNUDZzSG42NEttbVlLbU8weG8zUFpGeFBWQTdxQzA0VzRzUkhhWnRrWjdXRzRPZWpKaUt0VENYUzRuRDIxL1EzR0VaVXZZZU9OS3dRSndCSnNJenlkbmEwamFLVHg2OTlkR0RCMitoenlSTVd1QlgyUUl5cnZOM3E4RGFvYUl6eWV0d3A3R0JJNmJqRUJ0V2VUaGRlUTNCS09lQ3YyWFljeVh2VU9YWXVGb3U5ajNUblpGSnV0YUloSUd6VndrczhTNktPNTJUaTlSTHcyV3lsdDc2VnQwcmJkTGhUV0dVZUdWRnROcExCZ045d2ZVT1dCNGlBSVloSlFEREdJRTdMc1A2WlB0MDlhZEc4b3JqKzNyaUJLUDJqM1ZyVzZVV2phWEJxeGVGYm12ME9OVEdLdndBTUlQZy92MzdNYytVMVZ0Y0xKRUZsN21ueEJoVjZrREFlK1dabWFjdFZMYTl2dFU4dnYrNE9kcldwakRUN0grbGoyRXlvcWZ5U0tmYWJTbFphTUQrQTdIZ1FEV2JWU1B5SVd4bGFWbXpCclNybHo3K0xTelA2eU9XNkJlMUxGYi9HQkk0MUtiYmU1cDljYXJ6eHJhMnQvN0YzLzNEUC94K0tESDVNMm1CWDJFTG5ET3VsazBIcTU0cm5ZVUxPREhob3RpZEV4elNOYmlzeHVPR1NwMnZwWEdNbk02WU02YVlQSUYzcittZDU1cDBxYXR0YVFlejBiWmU0N0ZsV20xaVlNN2orR1crTTBMVXozUVlVRHVIU1lzODJpdnhHYktONDJ6UVhmL3dZcmt3RkxQeXZ0U29vM2FGYjFmdnJFK25UMzZJRS9vb1lGejdudXRJTDJPNXVzNzNZdU83amhTakEzbnVFeE5QeWZQcXp3eUNEejc0SUg0SVdDTDcybXV2b0g0WVYraDRmdUllVVQvUndtTjVka0hqcUVmTms0ZnJ6YlplOGFjMUZEQ3ZhVm5ocWNxUU1oNUxIVm1MTUpPSGJZV0JuZEY0NnB6SzVuVEE0YnlNKzZ5V2QyRkk1MWZtdFEzaFVqTy9xcmNzRGVReVhNQUtzSU9EWGJXbjh2cTR0dnQwL2FNUDd0MmJMQ3pncGt6Q3I2d0Y0b09XT3hLeEE1MkJpdzRDM0oyRTJLSENiQVJjZGxGY1paQzJITktaVDNuT3c4ZThrVmM5MTVTUFBVS24xQjA2UWhzcDFSclpnSFo0WWU4QzVqcG5qRDRFMHhPbkxnR0czV0JJSFNnV1FyQktmdjdRRmlVcUtzMG5Qc2tNbVRGNklHRjhiVWNlbmg0WDZmUnM4MDBCR21EaERTdHVoU1dNTWRlWXBaQXFnbmN1RE1FS2ttbFNSczRDb2YwSjRZbnFZeE4xSlEyY3hRVmNUT3AvODgwdnhhd0JhSDNQcUFQNDVQRjRaMC9tbW8yblc4MzZnL1htWlAra1daU3hsZDJVY2RXdVd2RURvL3ZQaHR5YXREQk5yQityYVUxcTVVUGduRDVhTVkxclZwWjNSdU9xODlyRVpXbHRRWmVHQ2JSejF0U3NwbTlwZkpZZnVPT1RBOG5VN0ZmTnpsaGZmL3JQdGo3Wi85L1g5OWYxQld3U0ppM3dxMm1CdENUUEtZdE9ZaU1DaVR1aTRTNXpIaHpEU0Q4clhJWTdWRmJsbVBkRk1KZi9vckg1TzhabytNSUlHaTV6MGhxVmZMVlBZek0rZmEzK3NFRG5lYVhveVBBQVoxcHhlYWdBSHJ4bVd3NTQzSU42d2NmQnVqai9hV1B6U3QzejNnTmoyaFV3NUhKcXdhTkhqNXB2ZmV0YnpWLzkxVjhGREVOTDNkQVQ0NG9oSmczKzRZRU1zczdKNG1zL2dSVnBzcWt5cHFkYXdzcXJ2ZXFuNjFUanB6S1JFWjlxRDlrejVabFN3TUFIK0l2eVVsZFhsalVVc1NnWmZDU1VJZFV3QUxLUWpWemFhbGw3d2I3K2hTOWV2WFZuNVhkRDRPVFBwQVYrUlMwUWl3aXFMQjVNZDBvNlF6VUF4alBjZVRxYUEyVytnSkd1Z2J3N3JjdU5uekZRREFRZUdzWVo0K1hkbzBqSG5CM0JQYzJIam9tM0ExMTJlR2hIZGVCMVBGeEo1TUlRdk5TUlZNNCtRRlpld0NvOXRvcUxLa0t2cmh2ODVOZWpvZWl3RExyUzlWUXllUWRjcjdIc3pNL0UrVk9WczBIMGlhNVQ5ak9WUEUxTGxjWXl1QXpFOGlGSytTTUowMDJKRHpSb3dyNnN6T2M5a1FKTTArSzdGM055Yzg2cjlrWnRqUzI0dEJjakE1RWcwMTU0MDltaVlGMGVZbE9WcUVPK3hyUGZIMTR5TXhHWXhJLzNlQ3BEU2FPZ0IzTng1WFEyZTFxRyttVDlhWFA3Vlk2SStVTE1hZDNhMEd1L0JDL3F0WDk1WmpFMlhkbTdmOUk4dmFjREVUZjJtNVVwTFFBUU5PYkdxbUs2eS9xbm9EcWNxbjF5VDFycHdmMWxjWWJrbmMydjZwZEhYdjNLWXJPazRZRGxhekt1eXlwSFBlbDBLaU45ckRZN1pxNndkTi9XOUszOW5UM05RamordmIzSFQvLzk0OTJ0eWJMWXl4K0JTZWxuMUFKMHhjRmdvK2dZSktjdmlpdWpha0FydkovdTQvWHo0Q092THhONHhhMXB5aHdNZDJ6NEx4cjMrZlh6bFQ5bDlhS3M1bXVhSHpOK3JQQmk4ZmJ3eFBCY21Udkthelh0NEhKL0xITDd3R2NvdU8yR3l2cXdaK0ZhVi9EUURROFJ2YmEzdDVzZi92Q0h6Wi8rNlo4MjMvdmU5NlR2ZEV6Vnlqckl1T3JERTd0czdXb2VLakRxU1lBZlAxZmtRM2FaN1dCZFpHZEh1S0lJWEdUUE1PNHFvOHB2Q0Q5ODhTT3ZHSjFvTTJMYTdlclZxOHpIWGJ4MTYrYi9rSndtZnljdDhNdHZnVUhqT25xb2VXb1Z5QTlkRjVVRlVmdm5vZzVQY2Irc253ZW42dUkwOEJvcVhVMGJ4ekJpWHk2cjhVWDhLNDU1RGNHR3lpcWUwOWFoeGhnRzh1aFFqU2RHQndQQnF6WWZrY0RCT0hrSWdYS01DTUhHMW5KcUROL25xVitscWVsS1gzVkFKdkl4ZGl5UC9lWTN2OWw4NHh2ZmFONS8vNTcwMVFjbm5jUUFQcDcvZ1pheGJncm41RWcwOG9ibGI4cEY1VFZmZGNBN0pxOFFZNjd4SmlHamE4dktld0lldm54Ym9VdGVHbmZTQkdTa2dlVmpHUHJ3MFVzekNUUXNzSGJsbW1ZenZOUzgvUEtkZjVYWWs3K1RGdmpsdDhDNVlRRjNJanF0TDhOcTV5U2REelFkSjE3bUx0VzJUd3N5TUdRUSt5THZNdE5ZRHZEOG9HWERiT1BmL1VhSVU5RDMvOEREd1h5ZEo3WjhwU280MHNZUG5MYVU5SWhqcXo5RlNocWpaWlY0REJORVBZSi9HdEZFRkJkMGt4R2hmSW92T1Fxa01UYmhvY2x3V2IvOXZaem1CQTV0aGRkSXpEM0EwTTB3SU5rRzYrMzg4OFRvbjdKc3RicDdReDFLclVOdDVESnNFQityWkdUM05FVnJaM3NuRmt2Y2VlVUx6YTBiMTJSTVQrSWpGck1MdHU1dHhkU3FlZWxNVGRsNlVMV05Oc2hCQWNrTkdFMUNPeW12dGduSjVPV1JNa3RnVGxPeDVwZFZkNVo2c2Y1QVhCaEc0SXd2RWNTU1c1WVhzd2poWUY4ZjNYWjE3ZXkrdG4reS95Y1BIaisrajlSSm1MVEFMN01GQm8wckFtMzBIRmNsM0dreEFIU3VNQnBLMXdDTVlLUGcyRGpPdzkrWFlZNkJFeXAvakt2emlFamN4QVBYeGhWNFAwQm51T09nR1RPT0hTL1RHemZpV3MrV3J0YmN5MVBUS0tDTmpHcW9ZbjJJSzRWMEl0dDZhQmhYdDNsZ29yT0szVWFjaElvZWJuZDByUG94aWQ3QmNPUFV2SEg2TWMyV2VDMmZWRDVnMWJoaTlPZTFhUXE0N0lXQWZyVHY2cFZWalhOdU5ZOGVQdGFwQVV2TjE3NzZHL3J3Tkt1REJCL0h5cTdqelJQTlZSVXQ5UXlMcUQrcWYremh5ck1VWWpHbXZnLzZnZUd1dHZBcC9aakVjSURHWGFkbFpCbVBqYU82TWE5aGlHWCtsV1EvQThaNytjSFowWkRGcmd6N2tlYm9QbnJ5K09QM1B2N2dPLzE2VC9LVEZ2aXNXK0NjY1hVbnB0UDRRbWgydUhIeGRDWTZPYStwcEIxcTJyREtDNWp6eEVNeWEzbmxaK09heG1YRXZkTlBha0JyR2Nhb3NYbFhtUEhES1BZS0tyL1dCb2FNVVkyTFBKS0pUeUs0dHFZMGRRb0RJRWliRTBKNlpTT0RLd05CZTJDODFLalJ2bFlIdmxyMEVlVWVHaUFtZ0kvM3lJWXgxaGM0NlpvSGRsbG9xeUtVVnNPK2NSV1l0cytsdWJuQUJPTks0RDdoUGJKMGxTV3lHTFRYWHYxQzgvcXJkNXJkYlJrMkdkejVRM21kNkNwQjAzeDAwbzhsM2pBWHVuUEdGbTNzWmM2eGtJQTJFUVpMaDZmNDJDZjZhWTIzY3Z5TDVtYnBPNXNJOUJHT2l6SWVSWFNjMDVRdDJtZFhudlNCUE9vendSNnVQNWo5d1U5Ky9JZWg4T1RQcEFWK2lTMHdhRnlSVnp1bE82ZU5YTTN6OEthaEc1bWFVTGZpbXBmcHpKL1locFhZK1NIOEtOU2ZuRG5BckFFODVvU0dSeld5Q21rVXFpelRPcjZvTE9YYVl6SjJ0Z1c1b05NWTRZamVobXNrbS9xVUh5WEsrNTRyM2xYUHVHSk16QUl6TStMUGlnTUZUbElsMEtiYUlqTGFqRFJ0NFBhM1FSWTBjTTJEMk9rb2VPWWYzMGNacldqZ2xBMS8ydG5ETWhoWGFSMjhmWTRXT05zeXFPZ0wxZU5IVDhLTFhWdTlFVWVKczZSMy9vak5ydFVxaUlrditxb3g2VlpzSHYydGpQN25HS3R3eFN4bUxJai85R0x1c3pETjBtRU5CMHd4RFlzVkJ5Q0pyd1pYaUdSSTlkRk1iUEZnOS9md1dnOWllR0o3ZCtPTjQvMkRiOTk3OHVoOUZVL0NwQVYrYVMxdzNwSklWTDlEMG9uN0J0VEcwNXFSNzhNbzY4UDZlZU1Nd2MyN2J4ejZlZk13Zmo5ZmVaTWV1dm8wbFZjL1hma04wWm4vVUZtZmwvT1ZKMm0zTjNYMUR3K0dsREs4VkQ1dWNmRXhDUml2djJud3pQRjhQTlJ1NTdIR0lmQ3VGekx3a1BrYWp4N3dSRmZMUnlmQzB1SktmT0Q2OHovLzgrYlAvdXpQMk1BNjZPYTA2eG12K1djWVZ1SGhrVHE0bnNoanZKV1lnQXd2TEVBbXd3TEdSYlovWUdSUDI4MWlNTzY1eUFGNkgyK08zcmR2M21xdXJLMTlIZmdrVEZyZ2w5a0M0Ym02QTlmTzV3Y2I0ZkZ3NHc0b3hJUFB3NjZMTkE4MkZ3RVlEM3NObGFmaDBKay81WFFVTHRKODRVMHZoWTZiM2xMMk1lUXp2Z2N0Y3RBRm1Va0hiZktrUTZiMzRqaDJ4eGM1Y1RldmxkTDhSNG8rTGhiQkE1eUtGNWk4N3RKNzlTV2E4NTFZd2txSUZWR2hJTVlDZnVpWmdSU3dXQjh2anpKakRRTUlQNDZWVmptL2J1bnBxUTFVbC9pMXd6c0dKK2hUSnlXampUanhJTkl5TWlqc2RneWcvckFqRktFUDkzMGdybGNnai8yaFBIOXpzeVZWSjBZb0FDbG1wUlNiekp3SkJ5ODVQR1h1bmVDY256V2o1YXlNbnpKM2RVRnpZUEZLSDY4L2xpR2VidDU4OC9YbTVzSU5iWGk5SjFiNmdkRHFyRk50akQydE5tWDhOazl6VUsxVlJYUmdMcTkzRVVObm5wSEZNOUZRYjgyM1pYZXRGWG11T3M5QnE3YlVYck1za1pXUzJoZDNUdnJNU2hjZHN4dWJ2UnhvcnV2QnRvNkUwUWV1bloyOXIvN0RPMi85NjdGcVR6S1RGdmlNVzJCc1Z5dy93STZyMGFzZDBtbDBvUk83SXdQdkI4TXFEVGpPVzRhTks0YlZaYVkxVC9MMjZJYU1lTVYzbXRqcHlxZkNqRU9NZ1J2TEY4T2ZlcXZ6UmxCbmp2cG1URExweHVrVEo4dVNQZzFYcHJPOWpKTjh6V2ZjQ0JvSE8wNWJPYmo5aVdrVEg4K05oMmM4M3gvbks2M1R4TVlqYlhrUnQyMFk5d2lMU3psanNiN2RwYzM0NElaeG5VVytMalo0WVQ5V2xxMUMrdVZYdmhUVHlrNjE1cCs5V3RsQW00SjliZllDLzJOa1dRYnBrS1lmRFQwWGVMM3N5aFhIYkdzM3JIbnQ0N29rYjNSUm03YXdITFpoWDFmbCtZbWFvNDNFNTB4R25xbGZ4NW9HeGhhRzIwZTd6ZWJPN3JYancrTnYzSDk4LzZPVy9TU2F0TUJuM2dMYVkzanVidVVhSGFqdFRIUXNMbUNHRDNWQTZJSDdjc2MwWC9NaGJ6NmsrN3l6TEkyVDhTb3RhUnRYeTRJUHdYaldqN3poTlhiYTVjNGpqMnRHbmRnd2NLeUhZYXBCbE5Oems4ZDU0OXJoSm1xVlpZdGtXRDl1bVY4WXNWSUtHbC9vUjZCZHVISXFVdTVDWmQ2VWs4Ymc5dHVOTXJkWlB5MGlRS3B5MXc0Y2Y1MjJyelY4UXVFSHFiV0hNcXppSnoxbVpEUVhOSFFnNXJIZS8wampyU3dpdUg3bFJ2TUZmZVJhMFE1YXU3czdNUThXM0gyVkl3ZWJuZjYvUEh6U1lvaW56OG93TGw3M09WQ0xtUUx6eWkvTG1BTG50ckIxSTBSNHpleXdOYVUzS2hsUk5ZN2dqRjhMdG5Xbzg3YmsyVDU4K3ZqK2V4Lzg5TnRad2NuZlNRdDg5aTBRbnFzN0t1emRXUzNLWmJXalVsYmhwTjI1M1ZFcnZ0T21xYnlSNXl2eHNrTWJSbXc2WXZPM2tTQWVLazllS2FtbXJYdU54MlNNZktXdWp1QmFYdlJpQUJjWVY0eW41Vmt2c0R1WWpYT0ZaWjNCSXhnM2M5M2Y0TmNhZC9TcGJVUSs3MEd1ZnFMTXdicFQvcXhRWlpzT2d6V1NoUlVOUzVvNjgxZDNRQ2hwYkluemlKdjBYaGRrL0RnbGdDTmdOamVmTmp2YUdQdlZMN3dXQmxaM05uQzFZWHZnTUxSd3hNWXozRk5kR1dPdG1WR2hId3o5T0NCdlNrTUF6QkE0ay9jN3pZYzFHZEZEOGQrVmw3d3BBNzZ0amJ3UDVSVnozdGEyamdZbmZTTGpmYWlURFRiM2RSQ2tOblBaMnRsNVkrZGcrOS9vNlBEY0UxRjhKMkhTQXA5bEM1d2JGb0E1bllyZ2p1WTRnT1ZQZFBiVzRORnhUVmRRSWxucGE2YzNQVENuUFlicXptdzRqRWpiUUl3NmZpdk1lTmFCL0ZDZ3ZKWTViUjBrSmVyUng3TzhQR3NMenVhVE1lS0NWeXZYZk1Hc2FmaFhtTXNjVi8yQitRcWk0SlVMQm96bmRxS2N0SWNGeUVQcmVqRXV6a2NuUG9CWkZqaUVtZ2VmQUgvMk13ZzVNbnJ4SVFuanhuaHcxREhyUWJta2hMMEZmaVo2eGtuWlJ2RllIaUpQRXEvemVKUE1KTmpZMkl1eDJUdDNYdEhIcGR1Q1N5OFp1em10UXB1U0VVWjhIS0d0N1JmeFRIbVBFTmQ0elo5SFBzWlhYdXVSYUhZMmRXRGkxcVpPS1RqUXZnc2NzYjNYck9za1dQWVNZQ2JDdm82RGVmcndTYk1sQTd1djQybTJ0UnZYOXVGTzZLWng0MnU3UjhlTDcvL3MzVzlSMzBtWXRNQm4zUUxuUEZkM1dnUzUwem11TUNzQ1BsZDZUZGtaSzc3eERLUHo5bVhZQUlEVE42NjFERjQycnVCYWRsK0daUmxlWTJqNjVTazNEUkhXd1BwVlBNdDZsbkhGbUpqT2ZKSGZ3VHFQc29NTi94QlV2VWU0R0RMVllaeG5HdUY4N2M5N1FEdEJBOHpMVTIwNFRXdWVOVzhjWkl6YUdvTXBQcFJwVjcvNGVjQ2tTcEhRQXdqL3lHR1FwekdLN2VzNU9MRkZvR0JTcDluUVVTMlBIejlxRmhjV216ZDFnc0dTbHFleTM4Q2hqT09SVm5KcGNDUEdiS0hqWTllUkRPZVJQTTRUSGZOeW9rVUFqTE95aDh1QnpzOEtvL2wwc3ptVDE4bzRiV3owSWs5NVFZYjU2c3BxalBOdXIyK3dNaXNNOEw3a0hHZ2piZlNZWjZiRjNPeC9QN093dFBQUlIrLy9aVnVSU1RScGdjK3NCYzRaVnpqVDZTNjZxbVFiSEUrRmNhYzNUdTI4bGEvTEs4eWRHdU5LMmxlZkJ6SU1zM3diZ2NxWGRGK2ZDak1QWUtTUlI4dy9oOGkzYmRIQmNreFczRnM5TWhaYW0wLzZQbi9UWTRnSUx1L0hRenFiRmx6Yk05S21OVDhNSUlmMjBSN3dzWUVGejBhMndreG5YcFdmWlViY3lxS2NvMWFDcmgxN2JYT0pqb0dUbFdNTVZzcU43aUYxNXBWK1ZvYnY0R1NxZlhYZjBHeUMrZWJtdFdzcW05VVhmQmsrR2RpRGZSbGExWUY1cVFmeVJIZjFpci81ZEYxZTZxYUdGTGEwTGFHR0VCYjAwVXF6Qkk0MDYrQk14amMrZG5FdUYvZFE4MkJYbDFlYmwyN2ZhbFlYWkxqbExSOXJob0NlS0JsclBHbm12K3BIUWp3WWh0amQzYnFtRTJlKzlmVHBvNDJzeE9UdnBBVStteGJJZVRzdEx6cFB2M1BYanRjdmR3Y203dE1OcVdjY3gvQnpBT1k4YVY4dUo2NTAxZmhDWjZOUjhZZlNsdVBZZk0yYnZQVncydm1LUTlsUXFIeUh5bjhSV01oWDIvaUhBRjdBTEJNOS9kclBFQUFYRzFtRDc3WC9wSU9QYUlmcVZjdU15MGd0OEpoeUovcCt3R3ZrUXhRQitienFFK1laZ2xEWk1WL3JOZVlKdjRXVk5XMExlTmo4Nk8yM20yK2V6RFMzMTY0MXYvbTEvMFpmK2ZNWW1ObEZHVTdSeUQ4TkEzMTJvTDFnR1l2RnA5WEhyWjJkN1dadVRjZTh5T1BsdUpkRG5iazF6NWl0RFBxSmhpendncGZrRmM5cG1wZVlOc3N5c050c2l5aCt4MHo5bXRheDM5cHpnQjhCbHVBdXpTOStmWFZ4OFEycCszNG9QZmt6YVlIUHFBVTB2RFY3MTd6b1FIUUFnanNlc2RQQXdhbDUwc0M0Q1BhYVNCdGU4ZUhQQmN4d3A3TXNYei94dFB3cTZuSjR4cVJMZVI1OGtZNzE2T3B3eU9RNjBUaWMyTVlsUk1taHg2TVgrdUhOOGFyY0dZY3FQMWhUZjVYMzRaUUJRNytzWjljR3lROS9WM3hsWWRnOUg2bStSS0Jjd2tJWGJlaE1tWlJYTExpS013OFBJTVBCT3NHT2RKZnYyaDdkRmpRdGlYcWVhTHlUVjIyK3lIUHhRUW40bkZaNHVWMTlyOGpERDNvTUtPbTRGNDZsbDFwRkJpdy9RTEVYYlhpSlVoeDk1Q09MaGs5OXdtSzFsQUs4amhubjFYM1JHSUUyV05HN3ZJWUdWblVRSVljTjhnVi9jMk05WmhEY3ZubER5MlJmZzZwWlhNSTN6cE1IenZTeGFtMXBzWG41eGcwWnhHT2RFcnNGS3hsd0djWGxKUjEwT0MzaktBTzZzdFFjYUIvWHZibXpabWxxdnJraW83c2lPaUZxWSs3TjV1TVBQMndXOGVybHhaN0pTNTdSQ2JhbnlwL3BpcVc3UjZkZldaNlpmL3pKay90dmgvS1RQNU1XK0F4YVlHd3FsanVzWS9pVHJwZGxWaHc2VXIxcVdVMmJYNThISGRrZHZEL21XdW1SWVJjcGphVzZ0UXlHalVRYXp6QlZvYlBsak1kZE9ienJCVjY4MG80VDlISWRQUVhXcjR1bFl3OXVHVkdBUVcwTmZNQmxTcEkyK1NvN0NxYkw4bGFXRFBoWXZpZUxSUTIwcFQxWURndGtyaWx0QkIxTFZkM2UvckdnWFNrajc1aTBBK1g1NHlYZUxZN3ZrN1F5bWxMNjhXR2R2K3FJd1NXbXFtSWRGNzhreDhlU3IxZjZlYjJXcTFpYnFtekt1OTV0cnE2dE5tOTgrZlhZZnBBNXI1end5bFF1VEMwZnhOaWdtdzlVSEowOW94MnhWbFpYVkNMR21tckZGQ3h0SXg0R2ZHNVJweE9JMTlMcWN1akZiSUZIbjJnVExMWTVCRjgrTWM4Si94Z2FrTXJ3ZkdON2IrY243MzM4L3JlRGFQSm4wZ0tmUVF0bzRjenNYWGRXK0EybGdWVjRINjhhMXVmVnlmeUk2Y2krcEVISWN0NTQ4QTNqU20rSWtCMCtPb29NUitwQWh4NnZRd0RhUDhrcmpRRnBYOGFwNVlhZGo5TjRZRERDZUF6R1NXWCt5ZGQ2UWQvSlZpcVFiWERiYkRJb2Y4MERXb0o1RjVTQTlZMHJSdEZEQk1SNGF0bU95WU4ydGlkYitSb0hHR240Y01XVXEyaTdOTVRXTy9YVEhOT2h6YTZ6c1VMVjlIclQwNVdwYlo1dVBHMGVQbmtRaHU2bFYxOU83MWhlTjNOWFovWG1BU25IYTI4SWIvM3BFNDNGSGphek1yckwybjFyVG5OK2RjS0E3S1lNckI2TFdSMzVNck82RklaMVVaNHRCdmxBQnZuSi9ZZk5uZzVEWEpuVFJ5d05CWnlLUDZ2TWx1VHh6aTB1TkVjNmEydm5ZTy9hek5uTVd3K2VQSGcvRkozOG1iVEFMOWdDTXE0emQrSGh6dXU0RHh1Q2cwUG9kOFNLbXhqZDMxcEcyaGVkUE5PZG9SMDJzR2xjN0xrNnB1Tmo3S3hMbGROSko1VXlJMVhrR3g5alp4N0dJWFlZNGJVR281OVBnenR1QUkwRGp5VHJkTEErTmxKOTR3cHRwY2R6TjZ6Q1J6QU5TNHdNb2RyVWV3RHd1bzhIaS9PUGtmVStCSXpGY2tGUHZmdFhYd1krYVZSQ0xpbkxYZTNCUnB0Uk9YbUZIdXJBRUFzanFnUU00V2Q2ZlQvUjBBaUdENjhXSGdlSCs3cjJ0SEpxczNuNTFzdk45V3ZYdFl4M0x2WUpZQWt0ZEJ0UDlkVmYrdU9CVG1sOGRsR2VLV1dNenpKRWROUWExeWtkLzdJZ0k4dlIyOUJOeVZQZWVyVGVyTjk3cUE5Zk9oR0JiUkwxcUVUOVdYdkFXSzlvOTArT1g5NC9PWng5OTZmdi9JbnY5U1NldE1BdjBnSWp6N1YySWhnNlQreDBIMjdCdFVNYTFvK2o4N1hBSVo0MnJsNythbytxNHBJT0d5byswWS9WZWRTRHdwaWtEdWM5MXlvM3hZL1hwMVZwRktVcGFERVJvakNtZ3pvaTFpS0tCdUlnS0RUUUVybzRjaU1ZOHJLc2pSTTl5b2YraExrU3o2cFRjR3hoSENkdDQ0cEg2dU5PTUtqc1NrV1RZVmpJMHpid2NkdGJ4MnpMNFI4cWZzd0kzcVZxOUtNUVVNWmtPYjJXREx3ekp1M3I0UFJRci9zeWl0SU5ROHp5MXlsdEc3aXREMVVmYW5PWEd5czZOZUNsMjFyQnRSTGJCREpmRmVNWnVpdmUzZGpTakFONXRuaXZHanRkMGtrSGZQVS8wSERJS2NlK3JNbHpsVGU2d0l3Q2ViYnp1blkzZHBxUFAvaFlVN21PYzRxV1pCL3FveFlMRDg0a2UzYUpHUWo2dGpzeis5dlhWdGR1dmZ2K3U5OUE4MG1ZdE1BdjBnTG5qS3M3bUR0dlAwYVlZVlh3ZVNPbXZoUEdyMkxSS2RORHJWRDRHVTVuSlYwdnlzMkxUVnN5MEdIcHNta0VNQ2gwZlBOSm5QTi9xekZ3UFlnSm1jZDZPdDBaTWVPR0c5YVdHNi9HcEFubTZYU1h4K2dVR2NXNHRvUVJ1YjZSR2Z2VDZXU3dkU05XMDQzdWo5c1FYdW5aczJzVVd3Vm1BSVpIaTZHRkZtTmNnM1Z3VEZtKzF0TmVyUjRwTU13bjM2azRsb1hTdW1MTGRZOVdWdDBYWkJEeE9JOFBOYXRBd0hsNXpvZWE0NnJWVXBwNnRSMWU1NDJiMTV1MU9HVldtOFRvRlo2UGszaTQyenFTZTA5R2tTOWJTL0pDVnpScmdLbGN1L3FZcVUwRmRjeTJ4bHoxTVNzMjhtWXBNMTZxVG05NGVQOVJMR0s0SnA3TXJVWGhveFBOajhXNGFzN3JnanpoSmRHdHJDeC9mWDU2L3VTOUQ5LzdEdldkaEVrTC9Md3RNUHFnNVE1cVJzNzNZOG9OTTY0N0g3SFQvVExuNmZCRHdUd3hQRjA2T3pENEhXL1QvM3pHTlhwenE0RGxrQ1ZOOEd3Qmw5bEFPUis5c3VDYnpuRXdhZitZeG1VWm8zZG5JSlVLYkJ0Y0tWSlp0R1hHQVh1OGZVQ29jaGh6dGJ3K0krQUhtdk5KY0h0aVhMbnl4eWs5V2NvcVQvQ2Q1NTAvK2ZzSHNmdXg1TGQwZWdyNUlRRXBvelF3cnRucCtkaFhsUTIxT1oxVjFQckVKTytWK3k2S0haM1d5c2JXVjNTaytLdDM3c1NyUCtPa25Hb1FwOS9xV0c0OFYzUms3dXl5UG53eGYvWlllcDNJVU01cHRnVEdsUTlpN0dCMnlvK0ozdnUxRTVabVRldzNTekxFYTJ0WE5HNnJEV0FrTU02Y0ZTMVR3QmJ4ZURXa0lLLzRueS9NTHA2OFB6R3czTWhKK0RsYklLWmlaV2ZKRGdTZm1uZW5xaDZoWVpicGprcnM0TFJqdy9HT0tqM2w1RHYreGZBSVRwbEQ4bkpuVGpvOFZ4c0dQTmZ6K0taMjNQR3JlcGl1R2xjYlZ1c0dEcFBRKzBhajVta0M4ekwvbWdkWEdJRVQ4QmEvR3RkK202RjV4eVByYjk0dWMvNUVIMmRvRDdjSjdlMlpBL0E5MHBpbHZWVnd6TmN3ZTYvVXVkNHI4NmU5UStiSXlQdCtxR1lxaXFsbzVaNzE5Wk1UcW1XcWgvcHdOYVBwVWt1TURNUkhxcm5wT1htT3k3RUs2OG1USjdSUTg4cnRsMktoZ1d4ZjdGM0xDcTI1d3pPTmoycFlnekZiNERLaTgxbzZlNm9aQ0d5a3JjOTNXa1N3SWdQSmNJRVdMY1FpQThYNlVkbmJQVUJZczNaMVRTdkVOQTlXd2cvbHZlNXAwUUxiS3M0d08wR24xRjY1Y2dYUCs1L0xvLy91Si9jL21VelBpanMrK2ZOcFcyQmtYT2s4ZENoM2JIZW1JWWJHSWZZRkhqVHUxSDA2ODNPSFJoYkI5QzduOVkrTC91bngxMFJrYUVBZFFGNEtMZzZkUFA2aGcvbW90MDJ6UGIwUXdPVktUeGhaR05YT3NDSVhYWHc1cjNHU1FHTWN6NWRKa2RUbmwwYlJ2Sk0vZFNHNFRzNEhjTVFqRGF4MVNuMGxRZS9XUVkzK0xROWlMaHFGK2FXcHo3aCtpU01QVEdPWU9SN0tmR0ZlOHozOWFrYmprSnBqS25yMHNiZEtub3M4SDd4MnRUYWZmV3ZudE5QL3ZMdzdKQitmeUNqcFI0WHgzQ2tzV2dpVFZlVEhUQmxVU2o2Z0kxTjRzUXlBcFFCTWZjcXhjZ3lyYkdyd3BpN3NQUUFQakRqRENib2ptdWU2b0VVRFo4MUhqKzgxbjJ3K2JxNi9jcXU1YytkVmlkZjRyT296c3lUUFZ4N29xZllLWUhPWEV3NHB2TFljSDhDTzVmWEtOOWFIcjhObVRydHV6Y3FEUFphOEUwMFBPenc5YUI1dlBtcVdUcVkxVmp2ZnJHbTg5cXFHSjViUVEveU9OZjFyU2NiNDlyV3J6Wnk4NnB0clZ6SHMvM0pqNDlFZlBucXFyMm1UTUdtQlQ5a0NZOGExMHRvZzlBMkU0UlczcGpGVy9WQjVZTVNjQjQ4OHdaM2MzbEowT0hVbTRDa3pqVkY4Q0FtS3BDTUpqN2pVT2ZFOG5RKzA1L3pqZWlHUFlCMXJiSGdnbEQrbUxhQXgra3FudnF5UWRVbTZUQU9yZUpsSlBTTGQvaGw1dUtOODBobEh2d2tSM0s1a3FuN1Vqeko3cW95M2tnWUh3NHhoQlhhc0hhZkFBODRQRHZHSVp6dGp3ZmNNR2UxdFZNTDFBWG8rWUVKQjFrOG8zbUdzckNLTjJ0Wno3MEE3V3NuRFBKUzN5ZW10Sy9OTHpRMnQ1RnFTdHptTG9XYWZBY0ZaQ2NiS3JTbnB6WnpZUmIzeXN4OHNHM3N2YW14MVFWY3NkaEJ2ZHNqYTFCTGE1U01OSGFnTm1JN0xGSzh6VFIxZ3RrQmMrZ0ZaMFJ6WlpRMUpMTWs0YzVTTVd1RmZidTV1LzIrVDNiUE8zOHNKNVBJV0dET3VmcmhONG53L3B0d3c0em9lZFVBRFdsend1ZHhoblFiTlplNnM1RW16RTczVG9rNjg4TWFneW80ZktYVlcrT0w1Vk9OcVdlQThLeUNIWU9OdW5ReXY5SDFZUHc5dWhaRjJQc1cwZFFtNGpYa2FNT01HdnNxelhwMTBqQmd3aDVvR0pvcXhjdU5aZm5xMjZhMUNHOFpWQnBWeTZoN0dWUjRsODBuOWxrRmJFOERQOXZFUEhyQ1VZS09Qb1NSWVh0VVBHUHZORXVjYlFER3VMUjgyZmptV044dm1MenRhdXZ2bzRTUDV2dFBhZytCNkxITmRXNUxSWkpTVzRRVDlBT3pLRUxNLzY1S21aYTFxSHV1UmpDVzdiRTFqYlBXUmlyRlZDWk9oUG9nanZ4ZTFYQlovZWxIUEVhZHlzeWhDeDNIRVdWencwMDlOczh4SE1yMGhNVHl3ZHUzNnFvN2wvdDIzM3Y3QkgyUk5KMzhuTGZCOExURGFjdENkb1pKbEp4ajNqR3I1VUpyT05NU3I0dFp5cHkwclBkYnMvSFJBakd5V3RiSHlCUFdYTVRuWmlkTWpJdDN2MUZYK1VOcDZJSTlnZlF5dnNFQm9jWngyZWEyL2VZemp3THN6VGpJemJYSEdsaDlBRjdVWVdhYzB1SUJxSFZ1VWFCZW4rekg2WURCcDQ3RzlCalFVNGVFUjJwWGdHT09iUzJkelpSZDBLZzBjNUZzSDN5dU1iVzJ6UUt4L1JKb3pDZHI3U1JuZUxwR0lqeGlTMEJ4VmxzdVM1a2dZZHNkaXY0Q2xsZVhtK29LKzltczhkVm12OU9pOHoyNWFNcTd6K25pMXBqSGJVekU2a05mTC9scUw4a0RuTk15QTk4cEJoZXoxZXJxK0U2dkFWcGtaSUFQTU1NZTBOdDltQTI2TU9tT3puRXdiTXVYNXZxUnBZUXRMUzY5cEM4V3Z2UFB1WkE1c3ZaV1Q5T1V0SU9NNmZ4ZVVTenRFajRkeEhidUQ5ZEJHV2ZCOGdldTBFWnduVHM4bzhidTVsUEtIYkpBY0Y4L1ZmTlE5MVVsYmI2L3QrUEI4bm1DOEdwUDJaUjR1dnlnL0JEZE44Z0lqZFlwOG13WkcyMXhtWEtFVXlpaVlMd0RTUVMvV2w5MFBlNk45QXdzOGh3ZVNsL2t4dnhUalN2bElqcEtVKzRjdzliRFI3OW83NFVFMitzT2lBWXdyQmpYMFpQNlcwbFFNZkF3Y2l3UU9aVmhQQk5PclZlelBpckc3cGgyMEZyV1RGdE92cm1oREZoRTBCOEk3bE1mSmNNR0tEUENNeG9YeGpnK2w3L3lxWmczSVFNNXFtMElkUXFBTnNyZWJiUzBtd0hObFQ0SkZmUVJERlY3L05UNGhnNno1czlyc1JSb3lGQ3dqcjQ5c010RFh0ZmVCcG5iOTl2N3V3Yzc3ayswSlIvZHlrcmk4QlVaYkRycEREbldJeTFsMHBlYlJRVEoxRWR5eWlKMjJjVTJQTmIyYm1vN2VJTFowQ2tKdXpwSnA5ZEJScDdVeGNNbXpZc3V2c1ExZDFjK3d5czgwd0dwZEs1MXgwTnVlYThCR3hqSXJaTHpnMzliUnNyS3NheXZEYSt3eFYyRGc5NitLU3hudGJTT1o3WngxWU9NWDJwREJGbVpoa1BiNDdLa3NGYmhKbXh1cllmUXh6bHBPSFNJc3Q4b2pQWU5CVXp6NmtTQ2gvNjdxb1dSaDdCaHpaZU50VHBQZDN0cU84VklvMmFlVjEvWmxQczdwaDFZYmE4VUpCRWNhVTJVajd5Vk5wV0pJNFZnZnhhWTB0WXJ0Q2RsQmk0TWIyY05nZDMxTHNqVjNWajhhakxscVQ5ZG1acEdkdDdUS1MvclBOekt1MGlsdmk0eTlEUFdLWmhlczZVT1hGbC84N3NjUFAvblg2K3ZyZk9HYmhFa0xYTm9DY2ZwcnhhQlRFR3drTHVva0Y4Rk5SK3gwNWQ5UHd5YzdkY3AxT3ZubnNFREMwdENPcktvZWYzQWNRcDVlQmZFNExQdDU1SnZldkZMdXVGRXlEckhMKzdDYU41NWg0elIwMjA3dnRoZVBZTllEMnNDa2pyck1BOE5NcUhnMWIrUHFjdFBWZG5YN21JNHl4bUp6cVd6eXg1aENpd0ZqemhNMFlXd1YxLzBKek1OMUd2dmhLSHBhSC9NQ1AzUURSNTZpVzRTNXFoaFZqQ016UXhoMzUzQkJObTNaMk5pSU1kSWxUYjlpcjlZRnZkclB5b0N5RCt6MjluWnpKancyeWw3VXg2aGo4V0g4bGUwS21WNjFxRmtHQi92YWJGdXpTVGlGOTBBN1pISDB5NXk4V293eHVBMHJ2RFFObUVVSnpHUmc5OWU5SXkyNWxiZTlKcStaWVludHJhMy9XWnU4L0I4VEE4dWRuNFRMV21BMExBQVNIV2pVQ1ZvcTU2TWp0TWJNTUZCcW1uenR1TTRUWHhUTTEzenN1WkwzVkt4SWV6aGdwRU55TkYzSWxYSEZJdGtRZ0VINmVZTDVnT3QwTlVnVlZuSE0yK1hPR3dlNHl6SWRKU00wbGJacHg1MThpa3piOFR0dlhJMURiRTgrWlZXam5PbCtleVJOZXFINXNXdWNCcmw1SmxicUFqNC9ZSGl4R0Z0Qnc0T2QxUWNseG1NcEE0ZGdIU0xUL2dsZThaemw4RUNPdjNibTlVeGVLK09tWnpLS01hTllVN0JZYmNVbUxXeDh2U2tEaTJHOXVYbzFoZ211NEZIS0VPN0p1MlhWbDZZUU5NQXcwcnRhaXF1di9Wb1lzTlNzYW5oZ1g4YjN1bDd6cGJpMkw5U1VNeGxYanBKaENTd2J6ckNKeTZLMkxHVGU3Q0gxVTFNZlM5ZERlYTlMMmlobVZSKzQ1dWRuVnovNThNUFZkMy8yM21TSmJMMnhrL1M1RmhnenJyWFVuZEJ4N1NpMTgxUWEwc1ozaklGeXNEZEVIaDZVMllBWmRzTGdtRHBzM3dNS1E2TU94OXhUU1JsMTNQVGtnS21zZUVEbVoxMnREL0NhTnA3alUzV2tYRCtQSHQyRnZVaWI0YkZGS0xJZWxwR1E3cS9oeUxQTU5INXB3QkxUNll6ZEhrRTdZS1RRclgrTjYwbGJuQS9Xd2ZmQVAySzh5bk5SRGt5UmpLUU1qT2FCZW1ZQmJZdlJaTHRDdkZaNCtJS1dHUWEwVyt5bnEzdktLL2ljUE1qUVMyT2g4TkVBVGl4Z29CRjE5MFl0RzRZMDVxSUtHODlSRmhYUGtYWmdjeGV1R1FtZmxRR1VZV3ZPbnVoa0FtMVRPS2U1cmFzM3IybjQ0RUJmL3VlYWF5dFhZa1lBSjh6U2R0YzFUNVhwVnFlYUpjQ20yRmV2WDJ0MmRyZWFSY2xla2llN2RIV2wyVDdlYTdaMG5VcTlReGxpdWVscUF3MDFLSDJtR1FkNHVBdHFFdzQyUE5DSHRWdFhyelVyMGsxN0dueDliMk4zNS8zN0gwMk9oem4vcUUwZ2JRdU1qQ3NQcEs5KzZ4aE83R0NZOHpZZXdHdWE4Z296dnVrZEc0K09iS05yUStOODRCWmpYV2x0UE5Jd3FxTmlKVXB3ZVNjbjlhcjVUSGRFNW04OU10OTVqaTRucm53TU42ZWE3eHRYdFhyYjd0MlBrUG1wS0FJMUdjSE10TVRtVDR5dVE4RTRsSmxYdjAyQXo4N3dCVDNiang4dTlJV25jVEhBRHVhSm9jWEk0czJ5OElCWGVXaUFjeHZBSTRaSGpESWdRTUgwVGhOUHl4aXpQeXNISEZMT2dBRTE0aU1VeTJEaHkvUXI1c0pPeTJnei8vWG0xUnN5Z2pLOG12eS9yaE5tZVkzSEMrWEFRLzFzeUFQVnh5NTVubWZvSWU4MU50dldtTzJwUG9RZHlmamEyOGVRTCtxREZuSTVVSkZWWU5TTC9XWGpiRERKdm5valBXVU5EZnp1bysybm5CN0x5b1ZKbUxUQXVSWUk0K3FIM0oySWZBMHVKNDRPMGlzM2JpMGozUStHbVgvbEMyN0Nzek9qQzNsaVgxSGVrNTAwblRGRmM4dHgzTmVqNWsxdkdPd05NejM1N2hvMnJxWXhIMkxUVkZnMXJrbGozaDNmRWY0RmRSMlZ0d25MZVZaYzZXcmRnS2N1c2tzeVV2SDFYa1lKUTRxeFRBK1dEMStwbzcxVzZPQmp3d3A4UWEvVTRGRlBIZ0dHQWNKRXhpTVZsbmF3WGVEREJTNzdzOEtMWVNGdGlSa2ZxakN5b1k5ZThYZTBvOVZqR1ZHV3RsNjllclc1ZmVOMmJQNEMvWlpXbURFVmkyZG1TY3RyTWJUTUpwaG42cFdHQkE3WnRsQzZzRWdnVm9OSlAwNXN3SmdTWnJSRm9VWmxZMFVZdTNHeElDMU93VlVhQTMrbWoxOTQyL0M5ZC8vQi9rOS85dDYzZzNEeVo5SUN2UmJRQjYyRnU3VlQxbkxEZ2JuejhRRFhQSEREZ1BOUTE3eDVHR1krRjhXd3A4d0dsZGc4SWxiZW9jS0JJU09tK2JScDQ3a01mRG90OFVYQlhrelZkMXlPamVGd0RKM3hMY1A1aklGMnRGMzZ2SEdscGFHcHdYcFZtUGtEbzcwdUMzMStsUlk2WHYyekRvekRZaVRUcUdKZytlRGxXUVFZVkdqQnBVMEp5TWE0Z3B0REFmQ2lKSTFteUJaTlg0ZnhPclhQaytqQ29JSlBtblpRdk0zcnU4WmxtUU83MjU0UHh2NnZMRExBWUxJTVlFZXpBakNXakxPeWNvdVBVOU1hVWxpVjk4b0h1amlaUVZvdFhXT1BnZmtZeCtVb0hPYlN6aHptUEdETzVFSSszaktWb0w1aUZNZkpSUDAwSzJGemIrZDNIcTAvbnN3ZTRCWlB3cmtXMElrWkZ4dVpUczVKQUFCQUFFbEVRVlRYUHJZN1JUODJIcDJFRGxZN2kzRXJ6UGd1YzV6d3pyQUM1NEluVitEUnlSUmNGakRsNFIveVZXNVpqb09nL1FQTU5CWHVkTXZlMlZGc21oempIWUhIOUFCbmlMOXBrd3I1blFGVURWdDl1bnFOdUFzMFR0dHlhT3M2d21zVDRBN2hWN3grZVQrUERVRy9iQWY5R0RGdFNVWU5qeFl2dHJZcGFlZDlqN3gvTE9PMndNU3RiUlA0b2tuVzB6cVozakZJY1pTTVpESzFDc05LbnNCcitwNm1UUEhLejZvcVh0ZjE5VDZNNEZXTnNWNjljVDMyWmQzZDM0c1RDQmIxa1kwTldxZ2o4MmN4L0ZmazZiTHdZRWZEQ3B5OU5hZFZYUHVhLzdxbjJRWnhRcTNjVXZhWXhRaHpabGg0cmpMVURCL3NhK3oxV0dzbzBJZE50aG1XZUxLMTlVOS8vT08zLzYzck00a25MZUFXa0hGZHZPdU1ZeDdHMGNQZUFvRzVJL2JqU3VkMG54NTRoWmxISDA3bm84eWRsZlRZMVhZMDZBd243WUNIZ3h4ZmhqdXVPaGcySHFzMzl3SnlIREE4OERDc0h4dVAyR1VWRnU3WG1JRXg3L1B0TzBJcjhpc3Yxd1U1bzZzaTlOTGdWSnBhYkhvMldlSDFHMlBLK1BXeHZMVzZaSlh4U28rNzRzMXgxZmF3MTBxTTEzdXV2bTM3VmRrMXJmZUtXRUVWcitENmVEYlZ6cW5scmpBUGxmT3pDQmk5VTVYdnlDZ3lENWFUQzFhMWxlQ3lGZzZjQ2U5SVh1MFp1MmhKM29Kb0R2V0JpcjFvMTI3ZDFCZXo2V1pMWjNGcFpMZFoxakNEN21oenFBOVdITUd0QVY5OTBOSllzWGh6NFpWVHgyUHh3aHRtVmdId1EzbkRNOXFGUy9OeHYvcGtaK3RQSGo5NG9JTzZKbUhTQWwwTHpDd3VkTWExZGhKUTNCRkp1L01STysvWU1PY3JYU0RyenhETVpjU1VjMkc4cW1GMW1qaDB1TVM0Sm4xeXBWTlVtZWJ2WVlGYVZ2V2dlclhNOVRaT0dvek9jTmJ5Mmc3R0p4NkhZeVpzVUtPVVB3cm4yOVZvTnZmamZKSXFLSXR4N2VldFg2VWxUWHNTWE5jT3hrZWoxRVczQXd6aEtKSmhBcGZkc2pDY3BEbjhrRk1OekFNamhEMmQxcGQ5cG1aaGlPR2JIeGxkWi9OMnJaQ1JiUlM0cWpTR2sydFdYbVJnUzFiTUtwQmU3SVRGaGk1Y2pNZXk0bXRYYzJBeGlNeHZ2YTVYZllZRDVtU1U5N1h4OXBRTUlWT29HRVlRUVRPdm9ZRlpMWW5kMHpqc3ZzWnVNYndyREdWSTN2Ym1Wc3hvaU1VUzJwclJPNVF4NWhxSzBDNVNqRU14OFlUaGR5TFE0L1VucSsrODgrUEo4VEI1S3lkLzJ4YVFvemY4c0ZQdXNvdGFxNVk3N1k1R1hOUHdNS3dmWDhSL0NHN2FvYkkrekRwVnVHR09heGxwNjF6aGxsa050dkZjTmhTYmg4dHF2cVlycndwMzJySHhuTDhzdHN3YWcxOTV1QTBNSTgvRnVDdDFKZUNsTW4rVnJSekJ3NENDazU1cEdtanp3ZWl3WEphcm13ZnI1d2grK1lObmVTR2cvMGNHTEx4aEdVVitBSGdGSjQ4KzRSWEx6MlFSd2F6ZzVGbkJ4Y2tFUDNuL3ZlYnZmL1NENXVtT3BsdkpHNzJxU2YvTWUyVWFGWVk2WHVVbGEwZHpaYzBMZzMwZ0k2dWpDWm8xRFNud0FZeUZDUndQanZIRVlPTXR1eTNZOHZCWUg5Rk9kTExCdEU1TzBIRmd6YTBiTjVzdnYvbWxmL1htbTIvcUxPOUptTFJBMXdJenkwdkxkM25ZdVhpSTZDak8xMDdnRG1RUHNtTXhuS3EweGdBR0gvTXdUOHBKMDVIeERDMC84NjNIcW5JNkU1c3N4ODhCT21NRTFBblR3OERMVWNjVVhOekVUM1Q2eDBjUU9wZGp2ZlZHb0s1RE9nWmlvb3orb2x0M0FVNkdBa2ZhTVhERWQ3aEpGMWpvcTJzcXZERTBVenZ6Rjk3cXpDZ3BsU01XcG1MNEpQOTBKTUVXWEIwK1lxaGJITXJEcVFwWUdqd29yVWR0N3pQSkY0dThRZ3p0RklKMS8xUC8zUENhajF0TWlkTEhJSG1pVTd3T2k1RDY1VDNTRzdTR0ROS1F0dU95ZUpLOGVlZ2VZWkJ6eFJmM00ybWozYzc0RnAvM2hqYm8veE8yK0V0SHFjUXFMUzdtdi9KS2p6N2hPU3FPcGxGOExPOXpYcXVzNWpWM2RXTnZzOW1WQzNyejlxM210WnN2YVYyc3hrbDE1dGEwdkZpV3kvSnEvMmhHcHhGYzFaRXUxMWViM1RnWThUQjIwNXFla3FjdDlrZWFxaFViaXV1OHJkQlQ5WW5aQXJTVmhrcllhNVk3Y2FpNk0rWjZvbUVFanM3WjNUOTg0NTEzSjk0cno5MGtaQXZNNkNDNHU3VXg2SkJEd1hESFF6Z1ZObVM0d3JoZ1RBWmtBTXNyalFQcGFsd3hFR0Vrc2x1TmVIUjBTYy84U0FkcUVucTBoZzA0WFFOWTFROGVYZWpvRGFzeXFxR2l2SllsdnV1UlBNMTdGRXQvMHlpUjlSRHFDTmJ5VEY0SmQ1cTQ2bDNocEpOSFoxd05HOE5yZjEzNjhzaG5RS2RNSVl0MDRxWnNZTFFCQWUrVVlRRjdka21WM2k2R2xROUk0TnJ6RExxUW4zeTVHLzJyMDhQY3h1UFV5ZVBDN2JDRGZpaVJ3Y1ZNQVgzemIrNWN1OW5jV05iQ0FrMjl3anVkMDlmOWVWMDdVOGN4ZzRCVldBUTJoR0dPN0x3TUpSL1E5R3RDUlNOT2J6ZG5tUENqclo4SURTOW9Qb0tNK29FV1RUQnI0VlEvakhzeThKczcyMS9kUDlyLzk0OFZ4aldlNUQ2dkxUQm1YSG13L2ZEV0Jxa1BmRTFYbkg0YVB2MWcza004Z09VMWJsdzdlSFlvUEZJSGw1RjNHcW1rQTZZL29ZZDBzVDU5NHpyQ2JXbm83TVlOSGlPOWtxY05TeTBqVFVoZXJjRWM1YU5vOUNmVzZydXM1UzNDa2M0anhFc1NWVC9RWElja2FTM2pPWGlXY2xzcVBtbm5NODJiUXVMeWwzU1c1LzNFZ05FR3dFakgrS1JpNjBSTUdaNXJ6bmxsajlnY1lramoydDAvUzBuK21hdHBsOWZZY3NBYmZiems3YVY5M3BpZXRiMngyYXhxaGRtckw3K2k0WUNaWm1ON1N4NW4wNnhxQXhiMmE0VnVrU0VBR2RnVGpyM1Jqd1NISkxJOVlXekdyV2VBdWpud2U4Q1BOc1pWbjdqU3VESzlTMlBLR0ZqVm5oK1pXUzJ2dlRyeFh0MXFrMWpEQWl0My9XRFc1cWdQK1VYcGl0OVBEL0VFQnEvS3ozU0cyM2lTcHpQYW1Ea3Q2akg2amk0dEFzYVRFRExhRHFlZUY1MFBHQjJrNmhaNFZrSnhmbnpwQUgzK3o4NTNQdzV3cWZ5RHRucmViVnVreHAxTTAxVmFsMXAzeDRaM3VNVXl1bkFzenZMUVJmSWRUQi9ES1IxWStoc2o3eDNHMUxnWVRUelhPcjZhaXdmU3U4Vjc1UUlmZlVObjN2ZmJZRDc5Mk9WRE1iaklEWVB0K3lwRWhvekNXNWJSeExqeWtldTZ4bDF2dnZ4U1RMdGl1MEUyZWJtaUhiSVlXR0xhVlV6VFVwb3BYVlNVL1FNb2d6ZERDT3dCTzJwbjVLb3QrRzAvcHQ0c2s5YnplU2JQbFdmcVFMZ0hlL3UvL1hmLytMM2ZIOUo3QXZ2OHRjRE0wdUx5WGFvOWVvaVU5c01PM01Fd3g0WmZGRmQreGdFRy9SQVB3NnR4WlZpZ2c2ZXh4YmdTRE8rbmJWd0R6aCtDTzdhU2RJUUVwUzZSYWYra3prT21MaEdRYVdNUHBPcmd2S0RuNmdlZXkyUDh0NlVkU1NybGdWaittTGEyWjAyUCtMWThrTjhQMXBOWVRUR21uOHM2UGhpL2tXWkNkanJieTU0citLUXhybHlrNFlXUnd6aWhvNzFYWWdMd2JEK1VnQzg4MFVlWHhNWkxpUWZGZytMOG42eEQ2b1FIU21EQ1AzSmpuRmNmdUREMlcxb1V3SmdvYzEvNXFyK2pxVmZJZjBuellXZUZUM3BHNVh3UVl3VVhyL3BYTkpVTFpkQWQ0eHJqeWFvYnVQR2pMRmxzcnMySHJnTk43V0ttQUhBK2ZyR3FiRTllODk3aHdWL2RmM0QvSjZIWTVNL251Z1hpZzFhL0JYaUFDYlhqR2NkbHpsOFU5dzBBZU1DR2VGSm11STByTUh1ckxpZHY0d3FNWUxyTWpabUZ5SVFlV0JRRjB0WDRBbk45b2l6d0VwY3lCOHZveDVSWFdPYUhQVFBMc2EwaWo2UWFRMDg0enpQdlI1WjJPdGU4K2F2VTRCRWZBT2FaUzF0THZzVTJQUityNHNPUmFWU2R2RzlKaytuOEFTRnQ0NG9CZ29jOTE1YnQ2TU1XWldtQTh3ZlQ1VW1Ud3d5azIxdmw0bk14T0tiQm9NWXowZDR5OU5FN3Z6NDg2VlZkRGEwVlZNMk9GaFN3NEdCRjA3UkUyRnpSQ1FiUXNTQUI0OHlTV0FJZnJSZ3E0T05pNktFOFI5MXdocGYzT21CbzRFU0xLb2paS1F0WkdOZ1FyeGlqdm51NC9mS1Azdm54SDUxVGZBTDQzTFhBeUxqeVFCSGlBVlhzaDloNXg4WUw1RXYrR0wraUFEUGZDaWR0T01iVmVQWmNYUjVlVDl1Uk92enNiT2JYRm1kV21kQkRjcTFQTmE3OXVpUk9jakIrbFFQVDBLRVY1ckkyMjlhaE02N0FMV09FSy9hR0lTblNuVDBjOFRlK2NTM0RzZUUxem5ReXEvQXdRSzFSa3BNMWtnOHY4Q3B1dG45Nm5rbm5aNks3ZCtDN0hleTkybk1sOW4wempOZDFZTFJweWlKR2RsNFlaRit5YVplR3Fxdmw4SU9GY1NkZzdGZ2tvUGYrTUs2UDlIMkpuK1JyVjlaaWpIVkJhT2lEY0k1LzRYaHZ4azdSbGFsa1o2TEZvMlYxRmtkNWMvWVdpd2JpTjBzd050cUdGZ1BMVm9WSXhaam5vZ3Y5MkV5ZmZrVVcrSzJQN24zeUZ2cE13dWUzQmZUam5aMnJkaGpEYUJZL3pQOS9hQ0k2cDQwZStqaHQrRkQ4YWZSMlhjMTNpTFpmMXMrYjVpSzR5eDAvTDU1MU14MnhZWTVyMmMrVHRpNk80VUhhRjNsa1lWaTU4QUF4Y0dtRTA2aXpqdDg0ZUhLOEt2TjZEUS9ndnVEVkQ1UTlUNGpYZEJuVE1JaUt6UnM5OEtSWjNCRHpWR1g4TnVTOS91eVRqNXFQN3QvVFZvVmJPblpiUzFobFNCa2FrTHVxMlFTYXM4b3FNQW5lMjk2Sk9iT01UREEreTJZdkxMWEZHSE5nSVVhWE9vOHVlZm53WWY0ck9DczZ3K3ZXclZ2TjFiVXJ2L004OVpqZ3ZOZ3RNTE82Y3VWdTdSejJBUHJWZHFmZ1FTYlVqdUN5Q2pOZTVRTU1XVFdZRmhqbGJBeUNGK09kbGVodnZvUVJEM2FjdzZUWE4vRFNvMURVZWova3JRZDBlS3FzNmlGRndPT293YmpXRjU1VnB6NnV5eHhUSDdjZk1PYUtFbHh1ZXZqVHRuVzJ3RWdURkcwRGREVllyd3E3S0EwdW5tZmxRZG84c2h6cXpuT00rdXFXT0dZVUVidURHdkY5UEhoaVVIbWRoM2RlVVJvR2puMWNPWXBic2FZcE1jZDFkSTgxTnhaZXpKdGx4LzhGSGJseXFxOUNiak5pZFBLVjlkS1VLQkVKSEpjMEVUZ3Y0TE02Um9iajFVOUZleXd3My9SUFJ6cE5OY3M4QjRKTnl3UGw4VmlRVVR4bU9wWldYMTFkWG1sZTFoU3RCYTBlNDhNVk0yNHhsSHp4WjVOdUZVZy9uYU1sVHpiR2llVVNIM0xjakdMYTQxVDE1TXd1Vm52RlBZL3hZVDB2Mm1lQTdRejU0TFczSTFsN2gxOC9XTi82UTIxSnVKRjFtdno5UExZQXo2RWVuRFFvbjZZQjNHRS9EUTI0N2tnWHhiOG92MmZSMi9COG1qcFhYUFRHU0ZwL2UxR0dQMHUreThFZkNoWHV0T01oL0NIWXA4VTNEK29KYmIxY1JteDRoZFcwNVJxdkg0UHI5amVkMjlheU1lN3g2aDB2M0x4MDU4V0hwRWpMWUkvRmxHUEVLYWRNay9wSlR1dEhMa0NxRTZjS1BOeFliOTc1Mlh2TlR6LzhXWGl6V0Y0OFhMelZlZjBnckMwdU4vT3lqb3l2c2lwTDR3TGh0WEtLQWZzWnNGRUxRdzBNSldEY2lka3ZGcytkeTk3czJ0cGFiTlI5NWZxTnI3dU9rL2p6MlFLejlXSDNnMzVaVTdnRGdVTzY2eFNYVVhWbGxiNkRuay8xTytaUS9qeFZkdDZxVjlTdi9ualFCMXNqWW5yWE8zRERTM0xKZUV3NXh0UXhwWGd3d0FqSko5c2xBQzNNYVdMWEg5eHplcmFJaGxjNnA2SDdyTUpGdkt6amtCenJyWnFNNmhKZW5OdEc3V2Q2WWk3L0FHVTd5VWdwQUlkWHZ6cW1CYWV2WHllYjBnekpRMjNTM3RkNXhTZnlLRms1aFF0N0pxK1dqMXRQOTNlYXR6LzVvTkZPS3pyUmRhVzVlZk9tRGlQVVhxK01xV3BWMXJTK2Q4MGVhWmhnTGhjSXJJamx0QXpyMHRVcjZaVnJQSFpLNDYzVGZORFMvaTR5cVdMT2xEQ01MTzY1SEY4WittdlRWNFAzcTYvZStWK2F0NW8vdHA2VCtQUFhBaG9XV0wxYnE5MDk5Tm1KNndOZDA2WUJOaFJxSjNINUVNeGxOYWF6dXNPNjh6aWZyNmZuUFczanFXK05BcHBGZlVhUThJc0M1bnBTUk5wWHJRNHdCL092aHBReXc0MG55QWhHV1Qrb3RBTzVYTEZ4SFlQa2RJMmQ3cGowVXgxLzQ5YTRwaTBEbUMvWHI4L1Z1RjFzRHo3SFBuUFdnRTVValpmeXRrMWxiT0RMRUUrTVcrb1ZmRXJMVE4ydTFzV3k4aDQ0Tnh6SFBWV1IvTnNSQWpCZTgrRzNKTzhUVDVMcFVuaWhlS2k4dmNlMEtieFZlYXJzSDNCZFI3YXNhcGlBUFFxZ1p5aUFWVm9iTXpsbXpCellHUzZWTVpNZzVBbjNXSXNPb3EwWWxwSWNaY0tEeFl1TmNRakpZSXhaaXhtK29pR0c3Mzd5OFA3YkkwVW5pYzlWQ3p6VHVBNjFSanhjYlllczVYUU9keGgzb0g3NUVMemkySWhXR2VQcEdNa1l5WUhXTWgxWGZxR1QrcUYxbzlNTmhVNnZydE4yc0U0R3ROYkhQd0pWWjVXT3NhODZoUTZ0RVFBSlNWR3V0aVNZcjlPWHhaUU5CWDRQTExNZkc5OXlhcm5Ucm5Qb2VvRmVpZHY5SUlFYnhsWExRTU9TalFUbDg0Qng5ZXV6TmdCVUMzQVBaWlRhbURSNmM4V3JmYnpQVTVHOEdQdk4xaEkvdFJxbWp2c1ljT0VBazAyTFdJNW5HRDNLR1Y4UG82aDZUR3M2RnZOZE5XSWJtMlV6RGV2bTlSdk5tbVlSZ0RzajQ3aWtSUWRiMDlySVJXTEpMMmlER081TXRJbndZME1YZlRCVEErZTRzWXhyRExzeXZzc1BSOVJUM3JCdzJGTjJZLzNwems4KytPbi9KUmFUOERsc2dUQ3V0V081YzlFV2h2ZmJCYml2V2xieEt4L2pBRFBkODhUUW5jZmpnMHJLZDNtTjZaK2pFTDFWUEFTMFBuUTJwNDFIM2xkMjRpenBZTWJNMlBLSFlrUlcrRGhsNm1JWXVvS3JQd0VpYlVNTklNb0c0a0MrOEUvSEM1UStqeUV5NDlTeUNpUHRpelpCUjdkVHEzcThPbk5jeXRodkZ3MnZBQTdHRmJyWkdlMDYxZGFUTXZqaExST0h6SmFHTW9MdmdmRUU0QTdLSUdhY1NQRldIaW94YlFwRGQ5cnl3Y0JpUEJralJRNWY5cGsxY0tSWkFyZGtYTy9jdVJOanF5ZmFIR1plWTZ2SEN4cEcwQml0dnNHRlY4dVVMUFlZWUtFQytuSDBDN1ZpK2hiMTRTTVd2SFZlVXNCbUZYTWE3YjVtU1d6dWJMMTJkTEQ3eDQrZVRqNXN4WDM2blAyWnViSjY1VzZ0c3g5eWR5YVhHVTYrbHRXMGNZbkI3NGNoV0IvSC9CeFRUdHBHSjc5V2Q1M2Q1Y2F2TXRMTUNLUDlnazlaZG8xeC9TcE45RkNSak1PUWtnRTVCTXVyK1JZam8vYXZ5MGZBdGxrQzN2TENQYXI4TGtyRDR5SzlSdnpEMTBwK3dDemY4UkM5eXpvZVhjcGx4RTdudlVnY3o2NWd0c0NCZHBuaWRGaGtCSDYrWkFneERYSjgrSm5SdkZLTWtZd3RPSjVPQmJmZ1A4WDNmeHFKSHp4NDVjWENobGlhekQxazNEUHVaSHEwM0pHWUVhS3lhVzNDZ29mS2RDdnJpd3hrK213dThKbUNKV3NiSzdpdTZHUllaZ3NjeWlBdmFuTVg1cmRPcVl5aGhqbnhtMlp2V3RHekNUZUdsQkN6UHFSL0RLTW94cml5V0FHUGw0TU9Zem5zOGVHcXRqZzhmdmVEOTc4VlJKTS9uNnNXR0QzK3o2cTFIMVRpbWphZFljNy92TEg1MEVHcklhaHA4NjZ3bXE3bFEzQ1hPN1pNNXgxRFd5L2c1bGZoTlczYW9kaTBRMldHV1plaDJERGpmcHE0eXJhK3B1L25EWGVNM0l0azIxQVNjOVZnR3ZoajRMZzQ2U0Q5VEhDWmNzV1FRRjRKcnh3eWJmMHdaUFp5SFZOVzB6R2RTbC82WTloQVpUaXdHTW53UGhYalZiS3B0cGFwTm4vL2c3ZDAvV1B6ZUd1ak9SYk5nWXcyUmhUTjJOQ0ZKYkR3MWkrQjNGakdpL0Z1RjhMVFphb1dGK091OGFPaGNtWU00T0V5dnJ5cWxWOHYzYnJkdlBUU25YOXh2a1lUeU9laEJiUXIxdXBkUDd5dWNPMFVMaU1tVU9aeTR4TzczTEZ4aU0yRE5CM1FaWlVlbU9GT08rK09tekY0NktHdUdITXZrMDZjdytHSlZUYldWUUtDVnl1SU5KNHJzWGxhQmlpWmhoL2RDeVBRcFExTDJaUmxnTVk4SW1aamttaXFwQTgrNllpcEhhUnp3YzhXRlIraHVvM2NmbFUvODBlaWZEUGhuNyttUEE5Vk5VVEhWS0lWSEFxbEp4akNLSlV5dnNCMnlDbFAwTFYxakkxV3VJZlE2RFU0UE5Pa3AvMDViUUJkMDdQa0pZSDVybmtCUjNkb2FUL3c1MmIxV1I3dWJUczRObTRPWXNyb2hzN29rSG9TVTY5cDVxUlNKcVp4bHhUaktYTGZ1YmR5SFdNZUtzZHBIOHV5K3ZMK0FRc3pDM0ZxN0w0OGJVNGplS3JOczJkbERHL2Z2TjFjWGJtaXpWalN5MllSQXRlMDV1Yk82MkpmMlZQSm5qdlVxYmlxQjhxYzhFYWtPTnBCODI4WHB1ZTAreFkvR05KRld4a3l6ZXZvOE9DYVVENzY0Sk9QdmhzVm4vejUzTFRBNklPV08zQS9waVhvaEliM1crWWllQi9QUnVNaS9Bb25YUzhiR3NkZFdUZitLb29VcWNpOFdraCtGeEZQZ3JyRGlIY0FnTkg3ZS9HdzRZRkg0bG9INkp4T3VYVDVQaXhBOFFmalNnQTNPWkhKdk9HVTJkaFlONWRoV0ZNT2tBemorUkZYRi9maWxBOFF1djdsK29WUzRJUUpNNHV1L2pJMUFmU3dRSGg0Z2h6cG8xWjZxTjJQR0lqSXdjT2JtOVZ1cTN4WWtsRVdTQUhqbVQ4SW1RZEdTS01hUXdGdFBxRzh6YWNIRzNtTXEvTHdwODFtWnZPTUxaZlZtUFQ4akF5bFBGTEdWUmxLNE53c2hndldWcTlvQ3RVdDhlQmdndHlPRVBWaU9FQk55aGdzUXdSVGVONUNvdllZYzdKOHlHS2Nkd1pQVnNNRFBFNjB3NUVXSUJ6cmgyWnpaL09WdDM3ODloOGdmeEkrUHkwdzlrSExIWTNxa3lhNGN6dmZqd05KZnd4M252aDVZUlVYbXFITHhzWThFK2U4Y1EydnBwVTk0b01BQmZLWUhzTURxRCt1SS9tYWRuNGNIdzVkM1NnYnk3Zkd5RFF1RHlUb25FaWlrVTRHWDBqWHlnbXZGVDZsblV5YmNlbzNEcXU1VGdQenFLVVl0UXpHY3d3VUw1UXhVRm81alN2NDhBbkRKdU5aajk0T2lxSW5lSHpRQWpkZW9ZVWZ2TVRQdWhBVFJuSXNENHVsRUIrbzhGUmxVSDJ2aUVjNnlNaWxRY1k0ZzRPZTBPWjF5dXUraGdhWVhUQXJvN2l2VTJBM041NnFOcWM2NW1XeHVTTUR5elF0WHZtMWhXRDhVUENxSDYvK0doS0lOeGpSOFNHTGZWempneGJldTR3cTA3SGlWRmp1c3ZSRERoNzk5dTdlYTFzYlQvNXc4bUdMTy9qNUNiRzNBTlgxUSsySDNFM2d2T09LNjNTbE5kMW5IYnNqbWE4N0pmbGFOcVJuSDJaOXpjdDV4NFlUVnhocFBCVXVleTAxSnYyc1lGMnRmODFYMmxydU5PWG9NSFJWMnVkTm0yL1ZvY0pJMjRoVnVQbTczSjRqQm1sRnUvOHZMaXpMY01tRGpDRVMvUUF5VzFScGpwakpZMkV3T2hpK3JyMmNkb3lNeXArMDgwN1gyRHBoMUR4Y2dHY2FIN29FSXdaK0lHK1NRQnRpZHZFNnR6VnQ2dTEzZjlMOHAvLzNyNXYxSjA5aW1JRlpCWHJ2YjA3MjVZbkxJTFB5U3dPNU1UWjdvcWxYREJHY3pldmptWVlNcG5RS0xESHdLYTMyWWhQdXBjV1ZabWxocVZsUmZFUGJITjY0ZWZ2M1F2RGt6K2VtQmVTNVhybkxnMGJveC8xV2NIbkZOVTYvck9hTk0wVG5NdU1UKzZwbGhoa3ZlUlhQMWEvTHFzb0lWMGlrNmQ0T05vQ1ZENTNVb2FhQmtUZS95TGNHMVBRdWN5d2ZKMWc1Yjd3QTZvODFDWGhiVjZRYnI5TFplSmlXbUxIVmlGdGEwaFd2RERZRTN2ay9lSjlaWDhzRXAwdTdMZHBub3ZYRWt3K3d0ajFrcVZMWExPR3Z2VmNNSi9OZXF3RUZsM0prY3liWERITkRGZU1CcHhlTVhQR1d2TlF2aldsNm5qaUNyVEdXQ3FRSktiL1ZzK1hQTUVYcUNJYTlWOWRKT2dxUG0zQ2s4VmJHaHZGWStYZXNqMWxNSmJ1bUh3WTJYN2w5KzNib1N6MDg4MkJCWGpFZnZsSlRiSy8wRUQ5bUNPU0NBbVVGNHB5M0UvYUliUTlxUERnNmtORisrb1czM3ZuUnYwR3JTZmg4dEVBWVY2cGFIOVJuVlIxY2gzN2FIYmVXRzFaeFhlN1laY1MrS0hPYWprbWEySUZYdEZINWtIRTFML1VHOEFqOWpWdXNtMk53U1BzaTd3QVBOdkVRc3dDWlo4U1VDVXJISWdEekZZRDJENVNtZzAvZ2hFSG9zRWJsTFFoZFJyeEtuVHVLVENWZUh6cWViKzNxQ0RqaU80SlFDM1JzMnhrM1BmS2h1Vkp0dVlyelhtUmJHWWZYWjR3ZjQ2NGpnOWpTSTR1TmJhRHpWZXVLL3ZGYUVGTFNnT2FyZlRHU1VpUHdoRk9maFpGODJnY1RMVm1veXJ4VUViUlhScm5Kak9CaDdHVm85ZnJPN0FKZTg3YytlUmhIY2IvMitoZmpSRmhXZVczckZBUEs1alFQOWt6MXMxenFGK1BJOHRpSnFZdTI3Slowelk0NDFKUXlsUU5qMnRibTFzYkxXdzgzLytUQjV1UDc2RG9KTDM0TGFKN3IydDM2Z0QrcnlzWjFiSHpuL2VBRE44dzRsOFhHSmZaVmVRRGpvWFpaeHAzQjVRRU9XR3VveHZCYXdjRG9SRFdncjQxQTFkMDR3TXdyWU9xek5lKzA0MmQ1cnYwUFd0Q0pZYkp1WTh0MkhEaktoQXg1cmpVUERqcTZIdW01bVhJb1RsbURKWkp2RlViR0ZUZFBJV1ZtZWJaVHRvdWtoMnpvdUQvWU1XSEhCVjRhV1hBU3poaGs0bkkvOHlMdjhkRVlRb0I2OUJ1YS9QMlJERGJjcitEV0trdmVNTDdrbzZ1ZkZiZExFT2dQaHBVcnhsRGxjY2JzRXRXQlhkVVlJOTErdEs3dEJ3NmJLOWZXbWp1djNta1dkRkxCcnZZZndFdGx5MEhtMFdLOE9YRVl3ODBVcnpuTmcrWDVJeitySThoSm44ampQVk5kVHlVTEhkanE4UEdUaDZzLy92QzlQN0V1ay9qRmJvSFJJK3dPZTFsMXMxTmRqUEU4UEM2bUhpNnBNcDBtOWpWRTljdlF3M0xnYmY2T1hmWnA0MHBmMCtiak9ycmV3QTB6anVPS1k5aW5qWitYaDNYbzQxTUhqQnl4NTRGaXhBamdVdVlZWTluM2JzMzNJcjF0UkN1ZStWR0cwV1FxbUV5NnJMTU1jTG1BY2NYS0tobFZXY0IyQnl3WlduMk13aXVORXdlRTlkWVBmOUQ4MVYvL2RmUGh4eC9IZG9MTDJ1aGxTdU9yblBnYXd3VElhZXVDL0JvdzZ0NGhLOXBEOVNSYzA3aXJEa3o4VnhWM2tuNnhXMkJzaFpZN09IRzlhaE5Vbkl2Z3hxbmxwQTN2ZHc3RHdhR01mQi9XTDZQVE1yL1FIZ3JlUk5DcDA0em94U2M4SFJHelhKTExucU4xc0J4M2toRnQwUVhabHRPOXBtYW53a2VEWitxajN5cDl0QUhYK05BUzRBc01xdEVsZlVJUDVrc3FUVUg2ZkJrYk1XRlJRL0hodGRmbGNNcGdQV2lUSEM3aGQ5T1lYZXg2TzRiYWRUY25WQ0VFbkdHUVVJd1lnNFdYcDBqMUlZQ0xQQllDNUN0LzEvN2d3QU5EaENIRitDVk53a2luQnlsdlQyMlRQUEZLOFVSbERQV1dZZHJVVVRMRUI4OHdQRlJoNGtHTzZpNzR0S1phTVM0ZEhtWU0wZERtMGltZWxkeDNsUW9jNjJQVmtlYWlScTMwaDNGVnZGTmlQazQ5ZnJyZUxLMHNOLy8wTjM2anViS3lHaHUrbkdqYTFxeUtWM1N5N0xUVXhJZWQ0OGREdlBnQXhvY3NUaktRdnlwdmQwZDd6bXJSZ3ZhNFBSQWQ5ZG5kMm1udTd6ejVkNVBqdDduekwzNFlNNjRYVmJkMlBuZXFJVngzcHFFeXd5bzk2Y3N1MHhBYnJ4cXVOQ1RaeWV1d1FKVUJiZFVmUTFqemxCUDZNT2NkZ3dOZm1RV1NyU0hvOUxKK2pCbU8wb0daZnd6RFdEaVl0OHNNZHd5YzRQS0laWVFjWEc2Y0d2ZlRwa0htUlhTV1UybU4yNCtIY0lEMWh5V1FoMkhGNHpzSmc4bnJkUDZvbUFlOGZWL3RFVm9lT0FUZzJYYXB2OHZkaHVBRXJQQWlUN2t2Y0RDbTlwakpJN2VHS2VuR0svek8xbmJveVJsYnI3NXlSNmNMckRWUG4ycktsbVlOUU1QSkJIaW9zWGlodmFjWVpyWTRoTWVoUG1JaDdKaTVydFJkTXc0Mk56ZWJEKzdkKzlFSEgzL3duNnZNU2ZyRmJJSG5NcTVVblFmVUQ3UmpOMGsvYjNpTmpUTVVBL01GVFUzMzVib3M0M2FjbFE3RlF3MGZlUXZtRVFuOWNlY2l0dWZxTXNlVU9WVDhDcWRjWGRWb0VWZDlBRXhweXBGaEZkRXc4M05jY1lLKzF4WXVOejFlRittaE1NSVpLbXhobHR2SGRiN3lkcm9mdzZvUDYvSXBpTHdOSmpMeFdqR3d1a090SmhuNXh5WU1Gc1pLaHNxOEtpSThNSXFFb1hMRCtXQnAyY2FESi9SeENSRStwUEdhd1hFNU91QjlvdXUrWmc1b1Z5dWRMTERidlA3NjY3cmVpQU1MNStRWlE4c3lXT2laZFVDQWxua1ByaCtuRmhEU3VDb3RHamJudnJmeDVOWmJiNy8xQjFFNCtmTkN0OERZSW9LaG12THc4VEFOQlQrOG42Yk1OT1pKYkpqNWtCK0NVZTZ5ak5QUThHRHpVQWVOK202bHJYS2c1d01FWVVodUZKUS80SmplNEdwY3F5NHVsMGtaNldnWXNYSFA4ZXZWditvK1JJOXhyYUdQVDF2VTBDK243Q0lZOEZybXRPTStyZUdPczV5L0dkREZCaXk4UmIwK08yOGFHemJnWGxqZ012TWhEeDRYUDI5RHdUUVlWOHVONTBLMFkwRjVqQ2YzQVhubVRSNzgyRHBRUDlCOHBHSm5xNmRQMXJYUDYxenorbXV2TmErKytxcnU3blNjQ3liQ3FBdlBBN3BEeThTS1dCSXJnUmhYUE5pWWpzV0tNQmwwUG01cEg0UFg5cC91ZnVQKzA0Y2ZqZWsxeWJ4d0xUQTJ6N1ZmT3ord2ZUajVmbG5OMTNTbEJjNUQ3S3VXMVRSNHhxMXcwaTZManFCeHJoR3NHRmY0OTROaDBCR2NoMThOaGp1dXVKSEdPMm4xSSsrMCtUQmJ3RERLSFlaZ0xpTTJmWVhWdFBYR3VGYmRUR3YrTlRhOVljYXRjY1Z4dXBaYkw4ZkdjZjU4M0xWdDNxUE8weWFQOTFyMUo4MkZnZUppMHhOaVFocFRTelRmODgrUGRRQ1RPMjlleEpTNVBHTGw3UUhidU5xVFJiOWR2YzVqZkdPSkxubnREL0Q0d2NObVVYcjlrLy9xdjliaWlMa3dyaXlaaFQ5YkRKby9ZN2I0cnN3YVlLVWEyeC9pdVhMYWdlZThibWt2ZzA4Kyt2aG43OTMvNER0ZHpTYXBGN0VGUnZOY242ZHlmb2d1d3FXOGRwd2h2SDY1ODVWM1RidmN2TnhoNkFqZGRDRktXeU01Yml0SEQ3N3BMeHR6dGF3YWszWWVIc3FaMVloMzFaY0Qrc2hYR0FSRE1NTnJUSnBRNlUwYk1QSHVoN0h5VWxoNUFIYStIMTlXTm9SckVjTmw0KzBERGhmM0MyT21MZmpDZURIK1NuRGJHb2RaQnFheFZ3dXRjVzF3ZlYrTUd3ajhhV1ZCNHd1Y0xOTHpxUVMwbGdmY1BJR3g5U0RHbFExcTJDeGJkN081Zi85K3M4TUJoeHAzZmYyTHJ6ZkwybFVMNDRwUjVyQk00cEFoZXY2RnNWWTV4alVXRStpRDFvR0dHUmgzM2ROeTI0OCsrZmo0aCsrLzgwZklub1FYdHdYT0dWYy9lSzZ5SDB6bmlmdXdmcjdpRHFXTlgyUFN6cnN6VlZxWDAwRzdUdE41UlR6VUVZcnRNVC9nTloySTQzL2RXUTExM3ZFSTNocFg4M1BzOHVjeHJuMmFaK1hoRFU3Z0tlNEgyb095b1hicjQxcVdZNWM3N3hpNDB6V21QUzRxaXdLMUQvaldxZUp6Ny9CY01XWVlML014anZPbU41dzhhYTZjUlpCcDRQV0N2bzY1ZHM5SjEyYWQ2UWQ3UE1CL2VrbW5EOENYdElyWnJPVlFld3h3a091V0RPeXJkMTV0WG5ubGxjQmhLYStOS3ovNitLMHp3ai9UTEFUMGxNTDZMKzlWd3dJTU1XQjB1ZTdmdS9jVmZURDdkNCszbmo0ZTEyQ1NlNUZhSUYyQzU2d1JEMTAvRE1IQTZjT2RkNmNqejFVN2dISDZNaTdLdThQVjJONE9OTUFKNXVzNGdMK0VQNVozR2V0bjZmQThQT0R2T2p0OUVkOGhlSVhWOUdWNlc4N3o0TUNUKzJvYWRBV0dBYnB5NVlvMlNGbUtlYkRralllM2lPSGRreEhxRHgxY0pOTnQxYStEMjZiRzVtRTlrT3R5eW9DVDUwUFdtY1pjMmZpYU5McWc3NzVtRUh6Lys5OXZ2dm5OYnpZZmEvNnJ4MjFOeDNQSEJ5dlh4eno1UWJGRFFIMVh4SXV6dTlZV2x2K0pkWnJFTDJZTHhINnVQQ0Q5aTRjRVdBMTluS0h5aWsrYUIvYXlPQXIxeDd5SS9kRDdkYzI2RUR1ZCtKMStxa0h5RU1neXpidkdMa01yZU1UTzhxV2VYaDVydkVvckFzblhlS0MrWEVTMStJSVJMNElZRWdSalFKUU90V1JRMUVualVqNW1NUUJYSjJSQ1ExN2lSMWxRQzE4eE1oeENQM1FzTURGeWNjUzF6RHE3bll3STNIakdjUXhPbGNPeDFvampZbHFWMDZxY01JY3Y0eVFOcDd0bSsrU3Rod2YzamVFU05wTE9uYVZZeDcrbkRWUHc4R3g4amsvMDZueVNhLzdSSSsyelhxM1pBMEFYYzJ4cFkvVDFjNEQrL2tHbFRyUHlIUEdLVCtROTBwS3pNbWhlUWNWTmkzclRIaXFMRGJSNXBzUnZ0RXlXcVZiNkVEV1B6c0tLSTEvWU8wREc5ckYyejlyZjJZdUZCUzk5NGRYbStzdTNZKzlZSGdNK2VrMGhWMTd1dEY3LzV3VmMwS21JcDN1SEdncloxZGlydkZueFBGYjVvbFo5M2J0Ly8rWVBQM3gzTWpUQURYeEJ3M2hQTFpYa0lhd2RzQlI5cXFRN3RZbjZlY09IWkJuWFpkYkpzV21Kd1RWK2pmdnBmcjd5cUdudytsY3QvM25UbHY5cDZJZnFENzNib2NZVmJobjlldFE4T0ZVbnB4MVhIazVmRkZ0UHlwMnVNV240WWt6NWNJWFJVeXVQNmdFZEhpRWVJSjRpWGlORzFDZkhVdDRQNXQrSGs2Zk1GM2tiNUZvMzB3T2pQTVo4c2VHaXhkTWtUNHpPbkM3d3lZUDd6WGYrMC8vVC9PVmYvbVdqeFFBeFF3QmM5TWJyMXJoRTBEcU8rc1lQaTJvcXZ2REJ1T3JVNWQ5R3AwbDRjVnRnYkNvV0R3SVBTbjM0WEhYREhCdnV1TUtkOW9Ocm5Cb2JwOEpJODREM1E4VWRUeWN1c1A0ODE5cVJLZzI4eVJ2bTJETHhnbHp1MkdXMWJWeTN2cjU0UTZaemJKa1I0L3lWQUU0TjZWT2ROM2dqdkJiZjhnMS9udGk2R2hlNVRoTm5PdTkvbCsrME0yNEg2ZWc3WHVQMTZkTllCNW12OERocGIzdWVZWDNFeURBTUVmTk9NWERVTno0VXRXc3dYUCtxaTNXQTNtbmtlZmlCZEczK1BnOTBuWlhCUjQ0RXR0UDJxSS9hUkxUb3c4WThqOWZYbXkxdDVuTDk1bzNtdG81eTRVaHU5b2s5MG9jcnhtaWh4YmhDaVM2Y2dzREZSekF4RDlqOVJ3OVhkeloySnh1NXhKMTZNZi9NK2dIandYS2F1TjhwK3RYdmw1dTI4akZPdjZ6aTlQa2FGN2pwalVOWjdUaWt1ODVxckk0TytzckRhY3VvNVM2cnNmR0luYWFjdFBHRzlPdzBHVTVWV3ZNZDhhbTl2NUNQOENTN0JzTnJYUG1iTHpCZmxiNmZyclR3ZE42eDVaaXU0bVJacDU5cEtpNzNER1BIT0tieDhmaHlERFBMZ0lPSDV4b2ZqV1RZZk4vTml4aTg1TkhkYytmTnd4K1JrSWsrdk9ybkxCUDB6UG16R0VFMnhBNXJxSFFlUmlpanI2R0ZDTkxsVlBzVTRIa3V6eS9Gc2RsLzg3Mi9hNWF1ck1ZWThuLzdtNytscVZwYUVxdHlWcCt4SEpZSVdRdzVJTnVueDZJRG52anRtemVicTFldi9FN3pZZlA5RkRMNSs2SzF3TXp5MHNyZGZpZW9sUndxRzRKQlk3aGpQK2pQNG1jODAxWDh5dGR3OExpOC9MV202U0F1ZDF6cHpJOHlwNG10QTUzWWRNWnhSKzNqOS9ISTA1a3EzRHdjMCtGcU1Od3c5Y2tJaGpzR1NEcjlvY1F4ckIrRDU4dVkvYnpoNTJOck1INC9vWCsrMExYclJUVEFHWnZHNktqbHc3Q0dWNm92Ni94WVdsZkh5RTBhOWtsdFhWY295dzlOaDlzNUNaVU92dldIdU5JYWovSmplYUM4QldFZGJkRHhXaG1MSjAvNzg4RnJhM3RidTF3OUNSM3V2UHhLODhydGwySjhka2JOaDRGbDd3RVZSbm1jQml2UGxSK1FRdzEzc0RQYnp2NXU4OG05K3lkdmYvanV2MFgrSkx4NExjRFhoM2dBZURocm1vY1BXSDBJKy9rZzZQMnBPSlVuYUM1ekRLenlyMm5UOW1Ob2hrS2xKVjFsbU1jUVRwOFh1SDE4d3h5YmY2V2xyUEt2WlRWdDNvWlZtaWhyZGEvbHBnR1hmODZEVTNVeHIzNXNYbzVOUDRUWFBnYUI2dkkrbmZNdWh4OXBZdjg0R2VjaVdUUGFkSnJYZlR4WVBGUU1ENi9XR0Zsb01MeWtHWDhsZ05jM2psVys1Um5tUFByQUp3eWpkT1RITFg0K01LQ1J5cnp1ZXZ6RHFMTDVOVzRvTk9pQlhIaWN5S2l5R2N1WjlGdGFXMjNXTnplYXYvaUx2MmhldVhHcitlSkxyK2pVZ1NWdDVwSWZ3cGlDeFFvdE1RbFY4RnpoQTA5a01INTcvZnExMzdHZWsvakZhd0hORnVnOFYzY0Vxa202NWwzMUlaakxIQnVuLzZCVDdqTFNRK1h4OEZHb0FHNy9BczVEeXNYcm5jczk1cW9lRXJCSzd6UXh3WEtyTHU1OGlkSDlCZGRYQisxNG9FY052N2puK2d3UHNhMHpNbDEzMTZQbW5YWmRyYU54RFhmczhqUTRYZTU1VXgzZnBMQjh3ODNIQmdiajQvdEkyNGR4MVF3QkcxZm8zTzQxWmg1eHpWdC95ME5PbFVrYU9mRnFMa01aSmxRd0IvTXkvUXpQbkFwajlvRFNqTFBpYWJJcEN6eU9tQkZBV25ENGJtdnU2N0dPZ3NGemZlWGxsNXRGcmVDS1owQUdsRVVFMUkwRkU0ZjY4YUNPQjd1NzRxRjZpdWVqSjQ4WE54K3YvK0VqSnRGT3dndlhBdE4rdUtoWlRUK3JwdlVCQnJlZnZ3ajJMTDU5SGZ6UW05K1FuRDVQZUJBcXI1cStDTDhQTjQ4aGVGOHZjSjVIdHlGZW53WjJrWXdoZUw4ZG5PL0xjOXZVY3NQNnVPU0haUFh4S2kvS3pBL2FrVEdWNGNGQVljRDhWWjQ4T01iSGtPSFpNbnVBMVYzUENwWmJkZlFQcDNuQ2czTGoxSmhWV1FSb0RJL1pDNW82eHFBQW14UnlFQ0VIRTY1ZHZkcXNhZFhXRDM3d2crWmIzL3BXODhFSEg0eG9vRVVlZkFqa3FSc1hnZm95YTBEWEd3R1kvSG5oV21CbWNXSHBMclh5elhjTnlYUFY0QWUzd296bm1ESS94TVI5T1BuS2g3eHBlQkRkdVFJNDhNZTBTZGM5c1BtUlF2V0l1Wm1wZTVWdE9iQ3M4Q3JDRDc1aHlLb2RFM2pWYjRnUDVWVkg4bmc4bGs4SFZVYU1kQkhUSG9wR1YvNHVqSGdnMDNLQ1J5QUtLTHp3a09SbkVmdUt0MTBWNGhseWdSamlrTmVtSGRkNXJPQUVVNzNXU3VMb3lyZURmRXNBRGw1dEZ4c1BxRE4wOGpxZVZDcDFnbCsySWUxRWV6TE5TZDdlTkx1anlqUFVhaVlhSTdjbGxKSFRvWURNaGFYdUdDVG12TVlydC9RSS9ueGwwaVdzdHI0WXhlNGV3SnZBd1lGek1wdzhIN0ZOSU1MRkk4Ky9VcDNGakwwQmpuaVZsMDRjazgxWUsvdStobzdzRTZ1Mm1ST2VQQklkNXFJZ3ZjNWsvS1BOdFkvcjV2NU84K29iYnpiWGJ0L1M0WVZ6emZyV2hzN20wdWtFR2dMUkhvVE50SEIzdEw4cld4QStZYnhXOHA2dWI5eDYrNk9mVHNaZGFjOFhMTVNZNjJkVkp6cUFEY3NRenpBT0tuZ1czaEJ0SDJZNXhIR3BleEhVL1NOdldYMjZUNXVIajY4aFdtUmJsblhxNDFVYzQ0SkQraUthaTNnWXY5SUNNN3h0aGlDdnNpaXZlUkJHTkgxaEEva2grajVheGFscDR5RWZMOVRqbU1EOWc4cVVLNHd1aXdqd0ZBKzBCaCt2MVFFOGFJbE5YMy9Jd0lOL3JTTnA2MEhNeFliZXhEV1lEcjRuTXVibVliaHhvZFBvYmU0WklPQ2k5RVdIZytPRDV2MzMzMjkyOWNyL3lzMDd6ZHJ2clNtK0dhLys4K0tKWjc2bHBiSTdtcjdGVWxqWE9ielhwWVUzekg4U3YxZ3RNTE8wdUh6WEQ1RWZLcXBvMktldHJoOWM0ajRQdzRpTlovN09EK25RNStNOEhrVjZRWmhVZVFjSzlsd2pYVHBibjI4Z0Qvemh3U2RZbjZxcmVWUVl1SWFUUmg4SDYrbTREeWRmYWFPODdmY1Y3alJ4enk0RWljdURYeXQrRE5hMlF4OFd4T2YrdE8wb211QlhZdWpiN0toOWhuRTZJMWRsZ290eHc0aHgxWGJFQURGRnlmelpWWXA3a2ZjaG54ZmpKK3ppZTRTSGFSeWVrZFF4aHgvZzd6SjBHejAvU3BPbmZiT2V6dWNOc1d4Umd4RFAyeHpER2Jwb3FWMU5KM3VxK2E4YjY1dmFmK0RsNW8wMzNtZ1c1U2x6amhhMGJFRjRyQmtEMiszaUNINDhPRmJtMGRQSEx6ODkzUDFmdFJHM0pzRk93b3ZVQW1QR3RWYk1EMWlGa2E1dzBvWkZvdjNqaDljdzhDcXNwczBEWE9EMVlUZTlZK01TNTlWOTBPSnhEM3FXbnlwVTNKcnZwOG5YVUhXcmFYRGdDY3hYcFhQYWNvM3YrdFJ5NHhBN0RVL1N2QTRiVnN2TlQyaURZVVRUMmZiQUc4RkhiWmIzYkloSnl1c1ltQmJjTG4zK2g3R1dkM2lkaE9TYmRjMWhnTnltanpwalFFMURuaWxhdFgwVEp3MFVITW5YME05VE5ob2lpam9uUDJCcDFNc3pvL0orZ0wzMWRabjFJV1lvaFI4Q1BxRG1SNjljZFRYZkRpTThmdlE0Nk45NDgwM3RvUFZhYk5peXBWa0Z6QmJnaDJWUFd4b3lIV3MvWmtHY05Pc2JHODM3UDMzL2p5YWJ1TGkxWDV4NHRJaUFCOGNQK1M5YVBmaFVmazQ3ZG5tVjAzK2dhMWxOOTNXRVozaWJyZkd3RE1lVjlublNWVGVuTGRNOHlidk1QQ25qZXQ1Z25zWTN2d3J2ODBzWnBoaVBMWitURUFqa0s4L0txOG9BMTNuam1JNHloOHJQTUdMam10Wnh4WEVhWEF3VHNiMVMwZ1NHQVBpYVBxdXhTMTZYMmRiUDN1M3h5V0hnV0JhMEhqSUF4ZytZZjhTUVgzVWdIYytIWHVqaFA2Y3RCUzB6bU9wUHBhbGxsYmR4cGhnL2xZRWx6OWxZdFBhaTlrdmdEQzMwUGRGaWc3LzV1NzlwdnZRZjNtaHVYNy9XWEYxWjBSRHVqSmJHN2pZSFIzdUJ1NFZnZWEzb3ZMZzQzeXd1eE5EQWp3QlB3b3ZUQXAyYjhpbnI1SWV3eHFScjNpejdNT1BWdUkvcmZJMTVvQjM4c0R1bUE3bkQ5dkZNOHp4eFh5ZnIvankweHFueURTTytDRjV4cXJ5YXJqaERhZk1tOWdWZVRadk91TTQ3ZHQyZEo2NjRUanV1ZUU1VHhuWFovY0F3Y29HRGdjRW9JZHQwd0JpRDVXczZzUTB5Y0Fkb3pjZThET3ZMSm85aDViSis1dFBQOTl1Y1BISjlnUThmWkxxOU5IalJIT3ExbnlPNTV4Zm5tZzJkbGZXZDczeW4rZlovL0xaMjFqcHNidHkrRVNmTU1qK1dLakRIRjM1bm9wblhjbGtaNE4reVBwUDR4V2tCRFFzczNmVkRVaDhzdy9wVnJUajlzcHJuSWV6ek1Lei9RRU1Iak5Dbk1jeXg1U2RlMTlsRUNVcDgvUjNIU1lOdm1Qa0U4c0NmaWtleGRiVitGZFluQjhmSHlKZ1BzUy93RFhlNjhrOFozUTlVbjMvbXUvSStyK0RaTm9uTExMdkdsbDM1RzkvdDJPVmJxYXBIaHU0SHJ0S1RybTFVeXl3N1ljbkh1SlRadUtiTThlY21ER2JNRU9pZUQ4dXlFU1ZmWmNoMGhhamtaeTg1eDhQbmRIS0E4WW5kL3FiM1RBUHJWM0hCNGVzL0s2NFkyOGZvODloNjFrYmd5bWp5REd4cUtJQ3BZN2R2WEc5ZXVua3JqQ2s3ZXgzczZrT2RqUE9Sak83MjduYXp0YnZUUE4xNXV2SDJ6OTcvWStnbjRjVnBnV3FkbnF0VytjQmVqUHFzOG9zb2Z4NjYyZ0hnNjQ3U2gxdm04OGdBeDVmcEhNUDNzakxqRVYra1E0WFh0R21mUjBkdyszam1SZXdMdkdmQndlbUhQdTkrdWZNVmIwaE8xY00weE5CaFVBbmdZQ1NCWWF3cW5ISmdYT0hwWWNuYUFGMzFYS3YzYXJrMXRpRjI3RExZSWR1WCtST0RRNkRNbml2NjRZRUNJekNEZ2IwUmtCOVR4UlF6TGd2OGh6LzhZZk4vLzRkdk56Lyt5VHZpbFo0NmV5WEFBKzhWRDNoS0s4RldWNi84MW05ODZVdHZCTVBKbnhlbUJUVFBkZkV1dGZIRDRnZmREeFN4eThEamdYTytYMWI1a0s3aGVSNW04NnR4NVVHYXpURjRyTGw0eUFsMEFlWWtzaXM4b0VwUE9uQ2tOenJRU1FoOW5KbzNmaUQyL3BnZllOUFVkRXJMTW1UMThRMERYdFBtRVR2WXEwWjRSbFRTTWJYa1g4b0VtMXJuUlJVOVoxVUlGSTdKRFVEN3g4WXIrZkE2TGgyMWFKTTVwdUtpQzU1SjM5ZlJzb2tKdnFmRURvbHovcGt4THBWeTJyamtPNk9YaHBZeTRHazB1dzlheUxGOHk2enhtV2IzVSs2MjlmTThxNG4vZkN4TGVGZS9yTE5vMmpiSU9iUWREL05HbDVDcnNWSldjZkV4QzkxaW5xeU1QNHNLOEdvWlg5M1ZQclhUTEtFVnpjT0hqMkl1N0JkZisyTHoybXRmMEI2MnUxcVo5VWhpcHdMdkNTZk1IaDNkdXZmZzhmLzU0T25qKzVZM2lYLzlXeUJXYUZFTlAvQTFEZXpUaHVlaE1ZNWxPdjlwWmYwOCtKYmxHQjVPRS92cTg2WmoxYXRmWHZQR3F6Q25MY3Q1eDlGeGxhbTBoaG1uSDFkZVEzcTczREgwdWJqQTlVeWpGZXVPZm81N2JYMmVwYWZ4SEZkOWdOVzgwNDdoblo1ZVRydXowVFF2eCtEYlFOZTRYMjRQRjNodGEvS1dTZnFpVU9zNmxHYjhkVW9HbHJJamphbHFpbFh6b3grLzNiejF3eDgwOXg4K0RPUE9PTEwxd051bGZzdEw4MSs5U09ZRS91dlpBakZiZ0llS2g4R3hxL0k4RDV0eGF3eWRMK0NWajlPT1RkZlBHLzVaeHBaQjdQcWFmeTBqN1R4NFhJUkswMDlUYmhyU0RzQk1YOU9VRCtHYjdzS1kxVWpvaDRjcHRTSW00UXR3dVpmcGlURWRpZm03akQ5bWVYcHNTR25iUWwvVHRkMVRzZ0g4SEtIV3E2TFhlaG1IOGdxditUNU80cVZlR0I2R0JUQkdCR0l1Y0NxZERlcU1QRUpldHdrMnl1QlJEZzNHMlFhYStJd1ZiNFRuOUNQZzVjdjFxWHBZQnZLbWRPM3VIVFEvZXZ2dDV0cTFhN0diMW05Kzdhdk44dXFLeGx0MzRoUURsdEtHVHJQelYxT1J5ZDhYcFFWR3UyTDFIMVkvT0ZTVWg2Zm1MNnY4RU42bm9iK005L09XOVhXbytacXUvQXgzWE12Nm5jZGxocHVHdkdIR0lhN2xUZ01md2gyQ1ZScm9ISWJnbUlvK25MejVkbVVZVzRZdE1EcnQwTHZTenh2ZzEvSHFxSVpnWFducVp0cnpPblc2aTMwRURJOE5iSjhQZWVUNUNvTVd5MkE3UzRrTXl3T1BORHpCSlhRNlJQYVpmOHpQdFAzNmt1Y0QxN0c4Vmo1c3phOHNOUnY2Y1BXM2YvLzlSbk1WbXF1clY1cVh0TUgyclBaLzVjZU1aYmt6V2xxclplaXZQRlA0Qk9IWHFnVjBEdHZDWFQ4d05iNnNGbjRnTDhLcEQxd2Z0NSsvaU1kRmNFWUlyYWNHSkxOenRCMEdlSTQ5Smc2ZGlGQmxPdTM0SWprVmJsekhMbk05RFNkUDJubW5IWnVPZUFoVzRlWmhtcjRzd3l1TjAvMnlNVGdHbFBYNDRlbEdpWFFocmpEeUY0Vnh3M1VSMWhBODYzejVQVWtQRytxdUxkR1ArcnNOSElQbGRuSzVub0FSSHZmZjdleHlhR3lzaWIzZ0lEWjNvUEFDRjlZeXF5N0FMRDlJOVFlanpiZ3IreGZnY1M5cXEwUldaakVyWUVmTFkxblJkVU5MWTVsbXhxcXViYzBvNENQWDNzSEJ6dkgwNlordHI2L25Ib3RtT0lsL2JWdEFQN0t0aTFDcTRBY0pVSDBvQzhxbFNmT3NNZW1odk9HT0wyWDhISVY5M1orRDVFS1VJWjBxcktaaFV2T2tMd3NYdGF0NTFIaWNEeDdYK01XWGFDN2dNWDdLS3o0ZXFXS3VzYlN3b28xR1htcG5MSlB2dUxTTGNoZnJkeEZGd2wzdm9mc0V6TzFtL3RWQXVnd1lGOGJSYWVkTmh6UU1IWmVIRWVCUG5tRURMc01yemVYYWQvZjRJaHBHR1NqRHdMS3BObHNMNnV5WDVsU3pBOVozdDVydi8vMC9OdS84NUtkYVVIRFNyRnk1cWsxZDJJVnJXdnZWTHYvZTlma3IvOTJ6NUUvS2YzMWFJSVlGZUJqNndRKy95K3FEMzhjZHlwdXVsaGwyRVMvTHJEUy9qTFQxY0d4OUhGdG1YNSthaDliNW1qWnRQemJ2U3RQSGdVL1ZxVjlPM3VVdU05OSszbkJpeXdRSEk4eXJhSVF3c0tUVGE4MTZaTkduK1p0MEtjZjZXYWJ6OEV1ZE9zNURPQjErWi9RTkF6OTU1S3Q5eDdPYjJxV1ArU01jY0RHbUJJd3Z3VENtU3VVVXI1eisxY2tJdEdmK01iNWo2MFdlRDFuTUtHQ1hyVjN0SVlBWE83T2dmUWJFbFFNTy8rWnZ2eHZUdGw1NVNmdS9MbXVEN1ExTk45TmJtSGJ3ZXZtWmdpY0l2ell0MEE2MkRldkxBK05yR09NODFBK2JTMnJlYWNmR2NYd1IzT1hQRzZOekRjNFRYeWFEc3N2S0swL1NGYmVtKzNqT1d3L25MNHVIZExFTXh4ZlJQMXRPR2h6b3pVdFZmNjdRNTIzNlN0ekhxV1ZPOTNHY2g5OFF6ejZkUFZiakV3TnpiSHlNSzd5NWpHdHY5aGZ4WE9FUHYzNEFodUhHd0NMelVHbmVJWmlhOWY3SFA1dmFtajFjK3Q0UC8rRnJ6SUZsajFwT1dHQ0lBRU8vTURHdS9lYjh0YzZQUG1oUkN4NE1QK1IrVVAxQTFsb2FCMWhOMTd3ZlBNZkdxektNVDVuTGdWMFdtRThZNDZxOEdzYXpqU0hWZGFZdnhId2cwRTZibzcxTktWSG5zZzdBWTdNTkN4am9ITUZOK3ZTRGVhQW42WnEzL29aVjJuNFpiNGtoVm55b3gyam8wNGxlZjRXbjcwWEs3Z3hGbFdQWkxLbU10T2lpRm9wUDFXakJRMjBtSHlybEt6VTlwUlZHbWppY3RLNVQxaDFaQk1mOWRCUU8vdUgzdXJZZkZlSzU4dlBWTFJ1TmRoQnVLeXJqZGpZRXJJRWozMFlRMk56c0FsSEFwNFhML0Z6S3VVNjE5K3JNYkQ3RFNZdFowL0NBTXN4L1BkVTcrK3dNQnlQbUxJRmpuY2VGSVNSZzNHYTByMEZ6bkN1NEFzZ2ZxUi90am9rVW55azlaN1BzeGlZNU50Smh3SVVhYmFVdEUrZmFKZ0ErcjMwSHB0aU1SdVZmL3ZLWHI3Nzc3cnVjT3ZDaitiK1ovV2Vha3ZVZnYvYTFyMm1KcjU1WnZVQmN2YnIyOVRmZmZIUHh2ZmZlMnhmT0pQeWF0MEI4MEtJT2REQjMwSnJ2dy92MXJUUXVxN0Nham9mUFNCZkVGUitVb1R5d0NxOTVkbDF5M2pnMWI5Z1E3d3RVR29HaHJYVWdYZlBCczhXdWNnSXUyZ3lkc2F4NnRZWFMzYW1MNGs3bU9kbEJQRzc4NFRJbXh4OEJnY2RzZ1d4TDQxd29GV3ZWaG9wckhSekR0UVp3Q1IxTng4ZndRQmo5QWI5Y3NYRzJES1QyV2VXSGlXQ2VsaG5HcmIwWHF0NkZBZndwL2FCQXo0K05mN1RNRDBKMnJybzgvSC90bmJ1eUpNZVozODl0TGlBbDNJSXJJdVRzQVEwNU5PVFIwQVBvRGZRMk11aklVRWlHREpwNmcvVzAzdTRickdJM0ZETEVDRVVRSUNSUkJLUmRFTndJRVpqTE9hUDhaZFd2KzkvZnlhcnVjeG5NRExjVHlQN3VsOHpLK2laUGRYWFZsSVN4MFhWc3dPbXl5NVQveEc4Sk5mTEo0OU1QVzU3UDJpMVpGenhlOFAvOC9kZGZmSER4Z3grMSsxeC9kdmE0L1FLdEZlRG4xeTkvK25mLzk4di8rTGZmSEYvN3NuNE0zZzFwWDRvc0ZQdSt0SE1oam5SVExpNUVIeng3K2xCUHVUSnA1ZklUdXRoekhNbEwzWDE0alpPMHVWUWZxVk5sU2FzblRGbkZqWld3Nm96R3U2UlQ1MFBieXEvMmxkNW5sMlBUTno2MHkySW96eGpJbHVRNUQrTFlpVk1zYmZLZ2liSFozYmJmOS9NYmZ6b1A1bjdSSGdGSWYvbnllZTg3WC82Vkx3WFpYZHIwYjVFR1RsK3c4VlBkNmVlNjNvbnc2T0xWZXhSV2Q2US8rZWduL1o3V1gvMlAzLzdyWDMzKzJWOTgyNjdMUHVZaE5lODliYmR1dlgvOE1ZR1QvSTdEelR1MDZpSmZHNWNMUzUxS3c0ZVhNSEgxSyt3RzhhRThXQnVVZkdubVBZTEt1K0lkUHRiaUt4UGlIdncyN1JCYmRTcXNjWnlQeWsvYU9ZSW5ubEJkZlZXNHowNzdFZFNYaFZPWThSTkhidGUyenE5ellvRlRMbDhhZTMzMXl3ZXpiKzhhNE5JQS9JeGpvZFpIK2x6Q2M5emJ2d3FtaW14aEJUNzU4TW1INkg3MnU4OSsveisvK3ZJWHYvM3FxeS8rMzdOdlR4NjM0dnJSaC8vNForbm5pTCs3TTNEKzZPTHh6MG5mUlpTTEtoZVJRMVF2YlZJMmtzdGo4ZW9UR3hlejlzTFVnU2V0SDJuMWhSTi9lMitqZWhXbXZuaUYyR1NURnBLNytlK01heTc2NnVsRHV1M2JkOFlqSDcyT3oySEJiOGk2czkyL01zeGhZOSt1N3FXdGNuazhnMkhiYnVhaS9sWm5peTNKNUUvNTdzN2IxbnJDdHZleDdrcndZVzh6c1JIeVovcFZmNHNxY3RiTTlzdTRqVklnSERibnpiejBDMlQrYWFrRFB1MDZlWGpNZEUzYVp6Vk04WmhUYkpwaHl5RnQwM2ZIKzJXRktRYjNZZFBPejEvOW05UFRqMy80eVNjZm5ISko0RTgrK3BNUDN6OTkvK1IzMy8zdTJXKy8vdXEvLytEaXlXL09uajcrY2J0azhLZnRUYkgvNkx2bnovNjg2ZTEvRzJQM2Z2eDRXMmZnVGp2WEhJd0xMWG5nOGhPQ1M2dFQ2ZlJUOVpXeGlHMDNGbmVjcE1yUVRSdHRSekR6cWZLVVpXN0pyemFIME5VKzZScEhXaDNodmpoMUxxU0YyT2NjaVkrZ05zSzEyS21qTDJNcHkxMGxQR2poOXMvNTNaMnN2bkkrY2djcm4xaml5UFhMcnRVZEt6SGN4YnF6MWI5amc2Ym5mT3RYSFdoaVREcFRMR3llUDcvNDl1blQwMi9VKytYbnYvemkrb1Byelk4Ri91cS8vWmMvKy9Wdi90ZS8vN3UvLythTEQ5NS8vMmYvOUpOUC9wVzZSL2p1enNET213Z09HUVlMcHk2OHRKc1cxblNpaWxjYitkaU5GcXoraktPK2RKVW5YWFdRMVJqcUw4RlJ2dnBkeXFYYXJQbEdWejlMZXNuZjFkM2RiYVllK0s3dUpNM3hPNDRKVGdVRHJkU1pySlkvOWFGR3hnUlhMa1J2NUIrZU9zTCtGdGp1WS9weXFkWFpWbXkzWHpSUmVJbFJZMW80bThmdUV6MmFlc2g3bTMvcVc0c29ldHB3NTBDN0w2RVhTbmF1NWpaZFE5Mk5iVEZWaHhqY1IveXEzNzNTY21sM0tienE5eE9mbmZ6KzkyZmM2dER2QlBBeUFmcTB2L21iLy96bkxZZW4vK3dubi82N2p6LzY2RjgyMWkrNjRQanh6czdBNW0vRVhCejdSdU9DVmEvUzhrZXc2bFk2YmFvc2FmTUYycld0dFB5N3dJdzVza2V1am5Da3Q4VFRScGg2OE5iNEl4bjJTM3puekJqTzA0aXZUb1ZWRi9tSVYrM1VHK1dXZVlpclQ4R2p5MDlvREh6V2pzeFlRSXBnTDRUdDFqTit0WGJkaXQ5VmU4MjEvVVY3Zyt2ekY5LzFuNkw2NnkyTExURnB3azYwai9UTFpZV3BUMFVaMmYvKzQxNDk2d0FBSlhoSlJFRlU3ZWVuVDk2N2Z1L3AwK3YzbmoyNy92Q0QySzNxNDdMZGVpWCsxMy85VjMvMnU2Ky8vc3YyR05BLy9lYy8vZW54MnFzVDg0N0M5ampLaTUrVHV3dVJCWkpOUHRDZSt1Q2pSYWV1OXVpeHVFY25DakwxMDVkNFF2MnBuM0NLUVo3enZiRHpOUzkwenRwdWdwZkt4ZVc4elppeHMvVjdJdWVUU1Y3R3lGeHlMRlZYR29qOUJzNVhOT1IxUVh6MDU3Y0dEVXBNZTZPNjFEeFUxWis3cTJtZ3hHVSsrRk4xNnYyYTRjU2Q1Z01IemY4cHY5dHNycmtYVkJzZ1V6Rk5oL3pHbmRjQ3BqY2IrZTMyYWZkSGdaeDJrNDVGbUQ2WXFxMysvTFBlMC9idGZpdUc3QWF2WDcxbzhWdStQTmkzMzNzNi84UzM0ZkM0RlUrL2RZNkljL1dTQVUxallYd2RiN1R6NC93eHh1bTJQdWR1MHVGZTZkSDRqZGw5a2xuN0IrR2pqOS8vdCt4UXVjNzZYYnUreW0xWUgzLzg4US96K1FISXlNdjI2T1RWZjMzL280Lyt4ZU9MeHovKzdJdGYvNlg4STN6M1ptQ3pjeVYxRnMxb1FUcXNsQ1d1L0JBNFdwaUgyS0dEN1ZMYjUzZTcrSmM4M0o2L2xzOCtiM2VadjR6bmVQMnpsSGdwSDhWM0RvVDVqd000ZmEybC8xSCtoL0NNUGRJbHRqbVpEM3J5MGxZY20rcXJ6bzAwY1ByaWFscjIrallXTUsrL2NrM1dYYXk2eHEweHlTTWJzZHF4bVg3eE1Bc290QzNHNWxwcjZvdi84dlBQdi9qNmI3LytUKzFvSEg5STRLUzhvN0R0WEIvOWZGNEkvZVQwWkhWQjVyamdIZExXOUhKUmlsZDk2UW96ZHBWSm16K1FYUVQ4cVU5Zk5PUVF0RW0vN0lmV21qbXY2WXhreG1yWmJISWE2azAvTzdzaDJ0aTNRekNOWit4SHZYU2dQanp5MytwTS81aDIrWndYMzNCWGZYMU5kdE11V3A3UWVVRkh2TXFnbFUyKzFOaENDeWx2Wk9oRmo5M3FYUGk1UVI5ODFNeDUybm51YWlCalBmUzFNZjl3Z2p5TWxkclRMajA1Vzd6SGNKNjI3QTJHUE8xZm5iNzhEMjJuZXZIQkI5TmRBaWpXbmVyR09KQkhUeDcvcWowOTYwYy8rdWlqcCswQjI3OEowUkY5aDJiZ2dnVmhFL2NFZ0M4UEhINmw0ZCsyNFNOOUphNnYxQm5KMVZ1U1RmeEpDN3lkRXdlMUhOL0lJT1hnU1p0THd1cWo1ekl6MDFZOWJhR1JTMi9oOXBnbzM4cjRwNEhpdUMxaWs5L3BwSi9pVGZkemptSlB1dFZXN2dTSlZWdnlFcitMM2xYNytTNE5QOU9sQUlyZ1ZHRGxJOHM0T1JiNTB6K3UzVlgvVUlkbnJGcFVlOUZ1bHlxQTdGaW5OaTBVOVkzRkd3Tm8rcDkwdDUvb0t3TW4vdlgxa3kveGUzcHgvZDVXY3ovMldmdUpiUFAxRjAvYlV3ZjJheDgxM3RZWjJEd1Zpd1hoQWdIYVhERFF5cFhkQmVwRFdQMGFtN2pxQ0RPZWVhbGYvYWlySCttSGdNWUVUaWRSN0tZaTc0eTF5VGVxdkx6VWEwY2h5VDRITzR5eWMzSjg1R0tYcC8razFjRW51RTIrTmlsVFp3VFZyN0xLbHhhbWZ2SW9kTFFzck1pblRnSGMzdUxVRmRzSE1vc3BRekozZWVqQmcrWlpCTWJvOXUzUkF0RDRvQkJ5blpYV2RlYzVCVWRPbS9LWTFxWnhnUENCN2YvZXRPODJweTgvdUx5OFBQRU9nWWIzb2lrOVdleCtmdjc1NThmM2FlMU95VHRIYlo1UzRVSnhFVGtTK2RCck11UXVNdkMxcHA2K1haaHBrem9wcnpta1RQdXFBeDllMXkzRlM1dmJRdkl6ZjNQRlIrSWpuNW1iOWlPOXl0TnYycVF2OUpXcG16NzYyRDN6VTFCdzlhcnZvdGJKcXFPdHV0QlZ4eHlWQ2JIcE9NK2duZTEyZDZ6VHpsSVpNQnNGRXQ4V05mQ01CWjkrM242YWlxMXlJTmRXOWFzZm9CMlpPT1U1bXpHMmNKSkNtK1BWMVpNdlQ4NmVmZEllM1BLaytlblhYTmNLYS9vLzR1L3VEUFRMQXR1RnNWMFFEc21GS0owd1pmcEkrUWgzMFFuUnFUZzhmU2VzdXREWkRzMGhiVzZMRzhPOHNJZVhZempVcHo2QTI3YmRCVzE1RXpiRm5rNXViWVNidkhoc0dBMlg2UllTdW4vTDNtQnZXd1dLUjIvenQrMGJmM051MHBQU2RIekVnZVpSOFVyanArcENiM3BMZW9QUHNhY0hnZU5wK3cvSVJOMk15NTBFMkZOSVU1KzR2YmpPZDhOWWJNMkhMNjRzb1BERUs1enVLdGd0c09hUzhlUVJoM3k0UkFDOGFuSE9IMS9kNmpLQnZvN3czWnFCemM0MTAyWVIwRmhrdEtUQjVYZmhQVDVjMkxpNGk4OTl1ZXlUM3lQMVRiN096V1lNTVQvS2hJNHg4MHA4bEUvYUdBTWJlOXAwM1ZLOFVnNU9zYkR3ZUd0VUx3QnpVV3VPTjJPcnR0TEV6bGJwbENXT0hqblN6VjlJWHIzNWIwTi9zd0tjdU9UQ3pmanpqd0NRYUF0dWcxZWJNUk02QjhUMWpnRHNvTkVENmgvYzNoOFRPUWRBYjZtbHpGajRTLzZTN1pIL3h6RUQvZGtDZWNERmhUbE1GNXM4ZEVaNnloUHUwL1drTUVhRjZRdGNmMExsL0RyR2V4YmxkZjMyTGZ6b1hLajVjeUxvVTZnZmM0UTJQM0YxbGsrM1dhT2QreGtUUDlERTdmY1l6dzZNcmE2d1JUYlVKczhOb3lGclA3MmZmSEpOa1Q5dXA3c3B2SmZUY2Z0N2VPTm5ZU0RYNlpGOHpPVmszMGJUY2VkOHVrZDF5bkUwWDV1N0FIckI0aExBZFAvck5KK3RpTFg3V09GdGl4dHpiYis1NjNYczVvdXViVHRuMkU5LzJ2ZjduZHRjOHl1czZaZFlXMW5Qb2IxR2tIZU1uYlhYc2dDM1Q4dDYxWi8zeXR0bDU5SHh6MUVMTlIydzZlME91L21aQjlENTVkZGE3YVdRditBdWdyemZOWFVUdjJ6WFp3KzV3eUJ0anZqYk1RUFQzMDczek1XRmZSODNlU0xjeHcrMjA0bTYzZDFKcDkrbG5ORTl0QjJhczdHQUkvOGpYczNoRUoxcWsvUytYUEdmTWNTRituSXMwc0xrRzB1b0RoQi8yOEk1UGtiR0JJcnJROTRhVEYxanBoOXRrZm1QMnZUcnF1bFp3UERkcWFMTEYxMWNsK1ZGZ2w0KzBCOVFYYUJOT2JUekFPei9XTDE2OUNWOENpZHdyUjJ2emE3Tnp0c3QyN2tzNElKd01XVHF5T0FyUzF3OWVQcVF0d1Qxb3p6dGxCa3paZW92d2JUUmo3cktwSmRnNm1Yc0hOOFN2dVF6K2VsVFByeUp2L3VuNDBoWG0zMHdjMXpTeFgvT2svR1diRk4zNUZPNTl2akxiZ0dTQnkwTzdNOVRMVFlacCtzMEJuYkdBRXBUdlBTWGRva3J4NDZpeW0xVzJyOTZQdDlmRzRVU1d3cHIxMmtwWGx5OGFtOFlhTy9FSWwvMnJ3M2lpMjRURjhydnhiVVJWMWZuMzdTeEhxKzlPakYvaEhEbnFWZzVQaGVnTUdXNVlCSlBuVFY4eVFaK3loSmY4NWV5ekZjOFllcU9jSFJwMm94MGtsZHpkQXdWWWxOMWpaRXdmZDhGcnpITVk4M1hLSDd5eFBGeGlMK3FnejJGcWNQK0UxWit4anJ1eGxxQyt0bnhXUXAweXZUaitLWHhRN080VWl6cDBPU1BuQjJyMEozcnQrMTEyQlJhYUdSMGZScGpCSjBUaWl1ZE9BMCt1VHhnOTZxLzIraHFjNFJ2YmdaMmRxNm13V0poTWRRbUgwaERSMTdWZlVnNmN6SDJmZnluaitwN0d0bmtQV1hHazVjK2tNbHZFN0taRjIxMjVNa01ISC8wOXM5TGg0bzJmbVVjQ0xGYnpISEJ4eFIvK29jRmxVNlhkV0ErMWY4b2xqb1dJWDJpbTkwQ05jbW5vcWNjWG0zSXpFTThvYmI0VlUrb1RHaWhZL2VLem91WDdkZjl6VCsyMmVCUmJKODk0MDZxK2RkZVRaOWJ1L0NCTFIyOWJCa1hQalQ2UGNiVnhUZG5aeTk1Y1BaQlAzVTlYaUxJbVgzNzhaM2l5Z0YzTVN5bG5qcml3RVBiYUFGaXU4US8xTytoZW11NWR0bDhndXliaDZWNGptUEpIdjZTYk1ydDVqOXF4a0xlelBjMmMwakY5WmlUNXNoT0g0ZllqL0tEdDF0Y3QvZXhLZ1BTczBrTGwrSlh2cjYwdzJmcVdEUXBjRGJrN2xqYlN3TTdHM3QxVTgvcnIzd1oxbjIwTDc2d3Q2ZXUrQ2dYQ3l5anZteTcxMlBoZExiK2VPQ211TElBV0NEQ3BTSG1RaG5wNE9PUVZ2WFNyM25nSi9HNytFMmJRM3psK0JPdnR0QTBkVEwvakxtRXAzM3E2RS9lYmYxcUI2dzVwMnlFOTlpeklPUHF4NXhSU1huRjBWTVgyVTV4bmE5UndrODdmV29uRFV4ZStnYkhoN3lKbm5KYjhrMXhSRS8vNmxIczRQT3FheG81NTVkWHhtaC9XUFNZeVBxZjl2M1pyZHVkdUw2RjNWbjdNRTZlSGVoY3Q5MXJ1Nko3dlBicVJQMFJ3ZTAvMzJWUUxnYlpTWU5MQzlVN0JOYUZON0k1Ukdka2x6eDgyT1hYZkIyTGNFbFAvaUV3WTlaeHBBeGZLVS84a0Rnam5aR1BFUS9ibkl2RTAyK2RsN1JMV2VJamUrUjFKNmhldFlVZU5jY0JUQnhkNldvN29wTUhMazJCWmVmS3RWZDNwdm8xSDRzd05sNlQxUWN3YzlOR2FCeG85WURONTg3VHM5US93bmQ3Qmpadkl1QWd1emdja29zQm1VMjg2c3RYYndtbW5qNkl3NGtuclMwTDJad3lGL0VLc1d2M0VQTFpYV3g5UW5OLzUzUWRiVHBCK0hkbCsreGE3dnVFMzc2ZTZMWjh0TFEySjk2R09jdU5EWis4c2FYeEM1eVVkV1o4dEpGMnY5anM5aGFyeWNoanJVMzNVNkpoVVpoT2FHZ1BFM2x6UDJvdlpneTlkV1B4aW1vYnZHdzk3L1kwcW16bzhCemMyYzNKcS9ZK3E4NWp2STFKakQ3UFhhTlp6aTY1bjVYN1ZRbHhldGJHek1OWG9GdGV6ZzlRbkppVnJ2bWg0enhQZHROdWt4OFdtRFkyL2VuL0pES1A3NHFZN1pkcDEvUGFlUG1TWndoY3RaMG5QNFdkeG9BZE8xRytxQUt5ZzRYMzNYZmY5U0pLSWFXZnRWZHp0K3VrYlN6Tkp3azFuVFlESjQvYWp4Nnd1emg1MHUydzNmUTJWMHdMT1Y5ZFBlOThKZ3B1dTN2MjVPclYyWWVmL3BOUG41NitPUDJPbHhiaWRsKzduTDhJTzE1TzJEZFRiMDYrdVN5UUtiQUlXQmkycE1XRnFRT2Vkc3B1QTdFZitaWnZESFJHVGRzUmxEZXlnOWQ5Ym9lOXBMYVhiNjdDTllNZU14UXFqUTk2dHFxVHNzUkg4YkVkK1pPWGNuanlxOStrd2MxcE45T3F0VnRBc2NsZXRUYys1L0ZEMTN3NnJ4ck9kTFd2YXNqVlVVYUJKQVo4ZjJoQVVWVVh5RDhtU1l0UHU5M3BpekgvRWNBdmNsdk5IL3I4NWZXdnJ4NjFXN3RPbm4vUzlBNHFydmhyTVRhdmpkSC9FYjQ5TTdDK1RTcDV1a2hjVEJVVzlTR3BUUlc2NklCTFBSZnNrcjMrUnhDYkVUOTUxZThTbmZtaXMwU25ESnhZUW5GcG9mbDB4UU0vbkRQVmF6NzZGbVpzZWRvQzlTZFVaK1EzN1RMM3hOV1JWNkgrRCtIcmF3U3hIN1hrZ3k4VlNOWlkzNEcyTDZ5NGc0RHVKUUw4TW43dHVlN0tUcGNPUG5YdWgrV3ZGLzRDWUZmZmRybEI2OE41VFhoeS92VHA1WUczWnJsai9mVFRUMytNejJONysyYmdWc1dWOUZsWWRhRktDKzh6VEJZYkN6d1hYZExwRzUxUk00OFJoRmY3eU1kZGVKbHo0bXUrYWk3UzFVWi95TFBKcnp4b1pMWnFCNy95akMxLzVCdTc5S3NmYmFGcCtoQlhQaXBxNmdoSHRzaHMranFFVGwzOXlqTVgvR3g0clNaeVdhSHRKMDh1emgrZlBMcDQwdnY1V1hzM1Zyc2t3TmhINjFGN3I4T21UK1BtdkRtMytOcjBpNU5mWTNmWkNpd2RmSzIxL050OVlVK2ZIZ3ZzMml5OU9kbU40dXBDcUNtTitNa1RCeDdTcTM4WG13dHdSR09UY21sNTZkTjhrcmVFWjc1TE92TE5DOXE0UW5sSmF5ZGNrMlhPNXFSZHl1UWx4Szhkdm5qRzIrY2ovYTNoTmJlTWxiS0s0MU9lVUY2Tmh6eGI2c3RmMDZuNnFRdE9ZYlc0cWd2MDJpb3lHcnRZZHEvK3lNRFlRTWV0UDJ4ZnZtd3ZQV3dQL1BhYWN4dHgwME4zNmlONy9GaXdYNzA4LzVhTzN1V2VBc3Z1OWZUMDJlYVYzZW43aUwvNUdiaFJYRTBwRnh6NHZwWW44VDVkNU9tejJpWU5MbDFoamFPODhnK2w3MnRQSEh6VW52RlRwbjdLeGMzRjR3QS81d3hhbmVwVFdlV25MM1JvMWVmRW5maFpnT1Jia0tTRnhwSk92K0pDZEJKM0hOb3V3WkZlK3RFdWVlRFM0a0RISVE5YmNJc3JFSnFpeDJXQkxLN3dhZmlZQ3VydTVRRXZFeUNuMWJucHpQaFFib0dGdHNDRzJoRDlyTDIxb09sL3Q2OFFENDJQek5jNkE4UGk2dUtwa1N2ZlJWSDExdWowa1RnMitMdHJxN1pMdWNrZndkdkVObDZGK05DMy90UkpXZFZKM2RTSHp6eloxUk5XWGZnam52ckFPdS9WdDNTRjJpWWZubU1CS2t0ZGNGdks1UUgxVWZGS1k3L1dVcjZFWTQvTUFpc05MNS8yMWJMcTlNVUYxMTRmdDl1MG52WmRMTHRaV2hiWFdtVDVpYXdGT3YwVHc5NmR0SS9SMk9IUkx2ZnNYdEdod0FMYnc3Zy9BQjdiMnpFRHcrSzZMelVQdkhyU1F2bHZDdFk4S3YyNjhpSk94bHJDYTN6dGhGVU9YVS9JMU5HdXhrc2ErMnlWUnBZODR3bTFyVFQ4VWZ3bFgvcFpncG16dnF0dStrWlc2Y3FyY3VqYXRYSDNDRTBqSDNnVVZEbzdXQzRUZ0NOTFAraGZYYmN2dDlydFZrQjYyd3R2T3M5VFdHdk9venFIN2w3VkJ4NExiTTdHbThVM2J5S29pL3F1YWRXRlhQMWtIQmVuT3RnbUQ5dy9yZEJKMytuSEJZNE9KNElOdmpRNHZzN1ArZTA0SndVN2c2MjhoZW8wdXhWYnhsdmpLUU95VzdHbGZlYXJISWhPNm9rRHNiRTdEbXlxcjdSQlQxcGRmUW5oWnpORzhzVDF4YmdtdlduWHBpL2p1UXZjRnAzcGRpVjlvei81MFBNRTlTKzNqZzMraURmcFQzOTI5eWRwYlJ5MGUxNjVuOWIvNWptRXh4ZFYvWXVwOWt6VzZhSFgvSVBqbXVOUC9KdC94cnYreUlITEE0eFBYdVlPajg0cnVKd2JVZ0xQdXczTzI1ZGkzQ043MHRZZmMzZlduazNRdmlscldhRGJucmgxOXJqN3dSZnpkWGIyaW9lNzRLbzM3eEtRRnNKSDcvVDB2UjgzK0d4SlQvMGpmUDB6c0sxRUR4QXJGOXRkM2FXUFhLVDQ4MFJkODQyTkhUMzlyZGt1bjd4cmtjYXlVUno5QzhlV043bm1qaVR4cXFuZkN0V1RMMzFYbVBOYWZSRGp0bkZHWXpxVVYrT3YwZm9FV2dTRkZEQTZ0SEpneGVWUlhPbFRZWngveE5DQ0k2ZnBWNWora2VjODZUUDVLWWYvNHJ2VGIxci9sZzY5MWl5b0xiZmpMNzdXSnVwN2t0MnB1THFRekRGcEY4Y1MxT1krRU4rMEN1RzVZSVh3bHByMlMvSzc4UFVKdE9NbjhUVy81dTJjQ3RObXhFdDU0cU44NUtYZVErSDR6dndjdDNBdGpuWkFjZlVyTFg4Tmp2eFk5SllnTnNxMFQ4Z3UxTDdkcFcrTE1mZTZXbEM5RHhhSXp6b0g2UmVaQlJ1WXV1Q0hOdTRlYUg0UHVwWHJVSjlIdmJ2TndKMktxNkZjSE5JUEJmRmIyNkVMekp4R1BxclBRM1NxelNHMHVYcUNDTEZWTnZLemxFK09hVWxuNU5lNEZXWWUxYzVZNkJoTGFNNnBJNjlDYll5ZDhtcGZhWFgxc1VUTFB3UWFRNGdOZUJaU2VXditLSHdVVlM4Uk9IL3BSenlMcTNHQnR1VGhKNHVxODVaUXV6WG8zUVBOanRkNTc3MVhkczNYVVhhL0diaHpjYzFGUWdxVnZtdGFhMzVZYURieGhPTHFyRUhqQU1YWDlBK1ZtWU53WkRlU21ZUDVKS3crbEZWKytxMDR0THdLOFdQODZyUFNJejE5NjdmYUtJZGY3U3RkYlIrQ0prYkd5VHhUbG5rYVZ4NHdpNStYQjRDMDlBTnRnWFVYbTVjZXpBV2Y0aFVTeTI0TytMVmRyaFRPRnJ1L3ZydlpIeThQT0dGdkFONjZ1TG9JUnJtdXlVYjZhN3oweGVLeUpTNHZvUXR4U1ErL2F6MTkzUVhQdkVmMjVpVkVSeHRodGF2NVZubjZTaGw4Ty95S3AyN0Z6U1ZoNGxXLzB1b2FFMWliT3NtdnZFcW43aEtlc2RJK2NXMlRoeDEwOHRUVEp6S0tIanRYbjU1RmdZV0hUdXBaVUlINU0xa0tMMDE5WThJWFI0WlBpL2hNSDFRc3VmYmE5QTk2QUxmak84S0huNEZiRjFkU3FJc3ZhUmZIRXR3M0JPMnFuZ3NSUHZnSXlsTlh2YTQ4ZitoL0NhYnVmWEQ5NndQYXRwUVhjdTBTYXJjR0hmT1NqbkxoU0M5ekhNbmhyZWtzK1laUEUzWmk4S0Z2b1NyUWxhZXN3bEVNN1JOaVp6RVRqbmhwQTQ1L2lsNythc3Ric3l5dzZPV08xY3NEUEdITDY2L0V3cGY1a29NZEdjM2lDcVRYZG5uQTd2VjRhMWFkdGUrUHZubkViaG1iaGZRMk5SZXNpMVpZVHhKeXp0eVZQL1JZTXNaZGZhLzVjSHhydnAyVHFqT3lYWXVWOW10NnlKUWJRNmdQNVlmUzZGVWJiVzhEelUxb1laVUdKazljU0N5TG5sOXNlZjIxWGlMQXhtNkJUVDk1WEl5clhKbndObU5FMXpzSG10L2psMXUzbmJ3SDB1LzN1ZUtMZzB2elgwZ1BLakJicFpGaFMwZW1IL2pxSmxSZWRkVlhWMXA5b0xneWRlV1BkTkN0TGZYQThXTnZOeUZ1MUhkSFBySDc3YkVialFreGowNlZPWUJuZnVETXI3UVF2ajZBOG9IbWhaMDQralQxSm1yNjlQaWxIRDExalpNMmlhdW5mZFhuNUplblgvTUNJbStaTXFDcFNEVzZQd08yVGV0NWV5N3NmR2RxaHV5NGVXTlB3MWZtWXN3dVhQbEltNUZhdTIrMDM5Ui9OWStqeHlYSGRyUC8xWHdmN0JScit2TWZ2UDNmTzgrbmJWUFptL253Y0cxMnJyeTQ4QTkvK0VNN0tHMi9NaXVodzcyMUwxOXczeTBQZ3JrNGVmNmlQVEdyejgvMGd3THlZWWR6MnU1MVJmKzZQUkcyTnZnVTd1dFg1eCsybldnWHQzbmFleThyWDI1ZHRudGUyeGk1bkhDOFRGQW45alhUaXp0WFR4d1hxekR6VVVmZVNFY1pjSjg4ZGZmaEx1NTllbStEbkZ6dG8zeHlMRXR6SkI4b1B2S1Z2UFNiT0RxVlRyczEzUGhBQ21IUzVvVnYrNXF2dDFHVzQxa2FIM2s3VnNmQWVMMCtTc0dHRnFxUFB6cTdXTHJYWkkyNUZxLzdlM1h5NitzWFo5OWNQVDg5K0dFdDdtQ1Bsd2M4VXQ4ZnZGRmNQZEF1aUNWNmlmOTlwTTVDcTQxOERtMGplMnh2NDJNcEZyN1hldHBsSG9tblR1S1puN2dRdlJwWFh2cElYdXBYblRXYW1IWUxodlFoNDFqei9YM0x6THZDVWFHck90S01tY0xLRHBhQ2FuY3UwSE9lZUdJV1Q4NTY4YUs5bnZzbFA1UGwyYThVWFg3SVFOOCsvNVZud3RKUFQva0xocDMwOWhpM0dBZS9scHNkTFBONkxMRGY3K3BhTEs0c0NKdUxLR0dWaldoOUNOVzVEM1RCQ20vcksrM0VIZGR0ZlMzcDR6ZjdraDU4YzZoNDB1YVhFUG1oYlpSTDVXVWVhMzYxdTYvT212MzNJWE11alZWcCtSV3FCN1FBbzBOeDVkcHJ6aU02Tm5UOWtzdnJyN2w3UlM5OXBtOWt6cnVGbXgwcy9NdVZMN1dRMjVxL1o4My84ZnFyRS9JOXdCdkZ0Y2JNQlpLeXlvZXV2TlIvS054RmhyOWN5TGZ4djJUM0VQbVBmSnR6d3R2a2k2N3phNDdTK2pGdXhoQlhKNkV5WWNyV2NFN3V0QUczSlI5ZXl0UjUyNkR6S055WG4zb0pHU2Z6UW5GMWZwRFRVZytjb3BtRk5pOE5kUDEyMWJWcDdmUVRkcTdzV25kM3J1MUJGaGNIUGZlMUo5SStXcDdjb25WOGNwWVQ4cHJoM3VKNm14TWtkWE54TVFZWDJYM0hRd3g3OVdYTXloL1JtZXRJL3BBOHg1NzVaZnpFbCtMcUEzbjZXZEpQdnZObG5JVEtVbjhOci9vMUYrWEdXUFAxdHNpYzIwTmczVkV5QnV3Y041Y0dMTEoxZkwyb3prL0w0Z2xaVjFlOEhvWkhFL0tBN2ZZRXJmNXFtTzI1VXZQQm56dFg0eDM2NUN5dXZiYjQ3Y2NGano4OGRMZGI4ei9TdDV1QllYR3RKNFowUW5IQ2dTZDl1eFR1cDMzYnVFdjZMT1NIYVByeHhEalVwM2xwTDUzMjZWTzlsSU5qVjN2VlVXOEVSN3JKTTRjbG1ENUhkc2w3MDNpT2dWeWdLWUQ3dW5iYUpPU3RzZjY0d0Yxc3l0MnBFc012dHZpQmdYeDBiY1lCMnZMWXlnTlNNT24xdWlvODlhWXZ0ODZPdTFjbjVEWERHOFhWazFwWTQxZCtwWE1oVk51SHBtdnNoL1ovVjM4NUI0bFhmelgvU3F1UER6czhmUXJWVzRKTGZ1VUxsK3dyMzF5QUZpSjUxVmVscTY4M1FZL21UWjdqV1lLT00vUFdGbDQrN3pXTEt6TDBxbCt2d3dLUjg4VlYrM25EamI3OWN1dm1aWmgyL2ZYYmRnZEI3ODNIcHBnU3N6WmZDNU5GdCtvYzZZZVpnZE1mUFAzaDlwL0Y1cE1GVVJzbmlGMlpKMDJGTGpUNWEvcXBvOTIwd0xZTENOcXVyNFRLaFBnRXA0Rm5oOGZ6TStFNVRuVTlFYzU1dm1ZMGRMTzk2b3MvT1FXZlk4dlZ2L25Ccjd5a09jbk16OXpUeGp5VkNkSFJEdHlXdmp2ZW4yVTduZVRRMk5qVVhhTGhUOC9CblRTTW5mREprMGU5Z1BBdE9JVmsrdkxtMmVZTnFjOWZQdHZFSkI0Nk5ITm4vTklkbVQvTWN4Zk9hN1hkV3lxZisxWFhtbnJvZ0ZlYTU3M2FrRG5mUXI2NG9tbXJ2UkE5eHN5YkNPanNTaG1qYzN2YTdtdTFjZDh2bHhHZXRyY2NlRG5oL05HMk5tNXM1anlNYlM3TWxhK1VNYWV6UjlmdmVmdVZjVWJ3Y3Q3UkhxSTdzai95OXMvQXpVcTYzK2ExYXJoSWE1QWxmdXFwQXhSUCtWMXdGL2hkYkxHNVRSN21QYktwUFBMS2JuNzc4czBZSTF3L2g4QWFIem9MQ1Q2TUFiNHZOM1RldGxaemxnYmF5VmsrNDZYNFVRaTlnd0RhZ3FpZTQ0Um16cktyNDl3SnRjbDQ0TWdUV2pnN2MrR2o1Zk9rMlIyLzNGcVluNGRnNzI3VFpvOGVYRWdQSERoOGFmRUswWHVJUmh4OTR3K2NadnhPREQ3VUc0aDJXT2s3ZlNaL3grQUJDY2VteTZRekYrVkNaVXM1eWhkaVYzMjNmM2E2TzMwSmpZSHR2cGIrMVpXM0thN2JEWEZYUWI3UDl6NjVzVjRuTkllbGVWRSt5Z0daUlpUQ3lpVUMvYkNiUmE0OWVqUjJueS9iTWRIdTVJeTNEMnp2bFVVSEgvcUJ4b2QwbFhFSFFkdTk4cVVWcXIyeE83WGd1bE50eCtsWmUydkJoNTkrK3VtUFAvLzg4Ni9VUGNLSG00RXpEN1l1S3kzL0VIZ2ZXLzNuWW5FQnBVeGNxUDRTVk0vY2hQSVRHZytkMUt0MDJvend6Q1hsK3Blbm5qUlFucnFaQjNMcG1wTjhkR2lWMXA4eTVRbkZ1NE9GRDNVcTFDL0ZBaG5kc2FRcjgxalRTZjAzaFp1ZjR6SVArUDREb2s3UzRoUklkNjVBaXlrMk5uMzV4WmJRT1VUUE9SUnFLNVMvS2M1TndDKzR1SXVBYTdIcVVWUnJrWDMxNnR1dm12M3haN0ZPMGdQRC9zK25pMlRrVzVtTFFocmQ1STFzWHplUGhVVnpnU1ZjaTUxNXA0OXFvNTc4U3N0UHFML2tqZkNxSnkwa2x2SEVrOWFuTXVqRWxTZkV0enBMTVBYdmd1dFhXMkxhNVMxQmJOOTBxL21iay93MW10eXpNTG9EcGJnNkIwSjA4VVV4N3J2WCtTZXhXV0F0MU9qV1poNzRzN0NDeXhkV3U2UXB0aTFHZi9acjhvLzR3OHpBem1VQkRnZ0g2RTAyRjBVdUZQTlJCajJTSjM5SnZqYkdQdlp5ZnEvcG05Y2E3RDVuQlgzbE9OSzI1b3llTnVncEY4b0RwbDdpNnNCVEwvSDAxUlgyZktnUHBBbTMrSnp6ZlBsQlBub1VnZXYySUpOYU5QUmhYdGk4NldZdTVBWnVqdVNWZE5XVHR1QmxnVVZXM3dBTGp5TmpVVzZ2ME56NE4yYk53UmprZ293WTNjOThqT1duSGp3YUJYWENqcCt2ZXdZV3Y5Q3FCNHRFOG1DSlYvaFFDYWRmOGN3aGVUV21pN0x5dFFHS280TytOc212OWc5RkcwdC9sWVp2amtKNUNjWE5PWFdWQVduR0FJNzZwSFhZcDc1U08zbUpvNVB4MGtaWjViMUplbWtPSy8vUUhCazd4WThmRnZqc0FXeXJQM2V3Rk5uczhPbExMZWUyNG5OaFgzMEd3YkhZTHMzcy9ma1hIR1FPU2paNGQya2pYN2YxcytRamMxclNxYkVZVjlwVitSSmQvVmQ2eWU0dS9FTnlkQXoxT04wMlhyZHZoenI5Vkh6dFJLN3hzTFVqbTN6dHJpVnRrSEd5ZTZkVWpna1p0RHh0M2tYb2ZBZ1pBK1BtMGdBTlBvMTVCdXQwTzkwYy8rbGNUQzJxUU93UG5acyt4ejNDNUxNL2crRDgrcjJaZFhMWmJzRnFPaythMzcyUExOVG1DTzgyQTV2bnVXTE9nYzZEbUFzRXZndERYVU5XbWZ3bG1IN1F5WmhKeTAvb1FvTW5meWtPZkdNNWxqTmVMRC96NVVIcnI1VUF5TVcyTDZieGNEREN1YVkyYXVvdStUYy94cSt1TWFEdC9hUnR0SHJRTm5UeTM4MzBndzR4NUNXdUREajUyRjVpZ0VkVFgzZzYrMEtmZTR2UHorZmo5V0x5a1hFbUQ3dnpKVStJWDlycHFlK3NBcCtrMDcyajg0WmdCcFBrNXFkK1VwSzUrRTlENmptbjZnbnhrVGcwZHY2Snp6R2dVMWpoMDluQnNnWTYzWjRkbk1mcHVqMGRxeGwzbjlnUU4zdkdTcnptWVN3aFk3cU1YMm8xbnp1RkZWbkxveGRjZkIxM3M4ekMvZHZPTmRmN3V6dk1Bd2U5TG81RExOTUdIRCtIdExRN1JQOCtPbXRqVTdZdjc4eTM2dTZqeVIzNzlKRzhkb29mTkR6c001WjA4bkFrclh6Tk9UcXBoeTEwK2xtelYwK2JmYnFIeWtkNVpKNFpEMTMxNGRkdVRQVW9qalowTGJqZHA1VzhLWFEvOFNSMml5cUYyaGo0cERpUEdyS2w1bDBEVTA2bkp4ZFB0anRaYlNpNDRrZjRNRE93dmsxN21CaDd2ZlNGTm11NWtDRGxDL2M1U3R0OXVuZVZHMk1KSHVMWDhWU0lyVHo5U0FQcG5yUWp5QW1wZnRvbkwzSGpWWjYyRlZZOVQyaHpVYi9TKytMb1IvdDlVUDBLOTltTjVFcys1R01qRGx6cldVaXJIbk5IcHppeUs2VTduL3BQR2w5ZWUvVU9BbmU4bzNGa25zWkt1R1FEMzUwcWtCM3NtdTVSZHZnTWZPL0YxWVZFaW9tN3NFeGRPbUhpNmdtVlFTYytrc3Q3WGRCeEFSTy9iVHpISWNRKzhTVi82Z2kxa3hhbS9hRThiZXE0Y3F4VkI5KzFWeDNwTndGekxJNWpCTWxOM1pybmlFK0JwQ3RqMTBwUnRjRFdPWmZXenVJcWpSLzk2YlBta2JSekxrLy8wZ2t0c00zL2NRZWJFM01QZlB3M3hqMGNIbUxxd3FnSE8ybDBvQk5XMzhvclArbjBtZnczalp0N3dwcFRqajNIQVo1MHRUdUVIdG5MOC9qZ0I5NklUdjVTbnVhQkxvWGxWVHdEQUpsMjZ0MEdhcHZ3TnZaVkZ6KzlDVU1oeDhvNFJnMGQyc1pQVVVKTzkxb3E4Tlg1Vkh4UDUvZTJJYithNDFOWWFSa1AzeFpYK0hUamxuQTdmSFdXY2t0Yml1emw4YmtET1NWM3hyLzM0c29COW1DdlpZMk91a0wxcFlYeUUyWU1jV0hxUFRSdVRrTDhnd3NkVjJlc2ZKaHIra0Zkdm5qU3V0UEd1UEFUVjI4SjZsT2JwQ3R1TEgxcDB5TGV5TlZpb0E5czFFK2V2a2F3eGh2cEhNb3o5bzcrZkt6SVI3a1F2YVg0OGlsKzJEcWV0SlZ2WWFUQTBscWtEdnRIUS9GaFE5ZUNqRDJYQnVEUmpLR3VzUEtoelFPODJYTjdWbGQzeDZxdEVKMkdIKytKZFVMdUFNZi9ETi9CMFgxTU9PQzE0dzlld2s2c2ZPaGpSZVhlSWhicFdqOGtRQjJYdExhVmh1L1lQRW5Nd1oyTXRISjl5WmV1dnZXcmZBMXFtemJ5OXRscGM0aittaTlranJIQ2ZYYTNrZXU3eG9QUG5OY3VINmp0YUt6STRGTWc3WFZ1OU9WbEFRb3F1TmRld1kxL216R2hTNnlYejg2KzhVdXVOZnZMdU1OZ1RlOG9HOC9BVzFGY3g2a3RjMGVMZGxsN2t0ekZacC9QZmZJODBmYnBLcTk1UWlkUG54WG15YVpNbjhBUkwrVWpQT01xbDFmelFxNU1YV0tPV3RWRFowbDNaSDhmM2lqMmtyL01TUnk0cjFkL2FhdU1QQ2l1d05yUmFWRjZBYzBDUzNIMU9BTzdYc3h4am0za3N4dTBEMlhzVHBjSzZQWEwwMitRYTNPRXQ1K0J6WThJOHNEYzNzM2hGaXdvbXZGY3FNbnJDdk1IZXVpb256SndGNjU4RjEzcXA4N3BxWDl5c1N1ZS9penJ0dDRHTTIyV2QyS21MK01zd1hiS2NHWnNXdHEyb1RTLzgzaDRUMUkvTWJZN25lbUJ5SE1DR3crN1k5ejFQNStZN1EvTGpJUGZuQWRreW5rNzA4bFpvL2xqdE9tWjZ1bDVPOUZiekt2TnEwYmFNV3JDZGlmbUJPZjU4VlVra2Q0R25jYmpIUXZUT0xoMWswYmU1MmVQVHg0Lyt1SEpNNzR6NldOdk44aTNaNXB5NnpHMkZKSjVlVXhHcitGenluSFpjVDV2dFd1eFhqaHcyUkhNOURSL2pIVWFMK3ViWjhweXoycWZaZWQrOWxPUFM5ZWZyN2xPOGRvenNzNmE3Vnc4cjVrWDVNek5mTTA2eDhBbEEzemtNVWFlT3ZqdDEzZzdmM3VKb0QxYTk1djIrTnJORHd4Ni9Qa0RmKzF0dE04dTIrNTE2ZEpCNmgveG16UFFuNG8xT2hnM1ZSK1dNNHBaRjhSU3hDVzlKZjZTbjdlUm55ZUpCVkg0TnVaNzI1d29CSnpvZElvUHplT0c3RTAzY3JHUGNqSFgxQkVYWXBmNGlPYVkxcUtJbm54bCtQRXlBRGpGdVhiNHh1akk3TWQxa3hBOHUvb1Y5dnl2dGsvVnF2SWp2WDhHZGxhekIybS8yZDAxK2tHYkZ3TmVLbjJvNTdUN1B2SStOSytIMHNzVEFwK2VFQS9sLzAzNW9haDZLNUxGMU9Qbm1OOVViald1YTZ4Q2lsdmxIVW9UZzNFeTl1eU9QV1hvRXN0TEF4WlpZTDMrU253YTl2cVNydERDblhyb1pNTWZzV21YeDJ1dk9UVUg0Mi9OenRYRnVTOXpGNUY2MG9mYWEvZTJ3anc1WFB6Q3R6WG4yK1JGY2VYazdqdlhWZ2c4ZnZoNEc4YnBPc3E4Y256eXExN2xhNk1ldERyZ0htY2hQSnEwQlpBTE4xeGlzS0FuQkpkTzMrbEhYS2gvNEZvejczYnQ5ZHVXeStLMTJUVWYvOUJsT3p2WGYraVRjUnovY1FhT00zQnpCdmh5NnliM3lOazNBLzhmQnF6YjM0UGFmTm9BQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbWcvdHJ1bXAucG5nXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1hcCA9IHtcblx0XCIuL2hpbGFyeS5wbmdcIjogMjQ5LFxuXHRcIi4vdHJ1bXAucG5nXCI6IDI1MCxcblx0XCIuL3R3aXR0ZXIucG5nXCI6IDEwNlxufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHR2YXIgaWQgPSBtYXBbcmVxXTtcblx0aWYoIShpZCArIDEpKSAvLyBjaGVjayBmb3IgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpO1xuXHRyZXR1cm4gaWQ7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDI1MjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ltZyBeXFwuXFwvLipcXC5wbmckXG4vLyBtb2R1bGUgaWQgPSAyNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==